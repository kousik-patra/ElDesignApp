/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@joint/core/dist/joint.js":
/*!************************************************!*\
  !*** ./node_modules/@joint/core/dist/joint.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*! JointJS v4.2.1 (2025-11-20) - JavaScript diagramming library

This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

(function (global, factory) {
	 true ? factory(exports) :
	0;
})(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  (function () { return this; })() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	'use strict';
	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	var f$4 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$2(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f$4
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject$1 = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject$1(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject$1(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty$1 = {}.hasOwnProperty;

	var has$2 = function (it, key) {
	  return hasOwnProperty$1.call(it, key);
	};

	var document$2 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject$1(document$2) && isObject$1(document$2.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$2.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	var f$3 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has$2(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$3
	};

	var anObject = function (it) {
	  if (!isObject$1(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store$1 = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store$1;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$2 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$2 === 'function' && /native code/.test(inspectSource(WeakMap$2));

	var isPure = false;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.8.3',
	  mode: isPure ? 'pure' : 'global',
	  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys$1 = shared('keys');

	var sharedKey = function (key) {
	  return keys$1[key] || (keys$1[key] = uid(key));
	};

	var hiddenKeys$1 = {};

	var WeakMap$1 = global_1.WeakMap;
	var set$1, get$1, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get$1(it) : set$1(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$1(it) || (state = get$1(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store = sharedStore.state || (sharedStore.state = new WeakMap$1());
	  var wmget = store.get;
	  var wmhas = store.has;
	  var wmset = store.set;
	  set$1 = function (it, metadata) {
	    metadata.facade = it;
	    wmset.call(store, it, metadata);
	    return metadata;
	  };
	  get$1 = function (it) {
	    return wmget.call(store, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys$1[STATE] = true;
	  set$1 = function (it, metadata) {
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get$1 = function (it) {
	    return has$2(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has$2(it, STATE);
	  };
	}

	var internalState = {
	  set: set$1,
	  get: get$1,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};
	var internalState_1 = internalState.set;
	var internalState_2 = internalState.get;
	var internalState_3 = internalState.has;
	var internalState_4 = internalState.enforce;
	var internalState_5 = internalState.getterFor;

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  var state;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has$2(value, 'name')) {
	      createNonEnumerableProperty(value, 'name', key);
	    }
	    state = enforceInternalState(value);
	    if (!state.source) {
	      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
	    }
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction$1 = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor$1 = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.es/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);
	};

	var min$6 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min$6(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max$4 = Math.max;
	var min$5 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max$4(integer + length, 0) : min$5(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$2 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$2(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$2(false)
	};
	var arrayIncludes_1 = arrayIncludes.includes;
	var arrayIncludes_2 = arrayIncludes.indexOf;

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has$2(hiddenKeys$1, key) && has$2(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has$2(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys);
	};

	var objectGetOwnPropertyNames = {
		f: f$1
	};

	var f = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has$2(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data$1[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data$1 = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has$2(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has$2(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
	    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html$1 = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html$1.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys$1[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	var defineProperty$1 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has$2(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has$2(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has$2(options, 0) ? options[0] : thrower;
	  var argument1 = has$2(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = { length: -1 };

	    if (ACCESSORS) defineProperty$1(O, 1, { enumerable: true, get: thrower });
	    else O[1] = 1;

	    method.call(O, argument0, argument1);
	  });
	};

	'use strict';

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.es/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$2 }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var es_array_includes = {

	};

	var aFunction = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var call = Function.call;

	var entryUnbind = function (CONSTRUCTOR, METHOD, length) {
	  return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);
	};

	var includes$3 = entryUnbind('Array', 'includes');

	var includes$2 = includes$3;

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    else if (isObject$1(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_OUT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else switch (TYPE) {
	          case 4: return false;             // every
	          case 7: push.call(target, value); // filterOut
	        }
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6),
	  // `Array.prototype.filterOut` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterOut: createMethod$1(7)
	};
	var arrayIteration_1 = arrayIteration.forEach;
	var arrayIteration_2 = arrayIteration.map;
	var arrayIteration_3 = arrayIteration.filter;
	var arrayIteration_4 = arrayIteration.some;
	var arrayIteration_5 = arrayIteration.every;
	var arrayIteration_6 = arrayIteration.find;
	var arrayIteration_7 = arrayIteration.findIndex;
	var arrayIteration_8 = arrayIteration.filterOut;

	'use strict';

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES$1 = true;

	var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.find` method
	// https://tc39.es/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$1 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var es_array_find = {

	};

	var find$1 = entryUnbind('Array', 'find');

	var find = find$1;

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod(true)
	};
	var stringMultibyte_1 = stringMultibyte.codeAt;
	var stringMultibyte_2 = stringMultibyte.charAt;

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has$2(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype : null;
	};

	'use strict';







	var ITERATOR$4 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	var returnThis$2 = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype$2[ITERATOR$4].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has$2(IteratorPrototype$2, ITERATOR$4)) {
	  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$4, returnThis$2);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};
	var iteratorsCore_1 = iteratorsCore.IteratorPrototype;
	var iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;

	var defineProperty = objectDefineProperty.f;



	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has$2(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
	    defineProperty(it, TO_STRING_TAG$2, { configurable: true, value: TAG });
	  }
	};

	var iterators = {};

	'use strict';
	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject$1(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	'use strict';












	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$3 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$3]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$3] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$3, returnThis);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      if (isPure) iterators[TO_STRING_TAG] = returnThis;
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ((!isPure || FORCED) && IterablePrototype[ITERATOR$3] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$3, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	'use strict';
	var charAt = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var es_string_iterator = {

	};

	var iteratorClose = function (iterator) {
	  var returnMethod = iterator['return'];
	  if (returnMethod !== undefined) {
	    return anObject(returnMethod.call(iterator)).value;
	  }
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    iteratorClose(iterator);
	    throw error;
	  }
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$2] === it);
	};

	'use strict';




	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$1] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	'use strict';








	// `Array.from` method implementation
	// https://tc39.es/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.es/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
	  from: arrayFrom
	});

	var es_array_from = {

	};

	var from_1$1 = path.Array.from;

	var from_1 = from_1$1;

	'use strict';

	var $findIndex = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	var es_array_findIndex = {

	};

	var findIndex$1 = entryUnbind('Array', 'findIndex');

	var findIndex = findIndex$1;

	var base64 = createCommonjsModule(function (module, exports) {
	  (function () {
	    /**
	     * version: 0.3.0
	     * git://github.com/davidchambers/Base64.js.git
	     */

	    var object =  true ? exports : 0; // #8: web workers
	    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	    function InvalidCharacterError(message) {
	      this.message = message;
	    }
	    InvalidCharacterError.prototype = new Error();
	    InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	    // encoder
	    // [https://gist.github.com/999166] by [https://github.com/nignag]
	    object.btoa || (object.btoa = function (input) {
	      var str = String(input);
	      for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next str index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      str.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	        charCode = str.charCodeAt(idx += 3 / 4);
	        if (charCode > 0xFF) {
	          throw new InvalidCharacterError('\'btoa\' failed: The string to be encoded contains characters outside of the Latin1 range.');
	        }
	        block = block << 8 | charCode;
	      }
	      return output;
	    });

	    // decoder
	    // [https://gist.github.com/1020396] by [https://github.com/atk]
	    object.atob || (object.atob = function (input) {
	      var str = String(input).replace(/=+$/, '');
	      if (str.length % 4 == 1) {
	        throw new InvalidCharacterError('\'atob\' failed: The string to be decoded is not correctly encoded.');
	      }
	      for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      // eslint-disable-next-line no-cond-assign
	      buffer = str.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	      // and if not first of each 4 characters,
	      // convert the first 8 bits to one ascii character
	      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
	        // try to find character in table (0-63, not found => -1)
	        buffer = chars.indexOf(buffer);
	      }
	      return output;
	    });
	  })();
	});

	// `Number.isNaN` method
	// https://tc39.es/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var es_number_isNan = {

	};

	var isNan$1 = path.Number.isNaN;

	var isNan = isNan$1;

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite
	_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

	var es_number_isFinite = {

	};

	var _isFinite$1 = path.Number.isFinite;

	var _isFinite = _isFinite$1;

	var MATCH$1 = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject$1(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (error1) {
	    try {
	      regexp[MATCH] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (error2) { /* empty */ }
	  } return false;
	};

	'use strict';





	// `String.prototype.includes` method
	// https://tc39.es/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var es_string_includes = {

	};

	var includes$1 = entryUnbind('String', 'includes');

	var includes = includes$1;

	'use strict';

	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;






	var nativeStartsWith = ''.startsWith;
	var min$4 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var es_string_startsWith = {

	};

	var startsWith$1 = entryUnbind('String', 'startsWith');

	var startsWith = startsWith$1;

	(function () {
	  if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {
	    return;
	  }
	  function subarray(start, end) {
	    return this.slice(start, end);
	  }
	  function set_(array, offset) {
	    if (arguments.length < 2) {
	      offset = 0;
	    }
	    for (var i = 0, n = array.length; i < n; ++i, ++offset) {
	      this[offset] = array[i] & 0xFF;
	    }
	  }

	  // we need typed arrays
	  function TypedArray(arg1) {
	    var result;
	    if (typeof arg1 === 'number') {
	      result = new Array(arg1);
	      for (var i = 0; i < arg1; ++i) {
	        result[i] = 0;
	      }
	    } else {
	      result = arg1.slice(0);
	    }
	    result.subarray = subarray;
	    result.buffer = result;
	    result.byteLength = result.length;
	    result.set = set_;
	    if (typeof arg1 === 'object' && arg1.buffer) {
	      result.buffer = arg1.buffer;
	    }
	    return result;
	  }
	  window.Uint8Array = TypedArray;
	  window.Uint32Array = TypedArray;
	  window.Int32Array = TypedArray;
	})();

	// Declare shorthands to the most used math functions.
	const {
	  round: round$4,
	  floor,
	  PI: PI$1
	} = Math;
	const scale = {
	  // Return the `value` from the `domain` interval scaled to the `range` interval.
	  linear: function (domain, range, value) {
	    var domainSpan = domain[1] - domain[0];
	    var rangeSpan = range[1] - range[0];
	    return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;
	  }
	};
	const normalizeAngle = function (angle) {
	  return angle % 360 + (angle < 0 ? 360 : 0);
	};
	const snapToGrid$1 = function (value, gridSize) {
	  return gridSize * round$4(value / gridSize);
	};
	const toDeg = function (rad) {
	  return 180 * rad / PI$1 % 360;
	};
	const toRad = function (deg, over360) {
	  over360 = over360 || false;
	  deg = over360 ? deg : deg % 360;
	  return deg * PI$1 / 180;
	};

	// Return a random integer from the interval [min,max], inclusive.
	const random = function (min, max) {
	  if (max === undefined) {
	    // use first argument as max, min is 0
	    max = min === undefined ? 1 : min;
	    min = 0;
	  } else if (max < min) {
	    // switch max and min
	    const temp = min;
	    min = max;
	    max = temp;
	  }
	  return floor(Math.random() * (max - min + 1) + min);
	};

	// @return the bearing (cardinal direction) of the line. For example N, W, or SE.
	// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.
	const {
	  cos: cos$2,
	  sin: sin$2,
	  atan2: atan2$1
	} = Math;
	const bearing = function (p, q) {
	  var lat1 = toRad(p.y);
	  var lat2 = toRad(q.y);
	  var lon1 = p.x;
	  var lon2 = q.x;
	  var dLon = toRad(lon2 - lon1);
	  var y = sin$2(dLon) * cos$2(lat2);
	  var x = cos$2(lat1) * sin$2(lat2) - sin$2(lat1) * cos$2(lat2) * cos$2(dLon);
	  var brng = toDeg(atan2$1(y, x));
	  var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
	  var index = brng - 22.5;
	  if (index < 0) index += 360;
	  index = parseInt(index / 45);
	  return bearings[index];
	};

	// @return {integer} length without sqrt
	// @note for applications where the exact length is not necessary (e.g. compare only)
	const squaredLength = function (start, end) {
	  var x0 = start.x;
	  var y0 = start.y;
	  var x1 = end.x;
	  var y1 = end.y;
	  return (x0 -= x1) * x0 + (y0 -= y1) * y0;
	};

	const length = function (start, end) {
	  return Math.sqrt(squaredLength(start, end));
	};

	const types = {
	  Point: 1,
	  Line: 2,
	  Ellipse: 3,
	  Rect: 4,
	  Polyline: 5,
	  Polygon: 6,
	  Curve: 7,
	  Path: 8
	};

	/*
	    Point is the most basic object consisting of x/y coordinate.

	    Possible instantiations are:
	    * `Point(10, 20)`
	    * `new Point(10, 20)`
	    * `Point('10 20')`
	    * `Point(Point(10, 20))`
	*/
	const {
	  abs: abs$2,
	  cos: cos$1,
	  sin: sin$1,
	  sqrt: sqrt$2,
	  min: min$3,
	  max: max$3,
	  atan2,
	  round: round$3,
	  pow: pow$3,
	  PI
	} = Math;
	const Point = function (x, y) {
	  if (!(this instanceof Point)) {
	    return new Point(x, y);
	  }
	  if (typeof x === 'string') {
	    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');
	    x = parseFloat(xy[0]);
	    y = parseFloat(xy[1]);
	  } else if (Object(x) === x) {
	    y = x.y;
	    x = x.x;
	  }
	  this.x = x === undefined ? 0 : x;
	  this.y = y === undefined ? 0 : y;
	};

	// Alternative constructor, from polar coordinates.
	// @param {number} Distance.
	// @param {number} Angle in radians.
	// @param {point} [optional] Origin.
	Point.fromPolar = function (distance, angle, origin) {
	  origin = new Point(origin);
	  var x = abs$2(distance * cos$1(angle));
	  var y = abs$2(distance * sin$1(angle));
	  var deg = normalizeAngle(toDeg(angle));
	  if (deg < 90) {
	    y = -y;
	  } else if (deg < 180) {
	    x = -x;
	    y = -y;
	  } else if (deg < 270) {
	    x = -x;
	  }
	  return new Point(origin.x + x, origin.y + y);
	};

	// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.
	Point.random = function (x1, x2, y1, y2) {
	  return new Point(random(x1, x2), random(y1, y2));
	};
	Point.prototype = {
	  type: types.Point,
	  chooseClosest: function (points) {
	    var n = points.length;
	    if (n === 1) return new Point(points[0]);
	    var closest = null;
	    var minSqrDistance = Infinity;
	    for (var i = 0; i < n; i++) {
	      var p = new Point(points[i]);
	      var sqrDistance = this.squaredDistance(p);
	      if (sqrDistance < minSqrDistance) {
	        closest = p;
	        minSqrDistance = sqrDistance;
	      }
	    }
	    return closest;
	  },
	  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,
	  // otherwise return point itself.
	  // (see Squeak Smalltalk, Point>>adhereTo:)
	  adhereToRect: function (r) {
	    if (r.containsPoint(this)) {
	      return this;
	    }
	    this.x = min$3(max$3(this.x, r.x), r.x + r.width);
	    this.y = min$3(max$3(this.y, r.y), r.y + r.height);
	    return this;
	  },
	  // Compute the angle between vector from me to p1 and the vector from me to p2.
	  // ordering of points p1 and p2 is important!
	  // theta function's angle convention:
	  // returns angles between 0 and 180 when the angle is counterclockwise
	  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones
	  // returns NaN if any of the points p1, p2 is coincident with this point
	  angleBetween: function (p1, p2) {
	    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);
	    if (angleBetween < 0) {
	      angleBetween += 360; // correction to keep angleBetween between 0 and 360
	    }
	    return angleBetween;
	  },
	  // Return the bearing between me and the given point.
	  bearing: function (point) {
	    return bearing(this, point);
	  },
	  // Returns change in angle from my previous position (-dx, -dy) to my new position
	  // relative to ref point.
	  changeInAngle: function (dx, dy, ref) {
	    // Revert the translation and measure the change in angle around x-axis.
	    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);
	  },
	  clone: function () {
	    return new Point(this);
	  },
	  // Returns the cross product of this point relative to two other points
	  // this point is the common point
	  // point p1 lies on the first vector, point p2 lies on the second vector
	  // watch out for the ordering of points p1 and p2!
	  // positive result indicates a clockwise ("right") turn from first to second vector
	  // negative result indicates a counterclockwise ("left") turn from first to second vector
	  // zero indicates that the first and second vector are collinear
	  // note that the above directions are reversed from the usual answer on the Internet
	  // that is because we are in a left-handed coord system (because the y-axis points downward)
	  cross: function (p1, p2) {
	    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;
	  },
	  difference: function (dx, dy) {
	    if (Object(dx) === dx) {
	      dy = dx.y;
	      dx = dx.x;
	    }
	    return new Point(this.x - (dx || 0), this.y - (dy || 0));
	  },
	  // Returns distance between me and point `p`.
	  distance: function (p) {
	    return length(this, p);
	  },
	  // Returns the dot product of this point with given other point
	  dot: function (p) {
	    return p ? this.x * p.x + this.y * p.y : NaN;
	  },
	  equals: function (p) {
	    return !!p && this.x === p.x && this.y === p.y;
	  },
	  // Linear interpolation
	  lerp: function (p, t) {
	    var x = this.x;
	    var y = this.y;
	    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);
	  },
	  magnitude: function () {
	    return sqrt$2(this.x * this.x + this.y * this.y) || 0.01;
	  },
	  // Returns a manhattan (taxi-cab) distance between me and point `p`.
	  manhattanDistance: function (p) {
	    return abs$2(p.x - this.x) + abs$2(p.y - this.y);
	  },
	  // Move point on line starting from ref ending at me by
	  // distance distance.
	  move: function (ref, distance) {
	    var theta = toRad(new Point(ref).theta(this));
	    var offset = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);
	    return offset;
	  },
	  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.
	  normalize: function (length) {
	    var scale = (length || 1) / this.magnitude();
	    return this.scale(scale, scale);
	  },
	  // Offset me by the specified amount.
	  offset: function (dx, dy) {
	    if (Object(dx) === dx) {
	      dy = dx.y;
	      dx = dx.x;
	    }
	    this.x += dx || 0;
	    this.y += dy || 0;
	    return this;
	  },
	  // Returns a point that is the reflection of me with
	  // the center of inversion in ref point.
	  reflection: function (ref) {
	    return new Point(ref).move(this, this.distance(ref));
	  },
	  // Rotate point by angle around origin.
	  // Angle is flipped because this is a left-handed coord system (y-axis points downward).
	  rotate: function (origin, angle) {
	    if (angle === 0) return this;
	    origin = origin || new Point(0, 0);
	    angle = toRad(normalizeAngle(-angle));
	    var cosAngle = cos$1(angle);
	    var sinAngle = sin$1(angle);
	    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;
	    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;
	    this.x = x;
	    this.y = y;
	    return this;
	  },
	  round: function (precision) {
	    let f = 1; // case 0
	    if (precision) {
	      switch (precision) {
	        case 1:
	          f = 10;
	          break;
	        case 2:
	          f = 100;
	          break;
	        case 3:
	          f = 1000;
	          break;
	        default:
	          f = pow$3(10, precision);
	          break;
	      }
	    }
	    this.x = round$3(this.x * f) / f;
	    this.y = round$3(this.y * f) / f;
	    return this;
	  },
	  // Scale point with origin.
	  scale: function (sx, sy, origin) {
	    origin = origin && new Point(origin) || new Point(0, 0);
	    this.x = origin.x + sx * (this.x - origin.x);
	    this.y = origin.y + sy * (this.y - origin.y);
	    return this;
	  },
	  snapToGrid: function (gx, gy) {
	    this.x = snapToGrid$1(this.x, gx);
	    this.y = snapToGrid$1(this.y, gy || gx);
	    return this;
	  },
	  squaredDistance: function (p) {
	    return squaredLength(this, p);
	  },
	  // Compute the angle between me and `p` and the x axis.
	  // (cartesian-to-polar coordinates conversion)
	  // Return theta angle in degrees.
	  theta: function (p) {
	    p = new Point(p);

	    // Invert the y-axis.
	    var y = -(p.y - this.y);
	    var x = p.x - this.x;
	    var rad = atan2(y, x); // defined for all 0 corner cases

	    // Correction for III. and IV. quadrant.
	    if (rad < 0) {
	      rad = 2 * PI + rad;
	    }
	    return 180 * rad / PI;
	  },
	  toJSON: function () {
	    return {
	      x: this.x,
	      y: this.y
	    };
	  },
	  // Converts rectangular to polar coordinates.
	  // An origin can be specified, otherwise it's 0@0.
	  toPolar: function (o) {
	    o = o && new Point(o) || new Point(0, 0);
	    var x = this.x;
	    var y = this.y;
	    this.x = sqrt$2((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r
	    this.y = toRad(o.theta(new Point(x, y)));
	    return this;
	  },
	  toString: function () {
	    return this.x + '@' + this.y;
	  },
	  serialize: function () {
	    return this.x + ',' + this.y;
	  },
	  update: function (x, y) {
	    if (Object(x) === x) {
	      y = x.y;
	      x = x.x;
	    }
	    this.x = x || 0;
	    this.y = y || 0;
	    return this;
	  },
	  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.
	  // Returns NaN if p is at 0,0.
	  vectorAngle: function (p) {
	    var zero = new Point(0, 0);
	    return zero.angleBetween(this, p);
	  }
	};
	Point.prototype.translate = Point.prototype.offset;

	// For backwards compatibility:
	const point = Point;

	const {
	  max: max$2,
	  min: min$2
	} = Math;
	const Line = function (p1, p2) {
	  if (!(this instanceof Line)) {
	    return new Line(p1, p2);
	  }
	  if (p1 instanceof Line) {
	    return new Line(p1.start, p1.end);
	  }
	  this.start = new Point(p1);
	  this.end = new Point(p2);
	};
	Line.prototype = {
	  type: types.Line,
	  // @returns the angle of incline of the line.
	  angle: function () {
	    var horizontalPoint = new Point(this.start.x + 1, this.start.y);
	    return this.start.angleBetween(this.end, horizontalPoint);
	  },
	  bbox: function () {
	    var left = min$2(this.start.x, this.end.x);
	    var top = min$2(this.start.y, this.end.y);
	    var right = max$2(this.start.x, this.end.x);
	    var bottom = max$2(this.start.y, this.end.y);
	    return new Rect(left, top, right - left, bottom - top);
	  },
	  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.
	  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.
	  bearing: function () {
	    return bearing(this.start, this.end);
	  },
	  clone: function () {
	    return new Line(this.start, this.end);
	  },
	  // @return {point} the closest point on the line to point `p`
	  closestPoint: function (p) {
	    return this.pointAt(this.closestPointNormalizedLength(p));
	  },
	  closestPointLength: function (p) {
	    return this.closestPointNormalizedLength(p) * this.length();
	  },
	  // @return {number} the normalized length of the closest point on the line to point `p`
	  closestPointNormalizedLength: function (p) {
	    var product = this.vector().dot(new Line(this.start, p).vector());
	    var cpNormalizedLength = min$2(1, max$2(0, product / this.squaredLength()));

	    // cpNormalizedLength returns `NaN` if this line has zero length
	    // we can work with that - if `NaN`, return 0
	    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`
	    // (`NaN` is the only value that is not equal to itself)

	    return cpNormalizedLength;
	  },
	  closestPointTangent: function (p) {
	    return this.tangentAt(this.closestPointNormalizedLength(p));
	  },
	  // Returns `true` if the point lies on the line.
	  containsPoint: function (p) {
	    var start = this.start;
	    var end = this.end;
	    if (start.cross(p, end) !== 0) return false;
	    // else: cross product of 0 indicates that this line and the vector to `p` are collinear

	    var length = this.length();
	    if (new Line(start, p).length() > length) return false;
	    if (new Line(p, end).length() > length) return false;
	    // else: `p` lies between start and end of the line

	    return true;
	  },
	  // Divides the line into two at requested `ratio` between 0 and 1.
	  divideAt: function (ratio) {
	    var dividerPoint = this.pointAt(ratio);

	    // return array with two lines
	    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
	  },
	  // Divides the line into two at requested `length`.
	  divideAtLength: function (length) {
	    var dividerPoint = this.pointAtLength(length);

	    // return array with two new lines
	    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
	  },
	  equals: function (l) {
	    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
	  },
	  // @return {point} Point where I'm intersecting a line.
	  // @return [point] Points where I'm intersecting a rectangle.
	  // @see Squeak Smalltalk, LineSegment>>intersectionWith:
	  intersect: function (shape, opt) {
	    if (shape && shape.intersectionWithLine) {
	      var intersection = shape.intersectionWithLine(this, opt);

	      // Backwards compatibility
	      if (intersection && shape instanceof Line) {
	        intersection = intersection[0];
	      }
	      return intersection;
	    }
	    return null;
	  },
	  intersectionWithLine: function (line) {
	    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
	    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);
	    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
	    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);
	    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
	    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
	    if (det === 0 || alpha * det < 0 || beta * det < 0) {
	      // No intersection found.
	      return null;
	    }
	    if (det > 0) {
	      if (alpha > det || beta > det) {
	        return null;
	      }
	    } else {
	      if (alpha < det || beta < det) {
	        return null;
	      }
	    }
	    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];
	  },
	  isDifferentiable: function () {
	    return !this.start.equals(this.end);
	  },
	  // @return {double} length of the line
	  length: function () {
	    return length(this.start, this.end);
	  },
	  // @return {point} my midpoint
	  midpoint: function () {
	    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
	  },
	  parallel: function (distance) {
	    const l = this.clone();
	    if (!this.isDifferentiable()) return l;
	    const {
	      start,
	      end
	    } = l;
	    const eRef = start.clone().rotate(end, 270);
	    const sRef = end.clone().rotate(start, 90);
	    start.move(sRef, distance);
	    end.move(eRef, distance);
	    return l;
	  },
	  // @return {point} my point at 't' <0,1>
	  pointAt: function (t) {
	    var start = this.start;
	    var end = this.end;
	    if (t <= 0) return start.clone();
	    if (t >= 1) return end.clone();
	    return start.lerp(end, t);
	  },
	  pointAtLength: function (length) {
	    var start = this.start;
	    var end = this.end;
	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    var lineLength = this.length();
	    if (length >= lineLength) return fromStart ? end.clone() : start.clone();
	    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);
	  },
	  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.
	  pointOffset: function (p) {
	    // Find the sign of the determinant of vectors (start,end), where p is the query point.
	    p = new Point(p);
	    var start = this.start;
	    var end = this.end;
	    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);
	    return determinant / this.length();
	  },
	  rotate: function (origin, angle) {
	    this.start.rotate(origin, angle);
	    this.end.rotate(origin, angle);
	    return this;
	  },
	  round: function (precision) {
	    this.start.round(precision);
	    this.end.round(precision);
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    this.start.scale(sx, sy, origin);
	    this.end.scale(sx, sy, origin);
	    return this;
	  },
	  // @return {number} scale the line so that it has the requested length
	  setLength: function (length) {
	    var currentLength = this.length();
	    if (!currentLength) return this;
	    var scaleFactor = length / currentLength;
	    return this.scale(scaleFactor, scaleFactor, this.start);
	  },
	  // @return {integer} length without sqrt
	  // @note for applications where the exact length is not necessary (e.g. compare only)
	  squaredLength: function () {
	    return squaredLength(this.start, this.end);
	  },
	  tangentAt: function (t) {
	    if (!this.isDifferentiable()) return null;
	    var start = this.start;
	    var end = this.end;
	    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1

	    var tangentLine = new Line(start, end);
	    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested

	    return tangentLine;
	  },
	  tangentAtLength: function (length) {
	    if (!this.isDifferentiable()) return null;
	    var start = this.start;
	    var end = this.end;
	    var tangentStart = this.pointAtLength(length);
	    var tangentLine = new Line(start, end);
	    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested

	    return tangentLine;
	  },
	  toString: function () {
	    return this.start.toString() + ' ' + this.end.toString();
	  },
	  serialize: function () {
	    return this.start.serialize() + ' ' + this.end.serialize();
	  },
	  translate: function (tx, ty) {
	    this.start.translate(tx, ty);
	    this.end.translate(tx, ty);
	    return this;
	  },
	  // @return vector {point} of the line
	  vector: function () {
	    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
	  }
	};

	// For backwards compatibility:
	Line.prototype.intersection = Line.prototype.intersect;

	// For backwards compatibility:
	const line$1 = Line;

	const {
	  sqrt: sqrt$1,
	  round: round$2,
	  pow: pow$2
	} = Math;
	const Ellipse$1 = function (c, a, b) {
	  if (!(this instanceof Ellipse$1)) {
	    return new Ellipse$1(c, a, b);
	  }
	  if (c instanceof Ellipse$1) {
	    return new Ellipse$1(new Point(c.x, c.y), c.a, c.b);
	  }
	  c = new Point(c);
	  this.x = c.x;
	  this.y = c.y;
	  this.a = a;
	  this.b = b;
	};
	Ellipse$1.fromRect = function (rect) {
	  rect = new Rect(rect);
	  return new Ellipse$1(rect.center(), rect.width / 2, rect.height / 2);
	};
	Ellipse$1.prototype = {
	  type: types.Ellipse,
	  bbox: function () {
	    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);
	  },
	  /**
	   * @returns {g.Point}
	   */
	  center: function () {
	    return new Point(this.x, this.y);
	  },
	  clone: function () {
	    return new Ellipse$1(this);
	  },
	  /**
	   * @param {g.Point} p
	   * @returns {boolean}
	   */
	  containsPoint: function (p) {
	    return this.normalizedDistance(p) <= 1;
	  },
	  equals: function (ellipse) {
	    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;
	  },
	  // inflate by dx and dy
	  // @param dx {delta_x} representing additional size to x
	  // @param dy {delta_y} representing additional size to y -
	  // dy param is not required -> in that case y is sized by dx
	  inflate: function (dx, dy) {
	    if (dx === undefined) {
	      dx = 0;
	    }
	    if (dy === undefined) {
	      dy = dx;
	    }
	    this.a += 2 * dx;
	    this.b += 2 * dy;
	    return this;
	  },
	  intersectionWithLine: function (line) {
	    var intersections = [];
	    var a1 = line.start;
	    var a2 = line.end;
	    var rx = this.a;
	    var ry = this.b;
	    var dir = line.vector();
	    var diff = a1.difference(new Point(this));
	    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
	    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));
	    var a = dir.dot(mDir);
	    var b = dir.dot(mDiff);
	    var c = diff.dot(mDiff) - 1.0;
	    var d = b * b - a * c;
	    if (d < 0) {
	      return null;
	    } else if (d > 0) {
	      var root = sqrt$1(d);
	      var ta = (-b - root) / a;
	      var tb = (-b + root) / a;
	      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {
	        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside
	        return null;
	      } else {
	        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));
	        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));
	      }
	    } else {
	      var t = -b / a;
	      if (0 <= t && t <= 1) {
	        intersections.push(a1.lerp(a2, t));
	      } else {
	        // outside
	        return null;
	      }
	    }
	    return intersections;
	  },
	  // Find point on me where line from my center to
	  // point p intersects my boundary.
	  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.
	  intersectionWithLineFromCenterToPoint: function (p, angle) {
	    p = new Point(p);
	    if (angle) p.rotate(new Point(this.x, this.y), angle);
	    var dx = p.x - this.x;
	    var dy = p.y - this.y;
	    var result;
	    if (dx === 0) {
	      result = this.bbox().pointNearestToPoint(p);
	      if (angle) return result.rotate(new Point(this.x, this.y), -angle);
	      return result;
	    }
	    var m = dy / dx;
	    var mSquared = m * m;
	    var aSquared = this.a * this.a;
	    var bSquared = this.b * this.b;
	    var x = sqrt$1(1 / (1 / aSquared + mSquared / bSquared));
	    x = dx < 0 ? -x : x;
	    var y = m * x;
	    result = new Point(this.x + x, this.y + y);
	    if (angle) return result.rotate(new Point(this.x, this.y), -angle);
	    return result;
	  },
	  /**
	   * @param {g.Point} point
	   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside
	   */
	  normalizedDistance: function (point) {
	    var x0 = point.x;
	    var y0 = point.y;
	    var a = this.a;
	    var b = this.b;
	    var x = this.x;
	    var y = this.y;
	    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);
	  },
	  round: function (precision) {
	    let f = 1; // case 0
	    if (precision) {
	      switch (precision) {
	        case 1:
	          f = 10;
	          break;
	        case 2:
	          f = 100;
	          break;
	        case 3:
	          f = 1000;
	          break;
	        default:
	          f = pow$2(10, precision);
	          break;
	      }
	    }
	    this.x = round$2(this.x * f) / f;
	    this.y = round$2(this.y * f) / f;
	    this.a = round$2(this.a * f) / f;
	    this.b = round$2(this.b * f) / f;
	    return this;
	  },
	  /** Compute angle between tangent and x axis
	   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.
	   * @returns {number} angle between tangent and x axis
	   */
	  tangentTheta: function (p) {
	    var refPointDelta = 30;
	    var x0 = p.x;
	    var y0 = p.y;
	    var a = this.a;
	    var b = this.b;
	    var center = this.bbox().center();
	    var m = center.x;
	    var n = center.y;
	    var q1 = x0 > center.x + a / 2;
	    var q3 = x0 < center.x - a / 2;
	    var y, x;
	    if (q1 || q3) {
	      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
	      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;
	    } else {
	      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
	      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;
	    }
	    return new Point(x, y).theta(p);
	  },
	  toString: function () {
	    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;
	  }
	};

	// For backwards compatibility:
	const ellipse$1 = Ellipse$1;

	const {
	  abs: abs$1,
	  cos,
	  sin,
	  min: min$1,
	  max: max$1,
	  round: round$1,
	  pow: pow$1
	} = Math;
	const Rect = function (x, y, w, h) {
	  if (!(this instanceof Rect)) {
	    return new Rect(x, y, w, h);
	  }
	  if (Object(x) === x) {
	    y = x.y;
	    w = x.width;
	    h = x.height;
	    x = x.x;
	  }
	  this.x = x === undefined ? 0 : x;
	  this.y = y === undefined ? 0 : y;
	  this.width = w === undefined ? 0 : w;
	  this.height = h === undefined ? 0 : h;
	};
	Rect.fromEllipse = function (e) {
	  e = new Ellipse$1(e);
	  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);
	};
	Rect.fromPointUnion = function (...points) {
	  if (points.length === 0) return null;
	  const p = new Point();
	  let minX, minY, maxX, maxY;
	  minX = minY = Infinity;
	  maxX = maxY = -Infinity;
	  for (let i = 0; i < points.length; i++) {
	    p.update(points[i]);
	    const x = p.x;
	    const y = p.y;
	    if (x < minX) minX = x;
	    if (x > maxX) maxX = x;
	    if (y < minY) minY = y;
	    if (y > maxY) maxY = y;
	  }
	  return new Rect(minX, minY, maxX - minX, maxY - minY);
	};
	Rect.fromRectUnion = function (...rects) {
	  if (rects.length === 0) return null;
	  const r = new Rect();
	  let minX, minY, maxX, maxY;
	  minX = minY = Infinity;
	  maxX = maxY = -Infinity;
	  for (let i = 0; i < rects.length; i++) {
	    r.update(rects[i]);
	    const x = r.x;
	    const y = r.y;
	    const mX = x + r.width;
	    const mY = y + r.height;
	    if (x < minX) minX = x;
	    if (mX > maxX) maxX = mX;
	    if (y < minY) minY = y;
	    if (mY > maxY) maxY = mY;
	  }
	  return new Rect(minX, minY, maxX - minX, maxY - minY);
	};
	Rect.prototype = {
	  type: types.Rect,
	  // Find my bounding box when I'm rotated with the center of rotation in the center of me.
	  // @return r {rectangle} representing a bounding box
	  bbox: function (angle) {
	    return this.clone().rotateAroundCenter(angle);
	  },
	  rotateAroundCenter: function (angle) {
	    if (!angle) return this;
	    const {
	      width,
	      height
	    } = this;
	    const theta = toRad(angle);
	    const st = abs$1(sin(theta));
	    const ct = abs$1(cos(theta));
	    const w = width * ct + height * st;
	    const h = width * st + height * ct;
	    this.x += (width - w) / 2;
	    this.y += (height - h) / 2;
	    this.width = w;
	    this.height = h;
	    return this;
	  },
	  bottomLeft: function () {
	    return new Point(this.x, this.y + this.height);
	  },
	  bottomLine: function () {
	    return new Line(this.bottomLeft(), this.bottomRight());
	  },
	  bottomMiddle: function () {
	    return new Point(this.x + this.width / 2, this.y + this.height);
	  },
	  center: function () {
	    return new Point(this.x + this.width / 2, this.y + this.height / 2);
	  },
	  clone: function () {
	    return new Rect(this);
	  },
	  // @return {bool} true if point p is inside me.
	  // @param {bool} strict If true, the point has to be strictly inside (not on the border).
	  containsPoint: function (p, opt) {
	    let x, y;
	    if (!p || typeof p === 'string') {
	      // Backwards compatibility: if the point is not provided,
	      // the point is considered to be the origin [0, 0].
	      ({
	        x,
	        y
	      } = new Point(p));
	    } else {
	      // Do not create a new Point object if the point is already a Point-like object.
	      ({
	        x = 0,
	        y = 0
	      } = p);
	    }
	    return opt && opt.strict ? x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
	  },
	  // @return {bool} true if rectangle `r` is inside me.
	  containsRect: function (r) {
	    var r0 = new Rect(this).normalize();
	    var r1 = new Rect(r).normalize();
	    var w0 = r0.width;
	    var h0 = r0.height;
	    var w1 = r1.width;
	    var h1 = r1.height;
	    if (!w0 || !h0 || !w1 || !h1) {
	      // At least one of the dimensions is 0
	      return false;
	    }
	    var x0 = r0.x;
	    var y0 = r0.y;
	    var x1 = r1.x;
	    var y1 = r1.y;
	    w1 += x1;
	    w0 += x0;
	    h1 += y1;
	    h0 += y0;
	    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;
	  },
	  corner: function () {
	    return new Point(this.x + this.width, this.y + this.height);
	  },
	  // @return {boolean} true if rectangles are equal.
	  equals: function (r) {
	    var mr = new Rect(this).normalize();
	    var nr = new Rect(r).normalize();
	    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;
	  },
	  // inflate by dx and dy, recompute origin [x, y]
	  // @param dx {delta_x} representing additional size to x
	  // @param dy {delta_y} representing additional size to y -
	  // dy param is not required -> in that case y is sized by dx
	  inflate: function (dx, dy) {
	    if (dx === undefined) {
	      dx = 0;
	    }
	    if (dy === undefined) {
	      dy = dx;
	    }
	    this.x -= dx;
	    this.y -= dy;
	    this.width += 2 * dx;
	    this.height += 2 * dy;
	    return this;
	  },
	  // @return {rect} if rectangles intersect, {null} if not.
	  intersect: function (r) {
	    var myOrigin = this.origin();
	    var myCorner = this.corner();
	    var rOrigin = r.origin();
	    var rCorner = r.corner();

	    // No intersection found
	    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;
	    var x = max$1(myOrigin.x, rOrigin.x);
	    var y = max$1(myOrigin.y, rOrigin.y);
	    return new Rect(x, y, min$1(myCorner.x, rCorner.x) - x, min$1(myCorner.y, rCorner.y) - y);
	  },
	  intersectionWithLine: function (line) {
	    var r = this;
	    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];
	    var points = [];
	    var dedupeArr = [];
	    var pt, i;
	    var n = rectLines.length;
	    for (i = 0; i < n; i++) {
	      pt = line.intersect(rectLines[i]);
	      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {
	        points.push(pt);
	        dedupeArr.push(pt.toString());
	      }
	    }
	    return points.length > 0 ? points : null;
	  },
	  // Find point on my boundary where line starting
	  // from my center ending in point p intersects me.
	  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.
	  intersectionWithLineFromCenterToPoint: function (p, angle) {
	    p = new Point(p);
	    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);
	    var result;
	    if (angle) p.rotate(center, angle);

	    // (clockwise, starting from the top side)
	    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];
	    var connector = new Line(center, p);
	    for (var i = sides.length - 1; i >= 0; --i) {
	      var intersection = sides[i].intersection(connector);
	      if (intersection !== null) {
	        result = intersection;
	        break;
	      }
	    }
	    if (result && angle) result.rotate(center, -angle);
	    return result;
	  },
	  leftLine: function () {
	    return new Line(this.topLeft(), this.bottomLeft());
	  },
	  leftMiddle: function () {
	    return new Point(this.x, this.y + this.height / 2);
	  },
	  maxRectScaleToFit: function (rect, origin) {
	    rect = new Rect(rect);
	    origin || (origin = rect.center());
	    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;
	    var ox = origin.x;
	    var oy = origin.y;

	    // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,
	    // so when the scale is applied the point is still inside the rectangle.

	    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;

	    // Top Left
	    var p1 = rect.topLeft();
	    if (p1.x < ox) {
	      sx1 = (this.x - ox) / (p1.x - ox);
	    }
	    if (p1.y < oy) {
	      sy1 = (this.y - oy) / (p1.y - oy);
	    }
	    // Bottom Right
	    var p2 = rect.bottomRight();
	    if (p2.x > ox) {
	      sx2 = (this.x + this.width - ox) / (p2.x - ox);
	    }
	    if (p2.y > oy) {
	      sy2 = (this.y + this.height - oy) / (p2.y - oy);
	    }
	    // Top Right
	    var p3 = rect.topRight();
	    if (p3.x > ox) {
	      sx3 = (this.x + this.width - ox) / (p3.x - ox);
	    }
	    if (p3.y < oy) {
	      sy3 = (this.y - oy) / (p3.y - oy);
	    }
	    // Bottom Left
	    var p4 = rect.bottomLeft();
	    if (p4.x < ox) {
	      sx4 = (this.x - ox) / (p4.x - ox);
	    }
	    if (p4.y > oy) {
	      sy4 = (this.y + this.height - oy) / (p4.y - oy);
	    }
	    return {
	      sx: min$1(sx1, sx2, sx3, sx4),
	      sy: min$1(sy1, sy2, sy3, sy4)
	    };
	  },
	  maxRectUniformScaleToFit: function (rect, origin) {
	    var scale = this.maxRectScaleToFit(rect, origin);
	    return min$1(scale.sx, scale.sy);
	  },
	  // Move and expand me.
	  // @param r {rectangle} representing deltas
	  moveAndExpand: function (r) {
	    this.x += r.x || 0;
	    this.y += r.y || 0;
	    this.width += r.width || 0;
	    this.height += r.height || 0;
	    return this;
	  },
	  moveAroundPoint: function (origin, angle) {
	    const newCenter = this.center().rotate(origin, angle);
	    this.x = newCenter.x - this.width / 2;
	    this.y = newCenter.y - this.height / 2;
	    return this;
	  },
	  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.
	  // If width < 0 the function swaps the left and right corners,
	  // and it swaps the top and bottom corners if height < 0
	  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized
	  normalize: function () {
	    var newx = this.x;
	    var newy = this.y;
	    var newwidth = this.width;
	    var newheight = this.height;
	    if (this.width < 0) {
	      newx = this.x + this.width;
	      newwidth = -this.width;
	    }
	    if (this.height < 0) {
	      newy = this.y + this.height;
	      newheight = -this.height;
	    }
	    this.x = newx;
	    this.y = newy;
	    this.width = newwidth;
	    this.height = newheight;
	    return this;
	  },
	  // Offset me by the specified amount.
	  offset: function (dx, dy) {
	    // pretend that this is a point and call offset()
	    // rewrites x and y according to dx and dy
	    return Point.prototype.offset.call(this, dx, dy);
	  },
	  origin: function () {
	    return new Point(this.x, this.y);
	  },
	  // @return {point} a point on my boundary nearest to the given point.
	  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:
	  pointNearestToPoint: function (point) {
	    point = new Point(point);
	    if (this.containsPoint(point)) {
	      var side = this.sideNearestToPoint(point);
	      switch (side) {
	        case 'right':
	          return new Point(this.x + this.width, point.y);
	        case 'left':
	          return new Point(this.x, point.y);
	        case 'bottom':
	          return new Point(point.x, this.y + this.height);
	        case 'top':
	          return new Point(point.x, this.y);
	      }
	    }
	    return point.adhereToRect(this);
	  },
	  rightLine: function () {
	    return new Line(this.topRight(), this.bottomRight());
	  },
	  rightMiddle: function () {
	    return new Point(this.x + this.width, this.y + this.height / 2);
	  },
	  round: function (precision) {
	    let f = 1; // case 0
	    if (precision) {
	      switch (precision) {
	        case 1:
	          f = 10;
	          break;
	        case 2:
	          f = 100;
	          break;
	        case 3:
	          f = 1000;
	          break;
	        default:
	          f = pow$1(10, precision);
	          break;
	      }
	    }
	    this.x = round$1(this.x * f) / f;
	    this.y = round$1(this.y * f) / f;
	    this.width = round$1(this.width * f) / f;
	    this.height = round$1(this.height * f) / f;
	    return this;
	  },
	  // Scale rectangle with origin.
	  scale: function (sx, sy, origin) {
	    origin = this.origin().scale(sx, sy, origin);
	    this.x = origin.x;
	    this.y = origin.y;
	    this.width *= sx;
	    this.height *= sy;
	    return this;
	  },
	  // @return {string} (left|right|top|bottom) side which is nearest to point
	  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:
	  sideNearestToPoint: function (point) {
	    point = new Point(point);
	    var distToLeft = point.x - this.x;
	    var distToRight = this.x + this.width - point.x;
	    var distToTop = point.y - this.y;
	    var distToBottom = this.y + this.height - point.y;
	    var closest = distToLeft;
	    var side = 'left';
	    if (distToRight < closest) {
	      closest = distToRight;
	      side = 'right';
	    }
	    if (distToTop < closest) {
	      closest = distToTop;
	      side = 'top';
	    }
	    if (distToBottom < closest) {
	      // closest = distToBottom;
	      side = 'bottom';
	    }
	    return side;
	  },
	  snapToGrid: function (gx, gy) {
	    var origin = this.origin().snapToGrid(gx, gy);
	    var corner = this.corner().snapToGrid(gx, gy);
	    this.x = origin.x;
	    this.y = origin.y;
	    this.width = corner.x - origin.x;
	    this.height = corner.y - origin.y;
	    return this;
	  },
	  toJSON: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  },
	  topLine: function () {
	    return new Line(this.topLeft(), this.topRight());
	  },
	  topMiddle: function () {
	    return new Point(this.x + this.width / 2, this.y);
	  },
	  topRight: function () {
	    return new Point(this.x + this.width, this.y);
	  },
	  toString: function () {
	    return this.origin().toString() + ' ' + this.corner().toString();
	  },
	  // @return {rect} representing the union of both rectangles.
	  union: function (rect) {
	    return Rect.fromRectUnion(this, rect);
	  },
	  update: function (x, y, w, h) {
	    if (Object(x) === x) {
	      y = x.y;
	      w = x.width;
	      h = x.height;
	      x = x.x;
	    }
	    this.x = x || 0;
	    this.y = y || 0;
	    this.width = w || 0;
	    this.height = h || 0;
	    return this;
	  }
	};
	Rect.prototype.bottomRight = Rect.prototype.corner;
	Rect.prototype.topLeft = Rect.prototype.origin;
	Rect.prototype.translate = Rect.prototype.offset;

	// For backwards compatibility:
	const rect = Rect;

	function parsePoints(svgString) {
	  // Step 1: Discard surrounding spaces
	  const trimmedString = svgString.trim();
	  if (trimmedString === '') return [];
	  const points = [];

	  // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces
	  // ReDoS mitigation: Have an anchor at the beginning of each alternation
	  // Note: This doesn't simplify double (or more) commas - causes empty coords
	  // This regex is used by `split()`, so it doesn't need to use /g
	  const coords = trimmedString.split(/\b\s*,\s*|,\s*|\s+/);
	  const numCoords = coords.length;
	  for (let i = 0; i < numCoords; i += 2) {
	    // Step 3: Convert each coord to number
	    // Note: If the coord cannot be converted to a number, it will be `NaN`
	    // Note: If the coord is empty ("", e.g. from ",," input), it will be `0`
	    // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`
	    points.push({
	      x: +coords[i],
	      y: +coords[i + 1]
	    });
	  }
	  return points;
	}
	function clonePoints(points) {
	  const numPoints = points.length;
	  if (numPoints === 0) return [];
	  const newPoints = [];
	  for (let i = 0; i < numPoints; i++) {
	    const point = points[i].clone();
	    newPoints.push(point);
	  }
	  return newPoints;
	}

	// Returns a convex-hull polyline from this polyline.
	// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).
	// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.
	// Minimal polyline is found (only vertices of the hull are reported, no collinear points).
	function convexHull(points) {
	  const {
	    abs
	  } = Math;
	  var i;
	  var n;
	  var numPoints = points.length;
	  if (numPoints === 0) return []; // if points array is empty

	  // step 1: find the starting point - point with the lowest y (if equality, highest x)
	  var startPoint;
	  for (i = 0; i < numPoints; i++) {
	    if (startPoint === undefined) {
	      // if this is the first point we see, set it as start point
	      startPoint = points[i];
	    } else if (points[i].y < startPoint.y) {
	      // start point should have lowest y from all points
	      startPoint = points[i];
	    } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
	      // if two points have the lowest y, choose the one that has highest x
	      // there are no points to the right of startPoint - no ambiguity about theta 0
	      // if there are several coincident start point candidates, first one is reported
	      startPoint = points[i];
	    }
	  }

	  // step 2: sort the list of points
	  // sorting by angle between line from startPoint to point and the x-axis (theta)

	  // step 2a: create the point records = [point, originalIndex, angle]
	  var sortedPointRecords = [];
	  for (i = 0; i < numPoints; i++) {
	    var angle = startPoint.theta(points[i]);
	    if (angle === 0) {
	      angle = 360; // give highest angle to start point
	      // the start point will end up at end of sorted list
	      // the start point will end up at beginning of hull points list
	    }
	    var entry = [points[i], i, angle];
	    sortedPointRecords.push(entry);
	  }

	  // step 2b: sort the list in place
	  sortedPointRecords.sort(function (record1, record2) {
	    // returning a negative number here sorts record1 before record2
	    // if first angle is smaller than second, first angle should come before second

	    var sortOutput = record1[2] - record2[2]; // negative if first angle smaller
	    if (sortOutput === 0) {
	      // if the two angles are equal, sort by originalIndex
	      sortOutput = record2[1] - record1[1]; // negative if first index larger
	      // coincident points will be sorted in reverse-numerical order
	      // so the coincident points with lower original index will be considered first
	    }
	    return sortOutput;
	  });

	  // step 2c: duplicate start record from the top of the stack to the bottom of the stack
	  if (sortedPointRecords.length > 2) {
	    var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];
	    sortedPointRecords.unshift(startPointRecord);
	  }

	  // step 3a: go through sorted points in order and find those with right turns
	  // we want to get our results in clockwise order
	  var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull
	  var hullPointRecords = []; // stack of records with right turns - hull point candidates

	  var currentPointRecord;
	  var currentPoint;
	  var lastHullPointRecord;
	  var lastHullPoint;
	  var secondLastHullPointRecord;
	  var secondLastHullPoint;
	  while (sortedPointRecords.length !== 0) {
	    currentPointRecord = sortedPointRecords.pop();
	    currentPoint = currentPointRecord[0];

	    // check if point has already been discarded
	    // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'
	    if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {
	      // this point had an incorrect turn at some previous iteration of this loop
	      // this disqualifies it from possibly being on the hull
	      continue;
	    }
	    var correctTurnFound = false;
	    while (!correctTurnFound) {
	      if (hullPointRecords.length < 2) {
	        // not enough points for comparison, just add current point
	        hullPointRecords.push(currentPointRecord);
	        correctTurnFound = true;
	      } else {
	        lastHullPointRecord = hullPointRecords.pop();
	        lastHullPoint = lastHullPointRecord[0];
	        secondLastHullPointRecord = hullPointRecords.pop();
	        secondLastHullPoint = secondLastHullPointRecord[0];
	        var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
	        if (crossProduct < 0) {
	          // found a right turn
	          hullPointRecords.push(secondLastHullPointRecord);
	          hullPointRecords.push(lastHullPointRecord);
	          hullPointRecords.push(currentPointRecord);
	          correctTurnFound = true;
	        } else if (crossProduct === 0) {
	          // the three points are collinear
	          // three options:
	          // there may be a 180 or 0 degree angle at lastHullPoint
	          // or two of the three points are coincident
	          var THRESHOLD = 1e-10; // we have to take rounding errors into account
	          var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
	          if (abs(angleBetween - 180) < THRESHOLD) {
	            // rounding around 180 to 180
	            // if the cross product is 0 because the angle is 180 degrees
	            // discard last hull point (add to insidePoints)
	            //insidePoints.unshift(lastHullPoint);
	            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;
	            // reenter second-to-last hull point (will be last at next iter)
	            hullPointRecords.push(secondLastHullPointRecord);
	            // do not do anything with current point
	            // correct turn not found
	          } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
	            // if the cross product is 0 because two points are the same
	            // discard last hull point (add to insidePoints)
	            //insidePoints.unshift(lastHullPoint);
	            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;
	            // reenter second-to-last hull point (will be last at next iter)
	            hullPointRecords.push(secondLastHullPointRecord);
	            // do not do anything with current point
	            // correct turn not found
	          } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
	            // rounding around 0 and 360 to 0
	            // if the cross product is 0 because the angle is 0 degrees
	            // remove last hull point from hull BUT do not discard it
	            // reenter second-to-last hull point (will be last at next iter)
	            hullPointRecords.push(secondLastHullPointRecord);
	            // put last hull point back into the sorted point records list
	            sortedPointRecords.push(lastHullPointRecord);
	            // we are switching the order of the 0deg and 180deg points
	            // correct turn not found
	          }
	        } else {
	          // found a left turn
	          // discard last hull point (add to insidePoints)
	          //insidePoints.unshift(lastHullPoint);
	          insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;
	          // reenter second-to-last hull point (will be last at next iter of loop)
	          hullPointRecords.push(secondLastHullPointRecord);
	          // do not do anything with current point
	          // correct turn not found
	        }
	      }
	    }
	  }
	  // at this point, hullPointRecords contains the output points in clockwise order
	  // the points start with lowest-y,highest-x startPoint, and end at the same point

	  // step 3b: remove duplicated startPointRecord from the end of the array
	  if (hullPointRecords.length > 2) {
	    hullPointRecords.pop();
	  }

	  // step 4: find the lowest originalIndex record and put it at the beginning of hull
	  var lowestHullIndex; // the lowest originalIndex on the hull
	  var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
	  n = hullPointRecords.length;
	  for (i = 0; i < n; i++) {
	    var currentHullIndex = hullPointRecords[i][1];
	    if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
	      lowestHullIndex = currentHullIndex;
	      indexOfLowestHullIndexRecord = i;
	    }
	  }
	  var hullPointRecordsReordered = [];
	  if (indexOfLowestHullIndexRecord > 0) {
	    var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);
	    var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);
	    hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
	  } else {
	    hullPointRecordsReordered = hullPointRecords;
	  }
	  var hullPoints = [];
	  n = hullPointRecordsReordered.length;
	  for (i = 0; i < n; i++) {
	    hullPoints.push(hullPointRecordsReordered[i][0]);
	  }
	  return hullPoints;
	}

	const Polyline$1 = function (points) {
	  if (!(this instanceof Polyline$1)) {
	    return new Polyline$1(points);
	  }
	  if (typeof points === 'string') {
	    return new Polyline$1.parse(points);
	  }
	  this.points = Array.isArray(points) ? points.map(Point) : [];
	};
	Polyline$1.parse = function (svgString) {
	  return new Polyline$1(parsePoints(svgString));
	};
	Polyline$1.fromRect = function (rect) {
	  return new Polyline$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft(), rect.topLeft()]);
	};
	Polyline$1.prototype = {
	  type: types.Polyline,
	  bbox: function () {
	    var x1 = Infinity;
	    var x2 = -Infinity;
	    var y1 = Infinity;
	    var y2 = -Infinity;
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty

	    for (var i = 0; i < numPoints; i++) {
	      var point = points[i];
	      var x = point.x;
	      var y = point.y;
	      if (x < x1) x1 = x;
	      if (x > x2) x2 = x;
	      if (y < y1) y1 = y;
	      if (y > y2) y2 = y;
	    }
	    return new Rect(x1, y1, x2 - x1, y2 - y1);
	  },
	  clone: function () {
	    return new Polyline$1(clonePoints(this.points));
	  },
	  closestPoint: function (p) {
	    var cpLength = this.closestPointLength(p);
	    return this.pointAtLength(cpLength);
	  },
	  closestPointLength: function (p) {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return 0; // if points array is empty
	    if (numPoints === 1) return 0; // if there is only one point

	    var cpLength;
	    var minSqrDistance = Infinity;
	    var length = 0;
	    var n = numPoints - 1;
	    for (var i = 0; i < n; i++) {
	      var line = new Line(points[i], points[i + 1]);
	      var lineLength = line.length();
	      var cpNormalizedLength = line.closestPointNormalizedLength(p);
	      var cp = line.pointAt(cpNormalizedLength);
	      var sqrDistance = cp.squaredDistance(p);
	      if (sqrDistance < minSqrDistance) {
	        minSqrDistance = sqrDistance;
	        cpLength = length + cpNormalizedLength * lineLength;
	      }
	      length += lineLength;
	    }
	    return cpLength;
	  },
	  closestPointNormalizedLength: function (p) {
	    var cpLength = this.closestPointLength(p);
	    if (cpLength === 0) return 0; // shortcut

	    var length = this.length();
	    if (length === 0) return 0; // prevents division by zero

	    return cpLength / length;
	  },
	  closestPointTangent: function (p) {
	    var cpLength = this.closestPointLength(p);
	    return this.tangentAtLength(cpLength);
	  },
	  // Returns `true` if the area surrounded by the polyline contains the point `p`.
	  // Implements the even-odd SVG algorithm (self-intersections are "outside").
	  // (Uses horizontal rays to the right of `p` to look for intersections.)
	  // Closes open polylines (always imagines a final closing segment).
	  containsPoint: function (p) {
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return false; // shortcut (this polyline has no points)

	    var x = p.x;
	    var y = p.y;

	    // initialize a final closing segment by creating one from last-first points on polyline
	    var startIndex = numPoints - 1; // start of current polyline segment
	    var endIndex = 0; // end of current polyline segment
	    var numIntersections = 0;
	    var segment = new Line();
	    var ray = new Line();
	    var rayEnd = new Point();
	    for (; endIndex < numPoints; endIndex++) {
	      var start = points[startIndex];
	      var end = points[endIndex];
	      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)
	      // current polyline segment
	      segment.start = start;
	      segment.end = end;
	      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)

	      // do we have an intersection?
	      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
	        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
	        // (when `y === start.y === end.y`)
	        // this conditional branch IS entered when `segment` touches `ray` at only one point
	        // (e.g. when `y === start.y !== end.y`)
	        // since this branch is entered again for the following segment, the two touches cancel out

	        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
	        if (xDifference >= 0) {
	          // segment lies at least partially to the right of `p`
	          rayEnd.x = x + xDifference;
	          rayEnd.y = y; // right
	          ray.start = p;
	          ray.end = rayEnd;
	          if (segment.intersect(ray)) {
	            // an intersection was detected to the right of `p`
	            numIntersections++;
	          }
	        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
	      }

	      // move to check the next polyline segment
	      startIndex = endIndex;
	    }

	    // returns `true` for odd numbers of intersections (even-odd algorithm)
	    return numIntersections % 2 === 1;
	  },
	  close: function () {
	    const {
	      start,
	      end,
	      points
	    } = this;
	    if (start && end && !start.equals(end)) {
	      points.push(start.clone());
	    }
	    return this;
	  },
	  lengthPoints: function () {
	    return this.points;
	  },
	  convexHull: function () {
	    return new Polyline$1(convexHull(this.points));
	  },
	  // Checks whether two polylines are exactly the same.
	  // If `p` is undefined or null, returns false.
	  equals: function (p) {
	    if (!p) return false;
	    var points = this.points;
	    var otherPoints = p.points;
	    var numPoints = points.length;
	    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal

	    for (var i = 0; i < numPoints; i++) {
	      var point = points[i];
	      var otherPoint = p.points[i];

	      // as soon as an inequality is found in points, return false
	      if (!point.equals(otherPoint)) return false;
	    }

	    // if no inequality found in points, return true
	    return true;
	  },
	  intersectionWithLine: function (l) {
	    var line = new Line(l);
	    var intersections = [];
	    var points = this.lengthPoints();
	    var l2 = new Line();
	    for (var i = 0, n = points.length - 1; i < n; i++) {
	      l2.start = points[i];
	      l2.end = points[i + 1];
	      var int = line.intersectionWithLine(l2);
	      if (int) intersections.push(int[0]);
	    }
	    return intersections.length > 0 ? intersections : null;
	  },
	  isDifferentiable: function () {
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return false;
	    var line = new Line();
	    var n = numPoints - 1;
	    for (var i = 0; i < n; i++) {
	      line.start = points[i];
	      line.end = points[i + 1];
	      // as soon as a differentiable line is found between two points, return true
	      if (line.isDifferentiable()) return true;
	    }

	    // if no differentiable line is found between pairs of points, return false
	    return false;
	  },
	  length: function () {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return 0; // if points array is empty

	    var length = 0;
	    var n = numPoints - 1;
	    for (var i = 0; i < n; i++) {
	      length += points[i].distance(points[i + 1]);
	    }
	    return length;
	  },
	  pointAt: function (ratio) {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty
	    if (numPoints === 1) return points[0].clone(); // if there is only one point

	    if (ratio <= 0) return points[0].clone();
	    if (ratio >= 1) return points[numPoints - 1].clone();
	    var polylineLength = this.length();
	    var length = polylineLength * ratio;
	    return this.pointAtLength(length);
	  },
	  pointAtLength: function (length) {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty
	    if (numPoints === 1) return points[0].clone(); // if there is only one point

	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    var l = 0;
	    var n = numPoints - 1;
	    for (var i = 0; i < n; i++) {
	      var index = fromStart ? i : n - 1 - i;
	      var a = points[index];
	      var b = points[index + 1];
	      var line = new Line(a, b);
	      var d = a.distance(b);
	      if (length <= l + d) {
	        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));
	      }
	      l += d;
	    }

	    // if length requested is higher than the length of the polyline, return last endpoint
	    var lastPoint = fromStart ? points[numPoints - 1] : points[0];
	    return lastPoint.clone();
	  },
	  round: function (precision) {
	    var points = this.points;
	    var numPoints = points.length;
	    for (var i = 0; i < numPoints; i++) {
	      points[i].round(precision);
	    }
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    var points = this.points;
	    var numPoints = points.length;
	    for (var i = 0; i < numPoints; i++) {
	      points[i].scale(sx, sy, origin);
	    }
	    return this;
	  },
	  simplify: function (opt = {}) {
	    const points = this.points;
	    if (points.length < 3) return this; // we need at least 3 points

	    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification

	    // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`
	    // because of the rounding errors that can occur when comparing distances.
	    const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified

	    // start at the beginning of the polyline and go forward
	    let currentIndex = 0;
	    // we need at least one intermediate point (3 points) in every iteration
	    // as soon as that stops being true, we know we reached the end of the polyline
	    while (points[currentIndex + 2]) {
	      const firstIndex = currentIndex;
	      const middleIndex = currentIndex + 1;
	      const lastIndex = currentIndex + 2;
	      const firstPoint = points[firstIndex];
	      const middlePoint = points[middleIndex];
	      const lastPoint = points[lastIndex];
	      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point
	      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
	      const closestPointDistance = closestPoint.distance(middlePoint);
	      if (closestPointDistance <= threshold) {
	        // middle point is close enough to the chord = simplify
	        // 1) remove middle point:
	        points.splice(middleIndex, 1);
	        // 2) in next iteration, investigate the newly-created triplet of points
	        //    - do not change `currentIndex`
	        //    = (first point stays, point after removed point becomes middle point)
	      } else {
	        // middle point is far from the chord
	        // 1) preserve middle point
	        // 2) in next iteration, move `currentIndex` by one step:
	        currentIndex += 1;
	        //    = (point after first point becomes first point)
	      }
	    }

	    // `points` array was modified in-place
	    return this;
	  },
	  tangentAt: function (ratio) {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty
	    if (numPoints === 1) return null; // if there is only one point

	    if (ratio < 0) ratio = 0;
	    if (ratio > 1) ratio = 1;
	    var polylineLength = this.length();
	    var length = polylineLength * ratio;
	    return this.tangentAtLength(length);
	  },
	  tangentAtLength: function (length) {
	    var points = this.lengthPoints();
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty
	    if (numPoints === 1) return null; // if there is only one point

	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    var lastValidLine; // differentiable (with a tangent)
	    var l = 0; // length so far
	    var n = numPoints - 1;
	    for (var i = 0; i < n; i++) {
	      var index = fromStart ? i : n - 1 - i;
	      var a = points[index];
	      var b = points[index + 1];
	      var line = new Line(a, b);
	      var d = a.distance(b);
	      if (line.isDifferentiable()) {
	        // has a tangent line (line length is not 0)
	        if (length <= l + d) {
	          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));
	        }
	        lastValidLine = line;
	      }
	      l += d;
	    }

	    // if length requested is higher than the length of the polyline, return last valid endpoint
	    if (lastValidLine) {
	      var ratio = fromStart ? 1 : 0;
	      return lastValidLine.tangentAt(ratio);
	    }

	    // if no valid line, return null
	    return null;
	  },
	  toString: function () {
	    return this.points + '';
	  },
	  translate: function (tx, ty) {
	    var points = this.points;
	    var numPoints = points.length;
	    for (var i = 0; i < numPoints; i++) {
	      points[i].translate(tx, ty);
	    }
	    return this;
	  },
	  // Return svgString that can be used to recreate this line.
	  serialize: function () {
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return ''; // if points array is empty

	    var output = '';
	    for (var i = 0; i < numPoints; i++) {
	      var point = points[i];
	      output += point.x + ',' + point.y + ' ';
	    }
	    return output.trim();
	  }
	};
	Object.defineProperty(Polyline$1.prototype, 'start', {
	  // Getter for the first point of the polyline.

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty

	    return this.points[0];
	  }
	});
	Object.defineProperty(Polyline$1.prototype, 'end', {
	  // Getter for the last point of the polyline.

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    var points = this.points;
	    var numPoints = points.length;
	    if (numPoints === 0) return null; // if points array is empty

	    return this.points[numPoints - 1];
	  }
	});

	const {
	  abs,
	  sqrt,
	  min,
	  max,
	  pow
	} = Math;
	const Curve = function (p1, p2, p3, p4) {
	  if (!(this instanceof Curve)) {
	    return new Curve(p1, p2, p3, p4);
	  }
	  if (p1 instanceof Curve) {
	    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);
	  }
	  this.start = new Point(p1);
	  this.controlPoint1 = new Point(p2);
	  this.controlPoint2 = new Point(p3);
	  this.end = new Point(p4);
	};

	// Curve passing through points.
	// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).
	// @param {array} points Array of points through which the smooth line will go.
	// @return {array} curves.
	Curve.throughPoints = function () {
	  // Get open-ended Bezier Spline Control Points.
	  // @param knots Input Knot Bezier spline points (At least two points!).
	  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.
	  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.
	  function getCurveControlPoints(knots) {
	    var firstControlPoints = [];
	    var secondControlPoints = [];
	    var n = knots.length - 1;
	    var i;

	    // Special case: Bezier curve should be a straight line.
	    if (n == 1) {
	      // 3P1 = 2P0 + P3
	      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);

	      // P2 = 2P1 â P0
	      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
	      return [firstControlPoints, secondControlPoints];
	    }

	    // Calculate first Bezier control points.
	    // Right hand side vector.
	    var rhs = [];

	    // Set right hand side X values.
	    for (i = 1; i < n - 1; i++) {
	      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
	    }
	    rhs[0] = knots[0].x + 2 * knots[1].x;
	    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;

	    // Get first control points X-values.
	    var x = getFirstControlPoints(rhs);

	    // Set right hand side Y values.
	    for (i = 1; i < n - 1; ++i) {
	      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
	    }
	    rhs[0] = knots[0].y + 2 * knots[1].y;
	    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;

	    // Get first control points Y-values.
	    var y = getFirstControlPoints(rhs);

	    // Fill output arrays.
	    for (i = 0; i < n; i++) {
	      // First control point.
	      firstControlPoints.push(new Point(x[i], y[i]));

	      // Second control point.
	      if (i < n - 1) {
	        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
	      } else {
	        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
	      }
	    }
	    return [firstControlPoints, secondControlPoints];
	  }

	  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.
	  // @param rhs Right hand side vector.
	  // @return Solution vector.
	  function getFirstControlPoints(rhs) {
	    var n = rhs.length;
	    // `x` is a solution vector.
	    var x = [];
	    var tmp = [];
	    var b = 2.0;
	    x[0] = rhs[0] / b;

	    // Decomposition and forward substitution.
	    for (var i = 1; i < n; i++) {
	      tmp[i] = 1 / b;
	      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
	      x[i] = (rhs[i] - x[i - 1]) / b;
	    }
	    for (i = 1; i < n; i++) {
	      // Backsubstitution.
	      x[n - i - 1] -= tmp[n - i] * x[n - i];
	    }
	    return x;
	  }
	  return function (points) {
	    if (!points || Array.isArray(points) && points.length < 2) {
	      throw new Error('At least 2 points are required');
	    }
	    var controlPoints = getCurveControlPoints(points);
	    var curves = [];
	    var n = controlPoints[0].length;
	    for (var i = 0; i < n; i++) {
	      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
	      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
	      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
	    }
	    return curves;
	  };
	}();
	Curve.prototype = {
	  type: types.Curve,
	  // Returns a bbox that tightly envelops the curve.
	  bbox: function () {
	    var start = this.start;
	    var controlPoint1 = this.controlPoint1;
	    var controlPoint2 = this.controlPoint2;
	    var end = this.end;
	    var x0 = start.x;
	    var y0 = start.y;
	    var x1 = controlPoint1.x;
	    var y1 = controlPoint1.y;
	    var x2 = controlPoint2.x;
	    var y2 = controlPoint2.y;
	    var x3 = end.x;
	    var y3 = end.y;
	    var points = new Array(); // local extremes
	    var tvalues = new Array(); // t values of local extremes
	    var bounds = [new Array(), new Array()];
	    var a, b, c, t;
	    var t1, t2;
	    var b2ac, sqrtb2ac;
	    for (var i = 0; i < 2; ++i) {
	      if (i === 0) {
	        b = 6 * x0 - 12 * x1 + 6 * x2;
	        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	        c = 3 * x1 - 3 * x0;
	      } else {
	        b = 6 * y0 - 12 * y1 + 6 * y2;
	        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	        c = 3 * y1 - 3 * y0;
	      }
	      if (abs(a) < 1e-12) {
	        // Numerical robustness
	        if (abs(b) < 1e-12) {
	          // Numerical robustness
	          continue;
	        }
	        t = -c / b;
	        if (0 < t && t < 1) tvalues.push(t);
	        continue;
	      }
	      b2ac = b * b - 4 * c * a;
	      sqrtb2ac = sqrt(b2ac);
	      if (b2ac < 0) continue;
	      t1 = (-b + sqrtb2ac) / (2 * a);
	      if (0 < t1 && t1 < 1) tvalues.push(t1);
	      t2 = (-b - sqrtb2ac) / (2 * a);
	      if (0 < t2 && t2 < 1) tvalues.push(t2);
	    }
	    var j = tvalues.length;
	    var jlen = j;
	    var mt;
	    var x, y;
	    while (j--) {
	      t = tvalues[j];
	      mt = 1 - t;
	      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
	      bounds[0][j] = x;
	      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
	      bounds[1][j] = y;
	      points[j] = {
	        X: x,
	        Y: y
	      };
	    }
	    tvalues[jlen] = 0;
	    tvalues[jlen + 1] = 1;
	    points[jlen] = {
	      X: x0,
	      Y: y0
	    };
	    points[jlen + 1] = {
	      X: x3,
	      Y: y3
	    };
	    bounds[0][jlen] = x0;
	    bounds[1][jlen] = y0;
	    bounds[0][jlen + 1] = x3;
	    bounds[1][jlen + 1] = y3;
	    tvalues.length = jlen + 2;
	    bounds[0].length = jlen + 2;
	    bounds[1].length = jlen + 2;
	    points.length = jlen + 2;
	    var left = min.apply(null, bounds[0]);
	    var top = min.apply(null, bounds[1]);
	    var right = max.apply(null, bounds[0]);
	    var bottom = max.apply(null, bounds[1]);
	    return new Rect(left, top, right - left, bottom - top);
	  },
	  clone: function () {
	    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
	  },
	  // Returns the point on the curve closest to point `p`
	  closestPoint: function (p, opt) {
	    return this.pointAtT(this.closestPointT(p, opt));
	  },
	  closestPointLength: function (p, opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    var localOpt = {
	      precision: precision,
	      subdivisions: subdivisions
	    };
	    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);
	  },
	  closestPointNormalizedLength: function (p, opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    var localOpt = {
	      precision: precision,
	      subdivisions: subdivisions
	    };
	    var cpLength = this.closestPointLength(p, localOpt);
	    if (!cpLength) return 0;
	    var length = this.length(localOpt);
	    if (length === 0) return 0;
	    return cpLength / length;
	  },
	  // Returns `t` of the point on the curve closest to point `p`
	  closestPointT: function (p, opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    // does not use localOpt

	    // identify the subdivision that contains the point:
	    var investigatedSubdivision;
	    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced
	    var investigatedSubdivisionEndT;
	    var distFromStart; // distance of point from start of baseline
	    var distFromEnd; // distance of point from end of baseline
	    var chordLength; // distance between start and end of the subdivision
	    var minSumDist; // lowest observed sum of the two distances
	    var n = subdivisions.length;
	    var subdivisionSize = n ? 1 / n : 0;
	    for (var i = 0; i < n; i++) {
	      var currentSubdivision = subdivisions[i];
	      var startDist = currentSubdivision.start.distance(p);
	      var endDist = currentSubdivision.end.distance(p);
	      var sumDist = startDist + endDist;

	      // check that the point is closest to current subdivision and not any other
	      if (!minSumDist || sumDist < minSumDist) {
	        investigatedSubdivision = currentSubdivision;
	        investigatedSubdivisionStartT = i * subdivisionSize;
	        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;
	        distFromStart = startDist;
	        distFromEnd = endDist;
	        chordLength = currentSubdivision.start.distance(currentSubdivision.end);
	        minSumDist = sumDist;
	      }
	    }
	    var precisionRatio = pow(10, -precision);

	    // recursively divide investigated subdivision:
	    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
	    // then return the closest endpoint of that final subdivision
	    while (true) {
	      // check if we have reached at least one required observed precision
	      // - calculated as: the difference in distances from point to start and end divided by the distance
	      // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
	      // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
	      // - this criterion works well for points lying far away from the curve
	      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;
	      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;
	      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;

	      // check if we have reached at least one required minimal distance
	      // - calculated as: the subdivision chord length multiplied by precisionRatio
	      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
	      // - this is a backup criterion that works well for points lying "almost at" the curve
	      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
	      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
	      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;

	      // do we stop now?
	      if (hasRequiredPrecision || hasMinimalDistance) {
	        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
	      }

	      // otherwise, set up for next iteration
	      var divided = investigatedSubdivision.divide(0.5);
	      subdivisionSize /= 2;
	      var startDist1 = divided[0].start.distance(p);
	      var endDist1 = divided[0].end.distance(p);
	      var sumDist1 = startDist1 + endDist1;
	      var startDist2 = divided[1].start.distance(p);
	      var endDist2 = divided[1].end.distance(p);
	      var sumDist2 = startDist2 + endDist2;
	      if (sumDist1 <= sumDist2) {
	        investigatedSubdivision = divided[0];
	        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved

	        distFromStart = startDist1;
	        distFromEnd = endDist1;
	      } else {
	        investigatedSubdivision = divided[1];
	        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved

	        distFromStart = startDist2;
	        distFromEnd = endDist2;
	      }
	    }
	  },
	  closestPointTangent: function (p, opt) {
	    return this.tangentAtT(this.closestPointT(p, opt));
	  },
	  // Returns `true` if the area surrounded by the curve contains the point `p`.
	  // Implements the even-odd algorithm (self-intersections are "outside").
	  // Closes open curves (always imagines a closing segment).
	  // Precision may be adjusted by passing an `opt` object.
	  containsPoint: function (p, opt) {
	    var polyline = this.toPolyline(opt);
	    return polyline.containsPoint(p);
	  },
	  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
	  // For a function that uses `t`, use Curve.divideAtT().
	  divideAt: function (ratio, opt) {
	    if (ratio <= 0) return this.divideAtT(0);
	    if (ratio >= 1) return this.divideAtT(1);
	    var t = this.tAt(ratio, opt);
	    return this.divideAtT(t);
	  },
	  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
	  divideAtLength: function (length, opt) {
	    var t = this.tAtLength(length, opt);
	    return this.divideAtT(t);
	  },
	  // Divides the curve into two at point defined by `t` between 0 and 1.
	  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).
	  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau
	  divideAtT: function (t) {
	    var start = this.start;
	    var controlPoint1 = this.controlPoint1;
	    var controlPoint2 = this.controlPoint2;
	    var end = this.end;

	    // shortcuts for `t` values that are out of range
	    if (t <= 0) {
	      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];
	    }
	    if (t >= 1) {
	      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];
	    }
	    var dividerPoints = this.getSkeletonPoints(t);
	    var startControl1 = dividerPoints.startControlPoint1;
	    var startControl2 = dividerPoints.startControlPoint2;
	    var divider = dividerPoints.divider;
	    var dividerControl1 = dividerPoints.dividerControlPoint1;
	    var dividerControl2 = dividerPoints.dividerControlPoint2;

	    // return array with two new curves
	    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];
	  },
	  // Returns the distance between the curve's start and end points.
	  endpointDistance: function () {
	    return this.start.distance(this.end);
	  },
	  // Checks whether two curves are exactly the same.
	  equals: function (c) {
	    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;
	  },
	  // Returns five helper points necessary for curve division.
	  getSkeletonPoints: function (t) {
	    var start = this.start;
	    var control1 = this.controlPoint1;
	    var control2 = this.controlPoint2;
	    var end = this.end;

	    // shortcuts for `t` values that are out of range
	    if (t <= 0) {
	      return {
	        startControlPoint1: start.clone(),
	        startControlPoint2: start.clone(),
	        divider: start.clone(),
	        dividerControlPoint1: control1.clone(),
	        dividerControlPoint2: control2.clone()
	      };
	    }
	    if (t >= 1) {
	      return {
	        startControlPoint1: control1.clone(),
	        startControlPoint2: control2.clone(),
	        divider: end.clone(),
	        dividerControlPoint1: end.clone(),
	        dividerControlPoint2: end.clone()
	      };
	    }
	    var midpoint1 = new Line(start, control1).pointAt(t);
	    var midpoint2 = new Line(control1, control2).pointAt(t);
	    var midpoint3 = new Line(control2, end).pointAt(t);
	    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
	    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
	    var divider = new Line(subControl1, subControl2).pointAt(t);
	    var output = {
	      startControlPoint1: midpoint1,
	      startControlPoint2: subControl1,
	      divider: divider,
	      dividerControlPoint1: subControl2,
	      dividerControlPoint2: midpoint3
	    };
	    return output;
	  },
	  // Returns a list of curves whose flattened length is better than `opt.precision`.
	  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%
	  // (Observed difference is not real precision, but close enough as long as special cases are covered)
	  // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)
	  // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)
	  // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)
	  // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)
	  // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)
	  // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)
	  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)
	  getSubdivisions: function (opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    // not using opt.subdivisions
	    // not using localOpt

	    var start = this.start;
	    var control1 = this.controlPoint1;
	    var control2 = this.controlPoint2;
	    var end = this.end;
	    var subdivisions = [new Curve(start, control1, control2, end)];
	    if (precision === 0) return subdivisions;

	    // special case #1: point-like curves
	    // - no need to calculate subdivisions, they would all be identical
	    var isPoint = !this.isDifferentiable();
	    if (isPoint) return subdivisions;
	    var previousLength = this.endpointDistance();
	    var precisionRatio = pow(10, -precision);

	    // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
	    // - not a problem for further iterations because cubic curves cannot have more than two local extrema
	    // - (i.e. cubic curves cannot intersect the baseline more than once)
	    // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length
	    // - (unless it's a straight-line curve, see below)
	    var minIterations = 2; // = 2*1

	    // special case #3: straight-line curves have the same observed length in all iterations
	    // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)
	    // - we enforce the expected number of iterations = 2 * precision
	    var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;
	    if (isLine) {
	      minIterations = 2 * precision;
	    }

	    // recursively divide curve at `t = 0.5`
	    // until we reach `minIterations`
	    // and until the difference between observed length at subsequent iterations is lower than `precision`
	    var iteration = 0;
	    while (true) {
	      iteration += 1;

	      // divide all subdivisions
	      var newSubdivisions = [];
	      var numSubdivisions = subdivisions.length;
	      for (var i = 0; i < numSubdivisions; i++) {
	        var currentSubdivision = subdivisions[i];
	        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)
	        newSubdivisions.push(divided[0], divided[1]);
	      }

	      // measure new length
	      var length = 0;
	      var numNewSubdivisions = newSubdivisions.length;
	      for (var j = 0; j < numNewSubdivisions; j++) {
	        var currentNewSubdivision = newSubdivisions[j];
	        length += currentNewSubdivision.endpointDistance();
	      }

	      // check if we have reached minimum number of iterations
	      if (iteration >= minIterations) {
	        // check if we have reached required observed precision
	        var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;
	        if (observedPrecisionRatio < precisionRatio) {
	          return newSubdivisions;
	        }
	      }

	      // otherwise, set up for next iteration
	      subdivisions = newSubdivisions;
	      previousLength = length;
	    }
	  },
	  isDifferentiable: function () {
	    var start = this.start;
	    var control1 = this.controlPoint1;
	    var control2 = this.controlPoint2;
	    var end = this.end;
	    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
	  },
	  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.
	  length: function (opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    // not using localOpt

	    var length = 0;
	    var n = subdivisions.length;
	    for (var i = 0; i < n; i++) {
	      var currentSubdivision = subdivisions[i];
	      length += currentSubdivision.endpointDistance();
	    }
	    return length;
	  },
	  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)
	  lengthAtT: function (t, opt) {
	    if (t <= 0) return 0;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    // not using opt.subdivisions
	    // not using localOpt

	    var subCurve = this.divide(t)[0];
	    var subCurveLength = subCurve.length({
	      precision: precision
	    });
	    return subCurveLength;
	  },
	  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
	  // Mirrors Line.pointAt() function.
	  // For a function that tracks `t`, use Curve.pointAtT().
	  pointAt: function (ratio, opt) {
	    if (ratio <= 0) return this.start.clone();
	    if (ratio >= 1) return this.end.clone();
	    var t = this.tAt(ratio, opt);
	    return this.pointAtT(t);
	  },
	  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
	  pointAtLength: function (length, opt) {
	    var t = this.tAtLength(length, opt);
	    return this.pointAtT(t);
	  },
	  // Returns the point at provided `t` between 0 and 1.
	  // `t` does not track distance along curve as it does in Line objects.
	  // Non-linear relationship, speeds up and slows down as curve warps!
	  // For linear length-based solution, use Curve.pointAt().
	  pointAtT: function (t) {
	    if (t <= 0) return this.start.clone();
	    if (t >= 1) return this.end.clone();
	    return this.getSkeletonPoints(t).divider;
	  },
	  // Default precision
	  PRECISION: 3,
	  round: function (precision) {
	    this.start.round(precision);
	    this.controlPoint1.round(precision);
	    this.controlPoint2.round(precision);
	    this.end.round(precision);
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    this.start.scale(sx, sy, origin);
	    this.controlPoint1.scale(sx, sy, origin);
	    this.controlPoint2.scale(sx, sy, origin);
	    this.end.scale(sx, sy, origin);
	    return this;
	  },
	  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
	  tangentAt: function (ratio, opt) {
	    if (!this.isDifferentiable()) return null;
	    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;
	    var t = this.tAt(ratio, opt);
	    return this.tangentAtT(t);
	  },
	  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
	  tangentAtLength: function (length, opt) {
	    if (!this.isDifferentiable()) return null;
	    var t = this.tAtLength(length, opt);
	    return this.tangentAtT(t);
	  },
	  // Returns a tangent line at requested `t`.
	  tangentAtT: function (t) {
	    if (!this.isDifferentiable()) return null;
	    if (t < 0) t = 0;else if (t > 1) t = 1;
	    var skeletonPoints = this.getSkeletonPoints(t);
	    var p1 = skeletonPoints.startControlPoint2;
	    var p2 = skeletonPoints.dividerControlPoint1;
	    var tangentStart = skeletonPoints.divider;
	    var tangentLine = new Line(p1, p2);
	    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested

	    return tangentLine;
	  },
	  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
	  tAt: function (ratio, opt) {
	    if (ratio <= 0) return 0;
	    if (ratio >= 1) return 1;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    var localOpt = {
	      precision: precision,
	      subdivisions: subdivisions
	    };
	    var curveLength = this.length(localOpt);
	    var length = curveLength * ratio;
	    return this.tAtLength(length, localOpt);
	  },
	  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
	  // Uses `precision` to approximate length within `precision` (always underestimates)
	  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated
	  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper
	  // - Precision 0 (chooses one of the two endpoints) - 0 levels
	  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level
	  // - Precision 2 (<1% error) - 3 levels
	  // - Precision 3 (<0.1% error) - 7 levels
	  // - Precision 4 (<0.01% error) - 15 levels
	  tAtLength: function (length, opt) {
	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    var localOpt = {
	      precision: precision,
	      subdivisions: subdivisions
	    };

	    // identify the subdivision that contains the point at requested `length`:
	    var investigatedSubdivision;
	    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced
	    var investigatedSubdivisionEndT;
	    //var baseline; // straightened version of subdivision to investigate
	    //var baselinePoint; // point on the baseline that is the requested distance away from start
	    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline
	    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline
	    var l = 0; // length so far
	    var n = subdivisions.length;
	    var subdivisionSize = 1 / n;
	    for (var i = 0; i < n; i++) {
	      var index = fromStart ? i : n - 1 - i;
	      var currentSubdivision = subdivisions[i];
	      var d = currentSubdivision.endpointDistance(); // length of current subdivision

	      if (length <= l + d) {
	        investigatedSubdivision = currentSubdivision;
	        investigatedSubdivisionStartT = index * subdivisionSize;
	        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;
	        baselinePointDistFromStart = fromStart ? length - l : d + l - length;
	        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;
	        break;
	      }
	      l += d;
	    }
	    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t
	    // note that precision affects what length is recorded
	    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
	    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1

	    var curveLength = this.length(localOpt);
	    var precisionRatio = pow(10, -precision);

	    // recursively divide investigated subdivision:
	    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
	    // then return the closest endpoint of that final subdivision
	    while (true) {
	      // check if we have reached required observed precision
	      var observedPrecisionRatio;
	      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;
	      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;
	      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;
	      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;

	      // otherwise, set up for next iteration
	      var newBaselinePointDistFromStart;
	      var newBaselinePointDistFromEnd;
	      var divided = investigatedSubdivision.divide(0.5);
	      subdivisionSize /= 2;
	      var baseline1Length = divided[0].endpointDistance();
	      var baseline2Length = divided[1].endpointDistance();
	      if (baselinePointDistFromStart <= baseline1Length) {
	        // point at requested length is inside divided[0]
	        investigatedSubdivision = divided[0];
	        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved

	        newBaselinePointDistFromStart = baselinePointDistFromStart;
	        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
	      } else {
	        // point at requested length is inside divided[1]
	        investigatedSubdivision = divided[1];
	        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved

	        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
	        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
	      }
	      baselinePointDistFromStart = newBaselinePointDistFromStart;
	      baselinePointDistFromEnd = newBaselinePointDistFromEnd;
	    }
	  },
	  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
	  // Flattened length is no more than 10^(-precision) away from real curve length.
	  toPoints: function (opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call
	    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
	      precision: precision
	    }) : opt.subdivisions;
	    // not using localOpt

	    var points = [subdivisions[0].start.clone()];
	    var n = subdivisions.length;
	    for (var i = 0; i < n; i++) {
	      var currentSubdivision = subdivisions[i];
	      points.push(currentSubdivision.end.clone());
	    }
	    return points;
	  },
	  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
	  // Flattened length is no more than 10^(-precision) away from real curve length.
	  toPolyline: function (opt) {
	    return new Polyline$1(this.toPoints(opt));
	  },
	  toString: function () {
	    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;
	  },
	  translate: function (tx, ty) {
	    this.start.translate(tx, ty);
	    this.controlPoint1.translate(tx, ty);
	    this.controlPoint2.translate(tx, ty);
	    this.end.translate(tx, ty);
	    return this;
	  }
	};
	Curve.prototype.divide = Curve.prototype.divideAtT;

	// Local helper function.
	// Add properties from arguments on top of properties from `obj`.
	// This allows for rudimentary inheritance.
	// - The `obj` argument acts as parent.
	// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.
	// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.
	function extend$1(obj) {
	  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.
	  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)
	  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?
	  // - First, realize that both of those quasiclasses would still have their own separate constructor function.
	  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.
	  // - This method provides a way to do exactly that.
	  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.
	  // - Therefore, to continue with the example above:
	  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`
	  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.
	  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.
	  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.
	  // - Multiple inheritance is also possible, if multiple arguments are provided.
	  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?
	  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`
	  //   - The ancestors are applied in order of appearance.
	  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.
	  //   - Any number of ancestors may be provided.
	  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.
	  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).
	  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.
	  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.
	  // - Therefore, both of the following are valid:
	  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`
	  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`

	  var i;
	  var n;
	  var args = [];
	  n = arguments.length;
	  for (i = 1; i < n; i++) {
	    // skip over obj
	    args.push(arguments[i]);
	  }
	  if (!obj) throw new Error('Missing a parent object.');
	  var child = Object.create(obj);
	  n = args.length;
	  for (i = 0; i < n; i++) {
	    var src = args[i];
	    var inheritedProperty;
	    var key;
	    for (key in src) {
	      if (src.hasOwnProperty(key)) {
	        delete child[key]; // delete property inherited from parent
	        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src
	        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)
	      }
	    }
	  }
	  return child;
	}

	// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.
	// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).
	const Path$1 = function (arg) {
	  if (!(this instanceof Path$1)) {
	    return new Path$1(arg);
	  }
	  if (typeof arg === 'string') {
	    // create from a path data string
	    return new Path$1.parse(arg);
	  }
	  this.segments = [];
	  var i;
	  var n;
	  if (!arg) {
	    // don't do anything
	  } else if (Array.isArray(arg) && arg.length !== 0) {
	    // if arg is a non-empty array
	    // flatten one level deep
	    // so we can chain arbitrary Path.createSegment results
	    arg = arg.reduce(function (acc, val) {
	      return acc.concat(val);
	    }, []);
	    n = arg.length;
	    if (arg[0].isSegment) {
	      // create from an array of segments
	      for (i = 0; i < n; i++) {
	        var segment = arg[i];
	        this.appendSegment(segment);
	      }
	    } else {
	      // create from an array of Curves and/or Lines
	      var previousObj = null;
	      for (i = 0; i < n; i++) {
	        var obj = arg[i];
	        if (!(obj instanceof Line || obj instanceof Curve)) {
	          throw new Error('Cannot construct a path segment from the provided object.');
	        }
	        if (i === 0) this.appendSegment(Path$1.createSegment('M', obj.start));

	        // if objects do not link up, moveto segments are inserted to cover the gaps
	        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path$1.createSegment('M', obj.start));
	        if (obj instanceof Line) {
	          this.appendSegment(Path$1.createSegment('L', obj.end));
	        } else if (obj instanceof Curve) {
	          this.appendSegment(Path$1.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));
	        }
	        previousObj = obj;
	      }
	    }
	  } else if (arg.isSegment) {
	    // create from a single segment
	    this.appendSegment(arg);
	  } else if (arg instanceof Line) {
	    // create from a single Line
	    this.appendSegment(Path$1.createSegment('M', arg.start));
	    this.appendSegment(Path$1.createSegment('L', arg.end));
	  } else if (arg instanceof Curve) {
	    // create from a single Curve
	    this.appendSegment(Path$1.createSegment('M', arg.start));
	    this.appendSegment(Path$1.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));
	  } else if (arg instanceof Polyline$1) {
	    // create from a Polyline
	    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty

	    n = arg.points.length;
	    for (i = 0; i < n; i++) {
	      var point = arg.points[i];
	      if (i === 0) this.appendSegment(Path$1.createSegment('M', point));else this.appendSegment(Path$1.createSegment('L', point));
	    }
	  } else {
	    // unknown object
	    throw new Error('Cannot construct a path from the provided object.');
	  }
	};

	// More permissive than V.normalizePathData and Path.prototype.serialize.
	// Allows path data strings that do not start with a Moveto command (unlike SVG specification).
	// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').
	// Allows for command argument chaining.
	// Throws an error if wrong number of arguments is provided with a command.
	// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).
	Path$1.parse = function (pathData) {
	  if (!pathData) return new Path$1();
	  var path = new Path$1();
	  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
	  var commands = pathData.match(commandRe);
	  var numCommands = commands.length;
	  for (var i = 0; i < numCommands; i++) {
	    var command = commands[i];
	    var argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
	    var args = command.match(argRe);
	    var segment = Path$1.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]
	    path.appendSegment(segment);
	  }
	  return path;
	};

	// Create a segment or an array of segments.
	// Accepts unlimited points/coords arguments after `type`.
	Path$1.createSegment = function (type) {
	  if (!type) throw new Error('Type must be provided.');
	  var segmentConstructor = Path$1.segmentTypes[type];
	  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');
	  var args = [];
	  var n = arguments.length;
	  for (var i = 1; i < n; i++) {
	    // do not add first element (`type`) to args array
	    args.push(arguments[i]);
	  }
	  return applyToNew(segmentConstructor, args);
	};
	Path$1.prototype = {
	  type: types.Path,
	  // Accepts one segment or an array of segments as argument.
	  // Throws an error if argument is not a segment or an array of segments.
	  appendSegment: function (arg) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    // works even if path has no segments

	    var currentSegment;
	    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null
	    var nextSegment = null;
	    if (!Array.isArray(arg)) {
	      // arg is a segment
	      if (!arg || !arg.isSegment) throw new Error('Segment required.');
	      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
	      segments.push(currentSegment);
	    } else {
	      // arg is an array of segments
	      // flatten one level deep
	      // so we can chain arbitrary Path.createSegment results
	      arg = arg.reduce(function (acc, val) {
	        return acc.concat(val);
	      }, []);
	      if (!arg[0].isSegment) throw new Error('Segments required.');
	      var n = arg.length;
	      for (var i = 0; i < n; i++) {
	        var currentArg = arg[i];
	        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
	        segments.push(currentSegment);
	        previousSegment = currentSegment;
	      }
	    }
	  },
	  // Returns the bbox of the path.
	  // If path has no segments, returns null.
	  // If path has only invisible segments, returns bbox of the end point of last segment.
	  bbox: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var bbox;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      if (segment.isVisible) {
	        var segmentBBox = segment.bbox();
	        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
	      }
	    }
	    if (bbox) return bbox;

	    // if the path has only invisible elements, return end point of last segment
	    var lastSegment = segments[numSegments - 1];
	    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);
	  },
	  // Returns a new path that is a clone of this path.
	  clone: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    // works even if path has no segments

	    var path = new Path$1();
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i].clone();
	      path.appendSegment(segment);
	    }
	    return path;
	  },
	  closestPoint: function (p, opt) {
	    var t = this.closestPointT(p, opt);
	    if (!t) return null;
	    return this.pointAtT(t);
	  },
	  closestPointLength: function (p, opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var t = this.closestPointT(p, localOpt);
	    if (!t) return 0;
	    return this.lengthAtT(t, localOpt);
	  },
	  closestPointNormalizedLength: function (p, opt) {
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var cpLength = this.closestPointLength(p, localOpt);
	    if (cpLength === 0) return 0; // shortcut

	    var length = this.length(localOpt);
	    if (length === 0) return 0; // prevents division by zero

	    return cpLength / length;
	  },
	  // Private function.
	  closestPointT: function (p, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var closestPointT;
	    var minSquaredDistance = Infinity;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      var subdivisions = segmentSubdivisions[i];
	      if (segment.isVisible) {
	        var segmentClosestPointT = segment.closestPointT(p, {
	          precision: precision,
	          subdivisions: subdivisions
	        });
	        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
	        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();
	        if (squaredDistance < minSquaredDistance) {
	          closestPointT = {
	            segmentIndex: i,
	            value: segmentClosestPointT
	          };
	          minSquaredDistance = squaredDistance;
	        }
	      }
	    }
	    if (closestPointT) return closestPointT;

	    // if no visible segment, return end of last segment
	    return {
	      segmentIndex: numSegments - 1,
	      value: 1
	    };
	  },
	  closestPointTangent: function (p, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var closestPointTangent;
	    var minSquaredDistance = Infinity;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      var subdivisions = segmentSubdivisions[i];
	      if (segment.isDifferentiable()) {
	        var segmentClosestPointT = segment.closestPointT(p, {
	          precision: precision,
	          subdivisions: subdivisions
	        });
	        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
	        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();
	        if (squaredDistance < minSquaredDistance) {
	          closestPointTangent = segment.tangentAtT(segmentClosestPointT);
	          minSquaredDistance = squaredDistance;
	        }
	      }
	    }
	    if (closestPointTangent) return closestPointTangent;

	    // if no valid segment, return null
	    return null;
	  },
	  // Returns `true` if the area surrounded by the path contains the point `p`.
	  // Implements the even-odd algorithm (self-intersections are "outside").
	  // Closes open paths (always imagines a final closing segment).
	  // Precision may be adjusted by passing an `opt` object.
	  containsPoint: function (p, opt) {
	    var polylines = this.toPolylines(opt);
	    if (!polylines) return false; // shortcut (this path has no polylines)

	    var numPolylines = polylines.length;

	    // how many component polylines does `p` lie within?
	    var numIntersections = 0;
	    for (var i = 0; i < numPolylines; i++) {
	      var polyline = polylines[i];
	      if (polyline.containsPoint(p)) {
	        // `p` lies within this polyline
	        numIntersections++;
	      }
	    }

	    // returns `true` for odd numbers of intersections (even-odd algorithm)
	    return numIntersections % 2 === 1;
	  },
	  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
	  divideAt: function (ratio, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    if (ratio < 0) ratio = 0;
	    if (ratio > 1) ratio = 1;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var pathLength = this.length(localOpt);
	    var length = pathLength * ratio;
	    return this.divideAtLength(length, localOpt);
	  },
	  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
	  divideAtLength: function (length, opt) {
	    var numSegments = this.segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var i;
	    var segment;

	    // identify the segment to divide:

	    var l = 0; // length so far
	    var divided;
	    var dividedSegmentIndex;
	    var lastValidSegment; // visible AND differentiable
	    var lastValidSegmentIndex;
	    var t;
	    for (i = 0; i < numSegments; i++) {
	      var index = fromStart ? i : numSegments - 1 - i;
	      segment = this.getSegment(index);
	      var subdivisions = segmentSubdivisions[index];
	      var d = segment.length({
	        precision: precision,
	        subdivisions: subdivisions
	      });
	      if (segment.isDifferentiable()) {
	        // segment is not just a point
	        lastValidSegment = segment;
	        lastValidSegmentIndex = index;
	        if (length <= l + d) {
	          dividedSegmentIndex = index;
	          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {
	            precision: precision,
	            subdivisions: subdivisions
	          });
	          break;
	        }
	      }
	      l += d;
	    }
	    if (!lastValidSegment) {
	      // no valid segment found
	      return null;
	    }

	    // else: the path contains at least one valid segment

	    if (!divided) {
	      // the desired length is greater than the length of the path
	      dividedSegmentIndex = lastValidSegmentIndex;
	      t = fromStart ? 1 : 0;
	      divided = lastValidSegment.divideAtT(t);
	    }

	    // create a copy of this path and replace the identified segment with its two divided parts:

	    var pathCopy = this.clone();
	    pathCopy.replaceSegment(dividedSegmentIndex, divided);
	    var divisionStartIndex = dividedSegmentIndex;
	    var divisionMidIndex = dividedSegmentIndex + 1;
	    var divisionEndIndex = dividedSegmentIndex + 2;

	    // do not insert the part if it looks like a point
	    if (!divided[0].isDifferentiable()) {
	      pathCopy.removeSegment(divisionStartIndex);
	      divisionMidIndex -= 1;
	      divisionEndIndex -= 1;
	    }

	    // insert a Moveto segment to ensure secondPath will be valid:
	    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
	    pathCopy.insertSegment(divisionMidIndex, Path$1.createSegment('M', movetoEnd));
	    divisionEndIndex += 1;

	    // do not insert the part if it looks like a point
	    if (!divided[1].isDifferentiable()) {
	      pathCopy.removeSegment(divisionEndIndex - 1);
	      divisionEndIndex -= 1;
	    }

	    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:

	    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
	    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {
	      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
	      segment = pathCopy.getSegment(i);
	      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
	        // pathCopy segment's subpathStartSegment is different from original segment's one
	        // convert this Closepath segment to a Lineto and replace it in pathCopy
	        var convertedSegment = Path$1.createSegment('L', originalSegment.end);
	        pathCopy.replaceSegment(i, convertedSegment);
	      }
	    }

	    // distribute pathCopy segments into two paths and return those:

	    var firstPath = new Path$1(pathCopy.segments.slice(0, divisionMidIndex));
	    var secondPath = new Path$1(pathCopy.segments.slice(divisionMidIndex));
	    return [firstPath, secondPath];
	  },
	  // Checks whether two paths are exactly the same.
	  // If `p` is undefined or null, returns false.
	  equals: function (p) {
	    if (!p) return false;
	    var segments = this.segments;
	    var otherSegments = p.segments;
	    var numSegments = segments.length;
	    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal

	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      var otherSegment = otherSegments[i];

	      // as soon as an inequality is found in segments, return false
	      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;
	    }

	    // if no inequality found in segments, return true
	    return true;
	  },
	  // Accepts negative indices.
	  // Throws an error if path has no segments.
	  // Throws an error if index is out of range.
	  getSegment: function (index) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) throw new Error('Path has no segments.');
	    if (index < 0) index = numSegments + index; // convert negative indices to positive
	    if (index >= numSegments || index < 0) throw new Error('Index out of range.');
	    return segments[index];
	  },
	  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.
	  getSegmentSubdivisions: function (opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    // works even if path has no segments

	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    // not using opt.segmentSubdivisions
	    // not using localOpt

	    var segmentSubdivisions = [];
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      var subdivisions = segment.getSubdivisions({
	        precision: precision
	      });
	      segmentSubdivisions.push(subdivisions);
	    }
	    return segmentSubdivisions;
	  },
	  // Returns an array of subpaths of this path.
	  // Invalid paths are validated first.
	  // Returns `[]` if path has no segments.
	  getSubpaths: function () {
	    const validatedPath = this.clone().validate();
	    const segments = validatedPath.segments;
	    const numSegments = segments.length;
	    const subpaths = [];
	    for (let i = 0; i < numSegments; i++) {
	      const segment = segments[i];
	      if (segment.isSubpathStart) {
	        // we encountered a subpath start segment
	        // create a new path for segment, and push it to list of subpaths
	        subpaths.push(new Path$1(segment));
	      } else {
	        // append current segment to the last subpath
	        subpaths[subpaths.length - 1].appendSegment(segment);
	      }
	    }
	    return subpaths;
	  },
	  // Insert `arg` at given `index`.
	  // `index = 0` means insert at the beginning.
	  // `index = segments.length` means insert at the end.
	  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.
	  // Accepts one segment or an array of segments as argument.
	  // Throws an error if index is out of range.
	  // Throws an error if argument is not a segment or an array of segments.
	  insertSegment: function (index, arg) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    // works even if path has no segments

	    // note that these are incremented compared to getSegments()
	    // we can insert after last element (note that this changes the meaning of index -1)
	    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive
	    if (index > numSegments || index < 0) throw new Error('Index out of range.');
	    var currentSegment;
	    var previousSegment = null;
	    var nextSegment = null;
	    if (numSegments !== 0) {
	      if (index >= 1) {
	        previousSegment = segments[index - 1];
	        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null
	      } else {
	        // if index === 0
	        // previousSegment is null
	        nextSegment = segments[0];
	      }
	    }
	    if (!Array.isArray(arg)) {
	      if (!arg || !arg.isSegment) throw new Error('Segment required.');
	      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
	      segments.splice(index, 0, currentSegment);
	    } else {
	      // flatten one level deep
	      // so we can chain arbitrary Path.createSegment results
	      arg = arg.reduce(function (acc, val) {
	        return acc.concat(val);
	      }, []);
	      if (!arg[0].isSegment) throw new Error('Segments required.');
	      var n = arg.length;
	      for (var i = 0; i < n; i++) {
	        var currentArg = arg[i];
	        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
	        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments
	        previousSegment = currentSegment;
	      }
	    }
	  },
	  intersectionWithLine: function (line, opt) {
	    var intersection = null;
	    var polylines = this.toPolylines(opt);
	    if (!polylines) return null;
	    for (var i = 0, n = polylines.length; i < n; i++) {
	      var polyline = polylines[i];
	      var polylineIntersection = line.intersect(polyline);
	      if (polylineIntersection) {
	        intersection || (intersection = []);
	        if (Array.isArray(polylineIntersection)) {
	          Array.prototype.push.apply(intersection, polylineIntersection);
	        } else {
	          intersection.push(polylineIntersection);
	        }
	      }
	    }
	    return intersection;
	  },
	  isDifferentiable: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      // as soon as a differentiable segment is found in segments, return true
	      if (segment.isDifferentiable()) return true;
	    }

	    // if no differentiable segment is found in segments, return false
	    return false;
	  },
	  // Checks whether current path segments are valid.
	  // Note that d is allowed to be empty - should disable rendering of the path.
	  isValid: function () {
	    var segments = this.segments;
	    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto
	    return isValid;
	  },
	  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.
	  // If path has no segments, returns 0.
	  length: function (opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return 0; // if segments is an empty array

	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var length = 0;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      var subdivisions = segmentSubdivisions[i];
	      length += segment.length({
	        subdivisions: subdivisions
	      });
	    }
	    return length;
	  },
	  // Private function.
	  lengthAtT: function (t, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return 0; // if segments is an empty array

	    var segmentIndex = t.segmentIndex;
	    if (segmentIndex < 0) return 0; // regardless of t.value

	    var tValue = t.value;
	    if (segmentIndex >= numSegments) {
	      segmentIndex = numSegments - 1;
	      tValue = 1;
	    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var subdivisions;
	    var length = 0;
	    for (var i = 0; i < segmentIndex; i++) {
	      var segment = segments[i];
	      subdivisions = segmentSubdivisions[i];
	      length += segment.length({
	        precisison: precision,
	        subdivisions: subdivisions
	      });
	    }
	    segment = segments[segmentIndex];
	    subdivisions = segmentSubdivisions[segmentIndex];
	    length += segment.lengthAtT(tValue, {
	      precisison: precision,
	      subdivisions: subdivisions
	    });
	    return length;
	  },
	  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
	  pointAt: function (ratio, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    if (ratio <= 0) return this.start.clone();
	    if (ratio >= 1) return this.end.clone();
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var pathLength = this.length(localOpt);
	    var length = pathLength * ratio;
	    return this.pointAtLength(length, localOpt);
	  },
	  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
	  // Accepts negative length.
	  pointAtLength: function (length, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    if (length === 0) return this.start.clone();
	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var lastVisibleSegment;
	    var l = 0; // length so far
	    for (var i = 0; i < numSegments; i++) {
	      var index = fromStart ? i : numSegments - 1 - i;
	      var segment = segments[index];
	      var subdivisions = segmentSubdivisions[index];
	      var d = segment.length({
	        precision: precision,
	        subdivisions: subdivisions
	      });
	      if (segment.isVisible) {
	        if (length <= l + d) {
	          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {
	            precision: precision,
	            subdivisions: subdivisions
	          });
	        }
	        lastVisibleSegment = segment;
	      }
	      l += d;
	    }

	    // if length requested is higher than the length of the path, return last visible segment endpoint
	    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;

	    // if no visible segment, return last segment end point (no matter if fromStart or no)
	    var lastSegment = segments[numSegments - 1];
	    return lastSegment.end.clone();
	  },
	  // Private function.
	  pointAtT: function (t) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var segmentIndex = t.segmentIndex;
	    if (segmentIndex < 0) return segments[0].pointAtT(0);
	    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);
	    var tValue = t.value;
	    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;
	    return segments[segmentIndex].pointAtT(tValue);
	  },
	  // Default precision
	  PRECISION: 3,
	  // Helper method for adding segments.
	  prepareSegment: function (segment, previousSegment, nextSegment) {
	    // insert after previous segment and before previous segment's next segment
	    segment.previousSegment = previousSegment;
	    segment.nextSegment = nextSegment;
	    if (previousSegment) previousSegment.nextSegment = segment;
	    if (nextSegment) nextSegment.previousSegment = segment;
	    var updateSubpathStart = segment;
	    if (segment.isSubpathStart) {
	      segment.subpathStartSegment = segment; // assign self as subpath start segment
	      updateSubpathStart = nextSegment; // start updating from next segment
	    }

	    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
	    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);
	    return segment;
	  },
	  // Remove the segment at `index`.
	  // Accepts negative indices, from `-1` to `-segments.length`.
	  // Throws an error if path has no segments.
	  // Throws an error if index is out of range.
	  removeSegment: function (index) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) throw new Error('Path has no segments.');
	    if (index < 0) index = numSegments + index; // convert negative indices to positive
	    if (index >= numSegments || index < 0) throw new Error('Index out of range.');
	    var removedSegment = segments.splice(index, 1)[0];
	    var previousSegment = removedSegment.previousSegment;
	    var nextSegment = removedSegment.nextSegment;

	    // link the previous and next segments together (if present)
	    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null
	    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null

	    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached
	    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
	  },
	  // Replace the segment at `index` with `arg`.
	  // Accepts negative indices, from `-1` to `-segments.length`.
	  // Accepts one segment or an array of segments as argument.
	  // Throws an error if path has no segments.
	  // Throws an error if index is out of range.
	  // Throws an error if argument is not a segment or an array of segments.
	  replaceSegment: function (index, arg) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) throw new Error('Path has no segments.');
	    if (index < 0) index = numSegments + index; // convert negative indices to positive
	    if (index >= numSegments || index < 0) throw new Error('Index out of range.');
	    var currentSegment;
	    var replacedSegment = segments[index];
	    var previousSegment = replacedSegment.previousSegment;
	    var nextSegment = replacedSegment.nextSegment;
	    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?

	    if (!Array.isArray(arg)) {
	      if (!arg || !arg.isSegment) throw new Error('Segment required.');
	      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
	      segments.splice(index, 1, currentSegment); // directly replace

	      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`
	    } else {
	      // flatten one level deep
	      // so we can chain arbitrary Path.createSegment results
	      arg = arg.reduce(function (acc, val) {
	        return acc.concat(val);
	      }, []);
	      if (!arg[0].isSegment) throw new Error('Segments required.');
	      segments.splice(index, 1);
	      var n = arg.length;
	      for (var i = 0; i < n; i++) {
	        var currentArg = arg[i];
	        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
	        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments
	        previousSegment = currentSegment;
	        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`
	      }
	    }

	    // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached
	    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
	  },
	  round: function (precision) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      segment.round(precision);
	    }
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      segment.scale(sx, sy, origin);
	    }
	    return this;
	  },
	  segmentAt: function (ratio, opt) {
	    var index = this.segmentIndexAt(ratio, opt);
	    if (!index) return null;
	    return this.getSegment(index);
	  },
	  // Accepts negative length.
	  segmentAtLength: function (length, opt) {
	    var index = this.segmentIndexAtLength(length, opt);
	    if (!index) return null;
	    return this.getSegment(index);
	  },
	  segmentIndexAt: function (ratio, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    if (ratio < 0) ratio = 0;
	    if (ratio > 1) ratio = 1;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var pathLength = this.length(localOpt);
	    var length = pathLength * ratio;
	    return this.segmentIndexAtLength(length, localOpt);
	  },
	  // Accepts negative length.
	  segmentIndexAtLength: function (length, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var lastVisibleSegmentIndex = null;
	    var l = 0; // length so far
	    for (var i = 0; i < numSegments; i++) {
	      var index = fromStart ? i : numSegments - 1 - i;
	      var segment = segments[index];
	      var subdivisions = segmentSubdivisions[index];
	      var d = segment.length({
	        precision: precision,
	        subdivisions: subdivisions
	      });
	      if (segment.isVisible) {
	        if (length <= l + d) return index;
	        lastVisibleSegmentIndex = index;
	      }
	      l += d;
	    }

	    // if length requested is higher than the length of the path, return last visible segment index
	    // if no visible segment, return null
	    return lastVisibleSegmentIndex;
	  },
	  // Returns a string that can be used to reconstruct the path.
	  // Additional error checking compared to toString (must start with M segment).
	  serialize: function () {
	    if (!this.isValid()) throw new Error('Invalid path segments.');
	    return this.toString();
	  },
	  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
	  tangentAt: function (ratio, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    if (ratio < 0) ratio = 0;
	    if (ratio > 1) ratio = 1;
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var localOpt = {
	      precision: precision,
	      segmentSubdivisions: segmentSubdivisions
	    };
	    var pathLength = this.length(localOpt);
	    var length = pathLength * ratio;
	    return this.tangentAtLength(length, localOpt);
	  },
	  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
	  // Accepts negative length.
	  tangentAtLength: function (length, opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var fromStart = true;
	    if (length < 0) {
	      fromStart = false; // negative lengths mean start calculation from end point
	      length = -length; // absolute value
	    }
	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    // not using localOpt

	    var lastValidSegment; // visible AND differentiable (with a tangent)
	    var l = 0; // length so far
	    for (var i = 0; i < numSegments; i++) {
	      var index = fromStart ? i : numSegments - 1 - i;
	      var segment = segments[index];
	      var subdivisions = segmentSubdivisions[index];
	      var d = segment.length({
	        precision: precision,
	        subdivisions: subdivisions
	      });
	      if (segment.isDifferentiable()) {
	        if (length <= l + d) {
	          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {
	            precision: precision,
	            subdivisions: subdivisions
	          });
	        }
	        lastValidSegment = segment;
	      }
	      l += d;
	    }

	    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
	    if (lastValidSegment) {
	      var t = fromStart ? 1 : 0;
	      return lastValidSegment.tangentAtT(t);
	    }

	    // if no valid segment, return null
	    return null;
	  },
	  // Private function.
	  tangentAtT: function (t) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    var segmentIndex = t.segmentIndex;
	    if (segmentIndex < 0) return segments[0].tangentAtT(0);
	    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);
	    var tValue = t.value;
	    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;
	    return segments[segmentIndex].tangentAtT(tValue);
	  },
	  toPoints: function (opt) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null; // if segments is an empty array

	    opt = opt || {};
	    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
	    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
	      precision: precision
	    }) : opt.segmentSubdivisions;
	    var points = [];
	    var partialPoints = [];
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      if (segment.isVisible) {
	        var currentSegmentSubdivisions = segmentSubdivisions[i];
	        if (currentSegmentSubdivisions.length > 0) {
	          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {
	            return curve.start;
	          });
	          Array.prototype.push.apply(partialPoints, subdivisionPoints);
	        } else {
	          partialPoints.push(segment.start);
	        }
	      } else if (partialPoints.length > 0) {
	        partialPoints.push(segments[i - 1].end);
	        points.push(partialPoints);
	        partialPoints = [];
	      }
	    }
	    if (partialPoints.length > 0) {
	      partialPoints.push(this.end);
	      points.push(partialPoints);
	    }
	    return points;
	  },
	  toPolylines: function (opt) {
	    var polylines = [];
	    var points = this.toPoints(opt);
	    if (!points) return null;
	    for (var i = 0, n = points.length; i < n; i++) {
	      polylines.push(new Polyline$1(points[i]));
	    }
	    return polylines;
	  },
	  toString: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    var pathData = '';
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      pathData += segment.serialize() + ' ';
	    }
	    return pathData.trim();
	  },
	  translate: function (tx, ty) {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      segment.translate(tx, ty);
	    }
	    return this;
	  },
	  // Helper method for updating subpath start of segments, starting with the one provided.
	  updateSubpathStartSegment: function (segment) {
	    var previousSegment = segment.previousSegment; // may be null
	    while (segment && !segment.isSubpathStart) {
	      // assign previous segment's subpath start segment to this segment
	      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null
	      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!

	      previousSegment = segment;
	      segment = segment.nextSegment; // move on to the segment after etc.
	    }
	  },
	  // If the path is not valid, insert M 0 0 at the beginning.
	  // Path with no segments is considered valid, so nothing is inserted.
	  validate: function () {
	    if (!this.isValid()) this.insertSegment(0, Path$1.createSegment('M', 0, 0));
	    return this;
	  }
	};
	Object.defineProperty(Path$1.prototype, 'start', {
	  // Getter for the first visible endpoint of the path.

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null;
	    for (var i = 0; i < numSegments; i++) {
	      var segment = segments[i];
	      if (segment.isVisible) return segment.start;
	    }

	    // if no visible segment, return last segment end point
	    return segments[numSegments - 1].end;
	  }
	});
	Object.defineProperty(Path$1.prototype, 'end', {
	  // Getter for the last visible endpoint of the path.

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    var segments = this.segments;
	    var numSegments = segments.length;
	    if (numSegments === 0) return null;
	    for (var i = numSegments - 1; i >= 0; i--) {
	      var segment = segments[i];
	      if (segment.isVisible) return segment.end;
	    }

	    // if no visible segment, return last segment end point
	    return segments[numSegments - 1].end;
	  }
	});

	// Local helper function.
	// Use an array of arguments to call a constructor (function called with `new`).
	// Adapted from https://stackoverflow.com/a/8843181/2263595
	// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).
	// - If that is the case, use `new constructor(arg1, arg2)`, for example.
	// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.
	// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.
	function applyToNew(constructor, argsArray) {
	  // The `new` keyword can only be applied to functions that take a limited number of arguments.
	  // - We can fake that with .bind().
	  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.
	  // - So `new (constructor.bind(thisArg, arg1, arg2...))`
	  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.
	  // We need to pass in a variable number of arguments to the bind() call.
	  // - We can use .apply().
	  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`
	  // - `thisArg` can still be anything because `new` overwrites it.
	  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.
	  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`

	  // The function expects `argsArray[0]` to be `thisArg`.
	  // - This means that whatever is sent as the first element will be ignored.
	  // - The constructor will only see arguments starting from argsArray[1].
	  // - So, a new dummy element is inserted at the start of the array.
	  argsArray.unshift(null);
	  return new (Function.prototype.bind.apply(constructor, argsArray))();
	}

	// Path segment interface:
	var segmentPrototype = {
	  // virtual
	  bbox: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  clone: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  closestPoint: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  closestPointLength: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  closestPointNormalizedLength: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.
	  closestPointT: function (p) {
	    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);
	    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');
	  },
	  // virtual
	  closestPointTangent: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  divideAt: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  divideAtLength: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.
	  divideAtT: function (t) {
	    if (this.divideAt) return this.divideAt(t);
	    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');
	  },
	  // virtual
	  equals: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  getSubdivisions: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  isDifferentiable: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  isSegment: true,
	  isSubpathStart: false,
	  // true for Moveto segments

	  isVisible: true,
	  // false for Moveto segments

	  // virtual
	  length: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.
	  lengthAtT: function (t) {
	    if (t <= 0) return 0;
	    var length = this.length();
	    if (t >= 1) return length;
	    return length * t;
	  },
	  nextSegment: null,
	  // needed for subpath start segment updating

	  // virtual
	  pointAt: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  pointAtLength: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.
	  pointAtT: function (t) {
	    if (this.pointAt) return this.pointAt(t);
	    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');
	  },
	  previousSegment: null,
	  // needed to get segment start property

	  // virtual
	  round: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  subpathStartSegment: null,
	  // needed to get Closepath segment end property

	  // virtual
	  scale: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  serialize: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  tangentAt: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  tangentAtLength: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.
	  tangentAtT: function (t) {
	    if (this.tangentAt) return this.tangentAt(t);
	    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');
	  },
	  // virtual
	  toString: function () {
	    throw new Error('Declaration missing for virtual function.');
	  },
	  // virtual
	  translate: function () {
	    throw new Error('Declaration missing for virtual function.');
	  }
	};

	// usually directly assigned
	// getter for Closepath
	Object.defineProperty(segmentPrototype, 'end', {
	  configurable: true,
	  enumerable: true,
	  writable: true
	});

	// always a getter
	// always throws error for Moveto
	Object.defineProperty(segmentPrototype, 'start', {
	  // get a reference to the end point of previous segment

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');
	    return this.previousSegment.end;
	  }
	});

	// virtual
	Object.defineProperty(segmentPrototype, 'type', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    throw new Error('Bad segment declaration. No type specified.');
	  }
	});

	// Path segment implementations:
	var Lineto = function () {
	  var args = [];
	  var n = arguments.length;
	  for (var i = 0; i < n; i++) {
	    args.push(arguments[i]);
	  }
	  if (!(this instanceof Lineto)) {
	    // switching context of `this` to Lineto when called without `new`
	    return applyToNew(Lineto, args);
	  }
	  if (n === 0) {
	    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');
	  }
	  var outputArray;
	  if (args[0] instanceof Line) {
	    // lines provided
	    if (n === 1) {
	      this.end = args[0].end.clone();
	      return this;
	    } else {
	      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');
	    }
	  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {
	    // coordinates provided
	    if (n === 2) {
	      this.end = new Point(+args[0], +args[1]);
	      return this;
	    } else if (n < 2) {
	      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');
	    } else {
	      // this is a poly-line segment
	      var segmentCoords;
	      outputArray = [];
	      for (i = 0; i < n; i += 2) {
	        // coords come in groups of two

	        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2
	        outputArray.push(applyToNew(Lineto, segmentCoords));
	      }
	      return outputArray;
	    }
	  } else {
	    // points provided (needs to be last to also cover plain objects with x and y)
	    if (n === 1) {
	      this.end = new Point(args[0]);
	      return this;
	    } else {
	      // this is a poly-line segment
	      var segmentPoint;
	      outputArray = [];
	      for (i = 0; i < n; i += 1) {
	        segmentPoint = args[i];
	        outputArray.push(new Lineto(segmentPoint));
	      }
	      return outputArray;
	    }
	  }
	};
	var linetoPrototype = {
	  clone: function () {
	    return new Lineto(this.end);
	  },
	  divideAt: function (ratio) {
	    var line = new Line(this.start, this.end);
	    var divided = line.divideAt(ratio);
	    return [new Lineto(divided[0]), new Lineto(divided[1])];
	  },
	  divideAtLength: function (length) {
	    var line = new Line(this.start, this.end);
	    var divided = line.divideAtLength(length);
	    return [new Lineto(divided[0]), new Lineto(divided[1])];
	  },
	  getSubdivisions: function () {
	    return [];
	  },
	  isDifferentiable: function () {
	    if (!this.previousSegment) return false;
	    return !this.start.equals(this.end);
	  },
	  round: function (precision) {
	    this.end.round(precision);
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    this.end.scale(sx, sy, origin);
	    return this;
	  },
	  serialize: function () {
	    var end = this.end;
	    return this.type + ' ' + end.x + ' ' + end.y;
	  },
	  toString: function () {
	    return this.type + ' ' + this.start + ' ' + this.end;
	  },
	  translate: function (tx, ty) {
	    this.end.translate(tx, ty);
	    return this;
	  }
	};
	Object.defineProperty(linetoPrototype, 'type', {
	  configurable: true,
	  enumerable: true,
	  value: 'L'
	});
	Lineto.prototype = extend$1(segmentPrototype, Line.prototype, linetoPrototype);
	var Curveto = function () {
	  var args = [];
	  var n = arguments.length;
	  for (var i = 0; i < n; i++) {
	    args.push(arguments[i]);
	  }
	  if (!(this instanceof Curveto)) {
	    // switching context of `this` to Curveto when called without `new`
	    return applyToNew(Curveto, args);
	  }
	  if (n === 0) {
	    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');
	  }
	  var outputArray;
	  if (args[0] instanceof Curve) {
	    // curves provided
	    if (n === 1) {
	      this.controlPoint1 = args[0].controlPoint1.clone();
	      this.controlPoint2 = args[0].controlPoint2.clone();
	      this.end = args[0].end.clone();
	      return this;
	    } else {
	      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');
	    }
	  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {
	    // coordinates provided
	    if (n === 6) {
	      this.controlPoint1 = new Point(+args[0], +args[1]);
	      this.controlPoint2 = new Point(+args[2], +args[3]);
	      this.end = new Point(+args[4], +args[5]);
	      return this;
	    } else if (n < 6) {
	      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');
	    } else {
	      // this is a poly-bezier segment
	      var segmentCoords;
	      outputArray = [];
	      for (i = 0; i < n; i += 6) {
	        // coords come in groups of six

	        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6
	        outputArray.push(applyToNew(Curveto, segmentCoords));
	      }
	      return outputArray;
	    }
	  } else {
	    // points provided (needs to be last to also cover plain objects with x and y)
	    if (n === 3) {
	      this.controlPoint1 = new Point(args[0]);
	      this.controlPoint2 = new Point(args[1]);
	      this.end = new Point(args[2]);
	      return this;
	    } else if (n < 3) {
	      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');
	    } else {
	      // this is a poly-bezier segment
	      var segmentPoints;
	      outputArray = [];
	      for (i = 0; i < n; i += 3) {
	        // points come in groups of three

	        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3
	        outputArray.push(applyToNew(Curveto, segmentPoints));
	      }
	      return outputArray;
	    }
	  }
	};
	var curvetoPrototype = {
	  clone: function () {
	    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);
	  },
	  divideAt: function (ratio, opt) {
	    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
	    var divided = curve.divideAt(ratio, opt);
	    return [new Curveto(divided[0]), new Curveto(divided[1])];
	  },
	  divideAtLength: function (length, opt) {
	    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
	    var divided = curve.divideAtLength(length, opt);
	    return [new Curveto(divided[0]), new Curveto(divided[1])];
	  },
	  divideAtT: function (t) {
	    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
	    var divided = curve.divideAtT(t);
	    return [new Curveto(divided[0]), new Curveto(divided[1])];
	  },
	  isDifferentiable: function () {
	    if (!this.previousSegment) return false;
	    var start = this.start;
	    var control1 = this.controlPoint1;
	    var control2 = this.controlPoint2;
	    var end = this.end;
	    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
	  },
	  round: function (precision) {
	    this.controlPoint1.round(precision);
	    this.controlPoint2.round(precision);
	    this.end.round(precision);
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    this.controlPoint1.scale(sx, sy, origin);
	    this.controlPoint2.scale(sx, sy, origin);
	    this.end.scale(sx, sy, origin);
	    return this;
	  },
	  serialize: function () {
	    var c1 = this.controlPoint1;
	    var c2 = this.controlPoint2;
	    var end = this.end;
	    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;
	  },
	  toString: function () {
	    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;
	  },
	  translate: function (tx, ty) {
	    this.controlPoint1.translate(tx, ty);
	    this.controlPoint2.translate(tx, ty);
	    this.end.translate(tx, ty);
	    return this;
	  }
	};
	Object.defineProperty(curvetoPrototype, 'type', {
	  configurable: true,
	  enumerable: true,
	  value: 'C'
	});
	Curveto.prototype = extend$1(segmentPrototype, Curve.prototype, curvetoPrototype);
	var Moveto = function () {
	  var args = [];
	  var n = arguments.length;
	  for (var i = 0; i < n; i++) {
	    args.push(arguments[i]);
	  }
	  if (!(this instanceof Moveto)) {
	    // switching context of `this` to Moveto when called without `new`
	    return applyToNew(Moveto, args);
	  }
	  if (n === 0) {
	    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');
	  }
	  var outputArray;
	  if (args[0] instanceof Line) {
	    // lines provided
	    if (n === 1) {
	      this.end = args[0].end.clone();
	      return this;
	    } else {
	      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');
	    }
	  } else if (args[0] instanceof Curve) {
	    // curves provided
	    if (n === 1) {
	      this.end = args[0].end.clone();
	      return this;
	    } else {
	      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');
	    }
	  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {
	    // coordinates provided
	    if (n === 2) {
	      this.end = new Point(+args[0], +args[1]);
	      return this;
	    } else if (n < 2) {
	      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');
	    } else {
	      // this is a moveto-with-subsequent-poly-line segment
	      var segmentCoords;
	      outputArray = [];
	      for (i = 0; i < n; i += 2) {
	        // coords come in groups of two

	        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2
	        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));
	      }
	      return outputArray;
	    }
	  } else {
	    // points provided (needs to be last to also cover plain objects with x and y)
	    if (n === 1) {
	      this.end = new Point(args[0]);
	      return this;
	    } else {
	      // this is a moveto-with-subsequent-poly-line segment
	      var segmentPoint;
	      outputArray = [];
	      for (i = 0; i < n; i += 1) {
	        // points come one by one

	        segmentPoint = args[i];
	        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));
	      }
	      return outputArray;
	    }
	  }
	};
	var movetoPrototype = {
	  bbox: function () {
	    return null;
	  },
	  clone: function () {
	    return new Moveto(this.end);
	  },
	  closestPoint: function () {
	    return this.end.clone();
	  },
	  closestPointNormalizedLength: function () {
	    return 0;
	  },
	  closestPointLength: function () {
	    return 0;
	  },
	  closestPointT: function () {
	    return 1;
	  },
	  closestPointTangent: function () {
	    return null;
	  },
	  divideAt: function () {
	    return [this.clone(), this.clone()];
	  },
	  divideAtLength: function () {
	    return [this.clone(), this.clone()];
	  },
	  equals: function (m) {
	    return this.end.equals(m.end);
	  },
	  getSubdivisions: function () {
	    return [];
	  },
	  isDifferentiable: function () {
	    return false;
	  },
	  isSubpathStart: true,
	  isVisible: false,
	  length: function () {
	    return 0;
	  },
	  lengthAtT: function () {
	    return 0;
	  },
	  pointAt: function () {
	    return this.end.clone();
	  },
	  pointAtLength: function () {
	    return this.end.clone();
	  },
	  pointAtT: function () {
	    return this.end.clone();
	  },
	  round: function (precision) {
	    this.end.round(precision);
	    return this;
	  },
	  scale: function (sx, sy, origin) {
	    this.end.scale(sx, sy, origin);
	    return this;
	  },
	  serialize: function () {
	    var end = this.end;
	    return this.type + ' ' + end.x + ' ' + end.y;
	  },
	  tangentAt: function () {
	    return null;
	  },
	  tangentAtLength: function () {
	    return null;
	  },
	  tangentAtT: function () {
	    return null;
	  },
	  toString: function () {
	    return this.type + ' ' + this.end;
	  },
	  translate: function (tx, ty) {
	    this.end.translate(tx, ty);
	    return this;
	  }
	};
	Object.defineProperty(movetoPrototype, 'start', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    throw new Error('Illegal access. Moveto segments should not need a start property.');
	  }
	});
	Object.defineProperty(movetoPrototype, 'type', {
	  configurable: true,
	  enumerable: true,
	  value: 'M'
	});
	Moveto.prototype = extend$1(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object

	var Closepath = function () {
	  var args = [];
	  var n = arguments.length;
	  for (var i = 0; i < n; i++) {
	    args.push(arguments[i]);
	  }
	  if (!(this instanceof Closepath)) {
	    // switching context of `this` to Closepath when called without `new`
	    return applyToNew(Closepath, args);
	  }
	  if (n > 0) {
	    throw new Error('Closepath constructor expects no arguments.');
	  }
	  return this;
	};
	var closepathPrototype = {
	  clone: function () {
	    return new Closepath();
	  },
	  divideAt: function (ratio) {
	    var line = new Line(this.start, this.end);
	    var divided = line.divideAt(ratio);
	    return [
	    // if we didn't actually cut into the segment, first divided part can stay as Z
	    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];
	  },
	  divideAtLength: function (length) {
	    var line = new Line(this.start, this.end);
	    var divided = line.divideAtLength(length);
	    return [
	    // if we didn't actually cut into the segment, first divided part can stay as Z
	    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];
	  },
	  getSubdivisions: function () {
	    return [];
	  },
	  isDifferentiable: function () {
	    if (!this.previousSegment || !this.subpathStartSegment) return false;
	    return !this.start.equals(this.end);
	  },
	  round: function () {
	    return this;
	  },
	  scale: function () {
	    return this;
	  },
	  serialize: function () {
	    return this.type;
	  },
	  toString: function () {
	    return this.type + ' ' + this.start + ' ' + this.end;
	  },
	  translate: function () {
	    return this;
	  }
	};
	Object.defineProperty(closepathPrototype, 'end', {
	  // get a reference to the end point of subpath start segment

	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');
	    return this.subpathStartSegment.end;
	  }
	});
	Object.defineProperty(closepathPrototype, 'type', {
	  configurable: true,
	  enumerable: true,
	  value: 'Z'
	});
	Closepath.prototype = extend$1(segmentPrototype, Line.prototype, closepathPrototype);
	var segmentTypes = Path$1.segmentTypes = {
	  L: Lineto,
	  C: Curveto,
	  M: Moveto,
	  Z: Closepath,
	  z: Closepath
	};
	Path$1.regexSupportedData = new RegExp('^[\\s\\d' + Object.keys(segmentTypes).join('') + ',.]*$');
	Path$1.isDataSupported = function (data) {
	  if (typeof data !== 'string') return false;
	  return this.regexSupportedData.test(data);
	};

	const bezier = {
	  // Cubic Bezier curve path through points.
	  // @deprecated
	  // @param {array} points Array of points through which the smooth line will go.
	  // @return {array} SVG Path commands as an array
	  curveThroughPoints: function (points) {
	    console.warn('deprecated');
	    return new Path$1(Curve.throughPoints(points)).serialize();
	  },
	  // Get open-ended Bezier Spline Control Points.
	  // @deprecated
	  // @param knots Input Knot Bezier spline points (At least two points!).
	  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.
	  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.
	  getCurveControlPoints: function (knots) {
	    console.warn('deprecated');
	    var firstControlPoints = [];
	    var secondControlPoints = [];
	    var n = knots.length - 1;
	    var i;

	    // Special case: Bezier curve should be a straight line.
	    if (n == 1) {
	      // 3P1 = 2P0 + P3
	      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);

	      // P2 = 2P1 â P0
	      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
	      return [firstControlPoints, secondControlPoints];
	    }

	    // Calculate first Bezier control points.
	    // Right hand side vector.
	    var rhs = [];

	    // Set right hand side X values.
	    for (i = 1; i < n - 1; i++) {
	      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
	    }
	    rhs[0] = knots[0].x + 2 * knots[1].x;
	    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;

	    // Get first control points X-values.
	    var x = this.getFirstControlPoints(rhs);

	    // Set right hand side Y values.
	    for (i = 1; i < n - 1; ++i) {
	      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
	    }
	    rhs[0] = knots[0].y + 2 * knots[1].y;
	    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;

	    // Get first control points Y-values.
	    var y = this.getFirstControlPoints(rhs);

	    // Fill output arrays.
	    for (i = 0; i < n; i++) {
	      // First control point.
	      firstControlPoints.push(new Point(x[i], y[i]));

	      // Second control point.
	      if (i < n - 1) {
	        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
	      } else {
	        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
	      }
	    }
	    return [firstControlPoints, secondControlPoints];
	  },
	  // Divide a Bezier curve into two at point defined by value 't' <0,1>.
	  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867
	  // @deprecated
	  // @param control points (start, control start, control end, end)
	  // @return a function that accepts t and returns 2 curves.
	  getCurveDivider: function (p0, p1, p2, p3) {
	    console.warn('deprecated');
	    var curve = new Curve(p0, p1, p2, p3);
	    return function divideCurve(t) {
	      var divided = curve.divide(t);
	      return [{
	        p0: divided[0].start,
	        p1: divided[0].controlPoint1,
	        p2: divided[0].controlPoint2,
	        p3: divided[0].end
	      }, {
	        p0: divided[1].start,
	        p1: divided[1].controlPoint1,
	        p2: divided[1].controlPoint2,
	        p3: divided[1].end
	      }];
	    };
	  },
	  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.
	  // @deprecated
	  // @param rhs Right hand side vector.
	  // @return Solution vector.
	  getFirstControlPoints: function (rhs) {
	    console.warn('deprecated');
	    var n = rhs.length;
	    // `x` is a solution vector.
	    var x = [];
	    var tmp = [];
	    var b = 2.0;
	    x[0] = rhs[0] / b;

	    // Decomposition and forward substitution.
	    for (var i = 1; i < n; i++) {
	      tmp[i] = 1 / b;
	      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
	      x[i] = (rhs[i] - x[i - 1]) / b;
	    }
	    for (i = 1; i < n; i++) {
	      // Backsubstitution.
	      x[n - i - 1] -= tmp[n - i] * x[n - i];
	    }
	    return x;
	  },
	  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on
	  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ï¬nd the parameter value t
	  // which corresponds to that point.
	  // @deprecated
	  // @param control points (start, control start, control end, end)
	  // @return a function that accepts a point and returns t.
	  getInversionSolver: function (p0, p1, p2, p3) {
	    console.warn('deprecated');
	    var curve = new Curve(p0, p1, p2, p3);
	    return function solveInversion(p) {
	      return curve.closestPointT(p);
	    };
	  }
	};

	const Polygon$1 = function (points) {
	  if (!(this instanceof Polygon$1)) {
	    return new Polygon$1(points);
	  }
	  if (typeof points === 'string') {
	    return new Polygon$1.parse(points);
	  }
	  this.points = Array.isArray(points) ? points.map(Point) : [];
	};
	Polygon$1.parse = function (svgString) {
	  return new Polygon$1(parsePoints(svgString));
	};
	Polygon$1.fromRect = function (rect) {
	  return new Polygon$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft()]);
	};
	Polygon$1.prototype = extend$1(Polyline$1.prototype, {
	  type: types.Polygon,
	  clone: function () {
	    return new Polygon$1(clonePoints(this.points));
	  },
	  convexHull: function () {
	    return new Polygon$1(convexHull(this.points));
	  },
	  lengthPoints: function () {
	    const {
	      start,
	      end,
	      points
	    } = this;
	    if (points.length <= 1 || start.equals(end)) return points;
	    return [...points, start.clone()];
	  }
	});

	function exists(shape1, shape2, shape1opt, shape2opt) {
	  switch (shape1.type) {
	    case types.Line:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return lineWithLine(shape1, shape2);
	            }
	        }
	        break;
	      }
	    case types.Ellipse:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return ellipseWithLine(shape1, shape2);
	            }
	          case types.Ellipse:
	            {
	              return ellipseWithEllipse(shape1, shape2);
	            }
	        }
	        break;
	      }
	    case types.Rect:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return rectWithLine(shape1, shape2);
	            }
	          case types.Ellipse:
	            {
	              return rectWithEllipse(shape1, shape2);
	            }
	          case types.Rect:
	            {
	              return rectWithRect(shape1, shape2);
	            }
	        }
	        break;
	      }
	    case types.Polyline:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return polylineWithLine(shape1, shape2);
	            }
	          case types.Ellipse:
	            {
	              return polylineWithEllipse(shape1, shape2);
	            }
	          case types.Rect:
	            {
	              return polylineWithRect(shape1, shape2);
	            }
	          case types.Polyline:
	            {
	              return polylineWithPolyline(shape1, shape2);
	            }
	        }
	        break;
	      }
	    case types.Polygon:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return polygonWithLine(shape1, shape2);
	            }
	          case types.Ellipse:
	            {
	              return polygonWithEllipse(shape1, shape2);
	            }
	          case types.Rect:
	            {
	              return polygonWithRect(shape1, shape2);
	            }
	          case types.Polyline:
	            {
	              return polygonWithPolyline(shape1, shape2);
	            }
	          case types.Polygon:
	            {
	              return polygonWithPolygon(shape1, shape2);
	            }
	        }
	        break;
	      }
	    case types.Path:
	      {
	        switch (shape2.type) {
	          case types.Line:
	            {
	              return pathWithLine(shape1, shape2, shape1opt);
	            }
	          case types.Ellipse:
	            {
	              return pathWithEllipse(shape1, shape2, shape1opt);
	            }
	          case types.Rect:
	            {
	              return pathWithRect(shape1, shape2, shape1opt);
	            }
	          case types.Polyline:
	            {
	              return pathWithPolyline(shape1, shape2, shape1opt);
	            }
	          case types.Polygon:
	            {
	              return pathWithPolygon(shape1, shape2, shape1opt);
	            }
	          case types.Path:
	            {
	              return pathWithPath(shape1, shape2, shape1opt, shape2opt);
	            }
	        }
	        break;
	      }
	  }
	  // None of the cases above
	  switch (shape2.type) {
	    case types.Ellipse:
	    case types.Rect:
	    case types.Polyline:
	    case types.Polygon:
	    case types.Path:
	      {
	        return exists(shape2, shape1, shape2opt, shape1opt);
	      }
	    default:
	      {
	        throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);
	      }
	  }
	}

	/* Line */

	function lineWithLine(line1, line2) {
	  const x1 = line1.start.x;
	  const y1 = line1.start.y;
	  const x2 = line1.end.x;
	  const y2 = line1.end.y;
	  const x3 = line2.start.x;
	  const y3 = line2.start.y;
	  const x4 = line2.end.x;
	  const y4 = line2.end.y;
	  const s1x = x2 - x1;
	  const s1y = y2 - y1;
	  const s2x = x4 - x3;
	  const s2y = y4 - y3;
	  const s3x = x1 - x3;
	  const s3y = y1 - y3;
	  const p = s1x * s2y - s2x * s1y;
	  const s = (s1x * s3y - s1y * s3x) / p;
	  const t = (s2x * s3y - s2y * s3x) / p;
	  return s >= 0 && s <= 1 && t >= 0 && t <= 1;
	}

	/* Ellipse */

	function ellipseWithLine(ellipse, line) {
	  const rex = ellipse.a;
	  const rey = ellipse.b;
	  const xe = ellipse.x;
	  const ye = ellipse.y;
	  const x1 = line.start.x - xe;
	  const x2 = line.end.x - xe;
	  const y1 = line.start.y - ye;
	  const y2 = line.end.y - ye;
	  const rex_2 = rex * rex;
	  const rey_2 = rey * rey;
	  const dx = x2 - x1;
	  const dy = y2 - y1;
	  const A = dx * dx / rex_2 + dy * dy / rey_2;
	  const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;
	  const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;
	  const D = B * B - 4 * A * C;
	  if (D === 0) {
	    const t = -B / 2 / A;
	    return t >= 0 && t <= 1;
	  } else if (D > 0) {
	    const sqrt = Math.sqrt(D);
	    const t1 = (-B + sqrt) / 2 / A;
	    const t2 = (-B - sqrt) / 2 / A;
	    return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;
	  }
	  return false;
	}
	function ellipseWithEllipse(ellipse1, ellipse2) {
	  return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);
	}

	/* Rect */

	function rectWithLine(rect, line) {
	  const {
	    start,
	    end
	  } = line;
	  const {
	    x,
	    y,
	    width,
	    height
	  } = rect;
	  if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) {
	    return false;
	  }
	  if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {
	    return true;
	  }
	  return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);
	}
	function rectWithEllipse(rect, ellipse) {
	  if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;
	  return polygonWithEllipse(Polygon$1.fromRect(rect), ellipse);
	}
	function rectWithRect(rect1, rect2) {
	  return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
	}

	/* Polyline */

	function polylineWithLine(polyline, line) {
	  return _polylineWithLine(polyline, line, {
	    interior: false
	  });
	}
	function polylineWithEllipse(polyline, ellipse) {
	  return _polylineWithEllipse(polyline, ellipse, {
	    interior: false
	  });
	}
	function polylineWithRect(polyline, rect) {
	  return _polylineWithRect(polyline, rect, {
	    interior: false
	  });
	}
	function polylineWithPolyline(polyline1, polyline2) {
	  return _polylineWithPolyline(polyline1, polyline2, {
	    interior: false
	  });
	}

	/* Polygon */

	function polygonWithLine(polygon, line) {
	  return _polylineWithLine(polygon, line, {
	    interior: true
	  });
	}
	function polygonWithEllipse(polygon, ellipse) {
	  return _polylineWithEllipse(polygon, ellipse, {
	    interior: true
	  });
	}
	function polygonWithRect(polygon, rect) {
	  return _polylineWithRect(polygon, rect, {
	    interior: true
	  });
	}
	function polygonWithPolyline(polygon, polyline) {
	  return _polylineWithPolyline(polygon, polyline, {
	    interior: true
	  });
	}
	function polygonWithPolygon(polygon1, polygon2) {
	  return _polylineWithPolygon(polygon1, polygon2, {
	    interior: true
	  });
	}

	/* Path */

	function pathWithLine(path, line, pathOpt) {
	  return path.getSubpaths().some(subpath => {
	    const [polyline] = subpath.toPolylines(pathOpt);
	    const {
	      type
	    } = subpath.getSegment(-1);
	    if (type === 'Z') {
	      return polygonWithLine(polyline, line);
	    } else {
	      return polylineWithLine(polyline, line);
	    }
	  });
	}
	function pathWithEllipse(path, ellipse, pathOpt) {
	  return path.getSubpaths().some(subpath => {
	    const [polyline] = subpath.toPolylines(pathOpt);
	    const {
	      type
	    } = subpath.getSegment(-1);
	    if (type === 'Z') {
	      return polygonWithEllipse(polyline, ellipse);
	    } else {
	      return polylineWithEllipse(polyline, ellipse);
	    }
	  });
	}
	function pathWithRect(path, rect, pathOpt) {
	  return pathWithPolygon(path, Polygon$1.fromRect(rect), pathOpt);
	}
	function pathWithPolyline(path, polyline, pathOpt) {
	  return _pathWithPolyline(path, polyline, pathOpt, {
	    interior: false
	  });
	}
	function pathWithPolygon(path, polygon, pathOpt) {
	  return _pathWithPolyline(path, polygon, pathOpt, {
	    interior: true
	  });
	}
	function pathWithPath(path1, path2, pathOpt1, pathOpt2) {
	  return path1.getSubpaths().some(subpath => {
	    const [polyline1] = subpath.toPolylines(pathOpt1);
	    const {
	      type
	    } = subpath.getSegment(-1);
	    if (type === 'Z') {
	      return pathWithPolygon(path2, polyline1, pathOpt2);
	    } else {
	      return pathWithPolyline(path2, polyline1, pathOpt2);
	    }
	  });
	}
	function _polylineWithLine(polyline, line, opt = {}) {
	  const {
	    interior = false
	  } = opt;
	  let thisPoints;
	  if (interior) {
	    if (polyline.containsPoint(line.start)) {
	      // If any point of the polyline lies inside this polygon (interior = true)
	      // there is an intersection (we've chosen the start point)
	      return true;
	    }
	    const {
	      start,
	      end,
	      points
	    } = polyline;
	    thisPoints = end.equals(start) ? points : [...points, start];
	  } else {
	    thisPoints = polyline.points;
	  }
	  const {
	    length
	  } = thisPoints;
	  const segment = new Line();
	  for (let i = 0; i < length - 1; i++) {
	    segment.start = thisPoints[i];
	    segment.end = thisPoints[i + 1];
	    if (lineWithLine(line, segment)) {
	      return true;
	    }
	  }
	  return false;
	}
	function _polylineWithEllipse(polyline, ellipse, opt = {}) {
	  const {
	    start,
	    end,
	    points
	  } = polyline;
	  if (ellipse.containsPoint(start)) {
	    return true;
	  }
	  let thisPoints;
	  const {
	    interior = false
	  } = opt;
	  if (interior) {
	    if (polyline.containsPoint(ellipse.center())) {
	      // If any point of the ellipse lies inside this polygon (interior = true)
	      // there is an intersection (we've chosen the center point)
	      return true;
	    }
	    thisPoints = end.equals(start) ? points : [...points, start];
	  } else {
	    thisPoints = points;
	  }
	  const {
	    length
	  } = thisPoints;
	  const segment = new Line();
	  for (let i = 0; i < length - 1; i++) {
	    segment.start = thisPoints[i];
	    segment.end = thisPoints[i + 1];
	    if (ellipseWithLine(ellipse, segment)) {
	      return true;
	    }
	  }
	  return false;
	}
	function _polylineWithRect(polyline, rect, opt) {
	  const polygon = Polygon$1.fromRect(rect);
	  return _polylineWithPolygon(polyline, polygon, opt);
	}
	function _pathWithPolyline(path, polyline1, pathOpt, opt) {
	  return path.getSubpaths().some(subpath => {
	    const [polyline2] = subpath.toPolylines(pathOpt);
	    const {
	      type
	    } = subpath.getSegment(-1);
	    if (type === 'Z') {
	      return _polylineWithPolygon(polyline1, polyline2, opt);
	    } else {
	      return _polylineWithPolyline(polyline1, polyline2, opt);
	    }
	  });
	}
	function _polylineWithPolyline(polyline1, polyline2, opt = {}) {
	  const {
	    interior = false
	  } = opt;
	  let thisPolyline;
	  if (interior) {
	    const {
	      start
	    } = polyline2;
	    if (polyline1.containsPoint(start)) {
	      // If any point of the polyline lies inside this polygon (interior = true)
	      // there is an intersection (we've chosen the start point)
	      return true;
	    }
	    thisPolyline = polyline1.clone().close();
	  } else {
	    thisPolyline = polyline1;
	  }
	  const otherPoints = polyline2.points;
	  const {
	    length
	  } = otherPoints;
	  const segment = new Line();
	  for (let i = 0; i < length - 1; i++) {
	    segment.start = otherPoints[i];
	    segment.end = otherPoints[i + 1];
	    if (polylineWithLine(thisPolyline, segment)) {
	      return true;
	    }
	  }
	  return false;
	}
	function _polylineWithPolygon(polyline, polygon, opt) {
	  return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);
	}
	function _ellipsesIntersection(e1, w1, e2, w2) {
	  const {
	    cos,
	    sin
	  } = Math;
	  const sinW1 = sin(w1);
	  const cosW1 = cos(w1);
	  const sinW2 = sin(w2);
	  const cosW2 = cos(w2);
	  const sinW1s = sinW1 * sinW1;
	  const cosW1s = cosW1 * cosW1;
	  const sinCos1 = sinW1 * cosW1;
	  const sinW2s = sinW2 * sinW2;
	  const cosW2s = cosW2 * cosW2;
	  const sinCos2 = sinW2 * cosW2;
	  const a1s = e1.a * e1.a;
	  const b1s = e1.b * e1.b;
	  const a2s = e2.a * e2.a;
	  const b2s = e2.b * e2.b;
	  const A1 = a1s * sinW1s + b1s * cosW1s;
	  const A2 = a2s * sinW2s + b2s * cosW2s;
	  const B1 = a1s * cosW1s + b1s * sinW1s;
	  const B2 = a2s * cosW2s + b2s * sinW2s;
	  let C1 = 2 * (b1s - a1s) * sinCos1;
	  let C2 = 2 * (b2s - a2s) * sinCos2;
	  let D1 = -2 * A1 * e1.x - C1 * e1.y;
	  let D2 = -2 * A2 * e2.x - C2 * e2.y;
	  let E1 = -C1 * e1.x - 2 * B1 * e1.y;
	  let E2 = -C2 * e2.x - 2 * B2 * e2.y;
	  const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;
	  const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;
	  C1 = C1 / 2;
	  C2 = C2 / 2;
	  D1 = D1 / 2;
	  D2 = D2 / 2;
	  E1 = E1 / 2;
	  E2 = E2 / 2;
	  const l3 = det3([[A1, C1, D1], [C1, B1, E1], [D1, E1, F1]]);
	  const l0 = det3([[A2, C2, D2], [C2, B2, E2], [D2, E2, F2]]);
	  const l2 = 0.33333333 * (det3([[A2, C1, D1], [C2, B1, E1], [D2, E1, F1]]) + det3([[A1, C2, D1], [C1, B2, E1], [D1, E2, F1]]) + det3([[A1, C1, D2], [C1, B1, E2], [D1, E1, F2]]));
	  const l1 = 0.33333333 * (det3([[A1, C2, D2], [C1, B2, E2], [D1, E2, F2]]) + det3([[A2, C1, D2], [C2, B1, E2], [D2, E1, F2]]) + det3([[A2, C2, D1], [C2, B2, E1], [D2, E2, F1]]));
	  const delta1 = det2([[l3, l2], [l2, l1]]);
	  const delta2 = det2([[l3, l1], [l2, l0]]);
	  const delta3 = det2([[l2, l1], [l1, l0]]);
	  const dP = det2([[2 * delta1, delta2], [delta2, 2 * delta3]]);
	  if (dP > 0 && (l1 > 0 || l2 > 0)) {
	    return false;
	  }
	  return true;
	}
	function det2(m) {
	  return m[0][0] * m[1][1] - m[0][1] * m[1][0];
	}
	function det3(m) {
	  return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];
	}

	var _intersection = {
		__proto__: null,
		ellipseWithEllipse: ellipseWithEllipse,
		ellipseWithLine: ellipseWithLine,
		exists: exists,
		lineWithLine: lineWithLine,
		pathWithEllipse: pathWithEllipse,
		pathWithLine: pathWithLine,
		pathWithPath: pathWithPath,
		pathWithPolygon: pathWithPolygon,
		pathWithPolyline: pathWithPolyline,
		pathWithRect: pathWithRect,
		polygonWithEllipse: polygonWithEllipse,
		polygonWithLine: polygonWithLine,
		polygonWithPolygon: polygonWithPolygon,
		polygonWithPolyline: polygonWithPolyline,
		polygonWithRect: polygonWithRect,
		polylineWithEllipse: polylineWithEllipse,
		polylineWithLine: polylineWithLine,
		polylineWithPolyline: polylineWithPolyline,
		polylineWithRect: polylineWithRect,
		rectWithEllipse: rectWithEllipse,
		rectWithLine: rectWithLine,
		rectWithRect: rectWithRect
	};

	// Geometry library.
	// -----------------

	const intersection$1 = _intersection;

	var g = {
		__proto__: null,
		Curve: Curve,
		Ellipse: Ellipse$1,
		Line: Line,
		Path: Path$1,
		Point: Point,
		Polygon: Polygon$1,
		Polyline: Polyline$1,
		Rect: Rect,
		bezier: bezier,
		ellipse: ellipse$1,
		intersection: intersection$1,
		line: line$1,
		normalizeAngle: normalizeAngle,
		point: point,
		random: random,
		rect: rect,
		scale: scale,
		snapToGrid: snapToGrid$1,
		toDeg: toDeg,
		toRad: toRad,
		types: types
	};

	// code is inspired by https://github.com/lodash/lodash

	/* eslint-disable no-case-declarations */
	// -- helper constants
	const argsTag = '[object Arguments]';
	const arrayTag = '[object Array]';
	const boolTag = '[object Boolean]';
	const dateTag = '[object Date]';
	const errorTag = '[object Error]';
	const funcTag = '[object Function]';
	const mapTag = '[object Map]';
	const numberTag = '[object Number]';
	const nullTag = '[object Null]';
	const objectTag = '[object Object]';
	const regexpTag = '[object RegExp]';
	const setTag = '[object Set]';
	const stringTag = '[object String]';
	const symbolTag = '[object Symbol]';
	const undefinedTag = '[object Undefined]';
	const weakMapTag = '[object WeakMap]';
	const arrayBufferTag = '[object ArrayBuffer]';
	const dataViewTag = '[object DataView]';
	const float32Tag = '[object Float32Array]';
	const float64Tag = '[object Float64Array]';
	const int8Tag = '[object Int8Array]';
	const int16Tag = '[object Int16Array]';
	const int32Tag = '[object Int32Array]';
	const uint8Tag = '[object Uint8Array]';
	const uint8ClampedTag = '[object Uint8ClampedArray]';
	const uint16Tag = '[object Uint16Array]';
	const uint32Tag = '[object Uint32Array]';
	const CLONEABLE_TAGS = {
	  [argsTag]: true,
	  [arrayTag]: true,
	  [arrayBufferTag]: true,
	  [dataViewTag]: true,
	  [boolTag]: true,
	  [dateTag]: true,
	  [float32Tag]: true,
	  [float64Tag]: true,
	  [int8Tag]: true,
	  [int16Tag]: true,
	  [int32Tag]: true,
	  [mapTag]: true,
	  [numberTag]: true,
	  [objectTag]: true,
	  [regexpTag]: true,
	  [setTag]: true,
	  [stringTag]: true,
	  [symbolTag]: true,
	  [uint8Tag]: true,
	  [uint8ClampedTag]: true,
	  [uint16Tag]: true,
	  [uint32Tag]: true,
	  [errorTag]: false,
	  [funcTag]: false,
	  [weakMapTag]: false
	};

	/** Used to compose unicode character classes. */
	const rsAstralRange = '\\ud800-\\udfff';
	const rsComboMarksRange = '\\u0300-\\u036f';
	const reComboHalfMarksRange = '\\ufe20-\\ufe2f';
	const rsComboSymbolsRange = '\\u20d0-\\u20ff';
	const rsComboMarksExtendedRange = '\\u1ab0-\\u1aff';
	const rsComboMarksSupplementRange = '\\u1dc0-\\u1dff';
	const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;
	const rsDingbatRange = '\\u2700-\\u27bf';
	const rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff';
	const rsMathOpRange = '\\xac\\xb1\\xd7\\xf7';
	const rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf';
	const rsPunctuationRange = '\\u2000-\\u206f';
	const rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000';
	const rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde';
	const rsVarRange = '\\ufe0e\\ufe0f';
	const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	const rsApos = '[\'\u2019]';
	const rsBreak = `[${rsBreakRange}]`;
	const rsCombo = `[${rsComboRange}]`;
	const rsDigit = '\\d';
	const rsDingbat = `[${rsDingbatRange}]`;
	const rsLower = `[${rsLowerRange}]`;
	const rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;
	const rsFitz = '\\ud83c[\\udffb-\\udfff]';
	const rsModifier = `(?:${rsCombo}|${rsFitz})`;
	const rsNonAstral = `[^${rsAstralRange}]`;
	const rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
	const rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
	const rsUpper = `[${rsUpperRange}]`;
	const rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	const rsMiscLower = `(?:${rsLower}|${rsMisc})`;
	const rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;
	const rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;
	const rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;
	const reOptMod = `${rsModifier}?`;
	const rsOptVar = `[${rsVarRange}]?`;
	const rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;
	const rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])';
	const rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])';
	const rsSeq = rsOptVar + reOptMod + rsOptJoin;
	const rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;

	// eslint-disable-next-line no-misleading-character-class
	const reUnicodeWords = RegExp([`${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`, `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`, `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`, `${rsUpper}+${rsOptContrUpper}`, rsOrdUpper, rsOrdLower, `${rsDigit}+`, rsEmoji].join('|'), 'g');
	const LARGE_ARRAY_SIZE = 200;
	const HASH_UNDEFINED = '__hash_undefined__';

	// Used to match `toStringTag` values of typed arrays
	const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;

	// Used to compose unicode capture groups
	const rsAstral = `[${rsAstralRange}]`;

	// Used to compose unicode regexes
	const rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;
	const rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;

	// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)
	// eslint-disable-next-line no-misleading-character-class
	const reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');
	const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
	const reIsPlainProp = /^\w*$/;
	const charCodeOfDot = '.'.charCodeAt(0);
	const reEscapeChar = /\\(\\)?/g;
	const rePropName = RegExp(
	// Match anything that isn't a dot or bracket.
	'[^.[\\]]+' + '|' +
	// Or match property names within brackets.
	'\\[(?:' +
	// Match a non-string expression.
	'([^"\'][^[]*)' + '|' +
	// Or match strings (supports escaping characters).
	'(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' + ')\\]' + '|' +
	// Or match "" as the space between consecutive dots or empty brackets.
	'(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))', 'g');
	const reIsUint = /^(?:0|[1-9]\d*)$/;
	const hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);
	const MAX_ARRAY_INDEX = 4294967295 - 1;

	/** Used to match words composed of alphanumeric characters. */
	// eslint-disable-next-line no-control-regex
	const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	// -- helper functions
	const hasUnicode = string => {
	  return reUnicode.test(string);
	};
	const unicodeToArray = string => {
	  return string.match(reUnicode) || [];
	};
	const asciiToArray = string => {
	  return string.split('');
	};
	const stringToArray = string => {
	  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
	};
	const values = object => {
	  if (object == null) {
	    return [];
	  }
	  return keys(object).map(key => object[key]);
	};
	const keys = object => {
	  return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));
	};
	const baseKeys = object => {
	  if (!isPrototype(object)) {
	    return Object.keys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	};
	const arrayLikeKeys = (value, inherited) => {
	  const isArr = Array.isArray(value);
	  const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;
	  const isType = !isArr && !isArg && isTypedArray(value);
	  const skipIndexes = isArr || isArg || isType;
	  const length = value.length;
	  const result = new Array(skipIndexes ? length : 0);
	  let index = skipIndexes ? -1 : length;
	  while (++index < length) {
	    result[index] = `${index}`;
	  }
	  for (const key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
	    // Safari 9 has enumerable `arguments.length` in strict mode.
	    key === 'length' ||
	    // Skip index properties.
	    isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	};
	const assocIndexOf = (array, key) => {
	  let {
	    length
	  } = array;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	};
	const eq = (value, other) => {
	  return value === other || value !== value && other !== other;
	};
	const isObjectLike = value => {
	  return value != null && typeof value == 'object';
	};
	const isIterateeCall = (value, index, object) => {
	  if (!isObject(object)) {
	    return false;
	  }
	  const type = typeof index;
	  const isPossibleIteratee = type == 'number' ? isArrayLike(object) && index > -1 && index < object.length : type == 'string' && index in object;
	  if (isPossibleIteratee) {
	    return eq(object[index], value);
	  }
	  return false;
	};
	const isSet = value => {
	  return isObjectLike(value) && getTag(value) == setTag;
	};
	const isMap = value => {
	  return isObjectLike(value) && getTag(value) == mapTag;
	};
	const isPrototype = value => {
	  const Ctor = value && value.constructor;
	  const proto = typeof Ctor === 'function' && Ctor.prototype || Object.prototype;
	  return value === proto;
	};
	const assignValue = (object, key, value) => {
	  const objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
	    object[key] = value;
	  }
	};
	const copyObject = (source, props, object) => {
	  let index = -1;
	  const length = props.length;
	  while (++index < length) {
	    const key = props[index];
	    assignValue(object, key, source[key]);
	  }
	  return object;
	};
	const isArrayLike = value => {
	  return value != null && typeof value !== 'function' && typeof value.length === 'number' && value.length > -1 && value.length % 1 === 0;
	};
	const isSymbol = value => {
	  return typeof value == 'symbol' || isObjectLike(value) && getTag(value) === symbolTag;
	};
	const initCloneArray = array => {
	  const length = array.length;
	  let result = new array.constructor(length);
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	};
	const copyArray = (source, array) => {
	  let index = -1;
	  const length = source.length;
	  array || (array = new Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	};
	const getTag = value => {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return Object.prototype.toString.call(value);
	};
	const cloneArrayBuffer = arrayBuffer => {
	  const result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	};
	const cloneTypedArray = (typedArray, isDeep) => {
	  const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	};
	const cloneRegExp = regexp => {
	  const result = new regexp.constructor(regexp.source, /\w*$/.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	};
	const initCloneObject = object => {
	  return typeof object.constructor == 'function' && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};
	};
	const getSymbols = object => {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  const symbols = Object.getOwnPropertySymbols(object);
	  return symbols.filter(symbol => propertyIsEnumerable.call(object, symbol));
	};
	const copySymbols = (source, object) => {
	  return copyObject(source, getSymbols(source), object);
	};
	function cloneDataView(dataView, isDeep) {
	  const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}
	const initCloneByTag = (object, tag, isDeep) => {
	  const Constructor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);
	    case boolTag:
	    case dateTag:
	      return new Constructor(+object);
	    case dataViewTag:
	      return cloneDataView(object, isDeep);
	    case float32Tag:
	    case float64Tag:
	    case int8Tag:
	    case int16Tag:
	    case int32Tag:
	    case uint8Tag:
	    case uint8ClampedTag:
	    case uint16Tag:
	    case uint32Tag:
	      return cloneTypedArray(object, isDeep);
	    case mapTag:
	      return new Constructor(object);
	    case numberTag:
	    case stringTag:
	      return new Constructor(object);
	    case regexpTag:
	      return cloneRegExp(object);
	    case setTag:
	      return new Constructor();
	    case symbolTag:
	      return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};
	  }
	};
	const isTypedArray = value => {
	  return isObjectLike(value) && reTypedTag.test(getTag(value));
	};
	const getAllKeys = object => {
	  const result = Object.keys(object);
	  if (!Array.isArray(object) && object != null) {
	    result.push(...getSymbols(Object(object)));
	  }
	  return result;
	};
	const getSymbolsIn = object => {
	  const result = [];
	  while (object) {
	    result.push(...getSymbols(object));
	    object = Object.getPrototypeOf(Object(object));
	  }
	  return result;
	};
	const getAllKeysIn = object => {
	  const result = [];
	  for (const key in object) {
	    result.push(key);
	  }
	  if (!Array.isArray(object)) {
	    result.push(...getSymbolsIn(object));
	  }
	  return result;
	};
	const getMapData = ({
	  __data__
	}, key) => {
	  const data = __data__;
	  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;
	};
	const equalObjects = (object, other, equalFunc, stack) => {
	  const objProps = getAllKeys(object);
	  const objLength = objProps.length;
	  const othProps = getAllKeys(other);
	  const othLength = othProps.length;
	  if (objLength != othLength) {
	    return false;
	  }
	  let key;
	  let index = objLength;
	  while (index--) {
	    key = objProps[index];
	    if (!hasOwnProperty.call(other, key)) {
	      return false;
	    }
	  }
	  const objStacked = stack.get(object);
	  const othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  let result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	  let compared;
	  let skipCtor;
	  while (++index < objLength) {
	    key = objProps[index];
	    const objValue = object[key];
	    const othValue = other[key];
	    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    const objCtor = object.constructor;
	    const othCtor = other.constructor;
	    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	};
	const baseIsEqual = (value, other, stack) => {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, stack);
	};
	const baseIsEqualDeep = (object, other, equalFunc, stack) => {
	  let objIsArr = Array.isArray(object);
	  const othIsArr = Array.isArray(other);
	  let objTag = objIsArr ? arrayTag : getTag(object);
	  let othTag = othIsArr ? arrayTag : getTag(other);
	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;
	  let objIsObj = objTag == objectTag;
	  const othIsObj = othTag == objectTag;
	  const isSameTag = objTag == othTag;
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack());
	    return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);
	  }
	  const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');
	  const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	  if (objIsWrapped || othIsWrapped) {
	    const objUnwrapped = objIsWrapped ? object.value() : object;
	    const othUnwrapped = othIsWrapped ? other.value() : other;
	    stack || (stack = new Stack());
	    return equalFunc(objUnwrapped, othUnwrapped, stack);
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack());
	  return equalObjects(object, other, equalFunc, stack);
	};
	const equalArrays = (array, other, compareUnordered, equalFunc, stack) => {
	  const isPartial = false;
	  const arrLength = array.length;
	  const othLength = other.length;
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  const arrStacked = stack.get(array);
	  const othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  let index = -1;
	  let result = true;
	  const seen = compareUnordered ? new SetCache() : undefined;
	  stack.set(array, other);
	  stack.set(other, array);
	  while (++index < arrLength) {
	    let compared;
	    const arrValue = array[index];
	    const othValue = other[index];
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    if (seen) {
	      if (!some(other, (othValue, othIndex) => {
	        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {
	          return seen.push(othIndex);
	        }
	      })) {
	        result = false;
	        break;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	};
	const some = (array, predicate) => {
	  let index = -1;
	  const length = array == null ? 0 : array.length;
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	};
	const cacheHas = (cache, key) => {
	  return cache.has(key);
	};
	const compareArrayBufferTag = (object, other, equalFunc, stack) => {
	  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {
	    return false;
	  }
	  return true;
	};
	const equalByTag = (object, other, tag, equalFunc, stack) => {
	  switch (tag) {
	    case dataViewTag:
	      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	      return compareArrayBufferTag(object, other, equalFunc, stack);
	    case arrayBufferTag:
	      return compareArrayBufferTag(object, other, equalFunc, stack);
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      return eq(+object, +other);
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	    case regexpTag:
	    case stringTag:
	      return object == `${other}`;
	    case mapTag:
	      // This use of 'var' is intentional. Don't remove if replacing all instances.
	      var convert = mapToArray;
	    // Intentional fallthrough
	    // eslint-disable-next-line no-fallthrough
	    case setTag:
	      convert || (convert = setToArray);
	      if (object.size != other.size) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      const stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);
	      stack['delete'](object);
	      return result;
	    case symbolTag:
	      return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);
	  }
	  return false;
	};
	const mapToArray = map => {
	  let index = -1;
	  let result = Array(map.size);
	  map.forEach((value, key) => {
	    result[++index] = [key, value];
	  });
	  return result;
	};
	const setToArray = set => {
	  let index = -1;
	  const result = new Array(set.size);
	  set.forEach(value => {
	    result[++index] = value;
	  });
	  return result;
	};
	const isKey = (value, object) => {
	  if (Array.isArray(value)) {
	    return false;
	  }
	  const type = typeof value;
	  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	};
	const stringToPath = string => {
	  const result = [];
	  if (string.charCodeAt(0) === charCodeOfDot) {
	    result.push('');
	  }
	  string.replace(rePropName, (match, expression, quote, subString) => {
	    let key = match;
	    if (quote) {
	      key = subString.replace(reEscapeChar, '$1');
	    } else if (expression) {
	      key = expression.trim();
	    }
	    result.push(key);
	  });
	  return result;
	};
	const castPath = (path, object) => {
	  if (Array.isArray(path)) {
	    return path;
	  }
	  return isKey(path, object) ? [path] : stringToPath(`${path}`);
	};
	const get = (object, path) => {
	  path = castPath(path, object);
	  let index = 0;
	  const length = path.length;
	  while (object != null && index < length) {
	    object = object[toKey(path[index])];
	    index++;
	  }
	  return index && index == length ? object : undefined;
	};
	function compareAscending(value, other) {
	  if (value !== other) {
	    const valIsDefined = value !== undefined;
	    const valIsNull = value === null;
	    const valIsReflexive = value === value;
	    const valIsSymbol = isSymbol(value);
	    const othIsDefined = other !== undefined;
	    const othIsNull = other === null;
	    const othIsReflexive = other === other;
	    const othIsSymbol = isSymbol(other);
	    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
	      return 1;
	    }
	    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}
	function compareMultiple(object, other, orders) {
	  let index = -1;
	  const objCriteria = object.criteria;
	  const othCriteria = other.criteria;
	  const length = objCriteria.length;
	  const ordersLength = orders.length;
	  while (++index < length) {
	    const order = index < ordersLength ? orders[index] : null;
	    const cmpFn = order && typeof order === 'function' ? order : compareAscending;
	    const result = cmpFn(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (order && typeof order !== 'function') {
	        return result * (order == 'desc' ? -1 : 1);
	      }
	      return result;
	    }
	  }
	  return object.index - other.index;
	}
	const diff = (array, values) => {
	  let includes = (array, value) => {
	    const length = array == null ? 0 : array.length;
	    return !!length && array.indexOf(value) > -1;
	  };
	  let isCommon = true;
	  const result = [];
	  const valuesLength = values.length;
	  if (!array.length) {
	    return result;
	  }
	  if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = (cache, key) => cache.has(key);
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer: for (let key in array) {
	    let value = array[key];
	    const computed = value;
	    value = value !== 0 ? value : 0;
	    if (isCommon && computed === computed) {
	      let valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    } else if (!includes(values, computed)) {
	      result.push(value);
	    }
	  }
	  return result;
	};
	const intersect = arrays => {
	  const includes = (array, value) => {
	    const length = array == null ? 0 : array.length;
	    return !!length && array.indexOf(value) > -1;
	  };
	  const cacheHas = (cache, key) => cache.has(key);
	  const length = arrays[0].length;
	  const othLength = arrays.length;
	  const caches = new Array(othLength);
	  const result = [];
	  let array;
	  let maxLength = Infinity;
	  let othIndex = othLength;
	  while (othIndex--) {
	    array = arrays[othIndex];
	    maxLength = Math.min(array.length, maxLength);
	    caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;
	  }
	  array = arrays[0];
	  let index = -1;
	  const seen = caches[0];
	  outer: while (++index < length && result.length < maxLength) {
	    let value = array[index];
	    const computed = value;
	    value = value !== 0 ? value : 0;
	    if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {
	      othIndex = othLength;
	      while (--othIndex) {
	        const cache = caches[othIndex];
	        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) {
	          continue outer;
	        }
	      }
	      if (seen) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	};
	const toKey = value => {
	  if (typeof value === 'string' || isSymbol(value)) {
	    return value;
	  }
	  const result = `${value}`;
	  return result == '0' && 1 / value == -Infinity ? '-0' : result;
	};
	const baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {
	  let result;
	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  const isArr = Array.isArray(value);
	  const tag = getTag(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    const isFunc = typeof value === 'function';
	    if (tag === objectTag || tag === argsTag || isFunc && !object) {
	      result = isFlat || isFunc ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));
	      }
	    } else {
	      if (isFunc || !CLONEABLE_TAGS[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  stack || (stack = new Stack());
	  const stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);
	  if (isMap(value)) {
	    value.forEach((subValue, key) => {
	      result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));
	    });
	    return result;
	  }
	  if (isSet(value)) {
	    value.forEach(subValue => {
	      result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));
	    });
	    return result;
	  }
	  if (isTypedArray(value)) {
	    return result;
	  }
	  const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
	  const props = isArr ? undefined : keysFunc(value);
	  (props || value).forEach((subValue, key) => {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));
	  });
	  return result;
	};
	const copySymbolsIn = (source, object) => {
	  return copyObject(source, getSymbolsIn(source), object);
	};
	const parent = (object, path) => {
	  return path.length < 2 ? object : get(object, path.slice(0, -1));
	};
	const set = (object, path, value) => {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);
	  const length = path.length;
	  const lastIndex = length - 1;
	  let index = -1;
	  let nested = object;
	  while (nested != null && ++index < length) {
	    const key = toKey(path[index]);
	    let newValue = value;
	    if (index != lastIndex) {
	      const objValue = nested[key];
	      newValue = undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	};
	const isIndex = (value, length) => {
	  const type = typeof value;
	  length = length == null ? Number.MAX_SAFE_INTEGER : length;
	  return !!length && (type === 'number' || type !== 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	};
	const unset = (object, path) => {
	  path = castPath(path, object);
	  object = parent(object, path);
	  const lastSegment = path[path.length - 1];
	  return object == null || delete object[toKey(lastSegment)];
	};
	const isKeyable = value => {
	  const type = typeof value;
	  return type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean' ? value !== '__proto__' : value === null;
	};
	const keysIn = object => {
	  const result = [];
	  for (const key in object) {
	    result.push(key);
	  }
	  return result;
	};
	const toPlainObject = value => {
	  value = Object(value);
	  const result = {};
	  for (const key in value) {
	    result[key] = value[key];
	  }
	  return result;
	};
	const safeGet = (object, key) => {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }
	  if (key == '__proto__') {
	    return;
	  }
	  return object[key];
	};
	function createAssigner(assigner, isMerge = false) {
	  return (object, ...sources) => {
	    let index = -1;
	    let length = sources.length;
	    let customizer = length > 1 ? sources[length - 1] : undefined;
	    const guard = length > 2 ? sources[2] : undefined;
	    customizer = assigner.length > 3 && typeof customizer === 'function' ? (length--, customizer) : isMerge ? (a, b) => {
	      if (Array.isArray(a) && !Array.isArray(b)) {
	        return b;
	      }
	    } : undefined;
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      const source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  };
	}
	const baseMerge = (object, source, srcIndex, customizer, stack) => {
	  if (object === source) {
	    return;
	  }
	  forIn(source, (srcValue, key) => {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack());
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    } else {
	      let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : undefined;
	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  });
	};
	const baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {
	  const objValue = safeGet(object, key);
	  const srcValue = safeGet(source, key);
	  const stacked = stack.get(srcValue);
	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : undefined;
	  let isCommon = newValue === undefined;
	  if (isCommon) {
	    const isArr = Array.isArray(srcValue);
	    const isTyped = !isArr && isTypedArray(srcValue);
	    newValue = srcValue;
	    if (isArr || isTyped) {
	      if (Array.isArray(objValue)) {
	        newValue = objValue;
	      } else if (isObjectLike(objValue) && isArrayLike(objValue)) {
	        newValue = copyArray(objValue);
	      } else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      } else {
	        newValue = [];
	      }
	    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      } else if (typeof objValue === 'function' || !isObject(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    } else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	};
	const assignMergeValue = (object, key, value) => {
	  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
	    assignValue(object, key, value);
	  }
	};
	function baseFor(object, iteratee, keysFunc) {
	  const iterable = Object(object);
	  const props = keysFunc(object);
	  let {
	    length
	  } = props;
	  let index = -1;
	  while (length--) {
	    const key = props[++index];
	    if (iteratee(iterable[key], key, iterable) === false) {
	      break;
	    }
	  }
	  return object;
	}
	const baseForOwn = (object, iteratee) => {
	  return object && baseFor(object, iteratee, keys);
	};
	const baseEach = (collection, iteratee) => {
	  if (collection == null) {
	    return collection;
	  }
	  if (!isArrayLike(collection)) {
	    return baseForOwn(collection, iteratee);
	  }
	  const length = collection.length;
	  const iterable = Object(collection);
	  let index = -1;
	  while (++index < length) {
	    if (iteratee(iterable[index], index, iterable) === false) {
	      break;
	    }
	  }
	  return collection;
	};
	function last(array) {
	  const length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}
	const createSet = Set && 1 / setToArray(new Set([undefined, -0]))[1] == 1 / 0 ? values => new Set(values) : () => {/* no-op */};
	function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	  if (isObject(objValue) && isObject(srcValue)) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, objValue);
	    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	    stack['delete'](srcValue);
	  }
	  return objValue;
	}
	function baseOrderBy(collection, iteratees, orders) {
	  if (iteratees.length) {
	    iteratees = iteratees.map(iteratee => {
	      if (Array.isArray(iteratee)) {
	        return value => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	      }
	      return iteratee;
	    });
	  } else {
	    iteratees = [value => value];
	  }
	  let criteriaIndex = -1;
	  let eachIndex = -1;
	  const result = isArrayLike(collection) ? new Array(collection.length) : [];
	  baseEach(collection, value => {
	    const criteria = iteratees.map(iteratee => iteratee(value));
	    result[++eachIndex] = {
	      criteria,
	      index: ++criteriaIndex,
	      value
	    };
	  });
	  return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));
	}
	function baseSortBy(array, comparer) {
	  let {
	    length
	  } = array;
	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	function matchesStrictComparable(key, srcValue) {
	  return object => {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
	  };
	}
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return object => {
	    const objValue = get(object, path);
	    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);
	  };
	}
	function baseMatches(source) {
	  const matchData = getMatchData(source);
	  if (matchData.length === 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return object => object === source || baseIsMatch(object, source, matchData);
	}
	function getMatchData(object) {
	  const result = keys(object);
	  let length = result.length;
	  while (length--) {
	    const key = result[length];
	    const value = object[key];
	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}
	function baseIsMatch(object, source, matchData, customizer) {
	  let index = matchData.length;
	  const length = index;
	  const noCustomizer = !customizer;
	  if (object == null) {
	    return !length;
	  }
	  let data;
	  let result;
	  object = Object(object);
	  while (index--) {
	    data = matchData[index];
	    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    const key = data[0];
	    const objValue = object[key];
	    const srcValue = data[1];
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      const stack = new Stack();
	      if (customizer) {
	        result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	function baseProperty(key) {
	  return object => object == null ? undefined : object[key];
	}
	function basePropertyDeep(path) {
	  return object => get(object, path);
	}
	function baseIteratee(value) {
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return val => val;
	  }
	  if (typeof value == 'object') {
	    return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
	  }
	  return property(value);
	}
	function getIteratee() {
	  const result = baseIteratee;
	  return arguments.length ? result(arguments[0], arguments[1]) : result;
	}
	const arrayReduce = (array, iteratee, accumulator, initAccum) => {
	  let index = -1;
	  const length = array == null ? 0 : array.length;
	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	};
	const baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {
	  eachFunc(collection, (value, index, collection) => {
	    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	};
	function reduce(collection, iteratee, accumulator) {
	  const func = Array.isArray(collection) ? arrayReduce : baseReduce;
	  const initAccum = arguments.length < 3;
	  return func(collection, iteratee, accumulator, initAccum, baseEach);
	}
	const isFlattenable = value => {
	  return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);
	};
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  let index = -1;
	  const length = array.length;
	  predicate || (predicate = isFlattenable);
	  result || (result = []);
	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        result.push(...value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}
	const isArguments = value => {
	  return isObjectLike(value) && getTag(value) == '[object Arguments]';
	};
	const basePick = (object, paths) => {
	  return basePickBy(object, paths, (value, path) => hasIn(object, path));
	};
	const basePickBy = (object, paths, predicate) => {
	  let index = -1;
	  const length = paths.length;
	  const result = {};
	  while (++index < length) {
	    const path = paths[index];
	    const value = get(object, path);
	    if (predicate(value, path)) {
	      set(result, castPath(path, object), value);
	    }
	  }
	  return result;
	};
	const isLength = value => {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;
	};
	const baseHasIn = (object, key) => {
	  return object != null && key in Object(object);
	};
	const hasPath = (object, path, hasFunc) => {
	  path = castPath(path, object);
	  var index = -1,
	    length = path.length,
	    result = false;
	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));
	};
	const asciiWords = string => {
	  return string.match(reAsciiWord);
	};
	const unicodeWords = string => {
	  return string.match(reUnicodeWords);
	};
	const words = (string, pattern) => {
	  if (pattern === undefined) {
	    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	    return result || [];
	  }
	  return string.match(pattern) || [];
	};
	const castSlice = (array, start, end) => {
	  const {
	    length
	  } = array;
	  end = end === undefined ? length : end;
	  return !start && end >= length ? array : array.slice(start, end);
	};
	const upperFirst = createCaseFirst('toUpperCase');
	function createCaseFirst(methodName) {
	  return string => {
	    if (!string) {
	      return '';
	    }
	    const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
	    const chr = strSymbols ? strSymbols[0] : string[0];
	    const trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
	    return chr[methodName]() + trailing;
	  };
	}
	function matches(source) {
	  return baseMatches(baseClone(source, true));
	}

	// -- helper classes
	class Stack {
	  constructor(entries) {
	    const data = this.__data__ = new ListCache(entries);
	    this.size = data.size;
	  }
	  clear() {
	    this.__data__ = new ListCache();
	    this.size = 0;
	  }
	  delete(key) {
	    const data = this.__data__;
	    const result = data['delete'](key);
	    this.size = data.size;
	    return result;
	  }
	  get(key) {
	    return this.__data__.get(key);
	  }
	  has(key) {
	    return this.__data__.has(key);
	  }
	  set(key, value) {
	    let data = this.__data__;
	    if (data instanceof ListCache) {
	      const pairs = data.__data__;
	      if (pairs.length < LARGE_ARRAY_SIZE - 1) {
	        pairs.push([key, value]);
	        this.size = ++data.size;
	        return this;
	      }
	      data = this.__data__ = new MapCache(pairs);
	    }
	    data.set(key, value);
	    this.size = data.size;
	    return this;
	  }
	}
	class ListCache {
	  constructor(entries) {
	    let index = -1;
	    const length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	      const entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  clear() {
	    this.__data__ = [];
	    this.size = 0;
	  }
	  delete(key) {
	    const data = this.__data__;
	    const index = assocIndexOf(data, key);
	    if (index < 0) {
	      return false;
	    }
	    const lastIndex = data.length - 1;
	    if (index == lastIndex) {
	      data.pop();
	    } else {
	      data.splice(index, 1);
	    }
	    --this.size;
	    return true;
	  }
	  get(key) {
	    const data = this.__data__;
	    const index = assocIndexOf(data, key);
	    return index < 0 ? undefined : data[index][1];
	  }
	  has(key) {
	    return assocIndexOf(this.__data__, key) > -1;
	  }
	  set(key, value) {
	    const data = this.__data__;
	    const index = assocIndexOf(data, key);
	    if (index < 0) {
	      ++this.size;
	      data.push([key, value]);
	    } else {
	      data[index][1] = value;
	    }
	    return this;
	  }
	}
	class MapCache {
	  constructor(entries) {
	    let index = -1;
	    const length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	      const entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  clear() {
	    this.size = 0;
	    this.__data__ = {
	      'hash': new Hash(),
	      'map': new Map(),
	      'string': new Hash()
	    };
	  }
	  delete(key) {
	    const result = getMapData(this, key)['delete'](key);
	    this.size -= result ? 1 : 0;
	    return result;
	  }
	  get(key) {
	    return getMapData(this, key).get(key);
	  }
	  has(key) {
	    return getMapData(this, key).has(key);
	  }
	  set(key, value) {
	    const data = getMapData(this, key);
	    const size = data.size;
	    data.set(key, value);
	    this.size += data.size == size ? 0 : 1;
	    return this;
	  }
	}
	class Hash {
	  constructor(entries) {
	    let index = -1;
	    const length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	      const entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  clear() {
	    this.__data__ = Object.create(null);
	    this.size = 0;
	  }
	  delete(key) {
	    const result = this.has(key) && delete this.__data__[key];
	    this.size -= result ? 1 : 0;
	    return result;
	  }
	  get(key) {
	    const data = this.__data__;
	    const result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  has(key) {
	    const data = this.__data__;
	    return data[key] !== undefined;
	  }
	  set(key, value) {
	    const data = this.__data__;
	    this.size += this.has(key) ? 0 : 1;
	    data[key] = value === undefined ? HASH_UNDEFINED : value;
	    return this;
	  }
	}
	class SetCache {
	  constructor(values) {
	    let index = -1;
	    const length = values == null ? 0 : values.length;
	    this.__data__ = new MapCache();
	    while (++index < length) {
	      this.add(values[index]);
	    }
	  }
	  add(value) {
	    this.__data__.set(value, HASH_UNDEFINED);
	    return this;
	  }
	  has(value) {
	    return this.__data__.has(value);
	  }
	}
	SetCache.prototype.push = SetCache.prototype.add;

	// -- top level functions

	const isBoolean = function (value) {
	  var toString = Object.prototype.toString;
	  return value === true || value === false || !!value && typeof value === 'object' && toString.call(value) === boolTag;
	};
	const isObject = function (value) {
	  return !!value && (typeof value === 'object' || typeof value === 'function');
	};
	const isNumber = function (value) {
	  var toString = Object.prototype.toString;
	  return typeof value === 'number' || !!value && typeof value === 'object' && toString.call(value) === numberTag;
	};
	const isString = function (value) {
	  var toString = Object.prototype.toString;
	  return typeof value === 'string' || !!value && typeof value === 'object' && toString.call(value) === stringTag;
	};
	const assign = createAssigner((object, source) => {
	  if (isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});
	const mixin = assign;
	const deepMixin = mixin;
	const supplement = (object, ...sources) => {
	  let index = -1;
	  let length = sources.length;
	  const guard = length > 2 ? sources[2] : undefined;
	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }
	  while (++index < length) {
	    const source = sources[index];
	    if (source == null) {
	      continue;
	    }
	    const props = Object.keys(source);
	    const propsLength = props.length;
	    let propsIndex = -1;
	    while (++propsIndex < propsLength) {
	      const key = props[propsIndex];
	      const value = object[key];
	      if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) {
	        object[key] = source[key];
	      }
	    }
	  }
	  return object;
	};
	const defaults = supplement;
	const deepSupplement = function defaultsDeep(...args) {
	  args.push(undefined, customDefaultsMerge);
	  return merge.apply(undefined, args);
	};
	const defaultsDeep = deepSupplement;

	// _.invokeMap
	const invoke = (collection, path, ...args) => {
	  let index = -1;
	  const isFunc = typeof path === 'function';
	  const result = isArrayLike(collection) ? new Array(collection.length) : [];
	  baseEach(collection, value => {
	    result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);
	  });
	  return result;
	};

	// _.invoke
	const invokeProperty = (object, path, ...args) => {
	  path = castPath(path, object);
	  object = parent(object, path);
	  const func = object == null ? object : object[toKey(last(path))];
	  return func == null ? undefined : func.apply(object, args);
	};
	const sortedIndex = (array, value, iteratee) => {
	  let low = 0;
	  let high = array == null ? 0 : array.length;
	  if (high == 0) {
	    return 0;
	  }
	  iteratee = getIteratee(iteratee, 2);
	  value = iteratee(value);
	  const valIsNaN = value !== value;
	  const valIsNull = value === null;
	  const valIsSymbol = isSymbol(value);
	  const valIsUndefined = value === undefined;
	  while (low < high) {
	    let setLow;
	    const mid = Math.floor((low + high) / 2);
	    const computed = iteratee(array[mid]);
	    const othIsDefined = computed !== undefined;
	    const othIsNull = computed === null;
	    const othIsReflexive = computed === computed;
	    const othIsSymbol = isSymbol(computed);
	    if (valIsNaN) {
	      setLow = othIsReflexive;
	    } else if (valIsUndefined) {
	      setLow = othIsReflexive && othIsDefined;
	    } else if (valIsNull) {
	      setLow = othIsReflexive && othIsDefined && !othIsNull;
	    } else if (valIsSymbol) {
	      setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;
	    } else if (othIsNull || othIsSymbol) {
	      setLow = false;
	    } else {
	      setLow = computed < value;
	    }
	    if (setLow) {
	      low = mid + 1;
	    } else {
	      high = mid;
	    }
	  }
	  return Math.min(high, MAX_ARRAY_INDEX);
	};
	const uniq = (array, iteratee) => {
	  let index = -1;
	  let includes = (array, value) => {
	    const length = array == null ? 0 : array.length;
	    return !!length && array.indexOf(value) > -1;
	  };
	  iteratee = getIteratee(iteratee, 2);
	  let isCommon = true;
	  const {
	    length
	  } = array;
	  const result = [];
	  let seen = result;
	  if (length >= LARGE_ARRAY_SIZE) {
	    const set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = (cache, key) => cache.has(key);
	    seen = new SetCache();
	  } else {
	    seen = iteratee ? [] : result;
	  }
	  outer: while (++index < length) {
	    let value = array[index];
	    const computed = iteratee ? iteratee(value) : value;
	    value = value !== 0 ? value : 0;
	    if (isCommon && computed === computed) {
	      let seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    } else if (!includes(seen, computed)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	};
	const clone$1 = value => baseClone(value);
	const cloneDeep = value => baseClone(value, true);
	const isEmpty = value => {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) && (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  const tag = getTag(value);
	  if (tag == '[object Map]' || tag == '[object Set]') {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (const key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	};
	const isEqual = (object, other) => baseIsEqual(object, other);
	const isFunction = value => typeof value === 'function';
	const isPlainObject = value => {
	  if (!isObjectLike(value) || getTag(value) != '[object Object]') {
	    return false;
	  }
	  if (Object.getPrototypeOf(value) === null) {
	    return true;
	  }
	  let proto = value;
	  while (Object.getPrototypeOf(proto) !== null) {
	    proto = Object.getPrototypeOf(proto);
	  }
	  return Object.getPrototypeOf(value) === proto;
	};
	const toArray$1 = value => {
	  if (!value) {
	    return [];
	  }
	  if (isArrayLike(value)) {
	    return isString(value) ? stringToArray(value) : copyArray(value);
	  }
	  if (Symbol.iterator && Symbol.iterator in Object(value)) {
	    const iterator = value[Symbol.iterator]();
	    let data;
	    const result = [];
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	  const tag = getTag(value);
	  const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
	  return func(value);
	};
	function debounce(func, wait, opt) {
	  if (typeof func !== 'function') {
	    throw new TypeError('Expected a function');
	  }
	  let lastArgs;
	  let lastThis;
	  let maxWait;
	  let result;
	  let timerId;
	  let lastCallTime;
	  let lastInvokeTime = 0;
	  let leading = false;
	  let maxing = false;
	  let trailing = true;
	  const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function';
	  wait = +wait || 0;
	  if (isObject(opt)) {
	    leading = !!opt.leading;
	    maxing = 'maxWait' in opt;
	    maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;
	    trailing = 'trailing' in opt ? !!opt.trailing : trailing;
	  }
	  function invokeFunc(time) {
	    const args = lastArgs;
	    const thisArg = lastThis;
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	  function startTimer(pendingFunc, wait) {
	    if (useRaf) {
	      window.cancelAnimationFrame(timerId);
	      return window.requestAnimationFrame(pendingFunc);
	    }
	    return setTimeout(pendingFunc, wait);
	  }
	  function cancelTimer(id) {
	    if (useRaf) {
	      return window.cancelAnimationFrame(id);
	    }
	    clearTimeout(id);
	  }
	  function leadingEdge(time) {
	    lastInvokeTime = time;
	    timerId = startTimer(timerExpired, wait);
	    return leading ? invokeFunc(time) : result;
	  }
	  function remainingWait(time) {
	    const timeSinceLastCall = time - lastCallTime;
	    const timeSinceLastInvoke = time - lastInvokeTime;
	    const timeWaiting = wait - timeSinceLastCall;
	    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	  }
	  function shouldInvoke(time) {
	    const timeSinceLastCall = time - lastCallTime;
	    const timeSinceLastInvoke = time - lastInvokeTime;
	    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	  }
	  function timerExpired() {
	    const time = Date.now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    timerId = startTimer(timerExpired, remainingWait(time));
	  }
	  function trailingEdge(time) {
	    timerId = undefined;
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }
	  function debounced(...args) {
	    const time = Date.now();
	    const isInvoking = shouldInvoke(time);
	    lastArgs = args;
	    lastThis = this;
	    lastCallTime = time;
	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        timerId = startTimer(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = startTimer(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = () => {
	    if (timerId !== undefined) {
	      cancelTimer(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  };
	  debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());
	  debounced.pending = () => timerId !== undefined;
	  return debounced;
	}
	const groupBy = (collection, iteratee) => {
	  iteratee = getIteratee(iteratee, 2);
	  return reduce(collection, (result, value) => {
	    const key = iteratee(value);
	    if (hasOwnProperty.call(result, key)) {
	      result[key].push(value);
	    } else {
	      assignValue(result, key, [value]);
	    }
	    return result;
	  }, {});
	};
	const sortBy = (collection, iteratees = []) => {
	  if (collection == null) {
	    return [];
	  }
	  const length = iteratees.length;
	  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  if (!Array.isArray(iteratees)) {
	    iteratees = [getIteratee(iteratees, 2)];
	  }
	  return baseOrderBy(collection, iteratees.flat(1), []);
	};
	const flattenDeep = array => {
	  const length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, Infinity) : [];
	};
	const without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];
	const difference = (array, ...values) => isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];
	const intersection = (...arrays) => {
	  const mapped = arrays.map(array => isObjectLike(array) && isArrayLike(array) ? array : []);
	  return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];
	};
	const union = (...arrays) => {
	  const array = arrays.flat(1);
	  return uniq(array);
	};
	const has = (object, key) => {
	  if (object == null) {
	    return false;
	  }
	  if (typeof key === 'string') {
	    key = key.split('.');
	  }
	  let index = -1;
	  let value = object;
	  while (++index < key.length) {
	    if (!value || !hasOwnProperty.call(value, key[index])) {
	      return false;
	    }
	    value = value[key[index]];
	  }
	  return true;
	};
	const result = (object, path, defaultValue) => {
	  path = castPath(path, object);
	  let index = -1;
	  let length = path.length;
	  if (!length) {
	    length = 1;
	    object = undefined;
	  }
	  while (++index < length) {
	    let value = object == null ? undefined : object[toKey(path[index])];
	    if (value === undefined) {
	      index = length;
	      value = defaultValue;
	    }
	    object = typeof value === 'function' ? value.call(object) : value;
	  }
	  return object;
	};
	const omit = (object, ...paths) => {
	  let result = {};
	  if (object == null) {
	    return result;
	  }
	  let isDeep = false;
	  paths = paths.flat(1).map(path => {
	    path = castPath(path, object);
	    isDeep || (isDeep = path.length > 1);
	    return path;
	  });
	  copyObject(object, getAllKeysIn(object), result);
	  if (isDeep) {
	    result = baseClone(result, true, true, true, value => isPlainObject(value) ? undefined : value);
	  }
	  let length = paths.length;
	  while (length--) {
	    unset(result, paths[length]);
	  }
	  return result;
	};
	const pick = (object, ...paths) => {
	  return object == null ? {} : basePick(object, paths.flat(Infinity));
	};
	const bindAll = (object, ...methodNames) => {
	  methodNames.flat(1).forEach(key => {
	    key = toKey(key);
	    assignValue(object, key, object[key].bind(object));
	  });
	  return object;
	};
	const forIn = (object, iteratee = value => value) => {
	  let index = -1;
	  const iterable = Object(object);
	  const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);
	  let length = props.length;
	  while (length--) {
	    const key = props[++index];
	    if (iteratee(iterable[key], key, iterable) === false) {
	      break;
	    }
	  }
	};
	const camelCase = (string = '') => words(`${string}`.replace(/['\u2019]/g, '')).reduce((result, word, index) => {
	  word = word.toLowerCase();
	  return result + (index ? upperFirst(word) : word);
	}, '');
	let idCounter = 0;
	const uniqueId = (prefix = '') => {
	  const id = ++idCounter;
	  return `${prefix}` + id;
	};
	const merge = createAssigner((object, source, srcIndex, customizer) => {
	  baseMerge(object, source, srcIndex, customizer);
	}, true);

	class Data {
	  constructor() {
	    this.map = new WeakMap();
	  }
	  has(obj, key) {
	    if (key === undefined) return this.map.has(obj);
	    return key in this.map.get(obj);
	  }
	  create(obj) {
	    if (!this.has(obj)) this.map.set(obj, Object.create(null));
	    return this.get(obj);
	  }
	  get(obj, key) {
	    if (!this.has(obj)) return undefined;
	    const data = this.map.get(obj);
	    if (key === undefined) return data;
	    return data[key];
	  }
	  set(obj, key, value) {
	    if (key === undefined) return;
	    const data = this.create(obj);
	    if (typeof key === 'string') {
	      data[key] = value;
	    } else {
	      Object.assign(data, key);
	    }
	  }
	  remove(obj, key) {
	    if (!this.has(obj)) return;
	    if (key === undefined) {
	      this.map.delete(obj);
	    } else {
	      const data = this.map.get(obj);
	      delete data[key];
	    }
	  }
	}

	const dataPriv = new Data();
	const dataUser = new Data();

	const Event = function (src, props) {
	  // Allow instantiation without the 'new' keyword
	  if (!(this instanceof Event)) {
	    return new Event(src, props);
	  }

	  // Event object
	  if (src && src.type) {
	    this.originalEvent = src;
	    this.type = src.type;

	    // Events bubbling up the document may have been marked as prevented
	    // by a handler lower down the tree; reflect the correct value.
	    this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;

	    // Create target properties
	    this.target = src.target;
	    this.currentTarget = src.currentTarget;
	    this.relatedTarget = src.relatedTarget;

	    // Event type
	  } else {
	    this.type = src;
	  }

	  // Put explicitly provided properties onto the event object
	  if (props) {
	    Object.assign(this, props);
	  }

	  // Create a timestamp if incoming event doesn't have one
	  this.timeStamp = src && src.timeStamp || Date.now();

	  // Mark it as fixed
	  this.envelope = true;
	};

	// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	Event.prototype = {
	  constructor: Event,
	  isDefaultPrevented: returnFalse,
	  isPropagationStopped: returnFalse,
	  isImmediatePropagationStopped: returnFalse,
	  preventDefault: function () {
	    const evt = this.originalEvent;
	    this.isDefaultPrevented = returnTrue;
	    if (evt) {
	      evt.preventDefault();
	    }
	  },
	  stopPropagation: function () {
	    const evt = this.originalEvent;
	    this.isPropagationStopped = returnTrue;
	    if (evt) {
	      evt.stopPropagation();
	    }
	  },
	  stopImmediatePropagation: function () {
	    const evt = this.originalEvent;
	    this.isImmediatePropagationStopped = returnTrue;
	    if (evt) {
	      evt.stopImmediatePropagation();
	    }
	    this.stopPropagation();
	  }
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	['altKey', 'bubbles', 'cancelable', 'changedTouches', 'ctrlKey', 'detail', 'eventPhase', 'metaKey', 'pageX', 'pageY', 'shiftKey', 'view', 'char', 'code', 'charCode', 'key', 'keyCode', 'button', 'buttons', 'clientX', 'clientY', 'offsetX', 'offsetY', 'pointerId', 'pointerType', 'screenX', 'screenY', 'targetTouches', 'toElement', 'touches', 'which'].forEach(name => addProp(name));
	function addProp(name) {
	  Object.defineProperty(Event.prototype, name, {
	    enumerable: true,
	    configurable: true,
	    get: function () {
	      return this.originalEvent ? this.originalEvent[name] : undefined;
	    },
	    set: function (value) {
	      Object.defineProperty(this, name, {
	        enumerable: true,
	        configurable: true,
	        writable: true,
	        value: value
	      });
	    }
	  });
	}
	function returnTrue() {
	  return true;
	}
	function returnFalse() {
	  return false;
	}

	/*!
	 * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty
	 * https://jquery.com/
	 *
	 * Copyright OpenJS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2023-11-24T14:04Z
	 */

	const document$1 = typeof window !== 'undefined' ? window.document : null;
	const documentElement = document$1 && document$1.documentElement;
	const rTypeNamespace = /^([^.]*)(?:\.(.+)|)/;

	// Only count HTML whitespace
	// Other whitespace should count in values
	// https://infra.spec.whatwg.org/#ascii-whitespace
	const rNotHtmlWhite = /[^\x20\t\r\n\f]+/g;

	// Define a local copy of $
	const $ = function (selector) {
	  // The $ object is actually just the init constructor 'enhanced'
	  // Need init if $ is called (just allow error to be thrown if not included)
	  return new $.Dom(selector);
	};
	$.fn = $.prototype = {
	  constructor: $,
	  // The default length of a $ object is 0
	  length: 0
	};

	// A global GUID counter for objects
	$.guid = 1;

	// User data storage
	$.data = dataUser;
	$.merge = function (first, second) {
	  let len = +second.length;
	  let i = first.length;
	  for (let j = 0; j < len; j++) {
	    first[i++] = second[j];
	  }
	  first.length = i;
	  return first;
	};
	$.parseHTML = function (string) {
	  // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.
	  const context = document$1.implementation.createHTMLDocument();
	  // Set the base href for the created document so any parsed elements with URLs
	  // are based on the document's URL
	  const base = context.createElement('base');
	  base.href = document$1.location.href;
	  context.head.appendChild(base);
	  context.body.innerHTML = string;
	  // remove scripts
	  const scripts = context.getElementsByTagName('script');
	  for (let i = 0; i < scripts.length; i++) {
	    scripts[i].remove();
	  }
	  return Array.from(context.body.childNodes);
	};
	if (typeof Symbol === 'function') {
	  $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];
	}
	$.fn.toArray = function () {
	  return Array.from(this);
	};

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	$.fn.pushStack = function (elements) {
	  // Build a new $ matched element set
	  const ret = $.merge(this.constructor(), elements);
	  // Add the old object onto the stack (as a reference)
	  ret.prevObject = this;
	  // Return the newly-formed element set
	  return ret;
	};
	$.fn.find = function (selector) {
	  const [el] = this;
	  const ret = this.pushStack([]);
	  if (!el) return ret;
	  // Early return if context is not an element, document or document fragment
	  const {
	    nodeType
	  } = el;
	  if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
	    return ret;
	  }
	  if (typeof selector !== 'string') {
	    if (el !== selector && el.contains(selector)) {
	      $.merge(ret, [selector]);
	    }
	  } else {
	    $.merge(ret, el.querySelectorAll(selector));
	  }
	  return ret;
	};
	$.fn.add = function (selector) {
	  const newElements = $(selector).toArray();
	  const prevElements = this.toArray();
	  const ret = this.pushStack([]);
	  $.merge(ret, uniq(prevElements.concat(newElements)));
	  return ret;
	};
	$.fn.addBack = function () {
	  return this.add(this.prevObject);
	};
	$.fn.filter = function (selector) {
	  const matches = [];
	  for (let i = 0; i < this.length; i++) {
	    const node = this[i];
	    if (!node.matches(selector)) continue;
	    matches.push(node);
	  }
	  return this.pushStack(matches);
	};

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	const rQuickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	function isObviousHtml(input) {
	  return input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3;
	}
	const Dom = function (selector) {
	  if (!selector) {
	    // HANDLE: $(""), $(null), $(undefined), $(false)
	    return this;
	  }
	  if (typeof selector === 'function') {
	    // HANDLE: $(function)
	    // Shortcut for document ready
	    throw new Error('function not supported');
	  }
	  if (arguments.length > 1) {
	    throw new Error('selector with context not supported');
	  }
	  if (selector.nodeType) {
	    // HANDLE: $(DOMElement)
	    this[0] = selector;
	    this.length = 1;
	    return this;
	  }
	  let match;
	  if (isObviousHtml(selector + '')) {
	    // Handle obvious HTML strings
	    // Assume that strings that start and end with <> are HTML and skip
	    // the regex check. This also handles browser-supported HTML wrappers
	    // like TrustedHTML.
	    match = [null, selector, null];
	  } else if (typeof selector === 'string') {
	    // Handle HTML strings or selectors
	    match = rQuickExpr.exec(selector);
	  } else {
	    // Array-like
	    return $.merge(this, selector);
	  }
	  if (!match || !match[1]) {
	    // HANDLE: $(expr)
	    return $root.find(selector);
	  }
	  // Match html or make sure no context is specified for #id
	  // Note: match[1] may be a string or a TrustedHTML wrapper
	  if (match[1]) {
	    // HANDLE: $(html) -> $(array)
	    $.merge(this, $.parseHTML(match[1]));
	    return this;
	  }
	  // HANDLE: $(#id)
	  const el = document$1.getElementById(match[2]);
	  if (el) {
	    // Inject the element directly into the $ object
	    this[0] = el;
	    this.length = 1;
	  }
	  return this;
	};
	$.Dom = Dom;

	// Give the init function the $ prototype for later instantiation
	Dom.prototype = $.fn;

	// Events

	$.Event = Event;
	$.event = {
	  special: Object.create(null)
	};
	$.event.has = function (elem, eventType) {
	  const events = dataPriv.get(elem, 'events');
	  if (!events) return false;
	  if (!eventType) return true;
	  return Array.isArray(events[eventType]) && events[eventType].length > 0;
	};
	$.event.on = function (elem, types, selector, data, fn, one) {
	  // Types can be a map of types/handlers
	  if (typeof types === 'object') {
	    // ( types-Object, selector, data )
	    if (typeof selector !== 'string') {
	      // ( types-Object, data )
	      data = data || selector;
	      selector = undefined;
	    }
	    for (let type in types) {
	      $.event.on(elem, type, selector, data, types[type], one);
	    }
	    return elem;
	  }
	  if (data == null && fn == null) {
	    // ( types, fn )
	    fn = selector;
	    data = selector = undefined;
	  } else if (fn == null) {
	    if (typeof selector === 'string') {
	      // ( types, selector, fn )
	      fn = data;
	      data = undefined;
	    } else {
	      // ( types, data, fn )
	      fn = data;
	      data = selector;
	      selector = undefined;
	    }
	  }
	  if (!fn) {
	    return elem;
	  }
	  if (one === 1) {
	    const origFn = fn;
	    fn = function (event) {
	      // Can use an empty set, since event contains the info
	      $().off(event);
	      return origFn.apply(this, arguments);
	    };

	    // Use same guid so caller can remove using origFn
	    fn.guid = origFn.guid || (origFn.guid = $.guid++);
	  }
	  for (let i = 0; i < elem.length; i++) {
	    $.event.add(elem[i], types, fn, data, selector);
	  }
	};
	$.event.add = function (elem, types, handler, data, selector) {
	  // Only attach events to objects for which we can store data
	  if (typeof elem != 'object') {
	    return;
	  }
	  const elemData = dataPriv.create(elem);

	  // Caller can pass in an object of custom data in lieu of the handler
	  let handleObjIn;
	  if (handler.handler) {
	    handleObjIn = handler;
	    handler = handleObjIn.handler;
	    selector = handleObjIn.selector;
	  }

	  // Ensure that invalid selectors throw exceptions at attach time
	  // Evaluate against documentElement in case elem is a non-element node (e.g., document)
	  if (selector) {
	    documentElement.matches(selector);
	  }

	  // Make sure that the handler has a unique ID, used to find/remove it later
	  if (!handler.guid) {
	    handler.guid = $.guid++;
	  }

	  // Init the element's event structure and main handler, if this is the first
	  let events;
	  if (!(events = elemData.events)) {
	    events = elemData.events = Object.create(null);
	  }
	  let eventHandle;
	  if (!(eventHandle = elemData.handle)) {
	    eventHandle = elemData.handle = function (e) {
	      // Discard the second event of a $.event.trigger() and
	      // when an event is called after a page has unloaded
	      return typeof $ !== 'undefined' ? $.event.dispatch.apply(elem, arguments) : undefined;
	    };
	  }

	  // Handle multiple events separated by a space
	  const typesArr = (types || '').match(rNotHtmlWhite) || [''];
	  let i = typesArr.length;
	  while (i--) {
	    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);
	    // There *must* be a type, no attaching namespace-only handlers
	    if (!origType) {
	      continue;
	    }
	    const namespaces = ns.split('.').sort();
	    // If event changes its type, use the special event handlers for the changed type
	    let special = $.event.special[origType];
	    // If selector defined, determine special event api type, otherwise given type
	    const type = special && (selector ? special.delegateType : special.bindType) || origType;
	    // Update special based on newly reset type
	    special = $.event.special[type];
	    // handleObj is passed to all event handlers
	    const handleObj = Object.assign({
	      type: type,
	      origType: origType,
	      data: data,
	      handler: handler,
	      guid: handler.guid,
	      selector: selector,
	      namespace: namespaces.join('.')
	    }, handleObjIn);
	    let handlers;
	    // Init the event handler queue if we're the first
	    if (!(handlers = events[type])) {
	      handlers = events[type] = [];
	      handlers.delegateCount = 0;

	      // Only use addEventListener if the special events handler returns false
	      if (!special || !special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	        if (elem.addEventListener) {
	          elem.addEventListener(type, eventHandle);
	        }
	      }
	    }
	    if (special && special.add) {
	      special.add.call(elem, handleObj);
	      if (!handleObj.handler.guid) {
	        handleObj.handler.guid = handler.guid;
	      }
	    }

	    // Add to the element's handler list, delegates in front
	    if (selector) {
	      handlers.splice(handlers.delegateCount++, 0, handleObj);
	    } else {
	      handlers.push(handleObj);
	    }
	  }
	};

	// Detach an event or set of events from an element
	$.event.remove = function (elem, types, handler, selector, mappedTypes) {
	  const elemData = dataPriv.get(elem);
	  if (!elemData || !elemData.events) return;
	  const events = elemData.events;

	  // Once for each type.namespace in types; type may be omitted
	  const typesArr = (types || '').match(rNotHtmlWhite) || [''];
	  let i = typesArr.length;
	  while (i--) {
	    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);
	    // Unbind all events (on this namespace, if provided) for the element
	    if (!origType) {
	      for (const type in events) {
	        $.event.remove(elem, type + typesArr[i], handler, selector, true);
	      }
	      continue;
	    }
	    const special = $.event.special[origType];
	    const type = special && (selector ? special.delegateType : special.bindType) || origType;
	    const handlers = events[type];
	    if (!handlers || handlers.length === 0) continue;
	    const namespaces = ns.split('.').sort();
	    const rNamespace = ns ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;

	    // Remove matching events
	    const origCount = handlers.length;
	    let j = origCount;
	    while (j--) {
	      const handleObj = handlers[j];
	      if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!rNamespace || rNamespace.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
	        handlers.splice(j, 1);
	        if (handleObj.selector) {
	          handlers.delegateCount--;
	        }
	        if (special && special.remove) {
	          special.remove.call(elem, handleObj);
	        }
	      }
	    }

	    // Remove generic event handler if we removed something and no more handlers exist
	    // (avoids potential for endless recursion during removal of special event handlers)
	    if (origCount && handlers.length === 0) {
	      if (!special || !special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	        // This "if" is needed for plain objects
	        if (elem.removeEventListener) {
	          elem.removeEventListener(type, elemData.handle);
	        }
	      }
	      delete events[type];
	    }
	  }

	  // Remove data if it's no longer used
	  if (isEmpty(events)) {
	    dataPriv.remove(elem, 'handle');
	    dataPriv.remove(elem, 'events');
	  }
	};
	$.event.dispatch = function (nativeEvent) {
	  const elem = this;
	  // Make a writable $.Event from the native event object
	  const event = $.event.fix(nativeEvent);
	  event.delegateTarget = elem;
	  // Use the fix-ed $.Event rather than the (read-only) native event
	  const args = Array.from(arguments);
	  args[0] = event;
	  const eventsData = dataPriv.get(elem, 'events');
	  const handlers = eventsData && eventsData[event.type] || [];
	  const special = $.event.special[event.type];

	  // Call the preDispatch hook for the mapped type, and let it bail if desired
	  if (special && special.preDispatch) {
	    if (special.preDispatch.call(elem, event) === false) return;
	  }

	  // Determine handlers
	  const handlerQueue = $.event.handlers.call(elem, event, handlers);

	  // Run delegates first; they may want to stop propagation beneath us
	  let i = 0;
	  let matched;
	  while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
	    event.currentTarget = matched.elem;
	    let j = 0;
	    let handleObj;
	    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
	      event.handleObj = handleObj;
	      event.data = handleObj.data;
	      const origSpecial = $.event.special[handleObj.origType];
	      let handler;
	      if (origSpecial && origSpecial.handle) {
	        handler = origSpecial.handle;
	      } else {
	        handler = handleObj.handler;
	      }
	      const ret = handler.apply(matched.elem, args);
	      if (ret !== undefined) {
	        if ((event.result = ret) === false) {
	          event.preventDefault();
	          event.stopPropagation();
	        }
	      }
	    }
	  }

	  // Call the postDispatch hook for the mapped type
	  if (special && special.postDispatch) {
	    special.postDispatch.call(elem, event);
	  }
	  return event.result;
	};
	$.event.handlers = function (event, handlers) {
	  const delegateCount = handlers.delegateCount;
	  const handlerQueue = [];

	  // Find delegate handlers
	  if (delegateCount &&
	  // Support: Firefox <=42 - 66+
	  // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
	  // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
	  // Support: IE 11+
	  // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
	  !(event.type === 'click' && event.button >= 1)) {
	    for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {
	      // Don't check non-elements (trac-13208)
	      // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
	      if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
	        const matchedHandlers = [];
	        const matchedSelectors = {};
	        for (let i = 0; i < delegateCount; i++) {
	          const handleObj = handlers[i];
	          // Don't conflict with Object.prototype properties (trac-13203)
	          const sel = handleObj.selector + ' ';
	          if (matchedSelectors[sel] === undefined) {
	            matchedSelectors[sel] = cur.matches(sel);
	          }
	          if (matchedSelectors[sel]) {
	            matchedHandlers.push(handleObj);
	          }
	        }
	        if (matchedHandlers.length) {
	          handlerQueue.push({
	            elem: cur,
	            handlers: matchedHandlers
	          });
	        }
	      }
	    }
	  }

	  // Add the remaining (directly-bound) handlers
	  if (delegateCount < handlers.length) {
	    handlerQueue.push({
	      elem: this,
	      handlers: handlers.slice(delegateCount)
	    });
	  }
	  return handlerQueue;
	};
	$.event.fix = function (originalEvent) {
	  return originalEvent.envelope ? originalEvent : new Event(originalEvent);
	};

	// A central reference to the root $(document)
	const $root = $(document$1);

	const svg$1 = 'http://www.w3.org/2000/svg';
	const xmlns = 'http://www.w3.org/2000/xmlns/';
	const xml = 'http://www.w3.org/XML/1998/namespace';
	const xlink = 'http://www.w3.org/1999/xlink';
	const xhtml = 'http://www.w3.org/1999/xhtml';

	var ns = {
		__proto__: null,
		svg: svg$1,
		xhtml: xhtml,
		xlink: xlink,
		xml: xml,
		xmlns: xmlns
	};

	/**
	 * @constant {boolean}
	 * @description Indicates the environment supports SVG.
	 */
	const isSVGSupported = typeof window === 'object' && !!window.SVGAngle;

	/**
	 * @constant {string}
	 * @description The version of the SVG document.
	 */
	const SVG_VERSION = '1.1';

	/**
	 * @constant {SVGSVGElement}
	 * @description The detached SVG document for various internal purposes.
	 * e.g. SVGMatrix has no constructor, so the only way to create it is
	 * to create an SVG document and then call `createSVGMatrix()`.
	 */
	const internalSVGDocument = isSVGSupported ? createSVGDocument() : null;

	/**
	 * @constant {SVGGElement}
	 * @description The detached SVG group element for various internal purposes.
	 */
	const internalSVGGroup = isSVGSupported ? createSVGElement('g') : null;

	/**
	 * @returns {SVGSVGElement}
	 * @description Creates an SVG document.
	 */
	function createSVGDocument() {
	  const svg = createSVGElement('svg');
	  svg.setAttributeNS(xmlns, 'xmlns:xlink', xlink);
	  svg.setAttribute('version', SVG_VERSION);
	  return svg;
	}

	/**
	 * @param {string} name
	 * @returns {SVGElement}
	 * @description Creates an SVG element with the given name.
	 */
	function createSVGElement(name) {
	  return document.createElementNS(svg$1, name);
	}

	/**
	 * @param {SVGElement} node1
	 * @param {SVGElement} node2
	 * @returns {SVGElement|null}
	 * @description Finds the common ancestor node of two nodes.
	 */
	function getCommonAncestor(node1, node2) {
	  // Find the common ancestor node of two nodes.
	  let parent = node1;
	  do {
	    if (parent.contains(node2)) return parent;
	    parent = parent.parentNode;
	  } while (parent);
	  return null;
	}

	/**
	 * @returns {SVGMatrix}
	 * @description Creates an identity matrix.
	 */
	function createIdentityMatrix() {
	  return internalSVGDocument.createSVGMatrix();
	}

	/**
	 * @param {Partial<SVGMatrix>} matrixInit
	 * @returns {SVGMatrix}
	 * @description Creates a new SVGMatrix object.
	 * If no matrix is provided, it returns the identity matrix.
	 * If a matrix like object is provided, it sets the matrix values.
	 */
	function createMatrix(matrixInit = {}) {
	  const matrix = internalSVGDocument.createSVGMatrix();
	  if (!matrixInit) return matrix;
	  if ('a' in matrixInit) matrix.a = matrixInit.a;
	  if ('b' in matrixInit) matrix.b = matrixInit.b;
	  if ('c' in matrixInit) matrix.c = matrixInit.c;
	  if ('d' in matrixInit) matrix.d = matrixInit.d;
	  if ('e' in matrixInit) matrix.e = matrixInit.e;
	  if ('f' in matrixInit) matrix.f = matrixInit.f;
	  return matrix;
	}

	/**
	 * @returns {SVGTransform}
	 * @description Creates a new SVGTransform object.
	 */
	function createSVGTransform() {
	  return internalSVGDocument.createSVGTransform();
	}

	/**
	 * @param {SVGElement} node
	 * @returns {SVGMatrix|null}
	 * @description Returns the transformation matrix of the given node.
	 * If the node has no transformation, it returns null.
	 */
	function getNodeMatrix(node) {
	  const consolidatedTransformation = node.transform.baseVal.consolidate();
	  return consolidatedTransformation ? consolidatedTransformation.matrix : null;
	}

	/**
	 * @param {string} transformString
	 * @returns {SVGMatrix}
	 * @description Creates a matrix from the given transform string.
	 */
	function createMatrixFromTransformString(transformString) {
	  internalSVGGroup.setAttribute('transform', transformString);
	  return getNodeMatrix(internalSVGGroup);
	}

	/**
	 * @param {SVGElement} node
	 * @param {Partial<SVGMatrix>} matrixInit
	 * @param {boolean} override
	 * @description Sets the transformation matrix of the given node.
	 * We don't use `node.transform.baseVal` here (@see `transformNode`)
	 * for the following reasons:
	 * - Performance: while Chrome performs slightly better, Firefox
	 *   and Safari are significantly slower
	 *   https://www.measurethat.net/Benchmarks/Show/34447/1/overriding-svg-transform-attribute
	 * - Limited support: JSDOM does not support `node.transform.baseVal`
	 */
	function replaceTransformNode(node, matrixInit) {
	  node.setAttribute('transform', matrixToTransformString(matrixInit));
	}

	/**
	 * @param {SVGElement} node
	 * @param {Partial<SVGMatrix>} matrixInit
	 * @description Applies a transformation matrix to the given node.
	 * If the node already has a transformation, it appends the new transformation.
	 * If the node has no transformation, it creates a new one.
	 */
	function transformNode(node, matrixInit) {
	  const transform = createSVGTransform();
	  const matrix = isSVGMatrix(matrixInit) ? matrixInit : createMatrix(matrixInit);
	  transform.setMatrix(matrix);
	  node.transform.baseVal.appendItem(transform);
	}
	const MATRIX_TYPE = '[object SVGMatrix]';

	/**
	 * @param {any} obj
	 * @returns {boolean}
	 * @description Checks if the given object is an SVGMatrix.
	 */
	function isSVGMatrix(obj) {
	  return Object.prototype.toString.call(obj) === MATRIX_TYPE;
	}

	/**
	 * @param {Partial<SVGMatrix>} matrixInit
	 * @returns {string}
	 * @description Converts a matrix to a transform string.
	 * If no matrix is provided, it returns the identity matrix string.
	 */
	function matrixToTransformString(matrixInit = {}) {
	  const {
	    a = 1,
	    b = 0,
	    c = 0,
	    d = 1,
	    e = 0,
	    f = 0
	  } = matrixInit;
	  return `matrix(${a},${b},${c},${d},${e},${f})`;
	}

	/**
	 *
	 * @param {SVGElement} a
	 * @param {SVGElement} b
	 * @returns {SVGMatrix|null}
	 * @description Finds the transformation matrix from `a` to `b`.
	 * It requires that both elements to be visible (in the render tree)
	 * in order to calculate the correct transformation matrix.
	 */
	function getRelativeTransformation(a, b) {
	  // Different SVG elements, no transformation possible
	  // Note: SVGSVGElement has no `ownerSVGElement`
	  if ((a.ownerSVGElement || a) !== (b.ownerSVGElement || b)) return null;
	  // Get the transformation matrix from `a` to `b`.
	  const am = b.getScreenCTM();
	  if (!am) return null;
	  const bm = a.getScreenCTM();
	  if (!bm) return null;
	  return am.inverse().multiply(bm);
	}

	/**
	 * @param {SVGElement} a
	 * @param {SVGElement} b
	 * @returns {SVGMatrix|null}
	 * @description Finds the transformation matrix from `a` to `b`.
	 * A safe way to calculate the transformation matrix between two elements.
	 * It does not require the elements to be visible (in the render tree).
	 */
	function getRelativeTransformationSafe(a, b) {
	  if (a === b) {
	    // No transformation needed
	    return createIdentityMatrix();
	  }
	  const position = a.compareDocumentPosition(b);
	  if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
	    // `b` is a descendant of `a`
	    return getLinealTransformation(a, b).inverse();
	  } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {
	    // `a` is a descendant of `b`
	    return getLinealTransformation(b, a);
	  }
	  const c = getCommonAncestor(a, b);
	  if (!c) {
	    // No common ancestor
	    return null;
	  }
	  const mca = getLinealTransformation(c, a);
	  const mcb = getLinealTransformation(c, b);
	  return mcb.inverse().multiply(mca);
	}

	/**
	 * @param {SVGElement} descendant
	 * @param {SVGElement} ancestor
	 * @returns {SVGMatrix}
	 * @description Finds the transformation matrix between the `ancestor` and `descendant`.
	 */
	function getLinealTransformation(ancestor, descendant) {
	  const transformations = [];
	  let n = descendant;
	  while (n && n.nodeType === Node.ELEMENT_NODE && n !== ancestor) {
	    const nm = getNodeMatrix(n);
	    if (nm) {
	      transformations.unshift(nm);
	    }
	    n = n.parentNode;
	  }
	  return transformations.reduce((m, t) => m.multiply(t), createIdentityMatrix());
	}

	// Vectorizer.
	// -----------

	const V = function () {
	  // SVG support is required.
	  if (!isSVGSupported) {
	    // Return a function that throws an error when it is used.
	    return function () {
	      throw new Error('SVG is required to use Vectorizer.');
	    };
	  }

	  // Declare shorthands to the most used math functions.
	  var math = Math;
	  var PI = math.PI;
	  var atan2 = math.atan2;
	  var sqrt = math.sqrt;
	  var min = math.min;
	  var max = math.max;
	  var cos = math.cos;
	  var sin = math.sin;
	  var V = function (el, attrs, children) {
	    // This allows using V() without the new keyword.
	    if (!(this instanceof V)) {
	      return V.apply(Object.create(V.prototype), arguments);
	    }
	    if (!el) return;
	    if (V.isV(el)) {
	      el = el.node;
	    }
	    attrs = attrs || {};
	    if (V.isString(el)) {
	      el = el.trim();
	      if (el.toLowerCase() === 'svg') {
	        // Create a new SVG canvas.
	        el = V.createSvgDocument();
	      } else if (el[0] === '<') {
	        // Create element from an SVG string.
	        // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.

	        var svgDoc = V.createSvgDocument(el);

	        // Note that `V()` might also return an array should the SVG string passed as
	        // the first argument contain more than one root element.
	        if (svgDoc.childNodes.length > 1) {
	          // Map child nodes to `V`s.
	          var arrayOfVels = [];
	          var i, len;
	          for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {
	            var childNode = svgDoc.childNodes[i];
	            arrayOfVels.push(new V(document.importNode(childNode, true)));
	          }
	          return arrayOfVels;
	        }
	        el = document.importNode(svgDoc.firstChild, true);
	      } else {
	        el = createSVGElement(el);
	      }
	      V.ensureId(el);
	    }
	    this.node = el;
	    this.setAttributes(attrs);
	    if (children) {
	      this.append(children);
	    }
	    return this;
	  };
	  var VPrototype = V.prototype;
	  Object.defineProperty(VPrototype, 'id', {
	    enumerable: true,
	    get: function () {
	      return this.node.id;
	    },
	    set: function (id) {
	      this.node.id = id;
	    }
	  });

	  /**
	   * Calculates the transformation matrix from this element to the target element.
	   * @param {SVGElement|V} target - The target element.
	   * @param {Object} [opt] - Options object for transformation calculation.
	   * @param {boolean} [opt.safe] - Use a safe traversal method to compute the matrix.
	   * @returns {DOMMatrix} The transformation matrix from this element to the target element.
	   */
	  VPrototype.getTransformToElement = function (target, opt) {
	    const node = this.node;
	    const targetNode = V.toNode(target);
	    let m;
	    if (V.isSVGGraphicsElement(targetNode) && V.isSVGGraphicsElement(node)) {
	      if (opt && opt.safe) {
	        // Use the traversal method to get the transformation matrix.
	        m = getRelativeTransformationSafe(node, targetNode);
	      } else {
	        m = getRelativeTransformation(node, targetNode);
	      }
	    }
	    return m || createIdentityMatrix();
	  };

	  /**
	   * @param {SVGMatrix} matrix
	   * @param {Object=} opt
	   * @returns {Vectorizer|SVGMatrix} Setter / Getter
	   */
	  VPrototype.transform = function (matrix, opt) {
	    const node = this.node;

	    // Getter
	    if (V.isUndefined(matrix)) {
	      return getNodeMatrix(node) || createIdentityMatrix();
	    }

	    // Setter
	    if (opt && opt.absolute) {
	      replaceTransformNode(node, matrix);
	    } else {
	      transformNode(node, matrix);
	    }
	    return this;
	  };
	  VPrototype.translate = function (tx, ty, opt) {
	    opt = opt || {};
	    ty = ty || 0;
	    var transformAttr = this.attr('transform') || '';
	    var transform = V.parseTransformString(transformAttr);
	    transformAttr = transform.value;
	    // Is it a getter?
	    if (V.isUndefined(tx)) {
	      return transform.translate;
	    }
	    transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
	    var newTx = opt.absolute ? tx : transform.translate.tx + tx;
	    var newTy = opt.absolute ? ty : transform.translate.ty + ty;
	    var newTranslate = 'translate(' + newTx + ',' + newTy + ')';

	    // Note that `translate()` is always the first transformation. This is
	    // usually the desired case.
	    this.attr('transform', (newTranslate + ' ' + transformAttr).trim());
	    return this;
	  };
	  VPrototype.rotate = function (angle, cx, cy, opt) {
	    opt = opt || {};
	    var transformAttr = this.attr('transform') || '';
	    var transform = V.parseTransformString(transformAttr);
	    transformAttr = transform.value;

	    // Is it a getter?
	    if (V.isUndefined(angle)) {
	      return transform.rotate;
	    }
	    transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
	    angle %= 360;
	    var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;
	    var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';
	    var newRotate = 'rotate(' + newAngle + newOrigin + ')';
	    this.attr('transform', (transformAttr + ' ' + newRotate).trim());
	    return this;
	  };

	  // Note that `scale` as the only transformation does not combine with previous values.
	  VPrototype.scale = function (sx, sy) {
	    sy = V.isUndefined(sy) ? sx : sy;
	    var transformAttr = this.attr('transform') || '';
	    var transform = V.parseTransformString(transformAttr);
	    transformAttr = transform.value;

	    // Is it a getter?
	    if (V.isUndefined(sx)) {
	      return transform.scale;
	    }
	    transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
	    var newScale = 'scale(' + sx + ',' + sy + ')';
	    this.attr('transform', (transformAttr + ' ' + newScale).trim());
	    return this;
	  };

	  // Get SVGRect that contains coordinates and dimension of the real bounding box,
	  // i.e. after transformations are applied.
	  // If `target` is specified, bounding box will be computed relatively to `target` element.
	  VPrototype.bbox = function (withoutTransformations, target) {
	    var box;
	    var node = this.node;
	    var ownerSVGElement = node.ownerSVGElement;

	    // If the element is not in the live DOM, it does not have a bounding box defined and
	    // so fall back to 'zero' dimension element.
	    if (!ownerSVGElement) {
	      return new Rect(0, 0, 0, 0);
	    }
	    try {
	      box = node.getBBox();
	    } catch {
	      // Fallback for IE.
	      box = {
	        x: node.clientLeft,
	        y: node.clientTop,
	        width: node.clientWidth,
	        height: node.clientHeight
	      };
	    }
	    if (withoutTransformations) {
	      return new Rect(box);
	    }
	    var matrix = this.getTransformToElement(target || ownerSVGElement);
	    return V.transformRect(box, matrix);
	  };

	  // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,
	  // i.e. after transformations are applied.
	  // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.
	  // Takes an (Object) `opt` argument (optional) with the following attributes:
	  // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this
	  // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();
	  VPrototype.getBBox = function (opt) {
	    var options = {};
	    var outputBBox;
	    var node = this.node;
	    var ownerSVGElement = node.ownerSVGElement;

	    // If the element is not in the live DOM, it does not have a bounding box defined and
	    // so fall back to 'zero' dimension element.
	    // If the element is not an SVGGraphicsElement, we could not measure the bounding box either
	    if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {
	      return new Rect(0, 0, 0, 0);
	    }
	    if (opt) {
	      if (opt.target) {
	        // check if target exists
	        options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects
	      }
	      if (opt.recursive) {
	        options.recursive = opt.recursive;
	      }
	    }
	    if (!options.recursive) {
	      try {
	        outputBBox = node.getBBox();
	      } catch {
	        // Fallback for IE.
	        outputBBox = {
	          x: node.clientLeft,
	          y: node.clientTop,
	          width: node.clientWidth,
	          height: node.clientHeight
	        };
	      }
	      if (!options.target) {
	        // transform like this (that is, not at all)
	        return new Rect(outputBBox);
	      } else {
	        // transform like target
	        var matrix = this.getTransformToElement(options.target);
	        return V.transformRect(outputBBox, matrix);
	      }
	    } else {
	      // if we want to calculate the bbox recursively
	      // browsers report correct bbox around svg elements (one that envelops the path lines tightly)
	      // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())
	      // this happens even if we wrap a single svg element into a group!
	      // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes

	      var children = this.children();
	      var n = children.length;
	      if (n === 0) {
	        return this.getBBox({
	          target: options.target,
	          recursive: false
	        });
	      }

	      // recursion's initial pass-through setting:
	      // recursive passes-through just keep the target as whatever was set up here during the initial pass-through
	      if (!options.target) {
	        // transform children/descendants like this (their parent/ancestor)
	        options.target = this;
	      } // else transform children/descendants like target

	      for (var i = 0; i < n; i++) {
	        var currentChild = children[i];
	        var childBBox;

	        // if currentChild is not a group element, get its bbox with a nonrecursive call
	        if (currentChild.children().length === 0) {
	          childBBox = currentChild.getBBox({
	            target: options.target,
	            recursive: false
	          });
	        } else {
	          // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call
	          childBBox = currentChild.getBBox({
	            target: options.target,
	            recursive: true
	          });
	        }
	        if (!outputBBox) {
	          // if this is the first iteration
	          outputBBox = childBBox;
	        } else {
	          // make a new bounding box rectangle that contains this child's bounding box and previous bounding box
	          outputBBox = outputBBox.union(childBBox);
	        }
	      }
	      return outputBBox;
	    }
	  };

	  // Text() helpers

	  function createTextPathNode(attrs, vel) {
	    attrs || (attrs = {});
	    var textPathElement = V('textPath');
	    var d = attrs.d;
	    if (d && attrs['xlink:href'] === undefined) {
	      // If `opt.attrs` is a plain string, consider it to be directly the
	      // SVG path data for the text to go along (this is a shortcut).
	      // Otherwise if it is an object and contains the `d` property, then this is our path.
	      // Wrap the text in the SVG <textPath> element that points
	      // to a path defined by `opt.attrs` inside the `<defs>` element.
	      var linkedPath = V('path').attr('d', d).appendTo(vel.defs());
	      textPathElement.attr('xlink:href', '#' + linkedPath.id);
	    }
	    if (V.isObject(attrs)) {
	      // Set attributes on the `<textPath>`. The most important one
	      // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.
	      // Note that we also allow the following construct:
	      // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.
	      // In other words, one can completely skip the auto-creation of the path
	      // and use any other arbitrary path that is in the document.
	      textPathElement.attr(attrs);
	    }
	    return textPathElement.node;
	  }
	  function annotateTextLine(lineNode, lineAnnotations, opt) {
	    opt || (opt = {});
	    var includeAnnotationIndices = opt.includeAnnotationIndices;
	    var eol = opt.eol;
	    var lineHeight = opt.lineHeight;
	    var baseSize = opt.baseSize;
	    var maxFontSize = 0;
	    var fontMetrics = {};
	    var lastJ = lineAnnotations.length - 1;
	    for (var j = 0; j <= lastJ; j++) {
	      var annotation = lineAnnotations[j];
	      var fontSize = null;
	      if (V.isObject(annotation)) {
	        var annotationAttrs = annotation.attrs;
	        var vTSpan = V('tspan', annotationAttrs);
	        var tspanNode = vTSpan.node;
	        var t = annotation.t;
	        if (eol && j === lastJ) t += eol;
	        tspanNode.textContent = t;
	        // Per annotation className
	        var annotationClass = annotationAttrs['class'];
	        if (annotationClass) vTSpan.addClass(annotationClass);
	        // If `opt.includeAnnotationIndices` is `true`,
	        // set the list of indices of all the applied annotations
	        // in the `annotations` attribute. This list is a comma
	        // separated list of indices.
	        if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);
	        // Check for max font size
	        fontSize = parseFloat(annotationAttrs['font-size']);
	        if (!isFinite(fontSize)) fontSize = baseSize;
	        if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
	      } else {
	        if (eol && j === lastJ) annotation += eol;
	        tspanNode = document.createTextNode(annotation || ' ');
	        if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;
	      }
	      lineNode.appendChild(tspanNode);
	    }
	    if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;
	    if (lineHeight) {
	      fontMetrics.lineHeight = lineHeight;
	    } else if (maxFontSize) {
	      fontMetrics.lineHeight = maxFontSize * 1.2;
	    }
	    return fontMetrics;
	  }
	  var emRegex = /em$/;
	  function convertEmToPx(em, fontSize) {
	    var numerical = parseFloat(em);
	    if (emRegex.test(em)) return numerical * fontSize;
	    return numerical;
	  }
	  function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
	    if (!Array.isArray(linesMetrics)) return 0;
	    var n = linesMetrics.length;
	    if (!n) return 0;
	    var lineMetrics = linesMetrics[0];
	    var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
	    var rLineHeights = 0;
	    var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);
	    for (var i = 1; i < n; i++) {
	      lineMetrics = linesMetrics[i];
	      var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
	      rLineHeights += iLineHeight;
	    }
	    var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
	    var dy;
	    switch (alignment) {
	      case 'middle':
	        dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
	        break;
	      case 'bottom':
	        dy = -(0.25 * llMaxFont) - rLineHeights;
	        break;
	      case 'top':
	      default:
	        dy = 0.8 * flMaxFont;
	        break;
	    }
	    return dy;
	  }
	  VPrototype.text = function (content, opt) {
	    if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');
	    opt || (opt = {});

	    // Backwards-compatibility: if no content was provided, treat it as an
	    // empty string so that subsequent string operations (e.g. split) do
	    // not throw and behaviour matches the previous implementation that
	    // always sanitised the input.
	    if (content == null) content = '';
	    if (opt.useNoBreakSpace) {
	      // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
	      // IE would otherwise collapse all spaces into one.
	      content = V.sanitizeText(content);
	    }
	    // Should we allow the text to be selected?
	    var displayEmpty = opt.displayEmpty;
	    // End of Line character
	    var eol = opt.eol;
	    // Text along path
	    var textPath = opt.textPath;
	    // Vertical shift
	    var verticalAnchor = opt.textVerticalAnchor;
	    var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';
	    // Horizontal shift applied to all the lines but the first.
	    var x = opt.x;
	    if (x === undefined) x = this.attr('x') || 0;
	    // Annotations
	    var iai = opt.includeAnnotationIndices;
	    var annotations = opt.annotations;
	    if (annotations && !V.isArray(annotations)) annotations = [annotations];
	    // Shift all the <tspan> but first by one line (`1em`)
	    var defaultLineHeight = opt.lineHeight;
	    var autoLineHeight = defaultLineHeight === 'auto';
	    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
	    // Clearing the element
	    this.empty();
	    this.attr({
	      // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.
	      'xml:space': 'preserve',
	      // An empty text gets rendered into the DOM in webkit-based browsers.
	      // In order to unify this behaviour across all browsers
	      // we rather hide the text element when it's empty.
	      'display': content || displayEmpty ? null : 'none'
	    });

	    // Set default font-size if none
	    var fontSize = parseFloat(this.attr('font-size'));
	    if (!fontSize) {
	      fontSize = 16;
	      if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);
	    }
	    var doc = document;
	    var containerNode;
	    if (textPath) {
	      // Now all the `<tspan>`s will be inside the `<textPath>`.
	      if (typeof textPath === 'string') textPath = {
	        d: textPath
	      };
	      containerNode = createTextPathNode(textPath, this);
	    } else {
	      containerNode = doc.createDocumentFragment();
	    }
	    var offset = 0;
	    var lines = content.split('\n');
	    var linesMetrics = [];
	    var annotatedY;
	    for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {
	      var dy = lineHeight;
	      var lineClassName = 'v-line';
	      var lineNode = doc.createElementNS(svg$1, 'tspan');
	      var line = lines[i];
	      var lineMetrics;
	      if (line) {
	        if (annotations) {
	          // Find the *compacted* annotations for this line.
	          var lineAnnotations = V.annotateString(line, annotations, {
	            offset: -offset,
	            includeAnnotationIndices: iai
	          });
	          lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
	            includeAnnotationIndices: iai,
	            eol: i !== lastI && eol,
	            lineHeight: autoLineHeight ? null : lineHeight,
	            baseSize: fontSize
	          });
	          // Get the line height based on the biggest font size in the annotations for this line.
	          var iLineHeight = lineMetrics.lineHeight;
	          if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;
	          if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;
	        } else {
	          if (eol && i !== lastI) line += eol;
	          lineNode.textContent = line;
	        }
	      } else {
	        // Make sure the textContent is never empty. If it is, add a dummy
	        // character and make it invisible, making the following lines correctly
	        // relatively positioned. `dy=1em` won't work with empty lines otherwise.
	        lineNode.textContent = '-';
	        lineClassName += ' v-empty-line';
	        // 'opacity' needs to be specified with fill, stroke. Opacity without specification
	        // is not applied in Firefox
	        var lineNodeStyle = lineNode.style;
	        lineNodeStyle.fillOpacity = 0;
	        lineNodeStyle.strokeOpacity = 0;
	        if (annotations) {
	          // Empty line with annotations.
	          lineMetrics = {};
	          lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);
	          let lineFontSize = fontSize;
	          // Check if any of the annotations overrides the font size.
	          for (let j = lineAnnotations.length; j > 0; j--) {
	            const attrs = lineAnnotations[j - 1].attrs;
	            if (!attrs || !('font-size' in attrs)) continue;
	            const fs = parseFloat(attrs['font-size']);
	            if (isFinite(fs)) {
	              lineFontSize = fs;
	              break;
	            }
	          }
	          if (autoLineHeight) {
	            if (i > 0) {
	              dy = lineFontSize * 1.2;
	            } else {
	              annotatedY = lineFontSize * 0.8;
	            }
	          }
	          // The font size is important for the native selection box height.
	          lineNode.setAttribute('font-size', lineFontSize);
	          lineMetrics.maxFontSize = lineFontSize;
	        }
	      }
	      if (lineMetrics) linesMetrics.push(lineMetrics);
	      if (i > 0) lineNode.setAttribute('dy', dy);
	      // Firefox requires 'x' to be set on the first line when inside a text path
	      if (i > 0 || textPath) lineNode.setAttribute('x', x);
	      lineNode.className.baseVal = lineClassName;
	      containerNode.appendChild(lineNode);
	      offset += line.length + 1; // + 1 = newline character.
	    }
	    // Y Alignment calculation
	    if (namedVerticalAnchor) {
	      if (annotations) {
	        dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
	      } else if (verticalAnchor === 'top') {
	        // A shortcut for top alignment. It does not depend on font-size nor line-height
	        dy = '0.8em';
	      } else {
	        var rh; // remaining height
	        if (lastI > 0) {
	          rh = parseFloat(lineHeight) || 1;
	          rh *= lastI;
	          if (!emRegex.test(lineHeight)) rh /= fontSize;
	        } else {
	          // Single-line text
	          rh = 0;
	        }
	        switch (verticalAnchor) {
	          case 'middle':
	            dy = 0.3 - rh / 2 + 'em';
	            break;
	          case 'bottom':
	            dy = -rh - 0.3 + 'em';
	            break;
	        }
	      }
	    } else {
	      if (verticalAnchor === 0) {
	        dy = '0em';
	      } else if (verticalAnchor) {
	        dy = verticalAnchor;
	      } else {
	        // No vertical anchor is defined
	        dy = 0;
	        // Backwards compatibility - we change the `y` attribute instead of `dy`.
	        if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');
	      }
	    }
	    containerNode.firstChild.setAttribute('dy', dy);
	    // Appending lines to the element.
	    this.append(containerNode);
	    return this;
	  };

	  /**
	   * @public
	   * @param {string} name
	   * @returns {Vectorizer}
	   */
	  VPrototype.removeAttr = function (name) {
	    const trueName = attributeNames[name];
	    const {
	      ns,
	      local
	    } = V.qualifyAttr(trueName);
	    const el = this.node;
	    if (ns) {
	      if (el.hasAttributeNS(ns, local)) {
	        el.removeAttributeNS(ns, local);
	      }
	    } else if (el.hasAttribute(trueName)) {
	      el.removeAttribute(trueName);
	    }
	    return this;
	  };
	  VPrototype.attr = function (name, value) {
	    if (V.isUndefined(name)) {
	      // Return all attributes.
	      var attributes = this.node.attributes;
	      var attrs = {};
	      for (var i = 0; i < attributes.length; i++) {
	        attrs[attributes[i].name] = attributes[i].value;
	      }
	      return attrs;
	    }
	    if (V.isString(name) && V.isUndefined(value)) {
	      return this.node.getAttribute(attributeNames[name]);
	    }
	    if (typeof name === 'object') {
	      for (var attrName in name) {
	        if (name.hasOwnProperty(attrName)) {
	          this.setAttribute(attrName, name[attrName]);
	        }
	      }
	    } else {
	      this.setAttribute(name, value);
	    }
	    return this;
	  };
	  VPrototype.normalizePath = function () {
	    var tagName = this.tagName();
	    if (tagName === 'PATH') {
	      this.attr('d', V.normalizePathData(this.attr('d')));
	    }
	    return this;
	  };
	  VPrototype.remove = function () {
	    if (this.node.parentNode) {
	      this.node.parentNode.removeChild(this.node);
	    }
	    return this;
	  };
	  VPrototype.empty = function () {
	    while (this.node.firstChild) {
	      this.node.removeChild(this.node.firstChild);
	    }
	    return this;
	  };

	  /**
	   * @private
	   * @param {object} attrs
	   * @returns {Vectorizer}
	   */
	  VPrototype.setAttributes = function (attrs) {
	    for (var key in attrs) {
	      if (attrs.hasOwnProperty(key)) {
	        this.setAttribute(key, attrs[key]);
	      }
	    }
	    return this;
	  };
	  VPrototype.append = function (els) {
	    if (!V.isArray(els)) {
	      els = [els];
	    }
	    for (var i = 0, len = els.length; i < len; i++) {
	      this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]
	    }
	    return this;
	  };
	  VPrototype.prepend = function (els) {
	    var child = this.node.firstChild;
	    return child ? V(child).before(els) : this.append(els);
	  };
	  VPrototype.before = function (els) {
	    var node = this.node;
	    var parent = node.parentNode;
	    if (parent) {
	      if (!V.isArray(els)) {
	        els = [els];
	      }
	      for (var i = 0, len = els.length; i < len; i++) {
	        parent.insertBefore(V.toNode(els[i]), node);
	      }
	    }
	    return this;
	  };
	  VPrototype.appendTo = function (node) {
	    V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]
	    return this;
	  };
	  VPrototype.svg = function () {
	    return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);
	  };
	  VPrototype.tagName = function () {
	    return this.node.tagName.toUpperCase();
	  };
	  VPrototype.defs = function () {
	    var context = this.svg() || this;
	    var defsNode = context.node.getElementsByTagName('defs')[0];
	    if (defsNode) return V(defsNode);
	    return V('defs').appendTo(context);
	  };
	  VPrototype.clone = function () {
	    var clone = V(this.node.cloneNode(true /* deep */));
	    // Note that clone inherits also ID. Therefore, we need to change it here.
	    clone.node.id = V.uniqueId();
	    return clone;
	  };
	  VPrototype.findOne = function (selector) {
	    var found = this.node.querySelector(selector);
	    return found ? V(found) : undefined;
	  };
	  VPrototype.find = function (selector) {
	    var vels = [];
	    var nodes = this.node.querySelectorAll(selector);
	    if (nodes) {
	      // Map DOM elements to `V`s.
	      for (var i = 0; i < nodes.length; i++) {
	        vels.push(V(nodes[i]));
	      }
	    }
	    return vels;
	  };

	  // Returns an array of V elements made from children of this.node.
	  VPrototype.children = function () {
	    var children = this.node.childNodes;
	    var outputArray = [];
	    for (var i = 0; i < children.length; i++) {
	      var currentChild = children[i];
	      if (currentChild.nodeType === 1) {
	        outputArray.push(V(children[i]));
	      }
	    }
	    return outputArray;
	  };

	  // Returns the V element from parentNode of this.node.
	  VPrototype.parent = function () {
	    return V(this.node.parentNode) || null;
	  },
	  // Find an index of an element inside its container.
	  VPrototype.index = function () {
	    var index = 0;
	    var node = this.node.previousSibling;
	    while (node) {
	      // nodeType 1 for ELEMENT_NODE
	      if (node.nodeType === 1) index++;
	      node = node.previousSibling;
	    }
	    return index;
	  };
	  VPrototype.findParentByClass = function (className, terminator) {
	    var ownerSVGElement = this.node.ownerSVGElement;
	    var node = this.node.parentNode;
	    while (node && node !== terminator && node !== ownerSVGElement) {
	      var vel = V(node);
	      if (vel.hasClass(className)) {
	        return vel;
	      }
	      node = node.parentNode;
	    }
	    return null;
	  };

	  // https://jsperf.com/get-common-parent
	  VPrototype.contains = function (el) {
	    var a = this.node;
	    var b = V.toNode(el);
	    var bup = b && b.parentNode;
	    return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);
	  };

	  // Convert global point into the coordinate space of this element.
	  VPrototype.toLocalPoint = function (x, y) {
	    var svg = this.svg().node;
	    var p = svg.createSVGPoint();
	    p.x = x;
	    p.y = y;
	    try {
	      var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());
	      var globalToLocalMatrix = this.getTransformToElement(svg).inverse();
	    } catch {
	      // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)
	      // We have to make do with the original coordinates.
	      return p;
	    }
	    return globalPoint.matrixTransform(globalToLocalMatrix);
	  };
	  VPrototype.translateCenterToPoint = function (p) {
	    var bbox = this.getBBox({
	      target: this.svg()
	    });
	    var center = bbox.center();
	    this.translate(p.x - center.x, p.y - center.y);
	    return this;
	  };

	  // Efficiently auto-orient an element. This basically implements the orient=auto attribute
	  // of markers. The easiest way of understanding on what this does is to imagine the element is an
	  // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while
	  // being auto-oriented (properly rotated) towards the `reference` point.
	  // `target` is the element relative to which the transformations are applied. Usually a viewport.
	  VPrototype.translateAndAutoOrient = function (position, reference, target) {
	    position = new Point(position);
	    reference = new Point(reference);
	    target || (target = this.svg());

	    // Clean-up previously set transformations except the scale. If we didn't clean up the
	    // previous transformations then they'd add up with the old ones. Scale is an exception as
	    // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the
	    // element is scaled by the factor 2, not 8.
	    var scale = this.scale();
	    this.attr('transform', '');
	    var bbox = this.getBBox({
	      target: target
	    }).scale(scale.sx, scale.sy);

	    // 1. Translate to origin.
	    var translateToOrigin = V.createSVGTransform();
	    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);

	    // 2. Rotate around origin.
	    var rotateAroundOrigin = V.createSVGTransform();
	    var angle = position.angleBetween(reference, position.clone().offset(1, 0));
	    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);

	    // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.
	    var translateFromOrigin = V.createSVGTransform();
	    var finalPosition = position.clone().move(reference, bbox.width / 2);
	    translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);

	    // 4. Get the current transformation matrix of this node
	    var ctm = this.getTransformToElement(target);

	    // 5. Apply transformations and the scale
	    var transform = V.createSVGTransform();
	    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));
	    this.attr('transform', matrixToTransformString(transform.matrix));
	    return this;
	  };
	  VPrototype.animateAlongPath = function (attrs, path) {
	    path = V.toNode(path);
	    var id = V.ensureId(path);
	    var animateMotion = V('animateMotion', attrs);
	    var mpath = V('mpath', {
	      'xlink:href': '#' + id
	    });
	    animateMotion.append(mpath);
	    this.append(animateMotion);
	    try {
	      animateMotion.node.beginElement();
	    } catch {
	      // Fallback for IE 9.
	      // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present
	      if (document.documentElement.getAttribute('smiling') === 'fake') {
	        /* global getTargets:true, Animator:true, animators:true id2anim:true */
	        // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
	        var animation = animateMotion.node;
	        animation.animators = [];
	        var animationID = animation.getAttribute('id');
	        if (animationID) id2anim[animationID] = animation;
	        var targets = getTargets(animation);
	        for (var i = 0, len = targets.length; i < len; i++) {
	          var target = targets[i];
	          var animator = new Animator(animation, target, i);
	          animators.push(animator);
	          animation.animators[i] = animator;
	          animator.register();
	        }
	      }
	    }
	    return this;
	  };

	  // Split a string into an array of tokens.
	  // https://infra.spec.whatwg.org/#ascii-whitespace
	  const noHTMLWhitespaceRegex = /[^\x20\t\r\n\f]+/g;
	  function getTokenList(str) {
	    if (!V.isString(str)) return [];
	    return str.trim().match(noHTMLWhitespaceRegex) || [];
	  }
	  VPrototype.hasClass = function (className) {
	    if (!V.isString(className)) return false;
	    return this.node.classList.contains(className.trim());
	  };
	  VPrototype.addClass = function (className) {
	    this.node.classList.add(...getTokenList(className));
	    return this;
	  };
	  VPrototype.removeClass = function (className) {
	    this.node.classList.remove(...getTokenList(className));
	    return this;
	  };
	  VPrototype.toggleClass = function (className, toAdd) {
	    const tokens = getTokenList(className);
	    for (let i = 0; i < tokens.length; i++) {
	      this.node.classList.toggle(tokens[i], toAdd);
	    }
	    return this;
	  };

	  // Interpolate path by discrete points. The precision of the sampling
	  // is controlled by `interval`. In other words, `sample()` will generate
	  // a point on the path starting at the beginning of the path going to the end
	  // every `interval` pixels.
	  // The sampler can be very useful for e.g. finding intersection between two
	  // paths (finding the two closest points from two samples).
	  VPrototype.sample = function (interval) {
	    interval = interval || 1;
	    var node = this.node;
	    var length = node.getTotalLength();
	    var samples = [];
	    var distance = 0;
	    var sample;
	    while (distance < length) {
	      sample = node.getPointAtLength(distance);
	      samples.push({
	        x: sample.x,
	        y: sample.y,
	        distance: distance
	      });
	      distance += interval;
	    }
	    return samples;
	  };
	  VPrototype.convertToPath = function () {
	    var path = V('path');
	    path.attr(this.attr());
	    var d = this.convertToPathData();
	    if (d) {
	      path.attr('d', d);
	    }
	    return path;
	  };
	  VPrototype.convertToPathData = function () {
	    var tagName = this.tagName();
	    switch (tagName) {
	      case 'PATH':
	        return this.attr('d');
	      case 'LINE':
	        return V.convertLineToPathData(this.node);
	      case 'POLYGON':
	        return V.convertPolygonToPathData(this.node);
	      case 'POLYLINE':
	        return V.convertPolylineToPathData(this.node);
	      case 'ELLIPSE':
	        return V.convertEllipseToPathData(this.node);
	      case 'CIRCLE':
	        return V.convertCircleToPathData(this.node);
	      case 'RECT':
	        return V.convertRectToPathData(this.node);
	    }
	    throw new Error(tagName + ' cannot be converted to PATH.');
	  };
	  V.prototype.toGeometryShape = function () {
	    var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;
	    switch (this.tagName()) {
	      case 'RECT':
	        x = parseFloat(this.attr('x')) || 0;
	        y = parseFloat(this.attr('y')) || 0;
	        width = parseFloat(this.attr('width')) || 0;
	        height = parseFloat(this.attr('height')) || 0;
	        return new Rect(x, y, width, height);
	      case 'CIRCLE':
	        cx = parseFloat(this.attr('cx')) || 0;
	        cy = parseFloat(this.attr('cy')) || 0;
	        r = parseFloat(this.attr('r')) || 0;
	        return new Ellipse$1({
	          x: cx,
	          y: cy
	        }, r, r);
	      case 'ELLIPSE':
	        cx = parseFloat(this.attr('cx')) || 0;
	        cy = parseFloat(this.attr('cy')) || 0;
	        rx = parseFloat(this.attr('rx')) || 0;
	        ry = parseFloat(this.attr('ry')) || 0;
	        return new Ellipse$1({
	          x: cx,
	          y: cy
	        }, rx, ry);
	      case 'POLYLINE':
	        points = V.getPointsFromSvgNode(this);
	        return new Polyline$1(points);
	      case 'POLYGON':
	        points = V.getPointsFromSvgNode(this);
	        if (points.length > 1) points.push(points[0]);
	        return new Polyline$1(points);
	      case 'PATH':
	        d = this.attr('d');
	        if (!Path$1.isDataSupported(d)) d = V.normalizePathData(d);
	        return new Path$1(d);
	      case 'LINE':
	        x1 = parseFloat(this.attr('x1')) || 0;
	        y1 = parseFloat(this.attr('y1')) || 0;
	        x2 = parseFloat(this.attr('x2')) || 0;
	        y2 = parseFloat(this.attr('y2')) || 0;
	        return new Line({
	          x: x1,
	          y: y1
	        }, {
	          x: x2,
	          y: y2
	        });
	    }

	    // Anything else is a rectangle
	    return this.getBBox();
	  };

	  // Find the intersection of a line starting in the center
	  // of the SVG `node` ending in the point `ref`.
	  // `target` is an SVG element to which `node`s transformations are relative to.
	  // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.
	  // Returns a point in the `target` coordinate system (the same system as `ref` is in) if
	  // an intersection is found. Returns `undefined` otherwise.
	  VPrototype.findIntersection = function (ref, target) {
	    var svg = this.svg().node;
	    target = target || svg;
	    var bbox = this.getBBox({
	      target: target
	    });
	    var center = bbox.center();
	    if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;
	    var spot;
	    var tagName = this.tagName();

	    // Little speed up optimization for `<rect>` element. We do not do conversion
	    // to path element and sampling but directly calculate the intersection through
	    // a transformed geometrical rectangle.
	    if (tagName === 'RECT') {
	      var gRect = new Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height')));
	      // Get the rect transformation matrix with regards to the SVG document.
	      var rectMatrix = this.getTransformToElement(target);
	      // Decompose the matrix to find the rotation angle.
	      var rectMatrixComponents = V.decomposeMatrix(rectMatrix);
	      // Now we want to rotate the rectangle back so that we
	      // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.
	      var resetRotation = svg.createSVGTransform();
	      resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
	      var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));
	      spot = new Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
	    } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {
	      var pathNode = tagName === 'PATH' ? this : this.convertToPath();
	      var samples = pathNode.sample();
	      var minDistance = Infinity;
	      var closestSamples = [];
	      var i, sample, gp, centerDistance, refDistance, distance;
	      for (i = 0; i < samples.length; i++) {
	        sample = samples[i];
	        // Convert the sample point in the local coordinate system to the global coordinate system.
	        gp = V.createSVGPoint(sample.x, sample.y);
	        gp = gp.matrixTransform(this.getTransformToElement(target));
	        sample = new Point(gp);
	        centerDistance = sample.distance(center);
	        // Penalize a higher distance to the reference point by 10%.
	        // This gives better results. This is due to
	        // inaccuracies introduced by rounding errors and getPointAtLength() returns.
	        refDistance = sample.distance(ref) * 1.1;
	        distance = centerDistance + refDistance;
	        if (distance < minDistance) {
	          minDistance = distance;
	          closestSamples = [{
	            sample: sample,
	            refDistance: refDistance
	          }];
	        } else if (distance < minDistance + 1) {
	          closestSamples.push({
	            sample: sample,
	            refDistance: refDistance
	          });
	        }
	      }
	      closestSamples.sort(function (a, b) {
	        return a.refDistance - b.refDistance;
	      });
	      if (closestSamples[0]) {
	        spot = closestSamples[0].sample;
	      }
	    }
	    return spot;
	  };

	  /**
	   * @private
	   * @param {string} name
	   * @param {string} value
	   * @returns {Vectorizer}
	   */
	  VPrototype.setAttribute = function (name, value) {
	    const el = this.node;
	    if (value === null) {
	      this.removeAttr(name);
	      return this;
	    }
	    const trueName = attributeNames[name];
	    const {
	      ns
	    } = V.qualifyAttr(trueName);
	    if (ns) {
	      // Attribute names can be namespaced. E.g. `image` elements
	      // have a `xlink:href` attribute to set the source of the image.
	      el.setAttributeNS(ns, trueName, value);
	    } else if (trueName === 'id') {
	      el.id = value;
	    } else {
	      el.setAttribute(trueName, value);
	    }
	    return this;
	  };

	  // Create an SVG document element.
	  // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.
	  V.createSvgDocument = function (content) {
	    if (content) {
	      const XMLString = `<svg xmlns="${svg$1}" xmlns:xlink="${xlink}" version="${SVG_VERSION}">${content}</svg>`;
	      const {
	        documentElement
	      } = V.parseXML(XMLString, {
	        async: false
	      });
	      return documentElement;
	    }
	    return createSVGDocument();
	  };
	  V.createSVGStyle = function (stylesheet) {
	    const {
	      node
	    } = V('style', {
	      type: 'text/css'
	    }, [V.createCDATASection(stylesheet)]);
	    return node;
	  }, V.createCDATASection = function (data = '') {
	    const xml = document.implementation.createDocument(null, 'xml', null);
	    return xml.createCDATASection(data);
	  };
	  V.idCounter = 0;

	  // A function returning a unique identifier for this client session with every call.
	  V.uniqueId = function () {
	    return 'v-' + ++V.idCounter;
	  };
	  V.toNode = function (el) {
	    return V.isV(el) ? el.node : el.nodeName && el || el[0];
	  };
	  V.ensureId = function (node) {
	    node = V.toNode(node);
	    return node.id || (node.id = V.uniqueId());
	  };

	  // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
	  // IE would otherwise collapse all spaces into one. This is used in the text() method but it is
	  // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests
	  // when you want to compare the actual DOM text content without having to add the unicode character in
	  // the place of all spaces.
	  /**
	   * @deprecated Use regular spaces and rely on xml:space="preserve" instead.
	   */
	  V.sanitizeText = function (text) {
	    return (text || '').replace(/ /g, '\u00A0');
	  };
	  V.isUndefined = function (value) {
	    return typeof value === 'undefined';
	  };
	  V.isString = function (value) {
	    return typeof value === 'string';
	  };
	  V.isObject = function (value) {
	    return value && typeof value === 'object';
	  };
	  V.isArray = Array.isArray;
	  V.parseXML = function (data, opt) {
	    opt = opt || {};
	    var xml;
	    try {
	      var parser = new DOMParser();
	      if (!V.isUndefined(opt.async)) {
	        parser.async = opt.async;
	      }
	      xml = parser.parseFromString(data, 'text/xml');
	    } catch {
	      xml = undefined;
	    }
	    if (!xml || xml.getElementsByTagName('parsererror').length) {
	      throw new Error('Invalid XML: ' + data);
	    }
	    return xml;
	  };

	  // Create an empty object which does not inherit any properties from `Object.prototype`.
	  // This is useful when we want to use an object as a dictionary without having to
	  // worry about inherited properties such as `toString`, `valueOf` etc.
	  const _attributeNames = Object.create(null);

	  // List of attributes for which not to split camel case words.
	  // It contains known SVG attribute names and may be extended with user-defined attribute names.
	  ['attributeName', 'baseFrequency', 'baseProfile', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes',
	  // deprecated
	  'filterUnits', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'requiredExtensions', 'requiredFeatures', 'repeatCount', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget',
	  // deprecated
	  'xChannelSelector', 'yChannelSelector', 'zoomAndPan' // deprecated
	  ].forEach(name => _attributeNames[name] = name);
	  _attributeNames['xlinkShow'] = 'xlink:show';
	  _attributeNames['xlinkRole'] = 'xlink:role';
	  _attributeNames['xlinkActuate'] = 'xlink:actuate';
	  _attributeNames['xlinkHref'] = 'xlink:href';
	  _attributeNames['xlinkType'] = 'xlink:type';
	  _attributeNames['xlinkTitle'] = 'xlink:title';
	  _attributeNames['xmlBase'] = 'xml:base';
	  _attributeNames['xmlLang'] = 'xml:lang';
	  _attributeNames['xmlSpace'] = 'xml:space';
	  const attributeNames = new Proxy(_attributeNames, {
	    get(cache, name) {
	      // The cache is a dictionary of attribute names. See `_attributeNames` above.
	      // If the attribute name is not in the cache, it means that it is not
	      // a camel-case attribute name. In that case, we need to convert
	      // the attribute name to dash-separated words.
	      if (!V.supportCamelCaseAttributes) return name;
	      if (name in cache) {
	        return cache[name];
	      }
	      // Convert camel case to dash-separated words.
	      return cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase();
	    }
	  });

	  // Dictionary of attribute names
	  Object.defineProperty(V, 'attributeNames', {
	    enumerable: true,
	    value: attributeNames,
	    writable: false
	  });

	  // Should camel case attributes be supported?
	  Object.defineProperty(V, 'supportCamelCaseAttributes', {
	    enumerable: true,
	    value: true,
	    writable: true
	  });

	  /**
	   * @param {string} name
	   * @returns {{ns: string|null, local: string}} namespace and attribute name
	   */
	  V.qualifyAttr = function (name) {
	    if (name.indexOf(':') !== -1) {
	      var combinedKey = name.split(':');
	      return {
	        ns: ns[combinedKey[0]],
	        local: combinedKey[1]
	      };
	    }
	    return {
	      ns: null,
	      local: name
	    };
	  };

	  // Note: This regex allows multiple commas as separator which is incorrect in SVG
	  // This regex is used by `split()`, so it doesn't need to use /g
	  V.transformSeparatorRegex = /[ ,]+/;
	  // Note: All following regexes are more restrictive than SVG specification
	  // ReDoS mitigation: Use an anchor at the beginning of the match
	  // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)
	  // ReDoS mitigation: Don't match initial `(` inside repeated part
	  // The following regexes need to use capturing groups (= cannot use /g)
	  V.transformFunctionRegex = /\b(\w+)\(([^()]+)\)/;
	  V.transformTranslateRegex = /\btranslate\(([^()]+)\)/;
	  V.transformRotateRegex = /\brotate\(([^()]+)\)/;
	  V.transformScaleRegex = /\bscale\(([^()]+)\)/;
	  V.transformStringToMatrix = function (transform) {
	    let matrix;
	    if (V.isString(transform)) {
	      matrix = createMatrixFromTransformString(transform);
	    }
	    return matrix || createIdentityMatrix();
	  };
	  V.matrixToTransformString = matrixToTransformString;
	  V.parseTransformString = function (transform) {
	    var translate, rotate, scale;
	    if (transform) {
	      var separator = V.transformSeparatorRegex;

	      // Special handling for `transform` with one or more matrix functions
	      if (transform.trim().indexOf('matrix') >= 0) {
	        // Convert EVERYTHING in `transform` string to a matrix
	        // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates
	        // Note: In non-matrix case, we only take first one of each (if any)
	        var matrix = V.transformStringToMatrix(transform);
	        var decomposedMatrix = V.decomposeMatrix(matrix);

	        // Extract `translate`, `scale`, `rotate` from matrix
	        translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];
	        scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
	        rotate = [decomposedMatrix.rotation];

	        // Rewrite `transform` string in `translate scale rotate` format
	        var transformations = [];
	        if (translate[0] !== 0 || translate[1] !== 0) {
	          transformations.push('translate(' + translate + ')');
	        }
	        if (scale[0] !== 1 || scale[1] !== 1) {
	          transformations.push('scale(' + scale + ')');
	        }
	        if (rotate[0] !== 0) {
	          transformations.push('rotate(' + rotate + ')');
	        }
	        transform = transformations.join(' ');
	      } else {
	        // Extract `translate`, `rotate`, `scale` functions from `transform` string
	        // Note: We only detect the first match of each (if any)
	        // `match()` returns value of capturing group as `[1]`
	        const translateMatch = transform.match(V.transformTranslateRegex);
	        if (translateMatch) {
	          translate = translateMatch[1].split(separator);
	        }
	        const rotateMatch = transform.match(V.transformRotateRegex);
	        if (rotateMatch) {
	          rotate = rotateMatch[1].split(separator);
	        }
	        const scaleMatch = transform.match(V.transformScaleRegex);
	        if (scaleMatch) {
	          scale = scaleMatch[1].split(separator);
	        }
	      }
	    }
	    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
	    return {
	      value: transform,
	      translate: {
	        tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,
	        ty: translate && translate[1] ? parseInt(translate[1], 10) : 0
	      },
	      rotate: {
	        angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,
	        cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,
	        cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined
	      },
	      scale: {
	        sx: sx,
	        sy: scale && scale[1] ? parseFloat(scale[1]) : sx
	      }
	    };
	  };
	  V.deltaTransformPoint = function (matrix, point) {
	    var dx = point.x * matrix.a + point.y * matrix.c + 0;
	    var dy = point.x * matrix.b + point.y * matrix.d + 0;
	    return {
	      x: dx,
	      y: dy
	    };
	  };
	  V.decomposeMatrix = function (matrix) {
	    // @see https://gist.github.com/2052247

	    // calculate delta transform point
	    var px = V.deltaTransformPoint(matrix, {
	      x: 0,
	      y: 1
	    });
	    var py = V.deltaTransformPoint(matrix, {
	      x: 1,
	      y: 0
	    });

	    // calculate skew
	    var skewX = 180 / PI * atan2(px.y, px.x) - 90;
	    var skewY = 180 / PI * atan2(py.y, py.x);
	    return {
	      translateX: matrix.e,
	      translateY: matrix.f,
	      scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
	      scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
	      skewX: skewX,
	      skewY: skewY,
	      rotation: skewX // rotation is the same as skew x
	    };
	  };

	  // Return the `scale` transformation from the following equation:
	  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
	  V.matrixToScale = function (matrix) {
	    var a, b, c, d;
	    if (matrix) {
	      a = V.isUndefined(matrix.a) ? 1 : matrix.a;
	      d = V.isUndefined(matrix.d) ? 1 : matrix.d;
	      b = matrix.b;
	      c = matrix.c;
	    } else {
	      a = d = 1;
	    }
	    return {
	      sx: b ? sqrt(a * a + b * b) : a,
	      sy: c ? sqrt(c * c + d * d) : d
	    };
	  };

	  // Return the `rotate` transformation from the following equation:
	  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
	  V.matrixToRotate = function (matrix) {
	    var p = {
	      x: 0,
	      y: 1
	    };
	    if (matrix) {
	      p = V.deltaTransformPoint(matrix, p);
	    }
	    return {
	      angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)
	    };
	  };

	  // Return the `translate` transformation from the following equation:
	  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
	  V.matrixToTranslate = function (matrix) {
	    return {
	      tx: matrix && matrix.e || 0,
	      ty: matrix && matrix.f || 0
	    };
	  };
	  V.isV = function (object) {
	    return object instanceof V;
	  };

	  // For backwards compatibility:
	  V.isVElement = V.isV;

	  // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`
	  // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
	  V.isSVGGraphicsElement = function (node) {
	    if (!node) return false;
	    node = V.toNode(node);
	    // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below
	    return node instanceof SVGElement && typeof node.getScreenCTM === 'function';
	  };
	  V.createSVGMatrix = createMatrix;
	  V.createSVGTransform = function (matrix) {
	    if (!V.isUndefined(matrix)) {
	      if (!isSVGMatrix(matrix)) {
	        matrix = createMatrix(matrix);
	      }
	      return internalSVGDocument.createSVGTransformFromMatrix(matrix);
	    }
	    return internalSVGDocument.createSVGTransform();
	  };
	  V.createSVGPoint = function (x, y) {
	    var p = internalSVGDocument.createSVGPoint();
	    p.x = x;
	    p.y = y;
	    return p;
	  };
	  V.transformRect = function (r, matrix) {
	    var p = internalSVGDocument.createSVGPoint();
	    p.x = r.x;
	    p.y = r.y;
	    var corner1 = p.matrixTransform(matrix);
	    p.x = r.x + r.width;
	    p.y = r.y;
	    var corner2 = p.matrixTransform(matrix);
	    p.x = r.x + r.width;
	    p.y = r.y + r.height;
	    var corner3 = p.matrixTransform(matrix);
	    p.x = r.x;
	    p.y = r.y + r.height;
	    var corner4 = p.matrixTransform(matrix);
	    var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);
	    var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);
	    var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);
	    var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);
	    return new Rect(minX, minY, maxX - minX, maxY - minY);
	  };
	  V.transformPoint = function (p, matrix) {
	    return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));
	  };
	  V.transformLine = function (l, matrix) {
	    return new Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));
	  };
	  V.transformPolyline = function (p, matrix) {
	    var inPoints = p instanceof Polyline$1 ? p.points : p;
	    if (!V.isArray(inPoints)) inPoints = [];
	    var outPoints = [];
	    for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);
	    return new Polyline$1(outPoints);
	  };

	  // Convert a style represented as string (e.g. `'fill="blue"; stroke="red"'`) to
	  // an object (`{ fill: 'blue', stroke: 'red' }`).
	  V.styleToObject = function (styleString) {
	    var ret = {};
	    var styles = styleString.split(';');
	    for (var i = 0; i < styles.length; i++) {
	      var style = styles[i];
	      var pair = style.split('=');
	      ret[pair[0].trim()] = pair[1].trim();
	    }
	    return ret;
	  };

	  // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
	  V.createSlicePathData = function (innerRadius, outerRadius, startAngle, endAngle) {
	    var svgArcMax = 2 * PI - 1e-6;
	    var r0 = innerRadius;
	    var r1 = outerRadius;
	    var a0 = startAngle;
	    var a1 = endAngle;
	    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);
	    var df = da < PI ? '0' : '1';
	    var c0 = cos(a0);
	    var s0 = sin(a0);
	    var c1 = cos(a1);
	    var s1 = sin(a1);
	    return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';
	  };

	  // Merge attributes from object `b` with attributes in object `a`.
	  // Note that this modifies the object `a`.
	  // Also important to note that attributes are merged but CSS classes are concatenated.
	  V.mergeAttrs = function (a, b) {
	    for (var attr in b) {
	      if (attr === 'class') {
	        // Concatenate classes.
	        a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];
	      } else if (attr === 'style') {
	        // `style` attribute can be an object.
	        if (V.isObject(a[attr]) && V.isObject(b[attr])) {
	          // `style` stored in `a` is an object.
	          a[attr] = V.mergeAttrs(a[attr], b[attr]);
	        } else if (V.isObject(a[attr])) {
	          // `style` in `a` is an object but it's a string in `b`.
	          // Convert the style represented as a string to an object in `b`.
	          a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));
	        } else if (V.isObject(b[attr])) {
	          // `style` in `a` is a string, in `b` it's an object.
	          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);
	        } else {
	          // Both styles are strings.
	          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));
	        }
	      } else {
	        a[attr] = b[attr];
	      }
	    }
	    return a;
	  };
	  V.annotateString = function (t, annotations, opt) {
	    annotations = annotations || [];
	    opt = opt || {};
	    var offset = opt.offset || 0;
	    var compacted = [];
	    var batch;
	    var ret = [];
	    var item;
	    var prev;
	    for (var i = 0; i < t.length; i++) {
	      item = ret[i] = t[i];
	      for (var j = 0; j < annotations.length; j++) {
	        var annotation = annotations[j];
	        var start = annotation.start + offset;
	        var end = annotation.end + offset;
	        if (i >= start && i < end) {
	          // Annotation applies.
	          if (V.isObject(item)) {
	            // There is more than one annotation to be applied => Merge attributes.
	            item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);
	          } else {
	            item = ret[i] = {
	              t: t[i],
	              attrs: annotation.attrs
	            };
	          }
	          if (opt.includeAnnotationIndices) {
	            (item.annotations || (item.annotations = [])).push(j);
	          }
	        }
	      }
	      prev = ret[i - 1];
	      if (!prev) {
	        batch = item;
	      } else if (V.isObject(item) && V.isObject(prev)) {
	        // Both previous item and the current one are annotations. If the attributes
	        // didn't change, merge the text.
	        if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {
	          batch.t += item.t;
	        } else {
	          compacted.push(batch);
	          batch = item;
	        }
	      } else if (V.isObject(item)) {
	        // Previous item was a string, current item is an annotation.
	        compacted.push(batch);
	        batch = item;
	      } else if (V.isObject(prev)) {
	        // Previous item was an annotation, current item is a string.
	        compacted.push(batch);
	        batch = item;
	      } else {
	        // Both previous and current item are strings.
	        batch = (batch || '') + item;
	      }
	    }
	    if (batch) {
	      compacted.push(batch);
	    }
	    return compacted;
	  };
	  V.findAnnotationsAtIndex = function (annotations, index) {
	    var found = [];
	    if (annotations) {
	      annotations.forEach(function (annotation) {
	        if (annotation.start < index && index <= annotation.end) {
	          found.push(annotation);
	        }
	      });
	    }
	    return found;
	  };
	  V.findAnnotationsBetweenIndexes = function (annotations, start, end) {
	    var found = [];
	    if (annotations) {
	      annotations.forEach(function (annotation) {
	        if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {
	          found.push(annotation);
	        }
	      });
	    }
	    return found;
	  };

	  // Shift all the text annotations after character `index` by `offset` positions.
	  V.shiftAnnotations = function (annotations, index, offset) {
	    if (annotations) {
	      annotations.forEach(function (annotation) {
	        if (annotation.start < index && annotation.end >= index) {
	          annotation.end += offset;
	        } else if (annotation.start >= index) {
	          annotation.start += offset;
	          annotation.end += offset;
	        }
	      });
	    }
	    return annotations;
	  };
	  V.convertLineToPathData = function (line) {
	    line = V(line);
	    var d = ['M', line.attr('x1') || '0', line.attr('y1') || '0', 'L', line.attr('x2') || '0', line.attr('y2') || '0'].join(' ');
	    return d;
	  };
	  V.convertPolygonToPathData = function (polygon) {
	    var points = V.getPointsFromSvgNode(polygon);
	    if (points.length === 0) return null;
	    return V.svgPointsToPath(points) + ' Z';
	  };
	  V.convertPolylineToPathData = function (polyline) {
	    var points = V.getPointsFromSvgNode(polyline);
	    if (points.length === 0) return null;
	    return V.svgPointsToPath(points);
	  };
	  V.svgPointsToPath = function (points) {
	    for (var i = 0, n = points.length; i < n; i++) {
	      points[i] = points[i].x + ' ' + points[i].y;
	    }
	    return 'M ' + points.join(' L');
	  };
	  V.getPointsFromSvgNode = function (node) {
	    node = V.toNode(node);
	    var points = [];
	    var nodePoints = node.points;
	    if (nodePoints) {
	      for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {
	        points.push(nodePoints.getItem(i));
	      }
	    }
	    return points;
	  };
	  V.KAPPA = 0.551784;
	  V.convertCircleToPathData = function (circle) {
	    circle = V(circle);
	    var cx = parseFloat(circle.attr('cx')) || 0;
	    var cy = parseFloat(circle.attr('cy')) || 0;
	    var r = parseFloat(circle.attr('r'));
	    var cd = r * V.KAPPA; // Control distance.

	    var d = ['M', cx, cy - r,
	    // Move to the first point.
	    'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy,
	    // I. Quadrant.
	    'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r,
	    // II. Quadrant.
	    'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy,
	    // III. Quadrant.
	    'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r,
	    // IV. Quadrant.
	    'Z'].join(' ');
	    return d;
	  };
	  V.convertEllipseToPathData = function (ellipse) {
	    ellipse = V(ellipse);
	    var cx = parseFloat(ellipse.attr('cx')) || 0;
	    var cy = parseFloat(ellipse.attr('cy')) || 0;
	    var rx = parseFloat(ellipse.attr('rx'));
	    var ry = parseFloat(ellipse.attr('ry')) || rx;
	    var cdx = rx * V.KAPPA; // Control distance x.
	    var cdy = ry * V.KAPPA; // Control distance y.

	    var d = ['M', cx, cy - ry,
	    // Move to the first point.
	    'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy,
	    // I. Quadrant.
	    'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry,
	    // II. Quadrant.
	    'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy,
	    // III. Quadrant.
	    'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry,
	    // IV. Quadrant.
	    'Z'].join(' ');
	    return d;
	  };
	  V.convertRectToPathData = function (rect) {
	    rect = V(rect);
	    return V.rectToPath({
	      x: parseFloat(rect.attr('x')) || 0,
	      y: parseFloat(rect.attr('y')) || 0,
	      width: parseFloat(rect.attr('width')) || 0,
	      height: parseFloat(rect.attr('height')) || 0,
	      rx: parseFloat(rect.attr('rx')) || 0,
	      ry: parseFloat(rect.attr('ry')) || 0
	    });
	  };

	  // Convert a rectangle to SVG path commands. `r` is an object of the form:
	  // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,
	  // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for
	  // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle
	  // that has only `rx` and `ry` attributes).
	  V.rectToPath = function (r) {
	    var d;
	    var x = r.x;
	    var y = r.y;
	    var width = r.width;
	    var height = r.height;
	    var topRx = min(r.rx || r['top-rx'] || 0, width / 2);
	    var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);
	    var topRy = min(r.ry || r['top-ry'] || 0, height / 2);
	    var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);
	    if (topRx || bottomRx || topRy || bottomRy) {
	      d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];
	    } else {
	      d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
	    }
	    return d.join(' ');
	  };

	  // Take a path data string
	  // Return a normalized path data string
	  // If data cannot be parsed, return 'M 0 0'
	  // Highly inspired by Raphael Library (www.raphael.com)
	  V.normalizePathData = function () {
	    var spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
	    var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');
	    var pathValues = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');
	    var math = Math;
	    var PI = math.PI;
	    var sin = math.sin;
	    var cos = math.cos;
	    var tan = math.tan;
	    var asin = math.asin;
	    var sqrt = math.sqrt;
	    var abs = math.abs;
	    function q2c(x1, y1, ax, ay, x2, y2) {
	      var _13 = 1 / 3;
	      var _23 = 2 / 3;
	      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
	    }
	    function rotate(x, y, rad) {
	      var X = x * cos(rad) - y * sin(rad);
	      var Y = x * sin(rad) + y * cos(rad);
	      return {
	        x: X,
	        y: Y
	      };
	    }
	    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	      // for more information of where this math came from visit:
	      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	      var _120 = PI * 120 / 180;
	      var rad = PI / 180 * (+angle || 0);
	      var res = [];
	      var xy;
	      if (!recursive) {
	        xy = rotate(x1, y1, -rad);
	        x1 = xy.x;
	        y1 = xy.y;
	        xy = rotate(x2, y2, -rad);
	        x2 = xy.x;
	        y2 = xy.y;
	        var x = (x1 - x2) / 2;
	        var y = (y1 - y2) / 2;
	        var h = x * x / (rx * rx) + y * y / (ry * ry);
	        if (h > 1) {
	          h = sqrt(h);
	          rx = h * rx;
	          ry = h * ry;
	        }
	        var rx2 = rx * rx;
	        var ry2 = ry * ry;
	        var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
	        if (!Number.isFinite(k)) {
	          // Arc is a single point
	          return [x1, y1, x2, y2, x2, y2];
	        }
	        var cx = k * rx * y / ry + (x1 + x2) / 2;
	        var cy = k * -ry * x / rx + (y1 + y2) / 2;
	        var f1 = asin(((y1 - cy) / ry).toFixed(9));
	        var f2 = asin(((y2 - cy) / ry).toFixed(9));
	        f1 = x1 < cx ? PI - f1 : f1;
	        f2 = x2 < cx ? PI - f2 : f2;
	        if (f1 < 0) f1 = PI * 2 + f1;
	        if (f2 < 0) f2 = PI * 2 + f2;
	        if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;
	        if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;
	      } else {
	        f1 = recursive[0];
	        f2 = recursive[1];
	        cx = recursive[2];
	        cy = recursive[3];
	      }
	      var df = f2 - f1;
	      if (abs(df) > _120) {
	        var f2old = f2;
	        var x2old = x2;
	        var y2old = y2;
	        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	        x2 = cx + rx * cos(f2);
	        y2 = cy + ry * sin(f2);
	        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	      }
	      df = f2 - f1;
	      var c1 = cos(f1);
	      var s1 = sin(f1);
	      var c2 = cos(f2);
	      var s2 = sin(f2);
	      var t = tan(df / 4);
	      var hx = 4 / 3 * (rx * t);
	      var hy = 4 / 3 * (ry * t);
	      var m1 = [x1, y1];
	      var m2 = [x1 + hx * s1, y1 - hy * c1];
	      var m3 = [x2 + hx * s2, y2 - hy * c2];
	      var m4 = [x2, y2];
	      m2[0] = 2 * m1[0] - m2[0];
	      m2[1] = 2 * m1[1] - m2[1];
	      if (recursive) {
	        return [m2, m3, m4].concat(res);
	      } else {
	        res = [m2, m3, m4].concat(res).join().split(',');
	        var newres = [];
	        var ii = res.length;
	        for (var i = 0; i < ii; i++) {
	          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
	        }
	        return newres;
	      }
	    }
	    function parsePathString(pathString) {
	      if (!pathString) return null;
	      var paramCounts = {
	        a: 7,
	        c: 6,
	        h: 1,
	        l: 2,
	        m: 2,
	        q: 4,
	        s: 4,
	        t: 2,
	        v: 1,
	        z: 0
	      };
	      var data = [];
	      String(pathString).replace(pathCommand, function (a, b, c) {
	        var params = [];
	        var name = b.toLowerCase();
	        c.replace(pathValues, function (a, b) {
	          if (b) params.push(+b);
	        });
	        if (name === 'm' && params.length > 2) {
	          data.push([b].concat(params.splice(0, 2)));
	          name = 'l';
	          b = b === 'm' ? 'l' : 'L';
	        }
	        while (params.length >= paramCounts[name]) {
	          data.push([b].concat(params.splice(0, paramCounts[name])));
	          if (!paramCounts[name]) break;
	        }
	      });
	      return data;
	    }
	    function pathToAbsolute(pathArray) {
	      if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {
	        // rough assumption
	        pathArray = parsePathString(pathArray);
	      }

	      // if invalid string, return 'M 0 0'
	      if (!pathArray || !pathArray.length) return [['M', 0, 0]];
	      var res = [];
	      var x = 0;
	      var y = 0;
	      var mx = 0;
	      var my = 0;
	      var start = 0;
	      var pa0;
	      var ii = pathArray.length;
	      for (var i = start; i < ii; i++) {
	        var r = [];
	        res.push(r);
	        var pa = pathArray[i];
	        pa0 = pa[0];
	        if (pa0 != pa0.toUpperCase()) {
	          r[0] = pa0.toUpperCase();
	          var jj;
	          var j;
	          switch (r[0]) {
	            case 'A':
	              r[1] = pa[1];
	              r[2] = pa[2];
	              r[3] = pa[3];
	              r[4] = pa[4];
	              r[5] = pa[5];
	              r[6] = +pa[6] + x;
	              r[7] = +pa[7] + y;
	              break;
	            case 'V':
	              r[1] = +pa[1] + y;
	              break;
	            case 'H':
	              r[1] = +pa[1] + x;
	              break;
	            case 'M':
	              mx = +pa[1] + x;
	              my = +pa[2] + y;
	              jj = pa.length;
	              for (j = 1; j < jj; j++) {
	                r[j] = +pa[j] + (j % 2 ? x : y);
	              }
	              break;
	            default:
	              jj = pa.length;
	              for (j = 1; j < jj; j++) {
	                r[j] = +pa[j] + (j % 2 ? x : y);
	              }
	              break;
	          }
	        } else {
	          var kk = pa.length;
	          for (var k = 0; k < kk; k++) {
	            r[k] = pa[k];
	          }
	        }
	        switch (r[0]) {
	          case 'Z':
	            x = +mx;
	            y = +my;
	            break;
	          case 'H':
	            x = r[1];
	            break;
	          case 'V':
	            y = r[1];
	            break;
	          case 'M':
	            mx = r[r.length - 2];
	            my = r[r.length - 1];
	            x = r[r.length - 2];
	            y = r[r.length - 1];
	            break;
	          default:
	            x = r[r.length - 2];
	            y = r[r.length - 1];
	            break;
	        }
	      }
	      return res;
	    }
	    function normalize(path) {
	      var p = pathToAbsolute(path);
	      var attrs = {
	        x: 0,
	        y: 0,
	        bx: 0,
	        by: 0,
	        X: 0,
	        Y: 0,
	        qx: null,
	        qy: null
	      };
	      function processPath(path, d, pcom) {
	        var nx, ny;
	        if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
	        if (!(path[0] in {
	          T: 1,
	          Q: 1
	        })) {
	          d.qx = null;
	          d.qy = null;
	        }
	        switch (path[0]) {
	          case 'M':
	            d.X = path[1];
	            d.Y = path[2];
	            break;
	          case 'A':
	            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
	              // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
	              // "If either rx or ry is 0, then this arc is treated as a
	              // straight line segment (a "lineto") joining the endpoints."
	              path = ['L', path[6], path[7]];
	            } else {
	              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
	            }
	            break;
	          case 'S':
	            if (pcom === 'C' || pcom === 'S') {
	              // In 'S' case we have to take into account, if the previous command is C/S.
	              nx = d.x * 2 - d.bx; // And reflect the previous
	              ny = d.y * 2 - d.by; // command's control point relative to the current point.
	            } else {
	              // or some else or nothing
	              nx = d.x;
	              ny = d.y;
	            }
	            path = ['C', nx, ny].concat(path.slice(1));
	            break;
	          case 'T':
	            if (pcom === 'Q' || pcom === 'T') {
	              // In 'T' case we have to take into account, if the previous command is Q/T.
	              d.qx = d.x * 2 - d.qx; // And make a reflection similar
	              d.qy = d.y * 2 - d.qy; // to case 'S'.
	            } else {
	              // or something else or nothing
	              d.qx = d.x;
	              d.qy = d.y;
	            }
	            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
	            break;
	          case 'Q':
	            d.qx = path[1];
	            d.qy = path[2];
	            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
	            break;
	          case 'H':
	            path = ['L'].concat(path[1], d.y);
	            break;
	          case 'V':
	            path = ['L'].concat(d.x, path[1]);
	            break;
	          case 'L':
	            break;
	          case 'Z':
	            break;
	        }
	        return path;
	      }
	      function fixArc(pp, i) {
	        if (pp[i].length > 7) {
	          pp[i].shift();
	          var pi = pp[i];
	          while (pi.length) {
	            pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved
	            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
	          }
	          pp.splice(i, 1);
	          ii = p.length;
	        }
	      }
	      var pcoms = []; // path commands of original path p
	      var pfirst = ''; // temporary holder for original path command
	      var pcom = ''; // holder for previous path command of original path

	      var ii = p.length;
	      for (var i = 0; i < ii; i++) {
	        if (p[i]) pfirst = p[i][0]; // save current path command

	        if (pfirst !== 'C') {
	          // C is not saved yet, because it may be result of conversion
	          pcoms[i] = pfirst; // Save current path command
	          if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom
	        }
	        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

	        if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command
	        // which may produce multiple 'C's
	        // so we have to make sure that 'C' is also 'C' in original path

	        fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms

	        var seg = p[i];
	        var seglen = seg.length;
	        attrs.x = seg[seglen - 2];
	        attrs.y = seg[seglen - 1];
	        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
	        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
	      }

	      // make sure normalized path data string starts with an M segment
	      if (!p[0][0] || p[0][0] !== 'M') {
	        p.unshift(['M', 0, 0]);
	      }
	      return p;
	    }
	    return function (pathData) {
	      return normalize(pathData).join(',').split(',').join(' ');
	    };
	  }();

	  /**
	   *
	   * @param {SVGElement|V} node1
	   * @param {SVGElement|V} node2
	   * @returns {SVGElement|null}
	   */
	  V.getCommonAncestor = function (node1, node2) {
	    if (!node1 || !node2) return null;
	    return getCommonAncestor(V.toNode(node1), V.toNode(node2));
	  };
	  V.namespace = {
	    ...ns
	  };
	  V.g = g;
	  return V;
	}();

	// Manipulation

	function cleanNodesData(nodes) {
	  let i = nodes.length;
	  while (i--) cleanNodeData(nodes[i]);
	}
	function cleanNodeData(node) {
	  $.event.remove(node);
	  dataPriv.remove(node);
	  dataUser.remove(node);
	}
	function removeNodes(nodes) {
	  for (let i = 0; i < nodes.length; i++) {
	    const node = nodes[i];
	    if (node.parentNode) {
	      node.parentNode.removeChild(node);
	    }
	  }
	}
	function remove() {
	  for (let i = 0; i < this.length; i++) {
	    const node = this[i];
	    cleanNodeData(node);
	    cleanNodesData(node.getElementsByTagName('*'));
	  }
	  removeNodes(this);
	  return this;
	}
	function detach() {
	  removeNodes(this);
	  return this;
	}
	function empty() {
	  for (let i = 0; i < this.length; i++) {
	    const node = this[i];
	    if (node.nodeType === 1) {
	      cleanNodesData(node.getElementsByTagName('*'));
	      // Remove any remaining nodes
	      node.textContent = '';
	    }
	  }
	  return this;
	}
	function clone() {
	  const clones = [];
	  for (let i = 0; i < this.length; i++) {
	    clones.push(this[i].cloneNode(true));
	  }
	  return this.pushStack(clones);
	}
	function html(html) {
	  const [el] = this;
	  if (!el) return null;
	  if (arguments.length === 0) return el.innerHTML;
	  if (html === undefined) return this; // do nothing
	  cleanNodesData(el.getElementsByTagName('*'));
	  if (typeof html === 'string' || typeof html === 'number') {
	    el.innerHTML = html;
	  } else {
	    el.innerHTML = '';
	    return this.append(html);
	  }
	  return this;
	}
	function append(...nodes) {
	  const [parent] = this;
	  if (!parent) return this;
	  nodes.forEach(node => {
	    if (!node) return;
	    if (typeof node === 'string') {
	      parent.append(...$.parseHTML(node));
	    } else if (node.toString() === '[object Object]') {
	      // $ object
	      this.append(...Array.from(node));
	    } else if (Array.isArray(node)) {
	      this.append(...node);
	    } else {
	      // DOM node
	      parent.appendChild(node);
	    }
	  });
	  return this;
	}
	function prepend(...nodes) {
	  const [parent] = this;
	  if (!parent) return this;
	  nodes.forEach(node => {
	    if (!node) return;
	    if (typeof node === 'string') {
	      parent.prepend(...$.parseHTML(node));
	    } else if (node.toString() === '[object Object]') {
	      // $ object
	      this.prepend(...Array.from(node));
	    } else if (Array.isArray(node)) {
	      this.prepend(...node);
	    } else {
	      // DOM node
	      parent.insertBefore(node, parent.firstChild);
	    }
	  });
	  return this;
	}
	function appendTo(parent) {
	  $(parent).append(this);
	  return this;
	}
	function prependTo(parent) {
	  $(parent).prepend(this);
	  return this;
	}

	// Styles and attributes

	const requireUnits = {};
	['width', 'height', 'top', 'bottom', 'left', 'right', 'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight'].forEach(cssProp => {
	  requireUnits[cssProp] = true;
	});
	function setCSSProperty(el, name, value) {
	  if (typeof value === 'number' && requireUnits[camelCase(name)]) {
	    value += 'px';
	  }
	  el.style[name] = value;
	}
	function css(name, value) {
	  let styles;
	  if (typeof name === 'string') {
	    if (value === undefined) {
	      const [el] = this;
	      if (!el) return null;
	      return el.style[name];
	    } else {
	      styles = {
	        [name]: value
	      };
	    }
	  } else if (!name) {
	    throw new Error('no styles provided');
	  } else {
	    styles = name;
	  }
	  for (let style in styles) {
	    if (styles.hasOwnProperty(style)) {
	      for (let i = 0; i < this.length; i++) {
	        setCSSProperty(this[i], style, styles[style]);
	      }
	    }
	  }
	  return this;
	}
	function data(name, value) {
	  if (arguments.length < 2) {
	    const [el] = this;
	    if (!el) return null;
	    if (name === undefined) {
	      return el.dataset;
	    }
	    return el.dataset[name];
	  }
	  for (let i = 0; i < this.length; i++) {
	    this[i].dataset[name] = value;
	  }
	  return this;
	}

	// Classes

	function setNodesClass(method, nodes, args) {
	  for (let i = 0; i < nodes.length; i++) {
	    const node = nodes[i];
	    V.prototype[method].apply({
	      node
	    }, args);
	  }
	}
	function removeClass() {
	  setNodesClass('removeClass', this, arguments);
	  return this;
	}
	function addClass$1() {
	  setNodesClass('addClass', this, arguments);
	  return this;
	}
	function toggleClass() {
	  setNodesClass('toggleClass', this, arguments);
	  return this;
	}
	function hasClass() {
	  const [node] = this;
	  if (!node) return false;
	  return V.prototype.hasClass.apply({
	    node
	  }, arguments);
	}

	// Traversing

	function children(selector) {
	  const matches = [];
	  for (let i = 0; i < this.length; i++) {
	    const node = this[i];
	    let children = Array.from(node.children);
	    if (typeof selector === 'string') {
	      children = children.filter(child => child.matches(selector));
	    }
	    matches.push(...children);
	  }
	  return this.pushStack(matches);
	}
	function closest(selector) {
	  const closest = [];
	  for (let i = 0; i < this.length; i++) {
	    const el = this[i];
	    if (typeof selector === 'string') {
	      const closestEl = el.closest(selector);
	      if (closestEl) {
	        closest.push(closestEl);
	      }
	    } else {
	      const [ancestorEl] = $(selector);
	      if (ancestorEl && ancestorEl.contains(el)) {
	        closest.push(ancestorEl);
	      }
	    }
	  }
	  return this.pushStack(closest);
	}

	// Events

	function on(types, selector, data, fn) {
	  $.event.on(this, types, selector, data, fn);
	  return this;
	}
	function one(types, selector, data, fn) {
	  $.event.on(this, types, selector, data, fn, 1);
	  return this;
	}
	function off(types, selector, fn) {
	  if (types && types.preventDefault && types.handleObj) {
	    // ( event )  dispatched $.Event
	    const handleObj = types.handleObj;
	    $(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
	    return this;
	  }
	  if (typeof types === 'object') {
	    // ( types-object [, selector] )
	    for (let type in types) {
	      this.off(type, selector, types[type]);
	    }
	    return this;
	  }
	  if (selector === false || typeof selector === 'function') {
	    // ( types [, fn] )
	    fn = selector;
	    selector = undefined;
	  }
	  for (let i = 0; i < this.length; i++) {
	    $.event.remove(this[i], types, fn, selector);
	  }
	  return this;
	}

	// Measurements

	function width() {
	  const [el] = this;
	  if (el === window) return el.document.documentElement.clientWidth;else if (!el) return undefined;
	  const styles = window.getComputedStyle(el);
	  const height = el.offsetWidth;
	  const borderTopWidth = parseFloat(styles.borderTopWidth);
	  const borderBottomWidth = parseFloat(styles.borderBottomWidth);
	  const paddingTop = parseFloat(styles.paddingTop);
	  const paddingBottom = parseFloat(styles.paddingBottom);
	  return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;
	}
	function height() {
	  const [el] = this;
	  if (el === window) return el.document.documentElement.clientHeight;
	  if (!el) return undefined;
	  const styles = window.getComputedStyle(el);
	  const width = el.offsetHeight;
	  const borderLeftWidth = parseFloat(styles.borderLeftWidth);
	  const borderRightWidth = parseFloat(styles.borderRightWidth);
	  const paddingLeft = parseFloat(styles.paddingLeft);
	  const paddingRight = parseFloat(styles.paddingRight);
	  return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;
	}
	function position() {
	  const [el] = this;
	  if (!el) return;
	  let $el = $(el);
	  let offsetParent;
	  let offset;
	  let doc;
	  let parentOffset = {
	    top: 0,
	    left: 0
	  };
	  // position:fixed elements are offset from the viewport, which itself always has zero offset
	  if ($el.css('position') === 'fixed') {
	    // Assume position:fixed implies availability of getBoundingClientRect
	    offset = el.getBoundingClientRect();
	  } else {
	    offset = $el.offset();
	    // Account for the *real* offset parent, which can be the document or its root element
	    // when a statically positioned element is identified
	    doc = el.ownerDocument;
	    offsetParent = el.offsetParent || doc.documentElement;
	    const isStaticallyPositioned = el => {
	      const {
	        position
	      } = getComputedStyle(el);
	      return position === 'static';
	    };
	    while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {
	      offsetParent = offsetParent.offsetParent || doc.documentElement;
	    }
	    if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {
	      // Incorporate borders into its offset, since they are outside its content origin
	      const offsetParentStyles = window.getComputedStyle(offsetParent);
	      const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;
	      const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;
	      parentOffset = $(offsetParent).offset();
	      parentOffset.top += borderTopWidth;
	      parentOffset.left += borderLeftWidth;
	    }
	  }
	  const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;
	  const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;
	  // Subtract parent offsets and element margins
	  return {
	    top: offset.top - parentOffset.top - marginTop,
	    left: offset.left - parentOffset.left - marginLeft
	  };
	}
	function offset(coordinates) {
	  const [el] = this;
	  //  Getter
	  if (coordinates === undefined) {
	    if (!el) return null;
	    if (!el.getClientRects().length) {
	      return {
	        top: 0,
	        left: 0
	      };
	    }
	    const rect = el.getBoundingClientRect();
	    return {
	      top: rect.top + window.scrollY,
	      left: rect.left + window.scrollX
	    };
	  }
	  // Setter
	  if (!el) return this;
	  const currentStyle = window.getComputedStyle(el);
	  if (currentStyle.position === 'static') {
	    this.css('position', 'relative');
	  }
	  const currentOffset = this.offset();
	  const topDifference = coordinates.top - currentOffset.top;
	  const leftDifference = coordinates.left - currentOffset.left;
	  this.css({
	    top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',
	    left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'
	  });
	  return this;
	}

	var methods$1 = {
		__proto__: null,
		addClass: addClass$1,
		append: append,
		appendTo: appendTo,
		children: children,
		clone: clone,
		closest: closest,
		css: css,
		data: data,
		detach: detach,
		empty: empty,
		hasClass: hasClass,
		height: height,
		html: html,
		off: off,
		offset: offset,
		on: on,
		one: one,
		position: position,
		prepend: prepend,
		prependTo: prependTo,
		remove: remove,
		removeClass: removeClass,
		toggleClass: toggleClass,
		width: width
	};

	const animationKey = 'animationFrameId';
	const cssReset = {};
	cssReset['transition-property'] = cssReset['transition-duration'] = cssReset['transition-delay'] = cssReset['transition-timing-function'] = cssReset['animation-name'] = cssReset['animation-duration'] = cssReset['animation-delay'] = cssReset['animation-timing-function'] = '';
	function animate(properties, opt = {}) {
	  this.stop();
	  for (let i = 0; i < this.length; i++) {
	    animateNode(this[i], properties, opt);
	  }
	  return this;
	}
	function animateNode(el, properties, opt = {}) {
	  let {
	    duration = 400,
	    easing = 'ease-in-out',
	    delay = 0,
	    complete
	  } = opt;
	  const delayId = setTimeout(function () {
	    const $el = $(el);
	    let fired = false;
	    let endEvent = 'transitionend';

	    // Convert milliseconds to seconds for CSS
	    duration = duration / 1000;
	    delay = delay / 1000;

	    // Set up CSS values for transition or keyframe animation
	    const cssValues = {};
	    if (typeof properties === 'string') {
	      // Keyframe animation
	      cssValues['animation-name'] = properties;
	      cssValues['animation-duration'] = duration + 's';
	      cssValues['animation-delay'] = delay + 's';
	      cssValues['animation-timing-function'] = easing;
	      endEvent = 'animationend';
	    } else {
	      // CSS transitions
	      const transitionProperties = [];
	      for (var key in properties) {
	        if (properties.hasOwnProperty(key)) {
	          cssValues[key] = properties[key];
	          transitionProperties.push(key);
	        }
	      }
	      if (duration > 0) {
	        cssValues['transition-property'] = transitionProperties.join(', ');
	        cssValues['transition-duration'] = duration + 's';
	        cssValues['transition-delay'] = delay + 's';
	        cssValues['transition-timing-function'] = easing;
	      }
	    }
	    const wrappedCallback = function (event) {
	      if (event) {
	        if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from "below"
	        event.target.removeEventListener(endEvent, wrappedCallback);
	      } else {
	        el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout
	      }
	      fired = true;
	      $el.css(cssReset);
	      complete && complete.call(el);
	    };
	    if (duration > 0) {
	      el.addEventListener(endEvent, wrappedCallback);
	      // transitionEnd is not always firing on older Android phones
	      // so make sure it gets fired
	      const callbackId = setTimeout(function () {
	        if (fired) return;
	        wrappedCallback(null);
	      }, (duration + delay) * 1000 + 25);
	      dataPriv.set(el, animationKey, {
	        id: callbackId,
	        stop: () => {
	          clearTimeout(callbackId);
	          el.removeEventListener(endEvent, wrappedCallback);
	        }
	      });
	    }
	    $el.css(cssValues);
	    if (duration <= 0) {
	      wrappedCallback(null);
	    }
	  });
	  dataPriv.set(el, animationKey, {
	    stop: () => clearTimeout(delayId)
	  });
	}
	function stop() {
	  for (let i = 0; i < this.length; i++) {
	    const el = this[i];
	    const animation = dataPriv.get(el, animationKey);
	    if (!animation) continue;
	    animation.stop();
	    dataPriv.remove(el, animationKey);
	  }
	  this.css(cssReset);
	  return this;
	}

	var animations = {
		__proto__: null,
		animate: animate,
		stop: stop
	};

	const propertySetters = {
	  outerWidth: 'offsetWidth',
	  outerHeight: 'offsetHeight',
	  innerWidth: 'clientWidth',
	  innerHeight: 'clientHeight',
	  scrollLeft: 'scrollLeft',
	  scrollTop: 'scrollTop',
	  val: 'value',
	  text: 'textContent'
	};
	const propertiesMap = {
	  disabled: 'disabled',
	  value: 'value',
	  text: 'textContent'
	};
	function prop(name, value) {
	  if (!name) throw new Error('no property provided');
	  if (arguments.length === 1) {
	    const [el] = this;
	    if (!el) return null;
	    return el[name];
	  }
	  if (value === undefined) return this;
	  for (let i = 0; i < this.length; i++) {
	    this[i][name] = value;
	  }
	  return this;
	}
	function attr(name, value) {
	  let attributes;
	  if (typeof name === 'string') {
	    if (value === undefined) {
	      const [el] = this;
	      if (!el) return null;
	      return el.getAttribute(name);
	    } else {
	      attributes = {
	        [name]: value
	      };
	    }
	  } else if (!name) {
	    throw new Error('no attributes provided');
	  } else {
	    attributes = name;
	  }
	  for (let attr in attributes) {
	    if (attributes.hasOwnProperty(attr)) {
	      const value = attributes[attr];
	      if (propertiesMap[attr]) {
	        this.prop(propertiesMap[attr], value);
	        continue;
	      }
	      for (let i = 0; i < this.length; i++) {
	        if (value === null) {
	          this[i].removeAttribute(attr);
	        } else {
	          this[i].setAttribute(attr, value);
	        }
	      }
	    }
	  }
	  return this;
	}
	const methods = {
	  prop,
	  attr
	};
	Object.keys(propertySetters).forEach(methodName => {
	  methods[methodName] = function (...args) {
	    return this.prop(propertySetters[methodName], ...args);
	  };
	});

	const config$3 = {
	  // How the cell attributes are merged when `cell.prop()` is called.
	  // DEFAULT: the arrays are merged into the source array.
	  cellMergeStrategy: null,
	  // How the cell default attributes are merged with the attributes provided
	  // in the cell constructor.
	  // DEFAULT: the arrays are merged by replacing the source array
	  // with the destination array.
	  cellDefaultsMergeStrategy: null,
	  // When set to `true` the cell selectors could be defined as CSS selectors.
	  // If not, only JSON Markup selectors are taken into account.
	  useCSSSelectors: false,
	  // The class name prefix config is for advanced use only.
	  // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.
	  classNamePrefix: 'joint-',
	  defaultTheme: 'default',
	  // The maximum delay required for two consecutive touchend events to be interpreted
	  // as a double-tap.
	  doubleTapInterval: 300,
	  // Name of the attribute used to store the layer id on the cell model.
	  layerAttribute: 'layer'
	};

	// TODO: should not read config outside the mvc package

	// Special events

	const special = Object.create(null);
	special.load = {
	  // Prevent triggered image.load events from bubbling to window.load
	  noBubble: true
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in $.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	[['mouseenter', 'mouseover'], ['mouseleave', 'mouseout'], ['pointerenter', 'pointerover'], ['pointerleave', 'pointerout']].forEach(([orig, fix]) => {
	  special[orig] = {
	    delegateType: fix,
	    bindType: fix,
	    handle: function (event) {
	      const target = this;
	      const related = event.relatedTarget;
	      const handleObj = event.handleObj;
	      let ret;
	      // For mouseenter/leave call the handler if related is outside the target.
	      // NB: No relatedTarget if the mouse left/entered the browser window
	      if (!related || !target.contains(related)) {
	        event.type = handleObj.origType;
	        ret = handleObj.handler.apply(target, arguments);
	        event.type = fix;
	      }
	      return ret;
	    }
	  };
	});

	// Gestures

	const maxDelay = config$3.doubleTapInterval;
	const minDelay = 30;
	special.dbltap = {
	  bindType: 'touchend',
	  delegateType: 'touchend',
	  handle: function (event, ...args) {
	    const {
	      handleObj,
	      target
	    } = event;
	    const targetData = $.data.create(target);
	    const now = new Date().getTime();
	    const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;
	    if (delta < maxDelay && delta > minDelay) {
	      targetData.lastTouch = null;
	      event.type = handleObj.origType;
	      // let $ handle the triggering of "dbltap" event handlers
	      handleObj.handler.call(this, event, ...args);
	    } else {
	      targetData.lastTouch = now;
	    }
	  }
	};

	Object.assign($.fn, methods$1);
	Object.assign($.fn, animations);
	Object.assign($.fn, methods);
	Object.assign($.event.special, special);

	const addClassNamePrefix = function (className) {
	  if (!className) return className;
	  return className.toString().split(' ').map(function (_className) {
	    if (_className.substr(0, config$3.classNamePrefix.length) !== config$3.classNamePrefix) {
	      _className = config$3.classNamePrefix + _className;
	    }
	    return _className;
	  }).join(' ');
	};
	const removeClassNamePrefix = function (className) {
	  if (!className) return className;
	  return className.toString().split(' ').map(function (_className) {
	    if (_className.substr(0, config$3.classNamePrefix.length) === config$3.classNamePrefix) {
	      _className = _className.substr(config$3.classNamePrefix.length);
	    }
	    return _className;
	  }).join(' ');
	};
	const parseDOMJSON = function (json, namespace) {
	  const selectors = {};
	  const groupSelectors = {};
	  const svgNamespace = V.namespace.svg;
	  const initialNS = namespace || svgNamespace;
	  const fragment = document.createDocumentFragment();
	  const parseNode = function (siblingsDef, parentNode, parentNS) {
	    for (let i = 0; i < siblingsDef.length; i++) {
	      const nodeDef = siblingsDef[i];

	      // Text node
	      if (typeof nodeDef === 'string') {
	        const textNode = document.createTextNode(nodeDef);
	        parentNode.appendChild(textNode);
	        continue;
	      }

	      // TagName
	      if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');
	      const tagName = nodeDef.tagName;
	      let node;

	      // Namespace URI
	      const ns = nodeDef.hasOwnProperty('namespaceURI') ? nodeDef.namespaceURI : parentNS;
	      node = document.createElementNS(ns, tagName);
	      const svg = ns === svgNamespace;
	      const wrapperNode = svg ? V(node) : $(node);
	      // Attributes
	      const attributes = nodeDef.attributes;
	      if (attributes) wrapperNode.attr(attributes);
	      // Style
	      const style = nodeDef.style;
	      if (style) $(node).css(style);
	      // ClassName
	      if (nodeDef.hasOwnProperty('className')) {
	        const className = nodeDef.className;
	        if (svg) {
	          node.className.baseVal = className;
	        } else {
	          node.className = className;
	        }
	      }
	      // TextContent
	      if (nodeDef.hasOwnProperty('textContent')) {
	        node.textContent = nodeDef.textContent;
	      }
	      // Selector
	      if (nodeDef.hasOwnProperty('selector')) {
	        const nodeSelector = nodeDef.selector;
	        if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');
	        selectors[nodeSelector] = node;
	        wrapperNode.attr('joint-selector', nodeSelector);
	      }
	      // Groups
	      if (nodeDef.hasOwnProperty('groupSelector')) {
	        let nodeGroups = nodeDef.groupSelector;
	        if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];
	        for (let j = 0; j < nodeGroups.length; j++) {
	          const nodeGroup = nodeGroups[j];
	          let group = groupSelectors[nodeGroup];
	          if (!group) group = groupSelectors[nodeGroup] = [];
	          group.push(node);
	        }
	      }
	      parentNode.appendChild(node);

	      // Children
	      const childrenDef = nodeDef.children;
	      if (Array.isArray(childrenDef)) {
	        parseNode(childrenDef, node, ns);
	      }
	    }
	  };
	  parseNode(json, fragment, initialNS);
	  return {
	    fragment: fragment,
	    selectors: selectors,
	    groupSelectors: groupSelectors
	  };
	};

	// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.
	const hashCode = function (str) {
	  let hash = 0;
	  if (str.length === 0) return hash;
	  for (let i = 0; i < str.length; i++) {
	    const c = str.charCodeAt(i);
	    hash = (hash << 5) - hash + c;
	    hash = hash & hash; // Convert to 32bit integer
	  }
	  return hash;
	};
	const getByPath = function (obj, path, delimiter) {
	  var keys = Array.isArray(path) ? path : path.split(delimiter || '/');
	  var key;
	  var i = 0;
	  var length = keys.length;
	  while (i < length) {
	    key = keys[i++];
	    if (Object(obj) === obj && key in obj) {
	      obj = obj[key];
	    } else {
	      return undefined;
	    }
	  }
	  return obj;
	};
	const isGetSafe = function (obj, key) {
	  // Prevent prototype pollution
	  // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399
	  if (typeof key !== 'string' && typeof key !== 'number') {
	    key = String(key);
	  }
	  if (key === 'constructor' && typeof obj[key] === 'function') {
	    return false;
	  }
	  if (key === '__proto__') {
	    return false;
	  }
	  return true;
	};
	const setByPath = function (obj, path, value, delimiter) {
	  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');
	  const last = keys.length - 1;
	  let diver = obj;
	  let i = 0;
	  for (; i < last; i++) {
	    const key = keys[i];
	    if (!isGetSafe(diver, key)) return obj;
	    const value = diver[key];
	    // diver creates an empty object if there is no nested object under such a key.
	    // This means that one can populate an empty nested object with setByPath().
	    diver = value || (diver[key] = {});
	  }
	  diver[keys[last]] = value;
	  return obj;
	};
	const unsetByPath = function (obj, path, delimiter) {
	  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');
	  const last = keys.length - 1;
	  let diver = obj;
	  let i = 0;
	  for (; i < last; i++) {
	    const key = keys[i];
	    if (!isGetSafe(diver, key)) return obj;
	    const value = diver[key];
	    if (!value) return obj;
	    diver = value;
	  }
	  delete diver[keys[last]];
	  return obj;
	};
	const flattenObject = function (obj, delim, stop) {
	  delim = delim || '/';
	  var ret = {};
	  for (var key in obj) {
	    if (!obj.hasOwnProperty(key)) continue;
	    var shouldGoDeeper = typeof obj[key] === 'object';
	    if (shouldGoDeeper && stop && stop(obj[key])) {
	      shouldGoDeeper = false;
	    }
	    if (shouldGoDeeper) {
	      var flatObject = flattenObject(obj[key], delim, stop);
	      for (var flatKey in flatObject) {
	        if (!flatObject.hasOwnProperty(flatKey)) continue;
	        ret[key + delim + flatKey] = flatObject[flatKey];
	      }
	    } else {
	      ret[key] = obj[key];
	    }
	  }
	  return ret;
	};
	const uuid = function () {
	  // credit: http://stackoverflow.com/posts/2117523/revisions

	  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0;
	    var v = c === 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	};

	// Generates global unique id and stores it as a property of the object, if provided.
	const guid = function (obj) {
	  guid.id = guid.id || 1;
	  if (obj === undefined) {
	    return 'j_' + guid.id++;
	  }
	  obj.id = obj.id === undefined ? 'j_' + guid.id++ : obj.id;
	  return obj.id;
	};
	const toKebabCase = function (string) {
	  return string.replace(/[A-Z]/g, '-$&').toLowerCase();
	};
	const normalizeEvent = function (evt) {
	  if (evt.normalized) return evt;
	  const {
	    originalEvent,
	    target
	  } = evt;

	  // If the event is a touch event, normalize it to a mouse event.
	  const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];
	  if (touch) {
	    for (let property in touch) {
	      // copy all the properties from the first touch that are not
	      // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)
	      if (evt[property] === undefined) {
	        evt[property] = touch[property];
	      }
	    }
	  }
	  // IE: evt.target could be set to SVGElementInstance for SVGUseElement
	  if (target) {
	    const useElement = target.correspondingUseElement;
	    if (useElement) evt.target = useElement;
	  }
	  evt.normalized = true;
	  return evt;
	};
	const normalizeWheel = function (evt) {
	  // Sane values derived empirically
	  const PIXEL_STEP = 10;
	  const LINE_HEIGHT = 40;
	  const PAGE_HEIGHT = 800;
	  let sX = 0,
	    sY = 0,
	    pX = 0,
	    pY = 0;

	  // Legacy
	  if ('detail' in evt) {
	    sY = evt.detail;
	  }
	  if ('wheelDelta' in evt) {
	    sY = -evt.wheelDelta / 120;
	  }
	  if ('wheelDeltaY' in evt) {
	    sY = -evt.wheelDeltaY / 120;
	  }
	  if ('wheelDeltaX' in evt) {
	    sX = -evt.wheelDeltaX / 120;
	  }

	  // side scrolling on FF with DOMMouseScroll
	  if ('axis' in evt && evt.axis === evt.HORIZONTAL_AXIS) {
	    sX = sY;
	    sY = 0;
	  }
	  pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;
	  pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;
	  if ((pX || pY) && evt.deltaMode) {
	    if (evt.deltaMode == 1) {
	      pX *= LINE_HEIGHT;
	      pY *= LINE_HEIGHT;
	    } else {
	      pX *= PAGE_HEIGHT;
	      pY *= PAGE_HEIGHT;
	    }
	  }

	  // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases
	  if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {
	    pX = pY;
	    pY = 0;
	    sX = sY;
	    sY = 0;
	  }

	  // Fall-back if spin cannot be determined
	  if (pX && !sX) {
	    sX = pX < 1 ? -1 : 1;
	  }
	  if (pY && !sY) {
	    sY = pY < 1 ? -1 : 1;
	  }
	  return {
	    spinX: sX,
	    spinY: sY,
	    deltaX: pX,
	    deltaY: pY
	  };
	};
	const cap = function (val, max) {
	  return val > max ? max : val < -max ? -max : val;
	};
	const nextFrame = function () {
	  var raf;
	  if (typeof window !== 'undefined') {
	    raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
	  }
	  if (!raf) {
	    var lastTime = 0;
	    raf = function (callback) {
	      var currTime = new Date().getTime();
	      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	      var id = setTimeout(function () {
	        callback(currTime + timeToCall);
	      }, timeToCall);
	      lastTime = currTime + timeToCall;
	      return id;
	    };
	  }
	  return function (callback, context, ...rest) {
	    return context !== undefined ? raf(callback.bind(context, ...rest)) : raf(callback);
	  };
	}();
	const cancelFrame = function () {
	  var caf;
	  var client = typeof window != 'undefined';
	  if (client) {
	    caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;
	  }
	  caf = caf || clearTimeout;
	  return client ? caf.bind(window) : caf;
	}();
	const isPercentage = function (val) {
	  return isString(val) && val.slice(-1) === '%';
	};
	const parseCssNumeric = function (val, restrictUnits) {
	  function getUnit(validUnitExp) {
	    // one or more numbers, followed by
	    // any number of (
	    //  `.`, followed by
	    //  one or more numbers
	    // ), followed by
	    // `validUnitExp`, followed by
	    // end of string
	    var matches = new RegExp('(?:\\d+(?:\\.\\d+)*)(' + validUnitExp + ')$').exec(val);
	    if (!matches) return null;
	    return matches[1];
	  }
	  var number = parseFloat(val);

	  // if `val` cannot be parsed as a number, return `null`
	  if (Number.isNaN(number)) return null;

	  // else: we know `output.value`
	  var output = {};
	  output.value = number;

	  // determine the unit
	  var validUnitExp;
	  if (restrictUnits == null) {
	    // no restriction
	    // accept any unit, as well as no unit
	    validUnitExp = '[A-Za-z]*';
	  } else if (Array.isArray(restrictUnits)) {
	    // if this is an empty array, top restriction - return `null`
	    if (restrictUnits.length === 0) return null;

	    // else: restriction - an array of valid unit strings
	    validUnitExp = restrictUnits.join('|');
	  } else if (isString(restrictUnits)) {
	    // restriction - a single valid unit string
	    validUnitExp = restrictUnits;
	  }
	  var unit = getUnit(validUnitExp);

	  // if we found no matches for `restrictUnits`, return `null`
	  if (unit === null) return null;

	  // else: we know the unit
	  output.unit = unit;
	  return output;
	};
	const NO_SPACE = 0;
	function splitWordWithEOL(word, eol) {
	  const eolWords = word.split(eol);
	  let n = 1;
	  for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {
	    const replacement = [];
	    if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);
	    replacement.push(eol);
	    if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);
	    eolWords.splice(n, 0, ...replacement);
	    n += replacement.length + 1;
	  }
	  return eolWords.filter(word => word !== '');
	}
	function getLineHeight(heightValue, textElement) {
	  if (heightValue === null) {
	    // Default 1em lineHeight
	    return textElement.getBBox().height;
	  }
	  switch (heightValue.unit) {
	    case 'em':
	      return textElement.getBBox().height * heightValue.value;
	    case 'px':
	    case '':
	      return heightValue.value;
	  }
	}
	const breakText = function (text, size, styles = {}, opt = {}) {
	  var width = size.width;
	  var height = size.height;
	  var svgDocument = opt.svgDocument || V('svg').node;
	  var textSpan = V('tspan').node;
	  var textElement = V('text').attr(styles).append(textSpan).node;
	  var textNode = document.createTextNode('');

	  // Prevent flickering
	  textElement.style.opacity = 0;
	  // Prevent FF from throwing an uncaught exception when `getBBox()`
	  // called on element that is not in the render tree (is not measurable).
	  // <tspan>.getComputedTextLength() returns always 0 in this case.
	  // Note that the `textElement` resp. `textSpan` can become hidden
	  // when it's appended to the DOM and a `display: none` CSS stylesheet
	  // rule gets applied.
	  textElement.style.display = 'block';
	  textSpan.style.display = 'block';
	  textSpan.appendChild(textNode);
	  svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]

	  if (!opt.svgDocument) {
	    document.body.appendChild(svgDocument);
	  }
	  const preserveSpaces = opt.preserveSpaces;
	  const space = ' ';
	  const separator = opt.separator || opt.separator === '' ? opt.separator : space;
	  // If separator is a RegExp, we use the space character to join words together again (not ideal)
	  const separatorChar = typeof separator === 'string' ? separator : space;
	  var eol = opt.eol || '\n';
	  var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\w\d\u00C0-\u1FFF\u2800-\uFFFD]/;
	  var maxLineCount = opt.maxLineCount;
	  if (!isNumber(maxLineCount)) maxLineCount = Infinity;
	  var words = text.split(separator);
	  var full = [];
	  var lines = [];
	  var p, h;
	  var lineHeight;
	  if (preserveSpaces) {
	    V(textSpan).attr('xml:space', 'preserve');
	  }
	  for (var i = 0, l = 0, len = words.length; i < len; i++) {
	    var word = words[i];
	    if (!word && !preserveSpaces) continue;
	    if (typeof word !== 'string') continue;
	    var isEol = false;
	    if (eol && word.indexOf(eol) >= 0) {
	      // word contains end-of-line character
	      if (word.length > 1) {
	        // separate word and continue cycle
	        const eolWords = splitWordWithEOL(words[i], eol);
	        words.splice(i, 1, ...eolWords);
	        i--;
	        len = words.length;
	        continue;
	      } else {
	        // creates a new line
	        if (preserveSpaces && typeof words[i - 1] === 'string') {
	          words.splice(i, NO_SPACE, '', NO_SPACE);
	          len += 2;
	          i--;
	          continue;
	        }
	        lines[++l] = !preserveSpaces || typeof words[i + 1] === 'string' ? '' : undefined;
	        isEol = true;
	      }
	    }
	    if (!isEol) {
	      let data;
	      if (preserveSpaces) {
	        data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;
	      } else {
	        data = lines[l] ? lines[l] + separatorChar + word : word;
	      }
	      textNode.data = data;
	      if (textSpan.getComputedTextLength() <= width) {
	        // the current line fits
	        lines[l] = data;
	        if (p || h) {
	          // We were partitioning. Put rest of the word onto next line
	          full[l++] = true;

	          // cancel partitioning and splitting by hyphens
	          p = 0;
	          h = 0;
	        }
	      } else {
	        if (!lines[l] || p) {
	          var partition = !!p;
	          p = word.length - 1;
	          if (partition || !p) {
	            // word has only one character.
	            if (!p) {
	              if (!lines[l]) {
	                // we won't fit this text within our rect
	                lines = [];
	                break;
	              }

	              // partitioning didn't help on the non-empty line
	              // try again, but this time start with a new line

	              // cancel partitions created
	              words.splice(i, 2, word + words[i + 1]);

	              // adjust word length
	              len--;
	              full[l++] = true;
	              i--;
	              continue;
	            }

	            // move last letter to the beginning of the next word
	            words[i] = word.substring(0, p);
	            const nextWord = words[i + 1];
	            words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);
	          } else {
	            if (h) {
	              // cancel splitting and put the words together again
	              words.splice(i, 2, words[i] + words[i + 1]);
	              h = 0;
	            } else {
	              var hyphenIndex = word.search(hyphen);
	              if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {
	                h = hyphenIndex + 1;
	                p = 0;
	              }

	              // We initiate partitioning or splitting
	              // split the long word into two words
	              words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));
	              // adjust words length
	              len++;
	            }
	            if (l && !full[l - 1]) {
	              // if the previous line is not full, try to fit max part of
	              // the current word there
	              l--;
	            }
	          }
	          if (!preserveSpaces || lines[l] !== '') {
	            i--;
	          }
	          continue;
	        }
	        l++;
	        i--;
	      }
	    }
	    var lastL = null;
	    if (lines.length > maxLineCount) {
	      lastL = maxLineCount - 1;
	    } else if (height !== undefined) {
	      // if size.height is defined we have to check whether the height of the entire
	      // text exceeds the rect height

	      if (lineHeight === undefined && textNode.data !== '') {
	        // use the same defaults as in V.prototype.text
	        if (styles.lineHeight === 'auto') {
	          lineHeight = getLineHeight({
	            value: 1.5,
	            unit: 'em'
	          }, textElement);
	        } else {
	          const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);
	          lineHeight = getLineHeight(parsed, textElement);
	        }
	      }
	      if (lineHeight * lines.length > height) {
	        // remove overflowing lines
	        lastL = Math.floor(height / lineHeight) - 1;
	      }
	    }
	    if (lastL !== null) {
	      lines.splice(lastL + 1);

	      // add ellipsis
	      var ellipsis = opt.ellipsis;
	      if (!ellipsis || lastL < 0) break;
	      if (typeof ellipsis !== 'string') ellipsis = '\u2026';
	      var lastLine = lines[lastL];
	      if (!lastLine && !isEol) break;
	      var k = lastLine.length;
	      var lastLineWithOmission, lastChar;
	      do {
	        lastChar = lastLine[k];
	        lastLineWithOmission = lastLine.substring(0, k);
	        if (!lastChar) {
	          lastLineWithOmission += separatorChar;
	        } else if (lastChar.match(separator)) {
	          lastLineWithOmission += lastChar;
	        }
	        lastLineWithOmission += ellipsis;
	        textNode.data = lastLineWithOmission;
	        if (textSpan.getComputedTextLength() <= width) {
	          lines[lastL] = lastLineWithOmission;
	          break;
	        }
	        k--;
	      } while (k >= 0);
	      break;
	    }
	  }
	  if (opt.svgDocument) {
	    // svg document was provided, remove the text element only
	    svgDocument.removeChild(textElement);
	  } else {
	    // clean svg document
	    document.body.removeChild(svgDocument);
	  }
	  return lines.join(eol);
	};

	// Sanitize HTML
	// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9
	// Parses a string into an array of DOM nodes.
	// Then outputs it back as a string.
	const sanitizeHTML = function (html) {
	  // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)
	  const [outputEl] = $.parseHTML('<div>' + html + '</div>');
	  Array.from(outputEl.getElementsByTagName('*')).forEach(function (node) {
	    // for all nodes
	    const names = node.getAttributeNames();
	    names.forEach(function (name) {
	      const value = node.getAttribute(name);
	      // Remove attribute names that start with "on" (e.g. onload, onerror...).
	      // Remove attribute values that start with "javascript:" pseudo protocol (e.g. `href="javascript:alert(1)"`).
	      if (name.startsWith('on') || value.startsWith('javascript:') || value.startsWith('data:') || value.startsWith('vbscript:')) {
	        node.removeAttribute(name);
	      }
	    });
	  });
	  return outputEl.innerHTML;
	};

	// Download `blob` as file with `fileName`.
	// Does not work in IE9.
	const downloadBlob = function (blob, fileName) {
	  if (window.navigator.msSaveBlob) {
	    // requires IE 10+
	    // pulls up a save dialog
	    window.navigator.msSaveBlob(blob, fileName);
	  } else {
	    // other browsers
	    // downloads directly in Chrome and Safari

	    // presents a save/open dialog in Firefox
	    // Firefox bug: `from` field in save dialog always shows `from:blob:`
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327

	    var url = window.URL.createObjectURL(blob);
	    var link = document.createElement('a');
	    link.href = url;
	    link.download = fileName;
	    document.body.appendChild(link);
	    link.click();
	    document.body.removeChild(link);
	    window.URL.revokeObjectURL(url); // mark the url for garbage collection
	  }
	};

	// Download `dataUri` as file with `fileName`.
	// Does not work in IE9.
	const downloadDataUri = function (dataUri, fileName) {
	  const blob = dataUriToBlob(dataUri);
	  downloadBlob(blob, fileName);
	};

	// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.
	const dataUriToBlob = function (dataUri) {
	  // first, make sure there are no newlines in the data uri
	  dataUri = dataUri.replace(/\s/g, '');
	  dataUri = decodeURIComponent(dataUri);
	  var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`

	  var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'
	  var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'

	  var data = dataUri.slice(firstCommaIndex + 1);
	  var decodedString;
	  if (dataTypeString.indexOf('base64') >= 0) {
	    // data may be encoded in base64
	    decodedString = atob(data); // decode data
	  } else {
	    // convert the decoded string to UTF-8
	    decodedString = unescape(encodeURIComponent(data));
	  }
	  // write the bytes of the string to a typed array
	  var ia = new Uint8Array(decodedString.length);
	  for (var i = 0; i < decodedString.length; i++) {
	    ia[i] = decodedString.charCodeAt(i);
	  }
	  return new Blob([ia], {
	    type: mimeString
	  }); // return the typed array as Blob
	};

	// Read an image at `url` and return it as base64-encoded data uri.
	// The mime type of the image is inferred from the `url` file extension.
	// If data uri is provided as `url`, it is returned back unchanged.
	// `callback` is a method with `err` as first argument and `dataUri` as second argument.
	// Works with IE9.
	const imageToDataUri = function (url, callback) {
	  if (!url || url.substr(0, 'data:'.length) === 'data:') {
	    // No need to convert to data uri if it is already in data uri.

	    // This not only convenient but desired. For example,
	    // IE throws a security error if data:image/svg+xml is used to render
	    // an image to the canvas and an attempt is made to read out data uri.
	    // Now if our image is already in data uri, there is no need to render it to the canvas
	    // and so we can bypass this error.

	    // Keep the async nature of the function.
	    return setTimeout(function () {
	      callback(null, url);
	    }, 0);
	  }

	  // chrome, IE10+
	  var modernHandler = function (xhr, callback) {
	    if (xhr.status === 200) {
	      var reader = new FileReader();
	      reader.onload = function (evt) {
	        var dataUri = evt.target.result;
	        callback(null, dataUri);
	      };
	      reader.onerror = function () {
	        callback(new Error('Failed to load image ' + url));
	      };
	      reader.readAsDataURL(xhr.response);
	    } else {
	      callback(new Error('Failed to load image ' + url));
	    }
	  };
	  var legacyHandler = function (xhr, callback) {
	    var Uint8ToString = function (u8a) {
	      var CHUNK_SZ = 0x8000;
	      var c = [];
	      for (var i = 0; i < u8a.length; i += CHUNK_SZ) {
	        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
	      }
	      return c.join('');
	    };
	    if (xhr.status === 200) {
	      var bytes = new Uint8Array(xhr.response);
	      var suffix = url.split('.').pop() || 'png';
	      var map = {
	        'svg': 'svg+xml'
	      };
	      var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';
	      var b64encoded = meta + btoa(Uint8ToString(bytes));
	      callback(null, b64encoded);
	    } else {
	      callback(new Error('Failed to load image ' + url));
	    }
	  };
	  var xhr = new XMLHttpRequest();
	  xhr.open('GET', url, true);
	  xhr.addEventListener('error', function () {
	    callback(new Error('Failed to load image ' + url));
	  });
	  xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
	  xhr.addEventListener('load', function () {
	    if (window.FileReader) {
	      modernHandler(xhr, callback);
	    } else {
	      legacyHandler(xhr, callback);
	    }
	  });
	  xhr.send();
	};
	const getElementBBox = function (el) {
	  var $el = $(el);
	  if ($el.length === 0) {
	    throw new Error('Element not found');
	  }
	  var element = $el[0];
	  var doc = element.ownerDocument;
	  var clientBBox = element.getBoundingClientRect();
	  var strokeWidthX = 0;
	  var strokeWidthY = 0;

	  // Firefox correction
	  if (element.ownerSVGElement) {
	    var vel = V(element);
	    var bbox = vel.getBBox({
	      target: vel.svg()
	    });

	    // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.
	    // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.
	    strokeWidthX = clientBBox.width - bbox.width;
	    strokeWidthY = clientBBox.height - bbox.height;
	  }
	  return {
	    x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,
	    y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,
	    width: clientBBox.width - strokeWidthX,
	    height: clientBBox.height - strokeWidthY
	  };
	};

	// Highly inspired by the jquery.sortElements plugin by Padolsey.
	// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.
	const sortElements = function (elements, comparator) {
	  elements = $(elements).toArray();
	  var placements = elements.map(function (sortElement) {
	    var parentNode = sortElement.parentNode;
	    // Since the element itself will change position, we have
	    // to have some way of storing it's original position in
	    // the DOM. The easiest way is to have a 'flag' node:
	    var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);
	    return function () {
	      if (parentNode === this) {
	        throw new Error('You can\'t sort elements if any one is a descendant of another.');
	      }

	      // Insert before flag:
	      parentNode.insertBefore(this, nextSibling);
	      // Remove flag:
	      parentNode.removeChild(nextSibling);
	    };
	  });
	  elements.sort(comparator);
	  for (var i = 0; i < placements.length; i++) {
	    placements[i].call(elements[i]);
	  }
	  return elements;
	};

	// Sets attributes on the given element and its descendants based on the selector.
	// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}
	const setAttributesBySelector = function (element, attrs) {
	  var $element = $(element);
	  forIn(attrs, function (attrs, selector) {
	    var $elements = $element.find(selector).addBack().filter(selector);
	    // Make a special case for setting classes.
	    // We do not want to overwrite any existing class.
	    if (has(attrs, 'class')) {
	      $elements.addClass(attrs['class']);
	      attrs = omit(attrs, 'class');
	    }
	    $elements.attr(attrs);
	  });
	};

	// Return a new object with all four sides (top, right, bottom, left) in it.
	// Value of each side is taken from the given argument (either number or object).
	// Default value for a side is 0.
	// Examples:
	// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }
	// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }
	// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }
	// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }
	// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }
	const normalizeSides = function (box) {
	  if (Object(box) !== box) {
	    // `box` is not an object
	    var val = 0; // `val` left as 0 if `box` cannot be understood as finite number
	    if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')

	    return {
	      top: val,
	      right: val,
	      bottom: val,
	      left: val
	    };
	  }

	  // `box` is an object
	  var top, right, bottom, left;
	  top = right = bottom = left = 0;
	  if (isFinite(box.vertical)) top = bottom = +box.vertical;
	  if (isFinite(box.horizontal)) right = left = +box.horizontal;
	  if (isFinite(box.top)) top = +box.top; // overwrite vertical
	  if (isFinite(box.right)) right = +box.right; // overwrite horizontal
	  if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical
	  if (isFinite(box.left)) left = +box.left; // overwrite horizontal

	  return {
	    top: top,
	    right: right,
	    bottom: bottom,
	    left: left
	  };
	};
	const timing = {
	  linear: function (t) {
	    return t;
	  },
	  quad: function (t) {
	    return t * t;
	  },
	  cubic: function (t) {
	    return t * t * t;
	  },
	  inout: function (t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t;
	    var t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  },
	  exponential: function (t) {
	    return Math.pow(2, 10 * (t - 1));
	  },
	  bounce: function (t) {
	    for (var a = 0, b = 1; 1; a += b, b /= 2) {
	      if (t >= (7 - 4 * a) / 11) {
	        var q = (11 - 6 * a - 11 * t) / 4;
	        return -q * q + b * b;
	      }
	    }
	  },
	  reverse: function (f) {
	    return function (t) {
	      return 1 - f(1 - t);
	    };
	  },
	  reflect: function (f) {
	    return function (t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  },
	  clamp: function (f, n, x) {
	    n = n || 0;
	    x = x || 1;
	    return function (t) {
	      var r = f(t);
	      return r < n ? n : r > x ? x : r;
	    };
	  },
	  back: function (s) {
	    if (!s) s = 1.70158;
	    return function (t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  },
	  elastic: function (x) {
	    if (!x) x = 1.5;
	    return function (t) {
	      return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
	    };
	  }
	};
	const interpolate = {
	  number: function (a, b) {
	    var d = b - a;
	    return function (t) {
	      return a + d * t;
	    };
	  },
	  object: function (a, b) {
	    var s = Object.keys(a);
	    return function (t) {
	      var i, p;
	      var r = {};
	      for (i = s.length - 1; i != -1; i--) {
	        p = s[i];
	        r[p] = a[p] + (b[p] - a[p]) * t;
	      }
	      return r;
	    };
	  },
	  hexColor: function (a, b) {
	    var ca = parseInt(a.slice(1), 16);
	    var cb = parseInt(b.slice(1), 16);
	    var ra = ca & 0x0000ff;
	    var rd = (cb & 0x0000ff) - ra;
	    var ga = ca & 0x00ff00;
	    var gd = (cb & 0x00ff00) - ga;
	    var ba = ca & 0xff0000;
	    var bd = (cb & 0xff0000) - ba;
	    return function (t) {
	      var r = ra + rd * t & 0x000000ff;
	      var g = ga + gd * t & 0x0000ff00;
	      var b = ba + bd * t & 0x00ff0000;
	      return '#' + (1 << 24 | r | g | b).toString(16).slice(1);
	    };
	  },
	  unit: function (a, b) {
	    var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
	    var ma = r.exec(a);
	    var mb = r.exec(b);
	    var p = mb[1].indexOf('.');
	    var f = p > 0 ? mb[1].length - p - 1 : 0;
	    a = +ma[1];
	    var d = +mb[1] - a;
	    var u = ma[2];
	    return function (t) {
	      return (a + d * t).toFixed(f) + u;
	    };
	  }
	};

	// SVG filters.
	// (values in parentheses are default values)
	const filter = {
	  // `color` ... outline color ('blue')
	  // `width`... outline width (1)
	  // `opacity` ... outline opacity (1)
	  // `margin` ... gap between outline and the element (2)
	  outline: function (args) {
	    var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" /><feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" /><feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/><feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/><feMerge><feMergeNode in="outline"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
	    var margin = Number.isFinite(args.margin) ? args.margin : 2;
	    var width = Number.isFinite(args.width) ? args.width : 1;
	    return template(tpl)({
	      color: args.color || 'blue',
	      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
	      outerRadius: margin + width,
	      innerRadius: margin
	    });
	  },
	  // `color` ... color ('red')
	  // `width`... width (1)
	  // `blur` ... blur (0)
	  // `opacity` ... opacity (1)
	  highlight: function (args) {
	    var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/><feComposite result="composed" in="colored" in2="morphed" operator="in"/><feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/><feBlend in="SourceGraphic" in2="blured" mode="normal"/></filter>';
	    return template(tpl)({
	      color: args.color || 'red',
	      width: Number.isFinite(args.width) ? args.width : 1,
	      blur: Number.isFinite(args.blur) ? args.blur : 0,
	      opacity: Number.isFinite(args.opacity) ? args.opacity : 1
	    });
	  },
	  // `x` ... horizontal blur (2)
	  // `y` ... vertical blur (optional)
	  blur: function (args) {
	    var x = Number.isFinite(args.x) ? args.x : 2;
	    return template('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>')({
	      stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x
	    });
	  },
	  // `dx` ... horizontal shift (0)
	  // `dy` ... vertical shift (0)
	  // `blur` ... blur (4)
	  // `color` ... color ('black')
	  // `opacity` ... opacity (1)
	  dropShadow: function (args) {
	    var tpl = 'SVGFEDropShadowElement' in window ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>' : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
	    return template(tpl)({
	      dx: args.dx || 0,
	      dy: args.dy || 0,
	      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
	      color: args.color || 'black',
	      blur: Number.isFinite(args.blur) ? args.blur : 4
	    });
	  },
	  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.
	  grayscale: function (args) {
	    var amount = Number.isFinite(args.amount) ? args.amount : 1;
	    return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>')({
	      a: 0.2126 + 0.7874 * (1 - amount),
	      b: 0.7152 - 0.7152 * (1 - amount),
	      c: 0.0722 - 0.0722 * (1 - amount),
	      d: 0.2126 - 0.2126 * (1 - amount),
	      e: 0.7152 + 0.2848 * (1 - amount),
	      f: 0.0722 - 0.0722 * (1 - amount),
	      g: 0.2126 - 0.2126 * (1 - amount),
	      h: 0.0722 + 0.9278 * (1 - amount)
	    });
	  },
	  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.
	  sepia: function (args) {
	    var amount = Number.isFinite(args.amount) ? args.amount : 1;
	    return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>')({
	      a: 0.393 + 0.607 * (1 - amount),
	      b: 0.769 - 0.769 * (1 - amount),
	      c: 0.189 - 0.189 * (1 - amount),
	      d: 0.349 - 0.349 * (1 - amount),
	      e: 0.686 + 0.314 * (1 - amount),
	      f: 0.168 - 0.168 * (1 - amount),
	      g: 0.272 - 0.272 * (1 - amount),
	      h: 0.534 - 0.534 * (1 - amount),
	      i: 0.131 + 0.869 * (1 - amount)
	    });
	  },
	  // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.
	  saturate: function (args) {
	    var amount = Number.isFinite(args.amount) ? args.amount : 1;
	    return template('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>')({
	      amount: 1 - amount
	    });
	  },
	  // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).
	  hueRotate: function (args) {
	    return template('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>')({
	      angle: args.angle || 0
	    });
	  },
	  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.
	  invert: function (args) {
	    var amount = Number.isFinite(args.amount) ? args.amount : 1;
	    return template('<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>')({
	      amount: amount,
	      amount2: 1 - amount
	    });
	  },
	  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
	  brightness: function (args) {
	    return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>')({
	      amount: Number.isFinite(args.amount) ? args.amount : 1
	    });
	  },
	  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
	  contrast: function (args) {
	    var amount = Number.isFinite(args.amount) ? args.amount : 1;
	    return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>')({
	      amount: amount,
	      amount2: .5 - amount / 2
	    });
	  }
	};
	const format$1 = {
	  // Formatting numbers via the Python Format Specification Mini-language.
	  // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.
	  // Heavilly inspired by the D3.js library implementation.
	  number: function (specifier, value, locale) {
	    locale = locale || {
	      currency: ['$', ''],
	      decimal: '.',
	      thousands: ',',
	      grouping: [3]
	    };

	    // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.
	    // [[fill]align][sign][symbol][0][width][,][.precision][type]
	    var re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	    var match = re.exec(specifier);
	    var fill = match[1] || ' ';
	    var align = match[2] || '>';
	    var sign = match[3] || '';
	    var symbol = match[4] || '';
	    var zfill = match[5];
	    var width = +match[6];
	    var comma = match[7];
	    var precision = match[8];
	    var type = match[9];
	    var scale = 1;
	    var prefix = '';
	    var suffix = '';
	    var integer = false;
	    if (precision) precision = +precision.substring(1);
	    if (zfill || fill === '0' && align === '=') {
	      zfill = fill = '0';
	      align = '=';
	      if (comma) width -= Math.floor((width - 1) / 4);
	    }
	    switch (type) {
	      case 'n':
	        comma = true;
	        type = 'g';
	        break;
	      case '%':
	        scale = 100;
	        suffix = '%';
	        type = 'f';
	        break;
	      case 'p':
	        scale = 100;
	        suffix = '%';
	        type = 'r';
	        break;
	      case 'b':
	      case 'o':
	      case 'x':
	      case 'X':
	        if (symbol === '#') prefix = '0' + type.toLowerCase();
	        break;
	      case 'c':
	      case 'd':
	        integer = true;
	        precision = 0;
	        break;
	      case 's':
	        scale = -1;
	        type = 'r';
	        break;
	    }
	    if (symbol === '$') {
	      prefix = locale.currency[0];
	      suffix = locale.currency[1];
	    }

	    // If no precision is specified for `'r'`, fallback to general notation.
	    if (type == 'r' && !precision) type = 'g';

	    // Ensure that the requested precision is in the supported range.
	    if (precision != null) {
	      if (type == 'g') precision = Math.max(1, Math.min(21, precision));else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));
	    }
	    var zcomma = zfill && comma;

	    // Return the empty string for floats formatted as ints.
	    if (integer && value % 1) return '';

	    // Convert negative to positive, and record the sign prefix.
	    var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;
	    var fullSuffix = suffix;

	    // Apply the scale, computing it from the value's exponent for si format.
	    // Preserve the existing suffix, if any, such as the currency symbol.
	    if (scale < 0) {
	      var unit = this.prefix(value, precision);
	      value = unit.scale(value);
	      fullSuffix = unit.symbol + suffix;
	    } else {
	      value *= scale;
	    }

	    // Convert to the desired precision.
	    value = this.convert(type, value, precision);

	    // Break the value into the integer part (before) and decimal part (after).
	    var i = value.lastIndexOf('.');
	    var before = i < 0 ? value : value.substring(0, i);
	    var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);
	    function formatGroup(value) {
	      var i = value.length;
	      var t = [];
	      var j = 0;
	      var g = locale.grouping[0];
	      while (i > 0 && g > 0) {
	        t.push(value.substring(i -= g, i + g));
	        g = locale.grouping[j = (j + 1) % locale.grouping.length];
	      }
	      return t.reverse().join(locale.thousands);
	    }

	    // If the fill character is not `'0'`, grouping is applied before padding.
	    if (!zfill && comma && locale.grouping) {
	      before = formatGroup(before);
	    }
	    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);
	    var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';

	    // If the fill character is `'0'`, grouping is applied after padding.
	    if (zcomma) before = formatGroup(padding + before);

	    // Apply prefix.
	    negative += prefix;

	    // Rejoin integer and decimal parts.
	    value = before + after;
	    return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	  },
	  // Formatting string via the Python Format string.
	  // See https://docs.python.org/2/library/string.html#format-string-syntax)
	  string: function (formatString, value) {
	    var fieldDelimiterIndex;
	    var fieldDelimiter = '{';
	    var endPlaceholder = false;
	    var formattedStringArray = [];
	    while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {
	      var pieceFormattedString, formatSpec, fieldName;
	      pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);
	      if (endPlaceholder) {
	        formatSpec = pieceFormattedString.split(':');
	        fieldName = formatSpec.shift().split('.');
	        pieceFormattedString = value;
	        for (var i = 0; i < fieldName.length; i++) pieceFormattedString = pieceFormattedString[fieldName[i]];
	        if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);
	      }
	      formattedStringArray.push(pieceFormattedString);
	      formatString = formatString.slice(fieldDelimiterIndex + 1);
	      endPlaceholder = !endPlaceholder;
	      fieldDelimiter = endPlaceholder ? '}' : '{';
	    }
	    formattedStringArray.push(formatString);
	    return formattedStringArray.join('');
	  },
	  convert: function (type, value, precision) {
	    switch (type) {
	      case 'b':
	        return value.toString(2);
	      case 'c':
	        return String.fromCharCode(value);
	      case 'o':
	        return value.toString(8);
	      case 'x':
	        return value.toString(16);
	      case 'X':
	        return value.toString(16).toUpperCase();
	      case 'g':
	        return value.toPrecision(precision);
	      case 'e':
	        return value.toExponential(precision);
	      case 'f':
	        return value.toFixed(precision);
	      case 'r':
	        return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));
	      default:
	        return value + '';
	    }
	  },
	  round: function (value, precision) {
	    return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);
	  },
	  precision: function (value, precision) {
	    return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);
	  },
	  prefix: function (value, precision) {
	    var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', 'Âµ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function (d, i) {
	      var k = Math.pow(10, Math.abs(8 - i) * 3);
	      return {
	        scale: i > 8 ? function (d) {
	          return d / k;
	        } : function (d) {
	          return d * k;
	        },
	        symbol: d
	      };
	    });
	    var i = 0;
	    if (value) {
	      if (value < 0) value *= -1;
	      if (precision) value = this.round(value, this.precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
	    }
	    return prefixes[8 + i / 3];
	  }
	};

	/*
	    Pre-compile the HTML to be used as a template.
	*/
	const template = function (html) {
	  /*
	      Must support the variation in templating syntax found here:
	      https://lodash.com/docs#template
	  */
	  var regex = /<%= ([^ ]+) %>|\$\{ ?([^{} ]+) ?\}|\{\{([^{} ]+)\}\}/g;
	  return function (data) {
	    data = data || {};
	    return html.replace(regex, function (match) {
	      var args = Array.from(arguments);
	      var attr = args.slice(1, 4).find(function (_attr) {
	        return !!_attr;
	      });
	      var attrArray = attr.split('.');
	      var value = data[attrArray.shift()];
	      while (value !== undefined && attrArray.length) {
	        value = value[attrArray.shift()];
	      }
	      return value !== undefined ? value : '';
	    });
	  };
	};

	/**
	 * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.
	 */
	const toggleFullScreen = function (el) {
	  var topDocument = window.top.document;
	  el = el || topDocument.body;
	  function prefixedResult(el, prop) {
	    var prefixes = ['webkit', 'moz', 'ms', 'o', ''];
	    for (var i = 0; i < prefixes.length; i++) {
	      var prefix = prefixes[i];
	      var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);
	      if (el[propName] !== undefined) {
	        return isFunction(el[propName]) ? el[propName]() : el[propName];
	      }
	    }
	  }
	  if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {
	    prefixedResult(topDocument, 'ExitFullscreen') ||
	    // Spec.
	    prefixedResult(topDocument, 'CancelFullScreen'); // Firefox
	  } else {
	    prefixedResult(el, 'RequestFullscreen') ||
	    // Spec.
	    prefixedResult(el, 'RequestFullScreen'); // Firefox
	  }
	};
	function findDifference(obj, baseObj, currentDepth, maxDepth) {
	  if (currentDepth === maxDepth) {
	    return {};
	  }
	  const diff = {};
	  Object.keys(obj).forEach(key => {
	    const objValue = obj[key];
	    const baseValue = baseObj[key];
	    if (!Array.isArray(objValue) && !Array.isArray(baseValue) && isObject(objValue) && isObject(baseValue)) {
	      const nestedDepth = currentDepth + 1;
	      const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);
	      if (Object.keys(nestedDiff).length > 0) {
	        diff[key] = nestedDiff;
	      } else if (currentDepth === 0 || nestedDepth === maxDepth) {
	        diff[key] = {};
	      }
	    } else if (!isEqual(objValue, baseValue)) {
	      diff[key] = objValue;
	    }
	  });
	  return diff;
	}
	function objectDifference(object, base, opt) {
	  const {
	    maxDepth = Number.POSITIVE_INFINITY
	  } = opt || {};
	  return findDifference(object, base, 0, maxDepth);
	}
	const noop = function () {
	  // Do nothing.
	};

	// Events
	// ---------------

	// A module that can be mixed in to *any object* in order to provide it with
	// a custom event channel. You may bind a callback to an event with `on` or
	// remove with `off`; `trigger`-ing an event fires all callbacks in
	// succession.
	//
	//     const object = {};
	//     assign(object, Events);
	//     object.on('expand', function(){ alert('expanded'); });
	//     object.trigger('expand');
	//
	var Events = {};

	// Regular expression used to split event strings.
	var eventSplitter = /\s+/;

	// A private global variable to share between listeners and listenees.
	var _listening;

	// Iterates over the standard `event, callback` (as well as the fancy multiple
	// space-separated events `"change blur", callback` and jQuery-style event
	// maps `{event: callback}`).
	var eventsApi = function (iteratee, events, name, callback, opts) {
	  var i = 0,
	    names;
	  if (name && typeof name === 'object') {
	    // Handle event maps.
	    if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
	    for (names = Object.keys(name); i < names.length; i++) {
	      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
	    }
	  } else if (name && eventSplitter.test(name)) {
	    // Handle space-separated event names by delegating them individually.
	    for (names = name.split(eventSplitter); i < names.length; i++) {
	      events = iteratee(events, names[i], callback, opts);
	    }
	  } else {
	    // Finally, standard events.
	    events = iteratee(events, name, callback, opts);
	  }
	  return events;
	};

	// Bind an event to a `callback` function. Passing `"all"` will bind
	// the callback to all events fired.
	Events.on = function (name, callback, context) {
	  this._events = eventsApi(onApi, this._events || {}, name, callback, {
	    context: context,
	    ctx: this,
	    listening: _listening
	  });
	  if (_listening) {
	    var listeners = this._listeners || (this._listeners = {});
	    listeners[_listening.id] = _listening;
	    // Allow the listening to use a counter, instead of tracking
	    // callbacks for library interop
	    _listening.interop = false;
	  }
	  return this;
	};

	// Inversion-of-control versions of `on`. Tell *this* object to listen to
	// an event in another object... keeping track of what it's listening to
	// for easier unbinding later.
	Events.listenTo = function (obj, name, callback) {
	  if (!obj) return this;
	  var id = obj._listenId || (obj._listenId = uniqueId('l'));
	  var listeningTo = this._listeningTo || (this._listeningTo = {});
	  var listening = _listening = listeningTo[id];

	  // This object is not listening to any other events on `obj` yet.
	  // Setup the necessary references to track the listening callbacks.
	  if (!listening) {
	    this._listenId || (this._listenId = uniqueId('l'));
	    listening = _listening = listeningTo[id] = new Listening(this, obj);
	  }

	  // Bind callbacks on obj.
	  var error = tryCatchOn(obj, name, callback, this);
	  _listening = void 0;
	  if (error) throw error;
	  // If the target obj is not Events, track events manually.
	  if (listening.interop) listening.on(name, callback);
	  return this;
	};

	// The reducing API that adds a callback to the `events` object.
	var onApi = function (events, name, callback, options) {
	  if (callback) {
	    var handlers = events[name] || (events[name] = []);
	    var context = options.context,
	      ctx = options.ctx,
	      listening = options.listening;
	    if (listening) listening.count++;
	    handlers.push({
	      callback: callback,
	      context: context,
	      ctx: context || ctx,
	      listening: listening
	    });
	  }
	  return events;
	};

	// An try-catch guarded #on function, to prevent poisoning the global
	// `_listening` variable.
	var tryCatchOn = function (obj, name, callback, context) {
	  try {
	    obj.on(name, callback, context);
	  } catch (e) {
	    return e;
	  }
	};

	// Remove one or many callbacks. If `context` is null, removes all
	// callbacks with that function. If `callback` is null, removes all
	// callbacks for the event. If `name` is null, removes all bound
	// callbacks for all events.
	Events.off = function (name, callback, context) {
	  if (!this._events) return this;
	  this._events = eventsApi(offApi, this._events, name, callback, {
	    context: context,
	    listeners: this._listeners
	  });
	  return this;
	};

	// Tell this object to stop listening to either specific events ... or
	// to every object it's currently listening to.
	Events.stopListening = function (obj, name, callback) {
	  var listeningTo = this._listeningTo;
	  if (!listeningTo) return this;
	  var ids = obj ? [obj._listenId] : Object.keys(listeningTo);
	  for (var i = 0; i < ids.length; i++) {
	    var listening = listeningTo[ids[i]];

	    // If listening doesn't exist, this object is not currently
	    // listening to obj. Break out early.
	    if (!listening) break;
	    listening.obj.off(name, callback, this);
	    if (listening.interop) listening.off(name, callback);
	  }
	  if (isEmpty(listeningTo)) this._listeningTo = void 0;
	  return this;
	};

	// The reducing API that removes a callback from the `events` object.
	var offApi = function (events, name, callback, options) {
	  if (!events) return;
	  var context = options.context,
	    listeners = options.listeners;
	  var i = 0,
	    names;

	  // Delete all event listeners and "drop" events.
	  if (!name && !context && !callback) {
	    if (listeners != null) {
	      for (names = Object.keys(listeners); i < names.length; i++) {
	        listeners[names[i]].cleanup();
	      }
	    }
	    return;
	  }
	  names = name ? [name] : Object.keys(events);
	  for (; i < names.length; i++) {
	    name = names[i];
	    var handlers = events[name];

	    // Bail out if there are no events stored.
	    if (!handlers) break;

	    // Find any remaining events.
	    var remaining = [];
	    for (var j = 0; j < handlers.length; j++) {
	      var handler = handlers[j];
	      if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
	        remaining.push(handler);
	      } else {
	        var listening = handler.listening;
	        if (listening) listening.off(name, callback);
	      }
	    }

	    // Replace events if there are any remaining.  Otherwise, clean up.
	    if (remaining.length) {
	      events[name] = remaining;
	    } else {
	      delete events[name];
	    }
	  }
	  return events;
	};

	// Bind an event to only be triggered a single time. After the first time
	// the callback is invoked, its listener will be removed. If multiple events
	// are passed in using the space-separated syntax, the handler will fire
	// once for each event, not once for a combination of all events.
	Events.once = function (name, callback, context) {
	  // Map the event into a `{event: once}` object.
	  var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
	  if (typeof name === 'string' && context == null) callback = void 0;
	  return this.on(events, callback, context);
	};

	// Inversion-of-control versions of `once`.
	Events.listenToOnce = function (obj, name, callback) {
	  // Map the event into a `{event: once}` object.
	  var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
	  return this.listenTo(obj, events);
	};

	// Reduces the event callbacks into a map of `{event: onceWrapper}`.
	// `offer` unbinds the `onceWrapper` after it has been called.
	var onceMap = function (map, name, callback, offer) {
	  if (callback) {
	    var once = map[name] = onceInvoke(function () {
	      offer(name, once);
	      callback.apply(this, arguments);
	    });
	    once._callback = callback;
	  }
	  return map;
	};

	// Creates a function that is restricted to invoking 'func' once.
	// Repeat calls to the function return the value of the first invocation.
	var onceInvoke = function (func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError('Expected a function');
	  }
	  var n = 2;
	  return function () {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	};

	// Trigger one or many events, firing all bound callbacks. Callbacks are
	// passed the same arguments as `trigger` is, apart from the event name
	// (unless you're listening on `"all"`, which will cause your callback to
	// receive the true name of the event as the first argument).
	Events.trigger = function (name) {
	  if (!this._events) return this;
	  var length = Math.max(0, arguments.length - 1);
	  var args = Array(length);
	  for (var i = 0; i < length; i++) args[i] = arguments[i + 1];
	  eventsApi(triggerApi, this._events, name, void 0, args);
	  return this;
	};

	// Handles triggering the appropriate event callbacks.
	var triggerApi = function (objEvents, name, callback, args) {
	  if (objEvents) {
	    var events = objEvents[name];
	    var allEvents = objEvents.all;
	    if (events && allEvents) allEvents = allEvents.slice();
	    if (events) triggerEvents(events, args);
	    if (allEvents) triggerEvents(allEvents, [name].concat(args));
	  }
	  return objEvents;
	};

	// A difficult-to-believe, but optimized internal dispatch function for
	// triggering events. Tries to keep the usual cases speedy (most internal
	// events have 3 arguments).
	var triggerEvents = function (events, args) {
	  var ev,
	    i = -1,
	    l = events.length,
	    a1 = args[0],
	    a2 = args[1],
	    a3 = args[2];
	  switch (args.length) {
	    case 0:
	      while (++i < l) (ev = events[i]).callback.call(ev.ctx);
	      return;
	    case 1:
	      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
	      return;
	    case 2:
	      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
	      return;
	    case 3:
	      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
	      return;
	    default:
	      while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
	      return;
	  }
	};

	// A listening class that tracks and cleans up memory bindings
	// when all callbacks have been offed.
	var Listening = function (listener, obj) {
	  this.id = listener._listenId;
	  this.listener = listener;
	  this.obj = obj;
	  this.interop = true;
	  this.count = 0;
	  this._events = void 0;
	};
	Listening.prototype.on = Events.on;

	// Offs a callback (or several).
	// Uses an optimized counter if the listenee uses Events.
	// Otherwise, falls back to manual tracking to support events
	// library interop.
	Listening.prototype.off = function (name, callback) {
	  var cleanup;
	  if (this.interop) {
	    this._events = eventsApi(offApi, this._events, name, callback, {
	      context: void 0,
	      listeners: void 0
	    });
	    cleanup = !this._events;
	  } else {
	    this.count--;
	    cleanup = this.count === 0;
	  }
	  if (cleanup) this.cleanup();
	};

	// Cleans up memory bindings between the listener and the listenee.
	Listening.prototype.cleanup = function () {
	  delete this.listener._listeningTo[this.obj._listenId];
	  if (!this.interop) delete this.obj._listeners[this.id];
	};

	// Aliases for backwards compatibility.
	Events.bind = Events.on;
	Events.unbind = Events.off;

	// Helpers
	// -------

	// Helper function to correctly set up the prototype chain for subclasses.
	// Similar to `goog.inherits`, but uses a hash of prototype properties and
	// class properties to be extended.
	var extend = function (protoProps, staticProps) {
	  var parent = this;
	  var child;

	  // The constructor function for the new subclass is either defined by you
	  // (the "constructor" property in your `extend` definition), or defaulted
	  // by us to simply call the parent constructor.
	  if (protoProps && has(protoProps, 'constructor')) {
	    child = protoProps.constructor;
	  } else {
	    child = function () {
	      return parent.apply(this, arguments);
	    };
	  }

	  // Add static properties to the constructor function, if supplied.
	  assign(child, parent, staticProps);

	  // Set the prototype chain to inherit from `parent`, without calling
	  // `parent`'s constructor function and add the prototype properties.
	  child.prototype = Object.assign(Object.create(parent.prototype), protoProps);
	  child.prototype.constructor = child;

	  // Set a convenience property in case the parent's prototype is needed
	  // later.
	  child.__super__ = parent.prototype;
	  return child;
	};

	// Proxy class methods to functions, wrapping the model's
	// `attributes` object or collection's `models` array behind the scenes.
	//
	// `Function#apply` can be slow so we use the method's arg count, if we know it.
	var addMethod = function (base, length, method, attribute) {
	  switch (length) {
	    case 1:
	      return function () {
	        return base[method](this[attribute]);
	      };
	    case 2:
	      return function (value) {
	        return base[method](this[attribute], value);
	      };
	    case 3:
	      return function (iteratee, context) {
	        return base[method](this[attribute], cb(iteratee, this), context);
	      };
	    case 4:
	      return function (iteratee, defaultVal, context) {
	        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);
	      };
	    default:
	      return function () {
	        var args = Array.prototype.slice.call(arguments);
	        args.unshift(this[attribute]);
	        return base[method].apply(base, args);
	      };
	  }
	};
	var addMethodsUtil = function (Class, base, methods, attribute) {
	  forIn(methods, function (length, method) {
	    if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);
	  });
	};

	// Support `collection.sortBy('attr')`.
	var cb = function (iteratee, instance) {
	  if (isFunction(iteratee)) return iteratee;
	  if (isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
	  if (isString(iteratee)) return function (model) {
	    return model.get(iteratee);
	  };
	  return iteratee;
	};
	var modelMatcher = function (attrs) {
	  var matcher = matches(attrs);
	  return function (model) {
	    return matcher(model.attributes);
	  };
	};

	// Model
	// --------------

	// **Models** are the basic data object in the framework --
	// frequently representing a row in a table in a database on your server.
	// A discrete chunk of data and a bunch of useful, related methods for
	// performing computations and transformations on that data.

	// Create a new model with the specified attributes. A client id (`cid`)
	// is automatically generated and assigned for you.

	var Model = function (attributes, options) {
	  var attrs = attributes || {};
	  options || (options = {});
	  this.eventPrefix = options.eventPrefix || '';
	  this.preinitialize.apply(this, arguments);
	  this.cid = uniqueId(this.cidPrefix);
	  this.attributes = {};
	  if (options.collection) this.collection = options.collection;
	  this._setDefaults(attrs, options);
	  this.changed = {};
	  this.initialize.apply(this, arguments);
	};

	// Attach all inheritable methods to the Model prototype.
	assign(Model.prototype, Events, {
	  // A hash of attributes whose current and previous value differ.
	  changed: null,
	  // The value returned during the last failed validation.
	  validationError: null,
	  // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	  // CouchDB users may want to set this to `"_id"`.
	  idAttribute: 'id',
	  // The prefix is used to create the client id which is used to identify models locally.
	  // You may want to override this if you're experiencing name clashes with model ids.
	  cidPrefix: 'c',
	  // preinitialize is an empty function by default. You can override it with a function
	  // or object.  preinitialize will run before any instantiation logic is run in the Model.
	  preinitialize: function () {
	    // No implementation.
	  },
	  // Initialize is an empty function by default. Override it with your own
	  // initialization logic.
	  initialize: function () {
	    // No implementation.
	  },
	  // Return a copy of the model's `attributes` object.
	  toJSON: function (options) {
	    return clone$1(this.attributes);
	  },
	  // Get the value of an attribute.
	  get: function (attr) {
	    return this.attributes[attr];
	  },
	  // Returns `true` if the attribute contains a value that is not null
	  // or undefined.
	  has: function (attr) {
	    return this.get(attr) != null;
	  },
	  // Set a hash of model attributes on the object, firing `"change"`. This is
	  // the core primitive operation of a model, updating the data and notifying
	  // anyone who needs to know about the change in state. The heart of the beast.
	  set: function (key, val, options) {
	    if (key == null) return this;

	    // Handle both `"key", value` and `{key: value}` -style arguments.
	    var attrs;
	    if (typeof key === 'object') {
	      attrs = key;
	      options = val;
	    } else {
	      (attrs = {})[key] = val;
	    }
	    options || (options = {});

	    // Run validation.
	    if (!this._validate(attrs, options)) return false;

	    // Extract attributes and options.
	    var unset = options.unset;
	    var silent = options.silent;
	    var changes = [];
	    var changing = this._changing;
	    this._changing = true;
	    if (!changing) {
	      this._previousAttributes = clone$1(this.attributes);
	      this.changed = {};
	    }
	    var current = this.attributes;
	    var changed = this.changed;
	    var prev = this._previousAttributes;

	    // For each `set` attribute, update or delete the current value.
	    for (var attr in attrs) {
	      val = attrs[attr];
	      if (!isEqual(current[attr], val)) changes.push(attr);
	      if (!isEqual(prev[attr], val)) {
	        changed[attr] = val;
	      } else {
	        delete changed[attr];
	      }
	      unset ? delete current[attr] : current[attr] = val;
	    }

	    // Update the `id`.
	    if (this.idAttribute in attrs) {
	      var prevId = this.id;
	      this.id = this.get(this.idAttribute);
	      this.trigger(this.eventPrefix + 'changeId', this, prevId, options);
	    }

	    // Trigger all relevant attribute changes.
	    if (!silent) {
	      if (changes.length) this._pending = options;
	      for (var i = 0; i < changes.length; i++) {
	        this.trigger(this.eventPrefix + 'change:' + changes[i], this, current[changes[i]], options);
	      }
	    }

	    // You might be wondering why there's a `while` loop here. Changes can
	    // be recursively nested within `"change"` events.
	    if (changing) return this;
	    if (!silent) {
	      while (this._pending) {
	        options = this._pending;
	        this._pending = false;
	        this.trigger(this.eventPrefix + 'change', this, options);
	      }
	    }
	    this._pending = false;
	    this._changing = false;
	    return this;
	  },
	  // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	  // if the attribute doesn't exist.
	  unset: function (attr, options) {
	    return this.set(attr, void 0, assign({}, options, {
	      unset: true
	    }));
	  },
	  // Clear all attributes on the model, firing `"change"`.
	  clear: function (options) {
	    var attrs = {};
	    for (var key in this.attributes) attrs[key] = void 0;
	    return this.set(attrs, assign({}, options, {
	      unset: true
	    }));
	  },
	  // Determine if the model has changed since the last `"change"` event.
	  // If you specify an attribute name, determine if that attribute has changed.
	  hasChanged: function (attr) {
	    if (attr == null) return !isEmpty(this.changed);
	    return has(this.changed, attr);
	  },
	  // Return an object containing all the attributes that have changed, or
	  // false if there are no changed attributes. Useful for determining what
	  // parts of a view need to be updated and/or what attributes need to be
	  // persisted to the server. Unset attributes will be set to undefined.
	  // You can also pass an attributes object to diff against the model,
	  // determining if there *would be* a change.
	  changedAttributes: function (diff) {
	    if (!diff) return this.hasChanged() ? clone$1(this.changed) : false;
	    var old = this._changing ? this._previousAttributes : this.attributes;
	    var changed = {};
	    var hasChanged;
	    for (var attr in diff) {
	      var val = diff[attr];
	      if (isEqual(old[attr], val)) continue;
	      changed[attr] = val;
	      hasChanged = true;
	    }
	    return hasChanged ? changed : false;
	  },
	  // Get the previous value of an attribute, recorded at the time the last
	  // `"change"` event was fired.
	  previous: function (attr) {
	    if (attr == null || !this._previousAttributes) return null;
	    return this._previousAttributes[attr];
	  },
	  // Get all of the attributes of the model at the time of the previous
	  // `"change"` event.
	  previousAttributes: function () {
	    return clone$1(this._previousAttributes);
	  },
	  // Create a new model with identical attributes to this one.
	  clone: function () {
	    return new this.constructor(this.attributes);
	  },
	  // Check if the model is currently in a valid state.
	  isValid: function (options) {
	    return this._validate({}, assign({}, options, {
	      validate: true
	    }));
	  },
	  // Run validation against the next complete set of model attributes,
	  // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	  _validate: function (attrs, options) {
	    if (!options.validate || !this.validate) return true;
	    attrs = assign({}, this.attributes, attrs);
	    var error = this.validationError = this.validate(attrs, options) || null;
	    if (!error) return true;
	    this.trigger('invalid', this, error, assign(options, {
	      validationError: error
	    }));
	    return false;
	  },
	  _setDefaults: function (ctorAttributes, options) {
	    const attributeDefaults = result(this, 'defaults');
	    // Just _.defaults would work fine, but the additional _.extends
	    // is in there for historical reasons. See #3843.
	    const attributes = defaults(assign({}, attributeDefaults, ctorAttributes), attributeDefaults);
	    this.set(attributes, options);
	  }
	});

	// Set up inheritance for the model.
	Model.extend = extend;

	// Clone `cells` returning an object that maps the original cell ID to the clone. The number
	// of clones is exactly the same as the `cells.length`.
	// This function simply clones all the `cells`. However, it also reconstructs
	// all the `source/target` and `parent/embed` references within the `cells`.
	// This is the main difference from the `cell.clone()` method. The
	// `cell.clone()` method works on one single cell only.
	// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`
	// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.
	// the source and target of the link `L2` is changed to point to `A2` and `B2`.
	function cloneCells(cells) {
	  cells = uniq(cells);

	  // A map of the form [original cell ID] -> [clone] helping
	  // us to reconstruct references for source/target and parent/embeds.
	  // This is also the returned value.
	  const cloneMap = toArray$1(cells).reduce(function (map, cell) {
	    map[cell.id] = cell.clone();
	    return map;
	  }, {});
	  toArray$1(cells).forEach(function (cell) {
	    const clone = cloneMap[cell.id];
	    // assert(clone exists)

	    if (clone.isLink()) {
	      const source = clone.source();
	      const target = clone.target();
	      if (source.id && cloneMap[source.id]) {
	        // Source points to an element and the element is among the clones.
	        // => Update the source of the cloned link.
	        clone.prop('source/id', cloneMap[source.id].id);
	      }
	      if (target.id && cloneMap[target.id]) {
	        // Target points to an element and the element is among the clones.
	        // => Update the target of the cloned link.
	        clone.prop('target/id', cloneMap[target.id].id);
	      }
	    }

	    // Find the parent of the original cell
	    const parent = cell.get('parent');
	    if (parent && cloneMap[parent]) {
	      clone.set('parent', cloneMap[parent].id);
	    }

	    // Find the embeds of the original cell
	    const embeds = toArray$1(cell.get('embeds')).reduce(function (newEmbeds, embed) {
	      // Embedded cells that are not being cloned can not be carried
	      // over with other embedded cells.
	      if (cloneMap[embed]) {
	        newEmbeds.push(cloneMap[embed].id);
	      }
	      return newEmbeds;
	    }, []);
	    if (!isEmpty(embeds)) {
	      clone.set('embeds', embeds);
	    }
	  });
	  return cloneMap;
	}

	const validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];
	const validProperties = validPropertiesList.reduce((acc, key) => {
	  acc[key] = true;
	  return acc;
	}, {});
	const props$1 = {
	  qualify: function (properties) {
	    return isPlainObject(properties);
	  },
	  set: function (properties, _, node) {
	    Object.keys(properties).forEach(function (key) {
	      if (validProperties[key] && key in node) {
	        const value = properties[key];
	        if (node.tagName === 'SELECT' && Array.isArray(value)) {
	          Array.from(node.options).forEach(function (option, index) {
	            option.selected = value.includes(option.value);
	          });
	        } else {
	          node[key] = value;
	        }
	      }
	    });
	  }
	};

	function positionWrapper(axis, dimension, origin) {
	  return function (value, refBBox) {
	    var valuePercentage = isPercentage(value);
	    value = parseFloat(value);
	    if (valuePercentage) {
	      value /= 100;
	    }
	    var delta;
	    if (isFinite(value)) {
	      var refOrigin = refBBox[origin]();
	      if (valuePercentage || value > 0 && value < 1) {
	        delta = refOrigin[axis] + refBBox[dimension] * value;
	      } else {
	        delta = refOrigin[axis] + value;
	      }
	    }
	    var point = Point();
	    point[axis] = delta || 0;
	    return point;
	  };
	}
	function setWrapper(attrName, dimension) {
	  return function (value, refBBox) {
	    var isValuePercentage = isPercentage(value);
	    value = parseFloat(value);
	    if (isValuePercentage) {
	      value /= 100;
	    }
	    var attrs = {};
	    if (isFinite(value)) {
	      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
	      attrs[attrName] = attrValue;
	    }
	    return attrs;
	  };
	}
	const legacyAttributesNS = {
	  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
	  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
	  // otherwise, `refX` is the left coordinate of the bounding box
	  'ref-x': {
	    position: positionWrapper('x', 'width', 'origin')
	  },
	  'ref-y': {
	    position: positionWrapper('y', 'height', 'origin')
	  },
	  // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom
	  // coordinate of the reference element.

	  'ref-dx': {
	    position: positionWrapper('x', 'width', 'corner')
	  },
	  'ref-dy': {
	    position: positionWrapper('y', 'height', 'corner')
	  },
	  // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to
	  // the reference element size
	  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
	  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20

	  'ref-width': {
	    set: setWrapper('width', 'width')
	  },
	  'ref-height': {
	    set: setWrapper('height', 'height')
	  },
	  'ref-rx': {
	    set: setWrapper('rx', 'width')
	  },
	  'ref-ry': {
	    set: setWrapper('ry', 'height')
	  },
	  'ref-cx': {
	    set: setWrapper('cx', 'width')
	  },
	  'ref-cy': {
	    set: setWrapper('cy', 'height')
	  },
	  'ref-r-inscribed': {
	    set: function (attrName) {
	      var widthFn = setWrapper(attrName, 'width');
	      var heightFn = setWrapper(attrName, 'height');
	      return function (value, refBBox) {
	        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;
	        return fn(value, refBBox);
	      };
	    }('r')
	  },
	  'ref-r-circumscribed': {
	    set: function (value, refBBox) {
	      var isValuePercentage = isPercentage(value);
	      value = parseFloat(value);
	      if (isValuePercentage) {
	        value /= 100;
	      }
	      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
	      var rValue;
	      if (isFinite(value)) {
	        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);
	      }
	      return {
	        r: rValue
	      };
	    }
	  }
	};

	// NOTE: refX & refY are SVG attributes that define the reference point of the marker.
	// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).
	legacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];
	legacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];

	// This allows to combine both absolute and relative positioning
	// refX: 50%, refX2: 20
	legacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];
	legacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];
	legacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];
	legacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];

	// Aliases
	legacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];

	const props = {
	  x: 'x',
	  y: 'y',
	  width: 'w',
	  height: 'h',
	  minimum: 's',
	  maximum: 'l',
	  diagonal: 'd'
	};
	const propsList = Object.keys(props).map(key => props[key]).join('');
	const numberPattern = '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';
	const findSpacesRegex = /\s/g;
	const parseFormulaRegExp = new RegExp(`^(${numberPattern}\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');
	function throwInvalid(expression) {
	  throw new Error(`Invalid calc() expression: ${expression}`);
	}

	/*
	* Evaluate the given calc formula.
	* e.g. 'w + 10' in a rect 100x100 -> 110
	*/
	function evalCalcFormula(formula, rect) {
	  const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));
	  if (!match) throwInvalid(formula);
	  parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run
	  const [, multiply, property, divide, add] = match;
	  const {
	    x,
	    y,
	    width,
	    height
	  } = rect;
	  let value = 0;
	  switch (property) {
	    case props.width:
	      {
	        value = width;
	        break;
	      }
	    case props.height:
	      {
	        value = height;
	        break;
	      }
	    case props.x:
	      {
	        value = x;
	        break;
	      }
	    case props.y:
	      {
	        value = y;
	        break;
	      }
	    case props.minimum:
	      {
	        value = Math.min(height, width);
	        break;
	      }
	    case props.maximum:
	      {
	        value = Math.max(height, width);
	        break;
	      }
	    case props.diagonal:
	      {
	        value = Math.sqrt(height * height + width * width);
	        break;
	      }
	  }
	  if (multiply) {
	    // e.g "2*"
	    value *= parseFloat(multiply);
	  }
	  if (divide) {
	    // e.g "/2"
	    value /= parseFloat(divide.slice(1));
	  }
	  if (add) {
	    value += evalAddExpression(add);
	  }
	  return value;
	}
	function evalAddExpression(addExpression) {
	  if (!addExpression) return 0;
	  const [sign] = addExpression;
	  switch (sign) {
	    case '+':
	      {
	        return parseFloat(addExpression.substr(1));
	      }
	    case '-':
	      {
	        return -parseFloat(addExpression.substr(1));
	      }
	  }
	  return parseFloat(addExpression);
	}

	/*
	* Check if the given value is a calc expression.
	* e.g. 'calc(10 + 100)' -> true
	*/
	function isCalcExpression(value) {
	  return typeof value === 'string' && value.includes('calc');
	}
	const calcStart = 'calc(';
	const calcStartOffset = calcStart.length;

	/*
	* Evaluate all calc formulas in the given expression.
	* e.g. 'calc(w + 10)' in rect 100x100 -> '110'
	*/
	function evalCalcExpression(expression, rect) {
	  let value = expression;
	  let startSearchIndex = 0;
	  do {
	    let calcIndex = value.indexOf(calcStart, startSearchIndex);
	    if (calcIndex === -1) return value;
	    let calcEndIndex = calcIndex + calcStartOffset;
	    let brackets = 1;
	    findClosingBracket: do {
	      switch (value[calcEndIndex]) {
	        case '(':
	          {
	            brackets++;
	            break;
	          }
	        case ')':
	          {
	            brackets--;
	            if (brackets === 0) break findClosingBracket;
	            break;
	          }
	        case undefined:
	          {
	            // Could not find the closing bracket.
	            throwInvalid(value);
	          }
	      }
	      calcEndIndex++;
	    } while (true);
	    // Get the calc() expression without nested calcs (recursion)
	    let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);
	    if (isCalcExpression(expression)) {
	      expression = evalCalcExpression(expression, rect);
	    }
	    // Eval the calc() expression without nested calcs.
	    const calcValue = String(evalCalcFormula(expression, rect));
	    // Replace the calc() expression and continue search
	    value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);
	    startSearchIndex = calcIndex + calcValue.length;
	  } while (true);
	}

	function isTextInUse(_value, _node, attrs) {
	  return attrs.text !== undefined;
	}
	const FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];
	const textAttributesNS = {
	  'line-height': {
	    qualify: isTextInUse
	  },
	  'text-vertical-anchor': {
	    qualify: isTextInUse
	  },
	  'text-path': {
	    qualify: isTextInUse
	  },
	  'annotations': {
	    qualify: isTextInUse
	  },
	  'eol': {
	    qualify: isTextInUse
	  },
	  'display-empty': {
	    qualify: isTextInUse
	  },
	  'text': {
	    qualify: function (_text, _node, attrs) {
	      const textWrap = attrs['text-wrap'];
	      return !textWrap || !isPlainObject(textWrap);
	    },
	    unset: function (node) {
	      node.textContent = '';
	    },
	    set: function (text, refBBox, node, attrs) {
	      const cacheName = 'joint-text';
	      const cache = $.data.get(node, cacheName);
	      const lineHeight = attrs['line-height'];
	      const textVerticalAnchor = attrs['text-vertical-anchor'];
	      const displayEmpty = attrs['display-empty'];
	      const fontSize = attrs['font-size'];
	      const annotations = attrs.annotations;
	      const eol = attrs.eol;
	      const x = attrs.x;
	      let textPath = attrs['text-path'];
	      const useNoBreakSpace = attrs['use-no-break-space'] === true;
	      // Update the text only if there was a change in the string
	      // or any of its attributes.
	      const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize, useNoBreakSpace]);
	      if (cache === undefined || cache !== textHash) {
	        // Chrome bug:
	        // <tspan> positions defined as `em` are not updated
	        // when container `font-size` change.
	        if (fontSize) node.setAttribute('font-size', fontSize);
	        // Text Along Path Selector
	        if (isObject(textPath)) {
	          const pathSelector = textPath.selector;
	          if (typeof pathSelector === 'string') {
	            const pathNode = this.findNode(pathSelector);
	            if (pathNode instanceof SVGPathElement) {
	              textPath = assign({
	                'xlink:href': '#' + pathNode.id
	              }, textPath);
	            }
	          }
	        }
	        V(node).text('' + text, {
	          lineHeight,
	          annotations,
	          textPath,
	          x,
	          textVerticalAnchor,
	          eol,
	          displayEmpty,
	          useNoBreakSpace
	        });
	        $.data.set(node, cacheName, textHash);
	      }
	    }
	  },
	  'text-wrap': {
	    qualify: isPlainObject,
	    set: function (value, refBBox, node, attrs) {
	      var size = {};
	      // option `width`
	      var width = value.width || 0;
	      if (isPercentage(width)) {
	        size.width = refBBox.width * parseFloat(width) / 100;
	      } else if (isCalcExpression(width)) {
	        size.width = Number(evalCalcExpression(width, refBBox));
	      } else {
	        if (value.width === null) {
	          // breakText() requires width to be specified.
	          size.width = Infinity;
	        } else if (width <= 0) {
	          size.width = refBBox.width + width;
	        } else {
	          size.width = width;
	        }
	      }
	      // option `height`
	      var height = value.height || 0;
	      if (isPercentage(height)) {
	        size.height = refBBox.height * parseFloat(height) / 100;
	      } else if (isCalcExpression(height)) {
	        size.height = Number(evalCalcExpression(height, refBBox));
	      } else {
	        if (value.height === null) {
	          // if height is not specified breakText() does not
	          // restrict the height of the text.
	        } else if (height <= 0) {
	          size.height = refBBox.height + height;
	        } else {
	          size.height = height;
	        }
	      }
	      // option `text`
	      var wrappedText;
	      var text = value.text;
	      if (text === undefined) text = attrs.text;
	      if (text !== undefined) {
	        const breakTextFn = value.breakText || breakText;
	        const computedStyles = getComputedStyle(node);
	        const wrapFontAttributes = {};
	        // The font size attributes must be set on the node
	        // to get the correct text wrapping.
	        // TODO: set the native SVG attributes before special attributes
	        for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {
	          const name = FONT_ATTRIBUTES[i];
	          if (name in attrs) {
	            node.setAttribute(name, attrs[name]);
	          }
	          // Note: computedStyles is a live object
	          // i.e. the properties are evaluated when accessed.
	          wrapFontAttributes[name] = computedStyles[name];
	        }

	        // The `line-height` attribute in SVG is JoinJS specific.
	        // TODO: change the `lineHeight` to breakText option.
	        wrapFontAttributes.lineHeight = attrs['line-height'];
	        let svgDocument = this.paper.svg;
	        if (!svgDocument.checkVisibility()) {
	          // If the paper is visible, we can utilize
	          // its SVG element to measure the text size
	          // when breaking the text.
	          // Otherwise, we need to create a temporary
	          // SVG document and append it to the DOM,
	          // (the default behavior of `breakText`).
	          svgDocument = null;
	        }
	        wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {
	          svgDocument,
	          ellipsis: value.ellipsis,
	          hyphen: value.hyphen,
	          separator: value.separator,
	          maxLineCount: value.maxLineCount,
	          preserveSpaces: value.preserveSpaces
	        });
	      } else {
	        wrappedText = '';
	      }
	      textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);
	    },
	    // We expose the font attributes list to allow
	    // the user to take other custom font attributes into account
	    // when wrapping the text.
	    FONT_ATTRIBUTES
	  },
	  'title': {
	    qualify: function (title, node) {
	      // HTMLElement title is specified via an attribute (i.e. not an element)
	      return node instanceof SVGElement;
	    },
	    unset: function (node) {
	      $.data.remove(node, 'joint-title');
	      const titleNode = node.firstElementChild;
	      if (titleNode) {
	        titleNode.remove();
	      }
	    },
	    set: function (title, refBBox, node) {
	      var cacheName = 'joint-title';
	      var cache = $.data.get(node, cacheName);
	      if (cache === undefined || cache !== title) {
	        $.data.set(node, cacheName, title);
	        if (node.tagName === 'title') {
	          // The target node is a <title> element.
	          node.textContent = title;
	          return;
	        }
	        // Generally <title> element should be the first child element of its parent.
	        var firstChild = node.firstElementChild;
	        if (firstChild && firstChild.tagName === 'title') {
	          // Update an existing title
	          firstChild.textContent = title;
	        } else {
	          // Create a new title
	          var titleNode = document.createElementNS(node.namespaceURI, 'title');
	          titleNode.textContent = title;
	          node.insertBefore(titleNode, firstChild);
	        }
	      }
	    }
	  }
	};

	function atConnectionWrapper(method, opt) {
	  var zeroVector = new Point(1, 0);
	  return function (value) {
	    var p, angle;
	    var tangent = this[method](value);
	    if (tangent) {
	      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
	      p = tangent.start;
	    } else {
	      p = this.path.start;
	      angle = 0;
	    }
	    if (angle === 0) return {
	      transform: 'translate(' + p.x + ',' + p.y + ')'
	    };
	    return {
	      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'
	    };
	  };
	}
	function isLinkView() {
	  return this.model.isLink();
	}
	const connectionAttributesNS = {
	  'connection': {
	    qualify: isLinkView,
	    unset: 'd',
	    set: function ({
	      stubs = 0
	    }) {
	      let d;
	      if (isFinite(stubs) && stubs !== 0) {
	        let offset;
	        if (stubs < 0) {
	          offset = (this.getConnectionLength() + stubs) / 2;
	        } else {
	          offset = stubs;
	        }
	        const path = this.getConnection();
	        const segmentSubdivisions = this.getConnectionSubdivisions();
	        const sourceParts = path.divideAtLength(offset, {
	          segmentSubdivisions
	        });
	        const targetParts = path.divideAtLength(-offset, {
	          segmentSubdivisions
	        });
	        if (sourceParts && targetParts) {
	          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
	        }
	      }
	      return {
	        d: d || this.getSerializedConnection()
	      };
	    }
	  },
	  'at-connection-length-keep-gradient': {
	    qualify: isLinkView,
	    unset: 'transform',
	    set: atConnectionWrapper('getTangentAtLength', {
	      rotate: true
	    })
	  },
	  'at-connection-length-ignore-gradient': {
	    qualify: isLinkView,
	    unset: 'transform',
	    set: atConnectionWrapper('getTangentAtLength', {
	      rotate: false
	    })
	  },
	  'at-connection-ratio-keep-gradient': {
	    qualify: isLinkView,
	    unset: 'transform',
	    set: atConnectionWrapper('getTangentAtRatio', {
	      rotate: true
	    })
	  },
	  'at-connection-ratio-ignore-gradient': {
	    qualify: isLinkView,
	    unset: 'transform',
	    set: atConnectionWrapper('getTangentAtRatio', {
	      rotate: false
	    })
	  }
	};
	connectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];
	connectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];

	function shapeWrapper(shapeConstructor, opt) {
	  var cacheName = 'joint-shape';
	  var resetOffset = opt && opt.resetOffset;
	  return function (value, refBBox, node) {
	    var cache = $.data.get(node, cacheName);
	    if (!cache || cache.value !== value) {
	      // only recalculate if value has changed
	      var cachedShape = shapeConstructor(value);
	      cache = {
	        value: value,
	        shape: cachedShape,
	        shapeBBox: cachedShape.bbox()
	      };
	      $.data.set(node, cacheName, cache);
	    }
	    var shape = cache.shape.clone();
	    var shapeBBox = cache.shapeBBox.clone();
	    var shapeOrigin = shapeBBox.origin();
	    var refOrigin = refBBox.origin();
	    shapeBBox.x = refOrigin.x;
	    shapeBBox.y = refOrigin.y;
	    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);
	    // `maxRectScaleToFit` can give Infinity if width or height is 0
	    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
	    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
	    shape.scale(sx, sy, shapeOrigin);
	    if (resetOffset) {
	      shape.translate(-shapeOrigin.x, -shapeOrigin.y);
	    }
	    return shape;
	  };
	}

	// `d` attribute for SVGPaths
	function dWrapper(opt) {
	  function pathConstructor(value) {
	    return new Path$1(V.normalizePathData(value));
	  }
	  var shape = shapeWrapper(pathConstructor, opt);
	  return function (value, refBBox, node) {
	    var path = shape(value, refBBox, node);
	    return {
	      d: path.serialize()
	    };
	  };
	}

	// `points` attribute for SVGPolylines and SVGPolygons
	function pointsWrapper(opt) {
	  var shape = shapeWrapper(Polyline$1, opt);
	  return function (value, refBBox, node) {
	    var polyline = shape(value, refBBox, node);
	    return {
	      points: polyline.serialize()
	    };
	  };
	}
	const shapeAttributesNS = {
	  'ref-d-reset-offset': {
	    unset: 'd',
	    set: dWrapper({
	      resetOffset: true
	    })
	  },
	  'ref-d-keep-offset': {
	    unset: 'd',
	    set: dWrapper({
	      resetOffset: false
	    })
	  },
	  'ref-points-reset-offset': {
	    unset: 'points',
	    set: pointsWrapper({
	      resetOffset: true
	    })
	  },
	  'ref-points-keep-offset': {
	    unset: 'points',
	    set: pointsWrapper({
	      resetOffset: false
	    })
	  }
	};

	// Aliases
	shapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];
	shapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];

	function contextMarker(context) {
	  var marker = {};
	  // Stroke
	  // The context 'fill' is disregarded here. The usual case is to use the marker with a connection
	  // (for which 'fill' attribute is set to 'none').
	  var stroke = context.stroke;
	  if (typeof stroke === 'string') {
	    marker['stroke'] = stroke;
	    marker['fill'] = stroke;
	  }
	  // Opacity
	  // Again the context 'fill-opacity' is ignored.
	  var strokeOpacity = context['stroke-opacity'];
	  if (strokeOpacity === undefined) strokeOpacity = context.opacity;
	  if (strokeOpacity !== undefined) {
	    marker['stroke-opacity'] = strokeOpacity;
	    marker['fill-opacity'] = strokeOpacity;
	  }
	  return marker;
	}
	function setPaintURL(def) {
	  const {
	    paper
	  } = this;
	  const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);
	  return `url(#${url})`;
	}
	const defsAttributesNS = {
	  'source-marker': {
	    qualify: isPlainObject,
	    unset: 'marker-start',
	    set: function (marker, refBBox, node, attrs) {
	      marker = assign(contextMarker(attrs), marker);
	      return {
	        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'
	      };
	    }
	  },
	  'target-marker': {
	    qualify: isPlainObject,
	    unset: 'marker-end',
	    set: function (marker, refBBox, node, attrs) {
	      marker = assign(contextMarker(attrs), {
	        'transform': 'rotate(180)'
	      }, marker);
	      return {
	        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'
	      };
	    }
	  },
	  'vertex-marker': {
	    qualify: isPlainObject,
	    unset: 'marker-mid',
	    set: function (marker, refBBox, node, attrs) {
	      marker = assign(contextMarker(attrs), marker);
	      return {
	        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'
	      };
	    }
	  },
	  'fill': {
	    qualify: isPlainObject,
	    set: setPaintURL
	  },
	  'stroke': {
	    qualify: isPlainObject,
	    set: setPaintURL
	  },
	  'filter': {
	    qualify: isPlainObject,
	    set: function (filter) {
	      return 'url(#' + this.paper.defineFilter(filter) + ')';
	    }
	  }
	};

	// Offset attributes require the cell view to be rendered before they can be applied
	// (they must be appended to the DOM).

	function offsetWrapper(axis, dimension, corner) {
	  return function (value, nodeBBox) {
	    var delta;
	    if (value === 'middle') {
	      delta = nodeBBox[dimension] / 2;
	    } else if (value === corner) {
	      delta = nodeBBox[dimension];
	    } else if (isFinite(value)) {
	      // TODO: or not to do a breaking change?
	      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;
	    } else if (isPercentage(value)) {
	      delta = nodeBBox[dimension] * parseFloat(value) / 100;
	    } else {
	      delta = 0;
	    }
	    var point = new Point();
	    point[axis] = -(nodeBBox[axis] + delta);
	    return point;
	  };
	}
	const offsetAttributesNS = {
	  // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.
	  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.
	  'x-alignment': {
	    offset: offsetWrapper('x', 'width', 'right')
	  },
	  // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.
	  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
	  'y-alignment': {
	    offset: offsetWrapper('y', 'height', 'bottom')
	  },
	  'reset-offset': {
	    offset: function (val, nodeBBox) {
	      return val ? {
	        x: -nodeBBox.x,
	        y: -nodeBBox.y
	      } : {
	        x: 0,
	        y: 0
	      };
	    }
	  }
	};

	function setIfChangedWrapper(attribute) {
	  return function setIfChanged(value, _, node) {
	    const vel = V(node);
	    if (vel.attr(attribute) === value) return;
	    vel.attr(attribute, value);
	  };
	}
	const attributesNS = {
	  'ref': {
	    // We do not set `ref` attribute directly on an element.
	    // The attribute itself does not qualify for relative positioning.
	  },
	  'href': {
	    set: setIfChangedWrapper('href')
	  },
	  'xlink:href': {
	    set: setIfChangedWrapper('xlink:href')
	  },
	  // `port` attribute contains the `id` of the port that the underlying magnet represents.
	  'port': {
	    set: function (port) {
	      return port === null || port.id === undefined ? port : port.id;
	    }
	  },
	  // `style` attribute is special in the sense that it sets the CSS style of the sub-element.
	  'style': {
	    qualify: isPlainObject,
	    set: function (styles, refBBox, node) {
	      $(node).css(styles);
	    }
	  },
	  'html': {
	    unset: function (node) {
	      $(node).empty();
	    },
	    set: function (html, refBBox, node) {
	      $(node).html(html + '');
	    }
	  },
	  // Properties setter (set various properties on the node)
	  props: props$1
	};
	assign(attributesNS, legacyAttributesNS);
	assign(attributesNS, textAttributesNS);
	assign(attributesNS, connectionAttributesNS);
	assign(attributesNS, shapeAttributesNS);
	assign(attributesNS, defsAttributesNS);
	assign(attributesNS, offsetAttributesNS);
	const attributes = attributesNS;

	// Internal tags to identify objects as specific JointJS types.
	// Used instead of `instanceof` for performance and cross-frame safety.

	// dia.Cell
	const CELL_MARKER = Symbol('joint.cellMarker');

	// dia.CellCollection
	const CELL_COLLECTION_MARKER = Symbol('joint.cellCollectionMarker');

	// dia.GraphLayer
	const GRAPH_LAYER_MARKER = Symbol('joint.graphLayerMarker');

	// dia.GraphLayerCollection
	const GRAPH_LAYER_COLLECTION_MARKER = Symbol('joint.graphLayerCollectionMarker');

	// dia.CellView
	const CELL_VIEW_MARKER = Symbol('joint.cellViewMarker');

	// dia.LayerView
	const LAYER_VIEW_MARKER = Symbol('joint.layerViewMarker');

	// dia.GraphLayerView
	const GRAPH_LAYER_VIEW_MARKER = Symbol('joint.graphLayerViewMarker');

	// Cell base model.
	// --------------------------

	const attributesMerger = function (a, b) {
	  if (Array.isArray(a)) {
	    return cloneDeep(b);
	  }
	};
	function removeEmptyAttributes(obj) {
	  // Remove toplevel empty attributes
	  for (const key in obj) {
	    const objValue = obj[key];
	    const isRealObject = isObject(objValue) && !Array.isArray(objValue);
	    if (!isRealObject) continue;
	    if (isEmpty(objValue)) {
	      delete obj[key];
	    }
	  }
	}
	const Cell = Model.extend({
	  cidPrefix: 'c',
	  // Default attributes are merged deeply instead of shallowly.
	  _setDefaults: function (ctorAttributes, options) {
	    let attributes;
	    const attributeDefaults = result(this, 'defaults');
	    if (attributeDefaults) {
	      const customizer = options && options.mergeArrays === true ? false : config$3.cellDefaultsMergeStrategy || attributesMerger;
	      attributes = merge({}, attributeDefaults, ctorAttributes, customizer);
	    } else {
	      attributes = ctorAttributes;
	    }
	    this.set(attributes, options);
	  },
	  translate: function (dx, dy, opt) {
	    throw new Error('Must define a translate() method.');
	  },
	  toJSON: function (opt) {
	    const {
	      ignoreDefaults,
	      ignoreEmptyAttributes = false
	    } = opt || {};
	    const defaults = result(this.constructor.prototype, 'defaults');
	    if (ignoreDefaults === false) {
	      // Return all attributes without omitting the defaults
	      const finalAttributes = cloneDeep(this.attributes);
	      if (!ignoreEmptyAttributes) return finalAttributes;
	      removeEmptyAttributes(finalAttributes);
	      return finalAttributes;
	    }
	    let defaultAttributes = {};
	    let attributes = cloneDeep(this.attributes);
	    if (ignoreDefaults === true) {
	      // Compare all attributes with the defaults
	      defaultAttributes = defaults;
	    } else {
	      // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified
	      const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];
	      differentiateKeys.forEach(key => {
	        defaultAttributes[key] = defaults[key] || {};
	      });
	    }

	    // Omit `id` and `type` attribute from the defaults since it should be always present
	    const finalAttributes = objectDifference(attributes, omit(defaultAttributes, 'id', 'type'), {
	      maxDepth: 4
	    });
	    if (ignoreEmptyAttributes) {
	      removeEmptyAttributes(finalAttributes);
	    }
	    return finalAttributes;
	  },
	  initialize: function (attributes) {
	    const idAttribute = this.getIdAttribute();
	    if (!attributes || attributes[idAttribute] === undefined) {
	      this.set(idAttribute, this.generateId(), {
	        silent: true
	      });
	    }
	    this._transitionIds = {};
	    this._scheduledTransitionIds = {};

	    // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.
	    this.processPorts();
	    this.on('change:attrs', this.processPorts, this);
	  },
	  getIdAttribute: function () {
	    return this.idAttribute || 'id';
	  },
	  generateId: function () {
	    return uuid();
	  },
	  /**
	   * @deprecated
	   */
	  processPorts: function () {
	    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it
	    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`
	    // set to that port, we remove those links as well (to follow the same behaviour as
	    // with a removed element).

	    var previousPorts = this.ports;

	    // Collect ports from the `attrs` object.
	    var ports = {};
	    forIn(this.get('attrs'), function (attrs, selector) {
	      if (attrs && attrs.port) {
	        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).
	        if (attrs.port.id !== undefined) {
	          ports[attrs.port.id] = attrs.port;
	        } else {
	          ports[attrs.port] = {
	            id: attrs.port
	          };
	        }
	      }
	    });

	    // Collect ports that have been removed (compared to the previous ports) - if any.
	    // Use hash table for quick lookup.
	    var removedPorts = {};
	    forIn(previousPorts, function (port, id) {
	      if (!ports[id]) removedPorts[id] = true;
	    });

	    // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.
	    if (this.graph && !isEmpty(removedPorts)) {
	      var inboundLinks = this.graph.getConnectedLinks(this, {
	        inbound: true
	      });
	      inboundLinks.forEach(function (link) {
	        if (removedPorts[link.get('target').port]) link.remove();
	      });
	      var outboundLinks = this.graph.getConnectedLinks(this, {
	        outbound: true
	      });
	      outboundLinks.forEach(function (link) {
	        if (removedPorts[link.get('source').port]) link.remove();
	      });
	    }

	    // Update the `ports` object.
	    this.ports = ports;
	  },
	  remove: function (opt = {}) {
	    const {
	      graph,
	      collection
	    } = this;
	    // If the cell is part of a graph, remove it using the graph API.
	    // To make sure the cell is removed in a batch operation.
	    if (graph) {
	      graph.removeCell(this, opt);
	    } else {
	      // The collection is a common mvc collection (not the graph collection).
	      if (collection) collection.remove(this, opt);
	    }
	    return this;
	  },
	  toFront: function (opt) {
	    const {
	      graph
	    } = this;
	    if (graph) {
	      opt = defaults(opt || {}, {
	        foregroundEmbeds: true
	      });
	      let cells;
	      if (opt.deep) {
	        cells = this.getEmbeddedCells({
	          deep: true,
	          breadthFirst: opt.breadthFirst !== false,
	          sortSiblings: opt.foregroundEmbeds
	        });
	        cells.unshift(this);
	      } else {
	        cells = [this];
	      }
	      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());
	      const layerId = graph.getCellLayerId(this);
	      const maxZ = graph.maxZIndex(layerId);
	      let z = maxZ - cells.length + 1;
	      const layerCells = graph.getLayer(layerId).cellCollection.toArray();
	      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== layerCells.length - cells.length;
	      if (!shouldUpdate) {
	        shouldUpdate = sortedCells.some(function (cell, index) {
	          return cell.z() !== z + index;
	        });
	      }
	      if (shouldUpdate) {
	        this.startBatch('to-front');
	        z = z + cells.length;
	        sortedCells.forEach(function (cell, index) {
	          cell.set('z', z + index, opt);
	        });
	        this.stopBatch('to-front');
	      }
	    }
	    return this;
	  },
	  toBack: function (opt) {
	    const {
	      graph
	    } = this;
	    if (graph) {
	      opt = defaults(opt || {}, {
	        foregroundEmbeds: true
	      });
	      let cells;
	      if (opt.deep) {
	        cells = this.getEmbeddedCells({
	          deep: true,
	          breadthFirst: opt.breadthFirst !== false,
	          sortSiblings: opt.foregroundEmbeds
	        });
	        cells.unshift(this);
	      } else {
	        cells = [this];
	      }
	      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());
	      const layerId = graph.getCellLayerId(this);
	      let z = graph.minZIndex(layerId);
	      const layerCells = graph.getLayer(layerId).cellCollection.toArray();
	      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== 0;
	      if (!shouldUpdate) {
	        shouldUpdate = sortedCells.some(function (cell, index) {
	          return cell.z() !== z + index;
	        });
	      }
	      if (shouldUpdate) {
	        this.startBatch('to-back');
	        z -= cells.length;
	        sortedCells.forEach(function (cell, index) {
	          cell.set('z', z + index, opt);
	        });
	        this.stopBatch('to-back');
	      }
	    }
	    return this;
	  },
	  parent: function (parent, opt) {
	    // getter
	    if (parent === undefined) return this.get('parent');
	    // setter
	    return this.set('parent', parent, opt);
	  },
	  embed: function (cell, opt = {}) {
	    const cells = Array.isArray(cell) ? cell : [cell];
	    if (!this.canEmbed(cells)) {
	      throw new Error('Recursive embedding not allowed.');
	    }
	    if (opt.reparent) {
	      const parents = uniq(cells.map(c => c.getParentCell()));

	      // Unembed cells from their current parents.
	      parents.forEach(parent => {
	        // Cell doesn't have to be embedded.
	        if (!parent) return;

	        // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases
	        // where not all elements of `cells` are embedded in the same parent.
	        parent._unembedCells(cells, opt);
	      });
	    } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {
	      throw new Error('Embedding of already embedded cells is not allowed.');
	    }
	    this._embedCells(cells, opt);
	    return this;
	  },
	  unembed: function (cell, opt) {
	    const cells = Array.isArray(cell) ? cell : [cell];
	    this._unembedCells(cells, opt);
	    return this;
	  },
	  canEmbed: function (cell) {
	    const cells = Array.isArray(cell) ? cell : [cell];
	    return cells.every(c => this !== c && !this.isEmbeddedIn(c));
	  },
	  _embedCells: function (cells, opt) {
	    const batchName = 'embed';
	    this.startBatch(batchName);
	    const embeds = assign([], this.get('embeds'));
	    cells.forEach(cell => {
	      // We keep all element ids after link ids.
	      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);
	      cell.parent(this.id, opt);
	    });
	    this.set('embeds', uniq(embeds), opt);
	    this.stopBatch(batchName);
	  },
	  _unembedCells: function (cells, opt) {
	    const batchName = 'unembed';
	    this.startBatch(batchName);
	    cells.forEach(cell => cell.unset('parent', opt));
	    this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);
	    this.stopBatch(batchName);
	  },
	  getParentCell: function () {
	    // unlike link.source/target, cell.parent stores id directly as a string
	    var parentId = this.parent();
	    var graph = this.graph;
	    return parentId && graph && graph.getCell(parentId) || null;
	  },
	  // Return an array of ancestor cells.
	  // The array is ordered from the parent of the cell
	  // to the most distant ancestor.
	  getAncestors: function () {
	    var ancestors = [];
	    if (!this.graph) {
	      return ancestors;
	    }
	    var parentCell = this.getParentCell();
	    while (parentCell) {
	      ancestors.push(parentCell);
	      parentCell = parentCell.getParentCell();
	    }
	    return ancestors;
	  },
	  getEmbeddedCells: function (opt) {
	    opt = opt || {};

	    // Cell models can only be retrieved when this element is part of a collection.
	    // There is no way this element knows about other cells otherwise.
	    // This also means that calling e.g. `translate()` on an element with embeds before
	    // adding it to a graph does not translate its embeds.
	    if (!this.graph) {
	      return [];
	    }
	    if (opt.deep) {
	      if (opt.breadthFirst) {
	        return this._getEmbeddedCellsBfs(opt.sortSiblings);
	      } else {
	        return this._getEmbeddedCellsDfs(opt.sortSiblings);
	      }
	    }
	    const embeddedIds = this.get('embeds');
	    if (isEmpty(embeddedIds)) {
	      return [];
	    }
	    let cells = embeddedIds.map(this.graph.getCell, this.graph);
	    if (opt.sortSiblings) {
	      cells = sortBy(cells, cell => cell.z());
	    }
	    return cells;
	  },
	  _getEmbeddedCellsBfs: function (sortSiblings) {
	    const cells = [];
	    const queue = [];
	    queue.push(this);
	    while (queue.length > 0) {
	      const current = queue.shift();
	      cells.push(current);
	      const embeddedCells = current.getEmbeddedCells({
	        sortSiblings: sortSiblings
	      });
	      queue.push(...embeddedCells);
	    }
	    cells.shift();
	    return cells;
	  },
	  _getEmbeddedCellsDfs: function (sortSiblings) {
	    const cells = [];
	    const stack = [];
	    stack.push(this);
	    while (stack.length > 0) {
	      const current = stack.pop();
	      cells.push(current);
	      const embeddedCells = current.getEmbeddedCells({
	        sortSiblings: sortSiblings
	      });

	      // When using the stack, cells that are embedded last are processed first.
	      // To maintain the original order, we need to push the cells in reverse order
	      for (let i = embeddedCells.length - 1; i >= 0; --i) {
	        stack.push(embeddedCells[i]);
	      }
	    }
	    cells.shift();
	    return cells;
	  },
	  isEmbeddedIn: function (cell, opt) {
	    var cellId = isString(cell) ? cell : cell.id;
	    var parentId = this.parent();
	    opt = assign({
	      deep: true
	    }, opt);

	    // See getEmbeddedCells().
	    if (this.graph && opt.deep) {
	      while (parentId) {
	        if (parentId === cellId) {
	          return true;
	        }
	        parentId = this.graph.getCell(parentId).parent();
	      }
	      return false;
	    } else {
	      // When this cell is not part of a collection check
	      // at least whether it's a direct child of given cell.
	      return parentId === cellId;
	    }
	  },
	  // Whether or not the cell is embedded in any other cell.
	  isEmbedded: function () {
	    return !!this.parent();
	  },
	  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).
	  // Shallow cloning simply clones the cell and returns a new cell with different ID.
	  // Deep cloning clones the cell and all its embedded cells recursively.
	  clone: function (opt) {
	    opt = opt || {};
	    if (!opt.deep) {
	      // Shallow cloning.

	      // Preserve the original's `portLayoutNamespace` and `portLabelLayoutNamespace`.
	      const clone = new this.constructor(this.attributes, {
	        portLayoutNamespace: this.portLayoutNamespace,
	        portLabelLayoutNamespace: this.portLabelLayoutNamespace
	      });
	      // We don't want the clone to have the same ID as the original.
	      clone.set(this.getIdAttribute(), this.generateId());
	      // A shallow cloned element does not carry over the original embeds.
	      clone.unset('embeds');
	      // And can not be embedded in any cell
	      // as the clone is not part of the graph.
	      clone.unset('parent');
	      return clone;
	    } else {
	      // Deep cloning.

	      // For a deep clone, simply call `util.cloneCells()` with the cell and all its embedded cells.
	      return toArray$1(cloneCells([this].concat(this.getEmbeddedCells({
	        deep: true
	      }))));
	    }
	  },
	  // A convenient way to set nested properties.
	  // This method merges the properties you'd like to set with the ones
	  // stored in the cell and makes sure change events are properly triggered.
	  // You can either set a nested property with one object
	  // or use a property path.
	  // The most simple use case is:
	  // `cell.prop('name/first', 'John')` or
	  // `cell.prop({ name: { first: 'John' } })`.
	  // Nested arrays are supported too:
	  // `cell.prop('series/0/data/0/degree', 50)` or
	  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.
	  prop: function (props, value, opt) {
	    var delim = '/';
	    var _isString = isString(props);
	    if (_isString || Array.isArray(props)) {
	      // Get/set an attribute by a special path syntax that delimits
	      // nested objects by the colon character.

	      if (arguments.length > 1) {
	        var path;
	        var pathArray;
	        if (_isString) {
	          path = props;
	          pathArray = path.split('/');
	        } else {
	          path = props.join(delim);
	          pathArray = props.slice();
	        }
	        var property = pathArray[0];
	        var pathArrayLength = pathArray.length;
	        const options = opt || {};
	        options.propertyPath = path;
	        options.propertyValue = value;
	        options.propertyPathArray = pathArray;
	        if (!('rewrite' in options)) {
	          options.rewrite = false;
	        }
	        var update = {};
	        // Initialize the nested object. Sub-objects are either arrays or objects.
	        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.
	        // Note that this imposes a limitation on object keys one can use with Inspector.
	        // Pure integer keys will cause issues and are therefore not allowed.
	        var initializer = update;
	        var prevProperty = property;
	        for (var i = 1; i < pathArrayLength; i++) {
	          var pathItem = pathArray[i];
	          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);
	          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};
	          prevProperty = pathItem;
	        }

	        // Fill update with the `value` on `path`.
	        update = setByPath(update, pathArray, value, '/');
	        var baseAttributes = merge({}, this.attributes);
	        // if rewrite mode enabled, we replace value referenced by path with
	        // the new one (we don't merge).
	        options.rewrite && unsetByPath(baseAttributes, path, '/');

	        // Merge update with the model attributes.
	        var attributes = merge(baseAttributes, update, config$3.cellMergeStrategy);
	        // Finally, set the property to the updated attributes.
	        return this.set(property, attributes[property], options);
	      } else {
	        return getByPath(this.attributes, props, delim);
	      }
	    }
	    const options = value || {};
	    // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.
	    options.propertyPath = null;
	    options.propertyValue = props;
	    options.propertyPathArray = [];
	    if (!('rewrite' in options)) {
	      options.rewrite = false;
	    }

	    // Create a new object containing only the changed attributes.
	    const changedAttributes = {};
	    for (const key in props) {
	      // Merging the values of changed attributes with the current ones.
	      const {
	        changedValue
	      } = merge(merge({}, {
	        changedValue: this.attributes[key]
	      }), {
	        changedValue: props[key]
	      }, config$3.cellMergeStrategy);
	      changedAttributes[key] = changedValue;
	    }
	    return this.set(changedAttributes, options);
	  },
	  // A convenient way to unset nested properties
	  removeProp: function (path, opt) {
	    opt = opt || {};
	    var pathArray = Array.isArray(path) ? path : path.split('/');

	    // Once a property is removed from the `attrs` attribute
	    // the cellView will recognize a `dirty` flag and re-render itself
	    // in order to remove the attribute from SVG element.
	    var property = pathArray[0];
	    if (property === 'attrs') opt.dirty = true;
	    if (pathArray.length === 1) {
	      // A top level property
	      return this.unset(path, opt);
	    }

	    // A nested property
	    var nestedPath = pathArray.slice(1);
	    var propertyValue = this.get(property);
	    if (propertyValue === undefined || propertyValue === null) return this;
	    propertyValue = cloneDeep(propertyValue);
	    unsetByPath(propertyValue, nestedPath, '/');
	    return this.set(property, propertyValue, opt);
	  },
	  // A convenient way to set nested attributes.
	  attr: function (attrs, value, opt) {
	    var args = Array.from(arguments);
	    if (args.length === 0) {
	      return this.get('attrs');
	    }
	    if (Array.isArray(attrs)) {
	      args[0] = ['attrs'].concat(attrs);
	    } else if (isString(attrs)) {
	      // Get/set an attribute by a special path syntax that delimits
	      // nested objects by the colon character.
	      args[0] = 'attrs/' + attrs;
	    } else {
	      args[0] = {
	        'attrs': attrs
	      };
	    }
	    return this.prop.apply(this, args);
	  },
	  // A convenient way to unset nested attributes
	  removeAttr: function (path, opt) {
	    if (Array.isArray(path)) {
	      return this.removeProp(['attrs'].concat(path));
	    }
	    return this.removeProp('attrs/' + path, opt);
	  },
	  transition: function (path, value, opt, delim) {
	    delim = delim || '/';
	    var defaults = {
	      duration: 100,
	      delay: 10,
	      timingFunction: timing.linear,
	      valueFunction: interpolate.number
	    };
	    opt = assign(defaults, opt);
	    var firstFrameTime = 0;
	    var interpolatingFunction;
	    const transitionKey = Array.isArray(path) ? path.join(delim) : path;
	    var setter = function (runtime) {
	      var id, progress, propertyValue;
	      firstFrameTime = firstFrameTime || runtime;
	      runtime -= firstFrameTime;
	      progress = runtime / opt.duration;
	      if (progress < 1) {
	        this._transitionIds[transitionKey] = id = nextFrame(setter);
	      } else {
	        progress = 1;
	        delete this._transitionIds[transitionKey];
	      }
	      propertyValue = interpolatingFunction(opt.timingFunction(progress));
	      opt.transitionId = id;
	      this.prop(path, propertyValue, opt);
	      if (!id) this.trigger('transition:end', this, transitionKey);
	    }.bind(this);
	    const {
	      _scheduledTransitionIds
	    } = this;
	    let initialId;
	    var initiator = callback => {
	      if (_scheduledTransitionIds[transitionKey]) {
	        _scheduledTransitionIds[transitionKey] = without(_scheduledTransitionIds[transitionKey], initialId);
	        if (_scheduledTransitionIds[transitionKey].length === 0) {
	          delete _scheduledTransitionIds[transitionKey];
	        }
	      }
	      this.stopPendingTransitions(path, delim);
	      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);
	      this._transitionIds[transitionKey] = nextFrame(callback);
	      this.trigger('transition:start', this, transitionKey);
	    };
	    initialId = setTimeout(initiator, opt.delay, setter);
	    _scheduledTransitionIds[transitionKey] || (_scheduledTransitionIds[transitionKey] = []);
	    _scheduledTransitionIds[transitionKey].push(initialId);
	    return initialId;
	  },
	  getTransitions: function () {
	    return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));
	  },
	  stopScheduledTransitions: function (path, delim = '/') {
	    const {
	      _scheduledTransitionIds = {}
	    } = this;
	    let transitions = Object.keys(_scheduledTransitionIds);
	    if (path) {
	      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values
	      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);
	      transitions = transitions.filter(key => {
	        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));
	      });
	    }
	    transitions.forEach(key => {
	      const transitionIds = _scheduledTransitionIds[key];
	      // stop the initiator
	      transitionIds.forEach(transitionId => clearTimeout(transitionId));
	      delete _scheduledTransitionIds[key];
	      // Note: we could trigger transition:cancel` event here
	    });
	    return this;
	  },
	  stopPendingTransitions(path, delim = '/') {
	    const {
	      _transitionIds = {}
	    } = this;
	    let transitions = Object.keys(_transitionIds);
	    if (path) {
	      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values
	      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);
	      transitions = transitions.filter(key => {
	        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));
	      });
	    }
	    transitions.forEach(key => {
	      const transitionId = _transitionIds[key];
	      // stop the setter
	      cancelFrame(transitionId);
	      delete _transitionIds[key];
	      this.trigger('transition:end', this, key);
	    });
	  },
	  stopTransitions: function (path, delim = '/') {
	    this.stopScheduledTransitions(path, delim);
	    this.stopPendingTransitions(path, delim);
	    return this;
	  },
	  // A shortcut making it easy to create constructs like the following:
	  // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.
	  addTo: function (graph, opt) {
	    graph.addCell(this, opt);
	    return this;
	  },
	  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`
	  // making it easy to create constructs like the following:
	  // `cell.findView(paper).highlight()`
	  findView: function (paper) {
	    return paper.findViewByModel(this);
	  },
	  isElement: function () {
	    return false;
	  },
	  isLink: function () {
	    return false;
	  },
	  startBatch: function (name, opt) {
	    if (this.graph) {
	      this.graph.startBatch(name, assign({}, opt, {
	        cell: this
	      }));
	    }
	    return this;
	  },
	  stopBatch: function (name, opt) {
	    if (this.graph) {
	      this.graph.stopBatch(name, assign({}, opt, {
	        cell: this
	      }));
	    }
	    return this;
	  },
	  getChangeFlag: function (attributes) {
	    var flag = 0;
	    if (!attributes) return flag;
	    for (var key in attributes) {
	      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;
	      flag |= attributes[key];
	    }
	    return flag;
	  },
	  angle: function () {
	    // To be overridden.
	    return 0;
	  },
	  position: function () {
	    // To be overridden.
	    return new Point(0, 0);
	  },
	  z: function () {
	    return this.get('z') || 0;
	  },
	  getPointFromConnectedLink: function () {
	    // To be overridden
	    return new Point();
	  },
	  getBBox: function () {
	    // To be overridden
	    return new Rect(0, 0, 0, 0);
	  },
	  getCenter: function () {
	    return this.getBBox().center();
	  },
	  getPointRotatedAroundCenter(angle, x, y) {
	    const point = new Point(x, y);
	    if (angle) point.rotate(this.getCenter(), angle);
	    return point;
	  },
	  getAbsolutePointFromRelative(x, y) {
	    // Rotate the position to take the model angle into account
	    return this.getPointRotatedAroundCenter(-this.angle(),
	    // Transform the relative position to absolute
	    this.position().offset(x, y));
	  },
	  getRelativePointFromAbsolute(x, y) {
	    return this
	    // Rotate the coordinates to mitigate the element's rotation.
	    .getPointRotatedAroundCenter(this.angle(), x, y)
	    // Transform the absolute position into relative
	    .difference(this.position());
	  },
	  layer: function (layerId, opt) {
	    const layerAttribute = config$3.layerAttribute;

	    // Getter:

	    // If `undefined` return the current layer ID
	    if (layerId === undefined) {
	      return this.get(layerAttribute) || null;
	    }

	    // Setter:

	    // If strictly `null` unset the layer
	    if (layerId === null) {
	      return this.unset(layerAttribute, opt);
	    }

	    // Otherwise set the layer ID
	    if (!isString(layerId)) {
	      throw new Error('dia.Cell: Layer id must be a string.');
	    }
	    return this.set(layerAttribute, layerId, opt);
	  }
	}, {
	  getAttributeDefinition: function (attrName) {
	    const defNS = this.attributes;
	    const globalDefNS = attributes;
	    const definition = defNS && defNS[attrName] || globalDefNS[attrName];
	    return definition !== undefined ? definition : null;
	  },
	  define: function (type, defaults, protoProps, staticProps) {
	    protoProps = assign({
	      defaults: defaultsDeep({
	        type: type
	      }, defaults, this.prototype.defaults)
	    }, protoProps);
	    var Cell = this.extend(protoProps, staticProps);
	    // es5 backward compatibility
	    /* eslint-disable no-undef */
	    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {
	      setByPath(joint.shapes, type, Cell, '.');
	    }
	    /* eslint-enable no-undef */
	    return Cell;
	  }
	});
	Object.defineProperty(Cell.prototype, CELL_MARKER, {
	  value: true
	});

	const wrapWith = function (object, methods, wrapper) {
	  if (isString(wrapper)) {
	    if (!wrappers[wrapper]) {
	      throw new Error('Unknown wrapper: "' + wrapper + '"');
	    }
	    wrapper = wrappers[wrapper];
	  }
	  if (!isFunction(wrapper)) {
	    throw new Error('Wrapper must be a function.');
	  }
	  toArray$1(methods).forEach(function (method) {
	    object[method] = wrapper(object[method]);
	  });
	};
	const wrappers = {
	  cells: function (fn) {
	    return function () {
	      var args = Array.from(arguments);
	      var n = args.length;
	      var cells = n > 0 && args[0] || [];
	      var opt = n > 1 && args[n - 1] || {};
	      if (!Array.isArray(cells)) {
	        if (opt instanceof Cell) {
	          cells = args;
	        } else if (cells instanceof Cell) {
	          if (args.length > 1) {
	            args.pop();
	          }
	          cells = args;
	        }
	      }
	      if (opt instanceof Cell) {
	        opt = {};
	      }
	      return fn.call(this, cells, opt);
	    };
	  }
	};

	function svg(strings, ...expressions) {
	  const svgParts = [];
	  strings.forEach((part, index) => {
	    svgParts.push(part);
	    if (index in expressions) {
	      svgParts.push(expressions[index]);
	    }
	  });
	  const markup = parseFromSVGString(svgParts.join(''));
	  return markup;
	}
	function parseFromSVGString(str) {
	  const parser = new DOMParser();
	  const markupString = `<svg>${str.trim()}</svg>`;
	  const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');
	  if (xmldocument.getElementsByTagName('parsererror')[0]) {
	    throw new Error('Invalid SVG markup');
	  }
	  const document = parser.parseFromString(markupString, 'text/html');
	  const svg = document.querySelector('svg');
	  return build(svg);
	}
	function buildNode(node) {
	  const markupNode = {};
	  const {
	    tagName,
	    attributes,
	    namespaceURI,
	    style,
	    childNodes
	  } = node;
	  markupNode.namespaceURI = namespaceURI;
	  markupNode.tagName = namespaceURI === V.namespace.xhtml
	  // XHTML documents must use lower case for all HTML element and attribute names.
	  // The tagName property returns upper case value for HTML elements.
	  // e.g. <DIV> vs.<div/>
	  ? tagName.toLowerCase() : tagName;
	  const stylesObject = {};
	  for (var i = style.length; i--;) {
	    var nameString = style[i];
	    stylesObject[nameString] = style.getPropertyValue(nameString);
	  }
	  markupNode.style = stylesObject;

	  // selector fallbacks to tagName
	  const selectorAttribute = attributes.getNamedItem('@selector');
	  if (selectorAttribute) {
	    markupNode.selector = selectorAttribute.value;
	    attributes.removeNamedItem('@selector');
	  }
	  const groupSelectorAttribute = attributes.getNamedItem('@group-selector');
	  if (groupSelectorAttribute) {
	    const groupSelectors = groupSelectorAttribute.value.split(',');
	    markupNode.groupSelector = groupSelectors.map(s => s.trim());
	    attributes.removeNamedItem('@group-selector');
	  }
	  const className = attributes.getNamedItem('class');
	  if (className) {
	    markupNode.className = className.value;
	  }
	  const children = [];
	  childNodes.forEach(node => {
	    switch (node.nodeType) {
	      case Node.TEXT_NODE:
	        {
	          const trimmedText = node.data.replace(/\s\s+/g, ' ');
	          if (trimmedText.trim()) {
	            children.push(trimmedText);
	          }
	          break;
	        }
	      case Node.ELEMENT_NODE:
	        {
	          children.push(buildNode(node));
	          break;
	        }
	      default:
	        break;
	    }
	  });
	  if (children.length) {
	    markupNode.children = children;
	  }
	  const nodeAttrs = {};
	  Array.from(attributes).forEach(nodeAttribute => {
	    const {
	      name,
	      value
	    } = nodeAttribute;
	    nodeAttrs[name] = value;
	  });
	  if (Object.keys(nodeAttrs).length > 0) {
	    markupNode.attributes = nodeAttrs;
	  }
	  return markupNode;
	}
	function build(root) {
	  const markup = [];
	  Array.from(root.children).forEach(node => {
	    markup.push(buildNode(node));
	  });
	  return markup;
	}

	const Positions = {
	  TOP: 'top',
	  RIGHT: 'right',
	  BOTTOM: 'bottom',
	  LEFT: 'left',
	  TOP_LEFT: 'top-left',
	  TOP_RIGHT: 'top-right',
	  BOTTOM_LEFT: 'bottom-left',
	  BOTTOM_RIGHT: 'bottom-right',
	  CENTER: 'center'
	};
	function getRectPoint(rect, position) {
	  const r = new Rect(rect);
	  switch (position) {
	    case undefined:
	      throw new Error('Position required');

	    // Middle Points
	    case Positions.LEFT:
	    case 'leftMiddle':
	      return r.leftMiddle();
	    case Positions.RIGHT:
	    case 'rightMiddle':
	      return r.rightMiddle();
	    case Positions.TOP:
	    case 'topMiddle':
	      return r.topMiddle();
	    case Positions.BOTTOM:
	    case 'bottomMiddle':
	      return r.bottomMiddle();

	    // Corners
	    case Positions.TOP_LEFT:
	    case 'topLeft':
	    case 'origin':
	      return r.topLeft();
	    case Positions.TOP_RIGHT:
	    case 'topRight':
	      return r.topRight();
	    case Positions.BOTTOM_LEFT:
	    case 'bottomLeft':
	      return r.bottomLeft();
	    case Positions.BOTTOM_RIGHT:
	    case 'bottomRight':
	    case 'corner':
	      return r.bottomRight();

	    // Center
	    case Positions.CENTER:
	      return r.center();

	    // TODO: calc(), percentage etc.
	    default:
	      throw new Error(`Unknown position: ${position}`);
	  }
	}

	var index$6 = {
		__proto__: null,
		addClassNamePrefix: addClassNamePrefix,
		assign: assign,
		bindAll: bindAll,
		breakText: breakText,
		camelCase: camelCase,
		cancelFrame: cancelFrame,
		cap: cap,
		clone: clone$1,
		cloneCells: cloneCells,
		cloneDeep: cloneDeep,
		dataUriToBlob: dataUriToBlob,
		debounce: debounce,
		deepMixin: deepMixin,
		deepSupplement: deepSupplement,
		defaults: defaults,
		defaultsDeep: defaultsDeep,
		difference: difference,
		downloadBlob: downloadBlob,
		downloadDataUri: downloadDataUri,
		evalCalcExpression: evalCalcExpression,
		evalCalcFormula: evalCalcFormula,
		filter: filter,
		flattenDeep: flattenDeep,
		flattenObject: flattenObject,
		forIn: forIn,
		format: format$1,
		getByPath: getByPath,
		getElementBBox: getElementBBox,
		getRectPoint: getRectPoint,
		groupBy: groupBy,
		guid: guid,
		has: has,
		hashCode: hashCode,
		imageToDataUri: imageToDataUri,
		interpolate: interpolate,
		intersection: intersection,
		invoke: invoke,
		invokeProperty: invokeProperty,
		isBoolean: isBoolean,
		isCalcExpression: isCalcExpression,
		isEmpty: isEmpty,
		isEqual: isEqual,
		isFunction: isFunction,
		isNumber: isNumber,
		isObject: isObject,
		isPercentage: isPercentage,
		isPlainObject: isPlainObject,
		isString: isString,
		merge: merge,
		mixin: mixin,
		nextFrame: nextFrame,
		noop: noop,
		normalizeEvent: normalizeEvent,
		normalizeSides: normalizeSides,
		normalizeWheel: normalizeWheel,
		objectDifference: objectDifference,
		omit: omit,
		parseCssNumeric: parseCssNumeric,
		parseDOMJSON: parseDOMJSON,
		pick: pick,
		removeClassNamePrefix: removeClassNamePrefix,
		result: result,
		sanitizeHTML: sanitizeHTML,
		setAttributesBySelector: setAttributesBySelector,
		setByPath: setByPath,
		sortBy: sortBy,
		sortElements: sortElements,
		sortedIndex: sortedIndex,
		supplement: supplement,
		svg: svg,
		template: template,
		timing: timing,
		toArray: toArray$1,
		toKebabCase: toKebabCase,
		toggleFullScreen: toggleFullScreen,
		union: union,
		uniq: uniq,
		uniqueId: uniqueId,
		unsetByPath: unsetByPath,
		uuid: uuid,
		without: without,
		wrapWith: wrapWith,
		wrappers: wrappers
	};

	function parseCoordinate(coordinate, dimension, bbox, value) {
	  if (isPercentage(value)) {
	    return parseFloat(value) / 100 * bbox[dimension];
	  }
	  if (isCalcExpression(value)) {
	    return Number(evalCalcExpression(value, bbox));
	  }
	  if (typeof value === 'string') {
	    const num = Number(value);
	    if (isNaN(num)) {
	      throw new TypeError(`Cannot convert port coordinate ${coordinate}: "${value}" to a number`);
	    }
	    return num;
	  }
	  return value;
	}
	function portTransformAttrs(point, angle, opt) {
	  var trans = point.toJSON();
	  trans.angle = angle || 0;
	  return defaults({}, opt, trans);
	}
	function lineLayout(ports, p1, p2, elBBox) {
	  return ports.map(function (port, index, ports) {
	    var p = this.pointAt((index + 0.5) / ports.length);
	    // `dx`,`dy` per port offset option
	    if (port.dx || port.dy) {
	      p.offset(port.dx || 0, port.dy || 0);
	    }
	    return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));
	  }, line$1(p1, p2));
	}
	function ellipseLayout(ports, elBBox, startAngle, stepFn) {
	  var center = elBBox.center();
	  var ratio = elBBox.width / elBBox.height;
	  var p1 = elBBox.topMiddle();
	  var ellipse = Ellipse$1.fromRect(elBBox);
	  return ports.map(function (port, index, ports) {
	    var angle = startAngle + stepFn(index, ports.length);
	    var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);
	    var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;

	    // `dx`,`dy` per port offset option
	    if (port.dx || port.dy) {
	      p2.offset(port.dx || 0, port.dy || 0);
	    }

	    // `dr` delta radius option
	    if (port.dr) {
	      p2.move(center, port.dr);
	    }
	    return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));
	  });
	}
	function argTransform(bbox, args) {
	  let {
	    x,
	    y,
	    angle
	  } = args;
	  return {
	    x: parseCoordinate('x', 'width', bbox, x),
	    y: parseCoordinate('y', 'height', bbox, y),
	    angle
	  };
	}

	// Creates a point stored in arguments
	function argPoint(bbox, args) {
	  const {
	    x,
	    y
	  } = argTransform(bbox, args);
	  return new Point(x || 0, y || 0);
	}

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const absolute = function (ports, elBBox, opt) {
	  return ports.map(port => {
	    const transformation = argPoint(elBBox, port).round().toJSON();
	    transformation.angle = port.angle || 0;
	    return transformation;
	  });
	};

	/**
	 * @deprecated
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const fn = function (ports, elBBox, opt) {
	  return opt.fn(ports, elBBox, opt);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const line = function (ports, elBBox, opt) {
	  var start = argPoint(elBBox, opt.start || elBBox.origin());
	  var end = argPoint(elBBox, opt.end || elBBox.corner());
	  return lineLayout(ports, start, end, elBBox);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const left$2 = function (ports, elBBox, opt) {
	  return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const right$2 = function (ports, elBBox, opt) {
	  return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const top$2 = function (ports, elBBox, opt) {
	  return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt opt Group options
	 * @returns {Array<g.Point>}
	 */
	const bottom$2 = function (ports, elBBox, opt) {
	  return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt Group options
	 * @returns {Array<g.Point>}
	 */
	const ellipseSpread = function (ports, elBBox, opt) {
	  var startAngle = opt.startAngle || 0;
	  var stepAngle = opt.step || 360 / ports.length;
	  return ellipseLayout(ports, elBBox, startAngle, function (index) {
	    return index * stepAngle;
	  });
	};

	/**
	 * @param {Array<Object>} ports
	 * @param {g.Rect} elBBox
	 * @param {Object=} opt Group options
	 * @returns {Array<g.Point>}
	 */
	const ellipse = function (ports, elBBox, opt) {
	  var startAngle = opt.startAngle || 0;
	  var stepAngle = opt.step || 20;
	  return ellipseLayout(ports, elBBox, startAngle, function (index, count) {
	    return (index + 0.5 - count / 2) * stepAngle;
	  });
	};

	var Port = {
		__proto__: null,
		absolute: absolute,
		bottom: bottom$2,
		ellipse: ellipse,
		ellipseSpread: ellipseSpread,
		fn: fn,
		left: left$2,
		line: line,
		right: right$2,
		top: top$2
	};

	function labelAttributes(opt1, opt2) {
	  // use value from `opt2` if it is missing in `opt1`
	  // use value from this object if it is missing in `opt2` as well
	  return defaultsDeep({}, opt1, opt2, {
	    x: 0,
	    y: 0,
	    angle: 0,
	    attrs: {}
	  });
	}
	function getBBoxAngles(elBBox) {
	  var center = elBBox.center();
	  var tl = center.theta(elBBox.origin());
	  var bl = center.theta(elBBox.bottomLeft());
	  var br = center.theta(elBBox.corner());
	  var tr = center.theta(elBBox.topRight());
	  return [tl, tr, br, bl];
	}
	function outsideLayout(portPosition, elBBox, autoOrient, opt) {
	  opt = defaults({}, opt, {
	    offset: 15
	  });
	  var angle = elBBox.center().theta(portPosition);
	  var tx, ty, y, textAnchor;
	  var offset = opt.offset;
	  var orientAngle = 0;
	  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
	  if (angle < bottomLeftAngle || angle > bottomRightAngle) {
	    y = '.3em';
	    tx = offset;
	    ty = 0;
	    textAnchor = 'start';
	  } else if (angle < topLeftAngle) {
	    tx = 0;
	    ty = -offset;
	    if (autoOrient) {
	      orientAngle = -90;
	      textAnchor = 'start';
	      y = '.3em';
	    } else {
	      textAnchor = 'middle';
	      y = '0';
	    }
	  } else if (angle < topRightAngle) {
	    y = '.3em';
	    tx = -offset;
	    ty = 0;
	    textAnchor = 'end';
	  } else {
	    tx = 0;
	    ty = offset;
	    if (autoOrient) {
	      orientAngle = 90;
	      textAnchor = 'start';
	      y = '.3em';
	    } else {
	      textAnchor = 'middle';
	      y = '.6em';
	    }
	  }
	  var round = Math.round;
	  return labelAttributes(opt, {
	    x: round(tx),
	    y: round(ty),
	    angle: orientAngle,
	    attrs: {
	      labelText: {
	        y,
	        textAnchor
	      }
	    }
	  });
	}
	function insideLayout(portPosition, elBBox, autoOrient, opt) {
	  opt = defaults({}, opt, {
	    offset: 15
	  });
	  var angle = elBBox.center().theta(portPosition);
	  var tx, ty, y, textAnchor;
	  var offset = opt.offset;
	  var orientAngle = 0;
	  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
	  if (angle < bottomLeftAngle || angle > bottomRightAngle) {
	    y = '.3em';
	    tx = -offset;
	    ty = 0;
	    textAnchor = 'end';
	  } else if (angle < topLeftAngle) {
	    tx = 0;
	    ty = offset;
	    if (autoOrient) {
	      orientAngle = 90;
	      textAnchor = 'start';
	      y = '.3em';
	    } else {
	      textAnchor = 'middle';
	      y = '.6em';
	    }
	  } else if (angle < topRightAngle) {
	    y = '.3em';
	    tx = offset;
	    ty = 0;
	    textAnchor = 'start';
	  } else {
	    tx = 0;
	    ty = -offset;
	    if (autoOrient) {
	      orientAngle = -90;
	      textAnchor = 'start';
	      y = '.3em';
	    } else {
	      textAnchor = 'middle';
	      y = '0';
	    }
	  }
	  var round = Math.round;
	  return labelAttributes(opt, {
	    x: round(tx),
	    y: round(ty),
	    angle: orientAngle,
	    attrs: {
	      labelText: {
	        y,
	        textAnchor
	      }
	    }
	  });
	}
	function radialLayout(portCenterOffset, autoOrient, opt) {
	  opt = defaults({}, opt, {
	    offset: 20
	  });
	  var origin = point(0, 0);
	  var angle = -portCenterOffset.theta(origin);
	  var orientAngle = angle;
	  var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();
	  var y = '.3em';
	  var textAnchor;
	  if ((angle + 90) % 180 === 0) {
	    textAnchor = autoOrient ? 'end' : 'middle';
	    if (!autoOrient && angle === -270) {
	      y = '0em';
	    }
	  } else if (angle > -270 && angle < -90) {
	    textAnchor = 'start';
	    orientAngle = angle - 180;
	  } else {
	    textAnchor = 'end';
	  }
	  var round = Math.round;
	  return labelAttributes(opt, {
	    x: round(offset.x),
	    y: round(offset.y),
	    angle: autoOrient ? orientAngle : 0,
	    attrs: {
	      labelText: {
	        y,
	        textAnchor
	      }
	    }
	  });
	}
	const manual = function (portPosition, elBBox, opt) {
	  return labelAttributes(opt);
	};
	const left$1 = function (portPosition, elBBox, opt) {
	  return labelAttributes(opt, {
	    x: -15,
	    attrs: {
	      labelText: {
	        y: '.3em',
	        textAnchor: 'end'
	      }
	    }
	  });
	};
	const right$1 = function (portPosition, elBBox, opt) {
	  return labelAttributes(opt, {
	    x: 15,
	    attrs: {
	      labelText: {
	        y: '.3em',
	        textAnchor: 'start'
	      }
	    }
	  });
	};
	const top$1 = function (portPosition, elBBox, opt) {
	  return labelAttributes(opt, {
	    y: -15,
	    attrs: {
	      labelText: {
	        y: '0',
	        textAnchor: 'middle'
	      }
	    }
	  });
	};
	const bottom$1 = function (portPosition, elBBox, opt) {
	  return labelAttributes(opt, {
	    y: 15,
	    attrs: {
	      labelText: {
	        y: '.6em',
	        textAnchor: 'middle'
	      }
	    }
	  });
	};
	const outsideOriented = function (portPosition, elBBox, opt) {
	  return outsideLayout(portPosition, elBBox, true, opt);
	};
	const outside = function (portPosition, elBBox, opt) {
	  return outsideLayout(portPosition, elBBox, false, opt);
	};
	const insideOriented = function (portPosition, elBBox, opt) {
	  return insideLayout(portPosition, elBBox, true, opt);
	};
	const inside = function (portPosition, elBBox, opt) {
	  return insideLayout(portPosition, elBBox, false, opt);
	};
	const radial = function (portPosition, elBBox, opt) {
	  return radialLayout(portPosition.difference(elBBox.center()), false, opt);
	};
	const radialOriented = function (portPosition, elBBox, opt) {
	  return radialLayout(portPosition.difference(elBBox.center()), true, opt);
	};

	var PortLabel = {
		__proto__: null,
		bottom: bottom$1,
		inside: inside,
		insideOriented: insideOriented,
		left: left$1,
		manual: manual,
		outside: outside,
		outsideOriented: outsideOriented,
		radial: radial,
		radialOriented: radialOriented,
		right: right$1,
		top: top$1
	};

	const DEFAULT_PORT_POSITION_NAME = 'left';
	const DEFAULT_ABSOLUTE_PORT_POSITION_NAME = 'absolute';
	const DEFAULT_PORT_LABEL_POSITION_NAME = 'left';
	const PortData = function (model) {
	  const {
	    portLayoutNamespace = Port,
	    portLabelLayoutNamespace = PortLabel
	  } = model;
	  const clonedData = cloneDeep(model.get('ports')) || {};
	  this.ports = [];
	  this.portsMap = {};
	  this.groups = {};
	  this.portLayoutNamespace = portLayoutNamespace;
	  this.portLabelLayoutNamespace = portLabelLayoutNamespace;
	  this.metrics = {};
	  this.metricsKey = null;
	  this._init(clonedData);
	};
	PortData.prototype = {
	  hasPort: function (id) {
	    return id in this.portsMap;
	  },
	  getPort: function (id) {
	    const port = this.portsMap[id];
	    if (port) return port;
	    throw new Error('Element: unable to find port with id ' + id);
	  },
	  getPorts: function () {
	    return this.ports;
	  },
	  getGroup: function (name) {
	    return this.groups[name] || {};
	  },
	  getPortsByGroup: function (groupName) {
	    return this.ports.filter(function (port) {
	      return port.group === groupName;
	    });
	  },
	  // Calculate SVG transformations based on evaluated group + port data
	  // NOTE: This function is also called for ports without a group (groupName = undefined)
	  getGroupPortsMetrics: function (groupName, rect) {
	    const {
	      x = 0,
	      y = 0,
	      width = 0,
	      height = 0
	    } = rect;
	    const metricsKey = `${x}:${y}:${width}:${height}`;
	    if (this.metricsKey !== metricsKey) {
	      // Clear the cache (the element size has changed)
	      this.metrics = {};
	      this.metricsKey = metricsKey;
	    }
	    let groupPortsMetrics = this.metrics[groupName];
	    if (groupPortsMetrics) {
	      // Return cached metrics
	      return groupPortsMetrics;
	    }

	    // Calculate the metrics
	    groupPortsMetrics = this.resolveGroupPortsMetrics(groupName, new Rect(x, y, width, height));
	    this.metrics[groupName] = groupPortsMetrics;
	    return groupPortsMetrics;
	  },
	  resolveGroupPortsMetrics: function (groupName, elBBox) {
	    // `groupName` of `undefined` (= not a string) means "the group of ports which do not have the `group` property".
	    const isNoGroup = groupName === undefined;
	    const group = this.getGroup(groupName);
	    const ports = this.getPortsByGroup(groupName);
	    const portsArgs = ports.map(function (port) {
	      return port && port.position && port.position.args;
	    });

	    // Get an array of transformations of individual ports according to the group's port layout function:
	    let groupPortTransformations;
	    if (isNoGroup) {
	      // Apply default port layout function to the set of ports without `group` property.
	      const noGroup = this._evaluateGroup({});
	      groupPortTransformations = this._getGroupPortTransformations(noGroup, portsArgs, elBBox);
	    } else {
	      groupPortTransformations = this._getGroupPortTransformations(group, portsArgs, elBBox);
	    }
	    let accumulator = {
	      ports: ports,
	      result: {}
	    };

	    // For each individual port transformation, find the information necessary to calculate SVG transformations:
	    toArray$1(groupPortTransformations).reduce((res, portTransformation, index) => {
	      const port = res.ports[index];
	      const portId = port.id;
	      res.result[portId] = {
	        index,
	        portId,
	        portTransformation: portTransformation,
	        labelTransformation: this._getPortLabelTransformation(port, Point(portTransformation), elBBox),
	        portAttrs: port.attrs,
	        portSize: port.size,
	        labelSize: port.label.size
	      };
	      return res;
	    }, accumulator);
	    return accumulator.result;
	  },
	  _getGroupPortTransformations: function (group, portsArgs, elBBox) {
	    const groupPosition = group.position || {};
	    const groupPositionArgs = groupPosition.args || {};
	    const groupPositionLayoutCallback = groupPosition.layoutCallback;
	    return groupPositionLayoutCallback(portsArgs, elBBox, groupPositionArgs);
	  },
	  _getPortLabelTransformation: function (port, portPosition, elBBox) {
	    const portLabelPosition = port.label.position || {};
	    const portLabelPositionArgs = portLabelPosition.args || {};
	    const portLabelPositionLayoutCallback = portLabelPosition.layoutCallback;
	    if (portLabelPositionLayoutCallback) {
	      return portLabelPositionLayoutCallback(portPosition, elBBox, portLabelPositionArgs);
	    }
	    return null;
	  },
	  _init: function (data) {
	    // Prepare groups:
	    // NOTE: This overwrites passed group properties with evaluated group properties.
	    if (isObject(data.groups)) {
	      var groups = Object.keys(data.groups);
	      for (var i = 0, n = groups.length; i < n; i++) {
	        var key = groups[i];
	        this.groups[key] = this._evaluateGroup(data.groups[key]);
	      }
	    }

	    // Prepare ports:
	    // NOTE: This overwrites passed port properties with evaluated port properties, plus mixed-in evaluated group properties (see above).
	    var ports = toArray$1(data.items);
	    for (var j = 0, m = ports.length; j < m; j++) {
	      const resolvedPort = this._evaluatePort(ports[j]);
	      this.ports.push(resolvedPort);
	      this.portsMap[resolvedPort.id] = resolvedPort;
	    }
	  },
	  _evaluateGroup: function (group) {
	    return merge({}, group, {
	      position: this._evaluateGroupPositionProperty(group),
	      label: this._evaluateGroupLabelProperty(group)
	    });
	  },
	  _evaluateGroupPositionProperty: function (group) {
	    const namespace = this.portLayoutNamespace;
	    const groupPosition = group.position;
	    if (groupPosition === undefined) {
	      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');
	      return {
	        layoutCallback
	      };
	    } else if (isFunction(groupPosition)) {
	      return {
	        layoutCallback: groupPosition
	      };
	    } else if (isObject(groupPosition)) {
	      if (groupPosition.name) {
	        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition.name, 'Provided port group');
	        return {
	          layoutCallback,
	          args: groupPosition.args
	        };
	      } else {
	        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');
	        return {
	          layoutCallback,
	          args: groupPosition.args
	        };
	      }
	    } else if (isString(groupPosition)) {
	      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).
	      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition, 'Provided port group');
	      return {
	        layoutCallback
	      };
	    } else if (Array.isArray(groupPosition)) {
	      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).
	      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_ABSOLUTE_PORT_POSITION_NAME, 'Default absolute port group');
	      return {
	        layoutCallback,
	        args: {
	          x: groupPosition[0],
	          y: groupPosition[1]
	        }
	      };
	    } else {
	      throw new Error('dia.Element: Provided port group position value has an invalid type.');
	    }
	  },
	  _evaluateGroupLabelProperty: function (group) {
	    const groupLabel = group.label;
	    if (!groupLabel) {
	      return {
	        position: this._evaluateGroupLabelPositionProperty({})
	      };
	    }
	    return merge({}, groupLabel, {
	      position: this._evaluateGroupLabelPositionProperty(groupLabel)
	    });
	  },
	  _evaluateGroupLabelPositionProperty: function (groupLabel) {
	    const namespace = this.portLabelLayoutNamespace;
	    const groupLabelPosition = groupLabel.position;
	    if (groupLabelPosition === undefined) {
	      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');
	      return {
	        layoutCallback
	      };
	    } else if (isFunction(groupLabelPosition)) {
	      return {
	        layoutCallback: groupLabelPosition
	      };
	    } else if (isObject(groupLabelPosition)) {
	      if (groupLabelPosition.name) {
	        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupLabelPosition.name, 'Provided port group label');
	        return {
	          layoutCallback,
	          args: groupLabelPosition.args
	        };
	      } else {
	        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');
	        return {
	          layoutCallback,
	          args: groupLabelPosition.args
	        };
	      }
	    } else {
	      throw new Error('dia.Element: Provided port group label position value has an invalid type.');
	    }
	  },
	  _evaluatePort: function (port) {
	    const group = this.getGroup(port.group);
	    const evaluated = assign({}, port);
	    evaluated.markup = evaluated.markup || group.markup;
	    evaluated.attrs = merge({}, group.attrs, evaluated.attrs);
	    evaluated.position = this._evaluatePortPositionProperty(group, evaluated);
	    evaluated.label = this._evaluatePortLabelProperty(group, evaluated);
	    evaluated.z = this._evaluatePortZProperty(group, evaluated);
	    evaluated.size = assign({}, group.size, evaluated.size);
	    return evaluated;
	  },
	  _evaluatePortPositionProperty: function (group, port) {
	    return {
	      args: merge({},
	      // NOTE: `x != null` is equivalent to `x !== null && x !== undefined`.
	      group.position != null ? group.position.args : {},
	      // Port can overwrite `group.position.args` via `port.position.args` or `port.args`.
	      // TODO: Remove `port.args` backwards compatibility.
	      port.position != null && port.position.args != null ? port.position.args : port.args)
	    };
	  },
	  _evaluatePortLabelProperty: function (group, port) {
	    const groupLabel = group.label;
	    const portLabel = port.label;
	    if (!portLabel) {
	      return assign({}, groupLabel);
	    }
	    return merge({}, groupLabel, merge({}, portLabel, {
	      position: this._evaluatePortLabelPositionProperty(portLabel)
	    }));
	  },
	  _evaluatePortLabelPositionProperty: function (portLabel) {
	    const namespace = this.portLabelLayoutNamespace;
	    const portLabelPosition = portLabel.position;
	    if (portLabelPosition === undefined) {
	      return {};
	    } else if (isFunction(portLabelPosition)) {
	      return {
	        layoutCallback: portLabelPosition
	      };
	    } else if (isObject(portLabelPosition)) {
	      if (portLabelPosition.name) {
	        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, portLabelPosition.name, 'Provided port label');
	        return {
	          layoutCallback,
	          args: portLabelPosition.args
	        };
	      } else {
	        return {
	          args: portLabelPosition.args
	        };
	      }
	    } else {
	      throw new Error('dia.Element: Provided port label position value has an invalid type.');
	    }
	  },
	  _evaluatePortZProperty: function (group, port) {
	    if (isNumber(port.z)) {
	      return port.z;
	    }
	    if (isNumber(group.z) || group.z === 'auto') {
	      return group.z;
	    }
	    return 'auto';
	  },
	  _resolveLayoutCallbackOrThrow: function (namespace, name, errorSubstring) {
	    const layoutCallback = namespace[name];
	    if (!layoutCallback) {
	      throw new Error(`dia.Element: ${errorSubstring} layout name is not recognized.`);
	    }
	    return layoutCallback;
	  }
	};
	const elementPortPrototype = {
	  _initializePorts: function (options) {
	    if (options) {
	      // Override port layout namespaces if provided in options
	      if (options.portLayoutNamespace) {
	        this.portLayoutNamespace = options.portLayoutNamespace;
	      }
	      // Override port label layout namespaces if provided in options
	      if (options.portLabelLayoutNamespace) {
	        this.portLabelLayoutNamespace = options.portLabelLayoutNamespace;
	      }
	    }
	    this._createPortData();
	    this.on('change:ports', function () {
	      this._processRemovedPort();
	      this._createPortData();
	    }, this);
	  },
	  /**
	   * remove links tied wiht just removed element
	   * @private
	   */
	  _processRemovedPort: function () {
	    var current = this.get('ports') || {};
	    var currentItemsMap = {};
	    toArray$1(current.items).forEach(function (item) {
	      currentItemsMap[item.id] = true;
	    });
	    var previous = this.previous('ports') || {};
	    var removed = {};
	    toArray$1(previous.items).forEach(function (item) {
	      if (!currentItemsMap[item.id]) {
	        removed[item.id] = true;
	      }
	    });
	    var graph = this.graph;
	    if (graph && !isEmpty(removed)) {
	      var inboundLinks = graph.getConnectedLinks(this, {
	        inbound: true
	      });
	      inboundLinks.forEach(function (link) {
	        if (removed[link.get('target').port]) link.remove();
	      });
	      var outboundLinks = graph.getConnectedLinks(this, {
	        outbound: true
	      });
	      outboundLinks.forEach(function (link) {
	        if (removed[link.get('source').port]) link.remove();
	      });
	    }
	  },
	  /**
	   * @returns {boolean}
	   */
	  hasPorts: function () {
	    return this._portSettingsData.getPorts().length > 0;
	  },
	  /**
	   * @param {string} id
	   * @returns {boolean}
	   */
	  hasPort: function (id) {
	    return this._portSettingsData.hasPort(id);
	  },
	  /**
	   * @returns {Array<object>}
	   */
	  getPorts: function () {
	    return cloneDeep(this.prop('ports/items')) || [];
	  },
	  /**
	   * @returns {Array<object>}
	   */
	  getGroupPorts: function (groupName) {
	    const groupPorts = toArray$1(this.prop(['ports', 'items'])).filter(port => port.group === groupName);
	    return cloneDeep(groupPorts);
	  },
	  /**
	   * @param {string} id
	   * @returns {object}
	   */
	  getPort: function (id) {
	    const port = toArray$1(this.prop('ports/items')).find(port => port.id && port.id === id);
	    return cloneDeep(port);
	  },
	  getPortGroupNames: function () {
	    return Object.keys(this._portSettingsData.groups);
	  },
	  /**
	   * @param {string} groupName
	   * @returns {Object<portId, {x: number, y: number, angle: number}>}
	   */
	  getPortsPositions: function (groupName) {
	    const portsMetrics = this.getGroupPortsMetrics(groupName);
	    const portsPosition = {};
	    for (const portId in portsMetrics) {
	      const {
	        portTransformation: {
	          x,
	          y,
	          angle
	        }
	      } = portsMetrics[portId];
	      portsPosition[portId] = {
	        x: x,
	        y: y,
	        angle
	      };
	    }
	    return portsPosition;
	  },
	  getPortMetrics: function (portId) {
	    const port = this._portSettingsData.getPort(portId);
	    return this.getGroupPortsMetrics(port.group)[portId];
	  },
	  getGroupPortsMetrics: function (groupName) {
	    return this._portSettingsData.getGroupPortsMetrics(groupName, this.size());
	  },
	  getPortRelativePosition: function (portId) {
	    const {
	      portTransformation: {
	        x,
	        y,
	        angle
	      }
	    } = this.getPortMetrics(portId);
	    return {
	      x,
	      y,
	      angle
	    };
	  },
	  getPortRelativeRect(portId) {
	    const {
	      portTransformation: {
	        x,
	        y,
	        angle
	      },
	      portSize: {
	        width,
	        height
	      }
	    } = this.getPortMetrics(portId);
	    const portRect = {
	      x: x - width / 2,
	      y: y - height / 2,
	      width,
	      height,
	      angle
	    };
	    return portRect;
	  },
	  /**
	   * @param {string} portId
	   * @returns {Point}
	   * @description Returns the port center in the graph coordinate system.
	   * The port center is in the graph coordinate system, and the position
	   * already takes into account the element rotation.
	   **/
	  getPortCenter(portId) {
	    const elementBBox = this.getBBox();
	    const portPosition = this.getPortRelativePosition(portId);
	    const portCenter = new Point(portPosition).offset(elementBBox.x, elementBBox.y);
	    const angle = this.angle();
	    if (angle) portCenter.rotate(elementBBox.center(), -angle);
	    return portCenter;
	  },
	  /**
	   * @param {string} portId
	   * @param {object} [opt]
	   * @param {boolean} [opt.rotate] - If true, the port bounding box is rotated
	   * around the port center.
	   * @returns {Rect}
	   * @description Returns the bounding box of the port in the graph coordinate system.
	   * The port center is rotated around the element center, but the port bounding box
	   * is not rotated (unless `opt.rotate` is set to true).
	   */
	  getPortBBox: function (portId, opt) {
	    const portRect = this.getPortRelativeRect(portId);
	    const elementBBox = this.getBBox();
	    // Note: the `angle` property of the `port` is ignore here for now
	    const portBBox = new Rect(portRect);
	    portBBox.offset(elementBBox.x, elementBBox.y);
	    const angle = this.angle();
	    if (angle) {
	      portBBox.moveAroundPoint(elementBBox.center(), -angle);
	    }
	    if (opt && opt.rotate) {
	      portBBox.rotateAroundCenter(angle);
	    }
	    return portBBox;
	  },
	  /**
	   * @param {string|Port} port port id or port
	   * @returns {number} port index
	   */
	  getPortIndex: function (port) {
	    var id = isObject(port) ? port.id : port;
	    if (!this._isValidPortId(id)) {
	      return -1;
	    }
	    return toArray$1(this.prop('ports/items')).findIndex(function (item) {
	      return item.id === id;
	    });
	  },
	  /**
	   * @param {object} port
	   * @param {object} [opt]
	   * @returns {joint.dia.Element}
	   */
	  addPort: function (port, opt) {
	    if (!isObject(port) || Array.isArray(port)) {
	      throw new Error('Element: addPort requires an object.');
	    }
	    var ports = assign([], this.prop('ports/items'));
	    ports.push(port);
	    this.prop('ports/items', ports, opt);
	    return this;
	  },
	  /**
	   * @param {string|Port|number} before
	   * @param {object} port
	   * @param {object} [opt]
	   * @returns {joint.dia.Element}
	   */
	  insertPort: function (before, port, opt) {
	    const index = typeof before === 'number' ? before : this.getPortIndex(before);
	    if (!isObject(port) || Array.isArray(port)) {
	      throw new Error('dia.Element: insertPort requires an object.');
	    }
	    const ports = assign([], this.prop('ports/items'));
	    ports.splice(index, 0, port);
	    this.prop('ports/items', ports, opt);
	    return this;
	  },
	  /**
	   * @param {string} portId
	   * @param {string|object=} path
	   * @param {*=} value
	   * @param {object=} opt
	   * @returns {joint.dia.Element}
	   */
	  portProp: function (portId, path, value, opt) {
	    var index = this.getPortIndex(portId);
	    if (index === -1) {
	      throw new Error('Element: unable to find port with id ' + portId);
	    }
	    var args = Array.prototype.slice.call(arguments, 1);
	    if (Array.isArray(path)) {
	      args[0] = ['ports', 'items', index].concat(path);
	    } else if (isString(path)) {
	      // Get/set an attribute by a special path syntax that delimits
	      // nested objects by the colon character.
	      args[0] = ['ports/items/', index, '/', path].join('');
	    } else {
	      args = ['ports/items/' + index];
	      if (isPlainObject(path)) {
	        args.push(path);
	        args.push(value);
	      }
	    }
	    return this.prop.apply(this, args);
	  },
	  _validatePorts: function () {
	    var portsAttr = this.get('ports') || {};
	    var errorMessages = [];
	    portsAttr = portsAttr || {};
	    var ports = toArray$1(portsAttr.items);
	    ports.forEach(function (p) {
	      if (typeof p !== 'object') {
	        errorMessages.push('Element: invalid port ', p);
	      }
	      if (!this._isValidPortId(p.id)) {
	        p.id = this.generatePortId();
	      }
	    }, this);
	    if (uniq(ports, 'id').length !== ports.length) {
	      errorMessages.push('Element: found id duplicities in ports.');
	    }
	    return errorMessages;
	  },
	  generatePortId: function () {
	    return this.generateId();
	  },
	  /**
	   * @param {string} id port id
	   * @returns {boolean}
	   * @private
	   */
	  _isValidPortId: function (id) {
	    return id !== null && id !== undefined && !isObject(id);
	  },
	  addPorts: function (ports, opt) {
	    if (ports.length) {
	      this.prop('ports/items', assign([], this.prop('ports/items')).concat(ports), opt);
	    }
	    return this;
	  },
	  removePort: function (port, opt) {
	    const options = opt || {};
	    const index = this.getPortIndex(port);
	    if (index !== -1) {
	      const ports = assign([], this.prop(['ports', 'items']));
	      ports.splice(index, 1);
	      options.rewrite = true;
	      this.startBatch('port-remove');
	      this.prop(['ports', 'items'], ports, options);
	      this.stopBatch('port-remove');
	    }
	    return this;
	  },
	  removePorts: function (portsForRemoval, opt) {
	    let options, newPorts;
	    if (Array.isArray(portsForRemoval)) {
	      options = opt || {};
	      if (portsForRemoval.length === 0) return this.this;
	      const currentPorts = assign([], this.prop(['ports', 'items']));
	      newPorts = currentPorts.filter(function (cp) {
	        return !portsForRemoval.some(function (rp) {
	          const rpId = isObject(rp) ? rp.id : rp;
	          return cp.id === rpId;
	        });
	      });
	    } else {
	      options = portsForRemoval || {};
	      newPorts = [];
	    }
	    this.startBatch('port-remove');
	    options.rewrite = true;
	    this.prop(['ports', 'items'], newPorts, options);
	    this.stopBatch('port-remove');
	    return this;
	  },
	  /**
	   * @private
	   */
	  _createPortData: function () {
	    var err = this._validatePorts();
	    if (err.length > 0) {
	      this.set('ports', this.previous('ports'));
	      throw new Error(err.join(' '));
	    }
	    var prevPortData;
	    if (this._portSettingsData) {
	      prevPortData = this._portSettingsData.getPorts();
	    }
	    this._portSettingsData = new PortData(this);
	    var curPortData = this._portSettingsData.getPorts();
	    if (prevPortData) {
	      var added = curPortData.filter(function (item) {
	        if (!prevPortData.find(function (prevPort) {
	          return prevPort.id === item.id;
	        })) {
	          return item;
	        }
	      });
	      var removed = prevPortData.filter(function (item) {
	        if (!curPortData.find(function (curPort) {
	          return curPort.id === item.id;
	        })) {
	          return item;
	        }
	      });
	      if (removed.length > 0) {
	        this.trigger('ports:remove', this, removed);
	      }
	      if (added.length > 0) {
	        this.trigger('ports:add', this, added);
	      }
	    }
	  }
	};
	const elementViewPortPrototype = {
	  portContainerMarkup: 'g',
	  portMarkup: [{
	    tagName: 'circle',
	    selector: 'circle',
	    attributes: {
	      'r': 10,
	      'fill': '#FFFFFF',
	      'stroke': '#000000'
	    }
	  }],
	  portLabelMarkup: [{
	    tagName: 'text',
	    selector: 'text',
	    attributes: {
	      'fill': '#000000'
	    }
	  }],
	  /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */
	  _portElementsCache: null,
	  /**
	   * @private
	   */
	  _initializePorts: function () {
	    this._cleanPortsCache();
	  },
	  /**
	   * @typedef {Object} Port
	   *
	   * @property {string} id
	   * @property {Object} position
	   * @property {Object} label
	   * @property {Object} attrs
	   * @property {string} markup
	   * @property {string} group
	   */

	  /**
	   * @private
	   */
	  _refreshPorts: function () {
	    this._removePorts();
	    this._cleanPortsCache();
	    this._renderPorts();
	  },
	  _cleanPortsCache: function () {
	    this._portElementsCache = {};
	  },
	  /**
	   * @private
	   */
	  _renderPorts: function () {
	    // references to rendered elements without z-index
	    var elementReferences = [];
	    var elem = this._getContainerElement();
	    for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {
	      elementReferences.push(elem.node.childNodes[i]);
	    }
	    var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), 'z');
	    var withoutZKey = 'auto';

	    // render non-z first
	    toArray$1(portsGropsByZ[withoutZKey]).forEach(function (port) {
	      var portElement = this._getPortElement(port);
	      elem.append(portElement);
	      elementReferences.push(portElement);
	    }, this);
	    var groupNames = Object.keys(portsGropsByZ);
	    for (var k = 0; k < groupNames.length; k++) {
	      var groupName = groupNames[k];
	      if (groupName !== withoutZKey) {
	        var z = parseInt(groupName, 10);
	        this._appendPorts(portsGropsByZ[groupName], z, elementReferences);
	      }
	    }
	    this._updatePorts();
	  },
	  /**
	   * @returns {V}
	   * @private
	   */
	  _getContainerElement: function () {
	    return this.rotatableNode || this.vel;
	  },
	  /**
	   * @param {Array<Port>}ports
	   * @param {number} z
	   * @param refs
	   * @private
	   */
	  _appendPorts: function (ports, z, refs) {
	    var containerElement = this._getContainerElement();
	    var portElements = toArray$1(ports).map(this._getPortElement, this);
	    if (refs[z] || z < 0) {
	      V(refs[Math.max(z, 0)]).before(portElements);
	    } else {
	      containerElement.append(portElements);
	    }
	  },
	  /**
	   * Try to get element from cache,
	   * @param port
	   * @returns {*}
	   * @private
	   */
	  _getPortElement: function (port) {
	    if (this._portElementsCache[port.id]) {
	      return this._portElementsCache[port.id].portElement;
	    }
	    return this._createPortElement(port);
	  },
	  findPortNodes: function (portId, selector) {
	    const portCache = this._portElementsCache[portId];
	    if (!portCache) return [];
	    if (!selector) return [portCache.portContentElement.node];
	    const portRoot = portCache.portElement.node;
	    const portSelectors = portCache.portSelectors;
	    return this.findBySelector(selector, portRoot, portSelectors);
	  },
	  findPortNode: function (portId, selector) {
	    const [node = null] = this.findPortNodes(portId, selector);
	    return node;
	  },
	  /**
	   * @private
	   */
	  _updatePorts: function () {
	    // layout ports without group
	    this._updatePortGroup(undefined);
	    // layout ports with explicit group
	    var groupsNames = Object.keys(this.model._portSettingsData.groups);
	    groupsNames.forEach(this._updatePortGroup, this);
	  },
	  /**
	   * @private
	   */
	  _removePorts: function () {
	    invoke(this._portElementsCache, 'portElement.remove');
	  },
	  /**
	   * @param {Port} port
	   * @returns {V}
	   * @private
	   */
	  _createPortElement: function (port) {
	    let portElement;
	    let labelElement;
	    let labelSelectors;
	    let portSelectors;
	    var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');
	    var portMarkup = this._getPortMarkup(port);
	    if (Array.isArray(portMarkup)) {
	      var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);
	      var portFragment = portDoc.fragment;
	      if (portFragment.childNodes.length > 1) {
	        portElement = V('g').append(portFragment);
	      } else {
	        portElement = V(portFragment.firstChild);
	      }
	      portSelectors = portDoc.selectors;
	    } else {
	      portElement = V(portMarkup);
	      if (Array.isArray(portElement)) {
	        portElement = V('g').append(portElement);
	      }
	    }
	    if (!portElement) {
	      throw new Error('ElementView: Invalid port markup.');
	    }
	    portElement.attr({
	      'port': port.id,
	      'port-group': port.group
	    });

	    // If the port ID is a number, we need to add
	    // extra information to the port element to distinguish
	    // between ports with the same ID but different types.
	    if (isNumber(port.id)) {
	      portElement.attr('port-id-type', 'number');
	    }
	    const labelMarkupDef = this._getPortLabelMarkup(port.label);
	    if (Array.isArray(labelMarkupDef)) {
	      // JSON Markup
	      const {
	        fragment,
	        selectors
	      } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);
	      const childCount = fragment.childNodes.length;
	      if (childCount > 0) {
	        labelSelectors = selectors;
	        labelElement = childCount === 1 ? V(fragment.firstChild) : V('g').append(fragment);
	      }
	    } else {
	      // String Markup
	      labelElement = V(labelMarkupDef);
	      if (Array.isArray(labelElement)) {
	        labelElement = V('g').append(labelElement);
	      }
	    }
	    var portContainerSelectors;
	    if (portSelectors && labelSelectors) {
	      for (var key in labelSelectors) {
	        if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');
	      }
	      portContainerSelectors = assign({}, portSelectors, labelSelectors);
	    } else {
	      portContainerSelectors = portSelectors || labelSelectors || {};
	    }

	    // The `portRootSelector` points to the root SVGNode of the port.
	    // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.
	    // Or the single SVGNode of the port.
	    const portRootSelector = 'portRoot';
	    // The `labelRootSelector` points to the root SVGNode of the label.
	    const labelRootSelector = 'labelRoot';
	    // The `labelTextSelector` points to all text SVGNodes of the label.
	    const labelTextSelector = 'labelText';
	    if (!(portRootSelector in portContainerSelectors)) {
	      portContainerSelectors[portRootSelector] = portElement.node;
	    }
	    if (labelElement) {
	      const labelNode = labelElement.node;
	      if (!(labelRootSelector in portContainerSelectors)) {
	        portContainerSelectors[labelRootSelector] = labelNode;
	      }
	      if (!(labelTextSelector in portContainerSelectors)) {
	        // If the label is a <text> element, we can use it directly.
	        // Otherwise, we need to find the <text> element within the label.
	        const labelTextNode = labelElement.tagName() === 'TEXT' ? labelNode : Array.from(labelNode.querySelectorAll('text'));
	        portContainerSelectors[labelTextSelector] = labelTextNode;
	        if (!labelSelectors) labelSelectors = {};
	        labelSelectors[labelTextSelector] = labelTextNode;
	      }
	    }
	    portContainerElement.append(portElement.addClass('joint-port-body'));
	    if (labelElement) {
	      portContainerElement.append(labelElement.addClass('joint-port-label'));
	    }
	    this._portElementsCache[port.id] = {
	      portElement: portContainerElement,
	      portLabelElement: labelElement,
	      portSelectors: portContainerSelectors,
	      portLabelSelectors: labelSelectors,
	      portContentElement: portElement,
	      portContentSelectors: portSelectors
	    };
	    return portContainerElement;
	  },
	  /**
	   * @param {string=} groupName
	   * @private
	   */
	  _updatePortGroup: function (groupName) {
	    const portsMetrics = this.model.getGroupPortsMetrics(groupName);
	    const portsIds = Object.keys(portsMetrics);
	    for (let i = 0, n = portsIds.length; i < n; i++) {
	      const portId = portsIds[i];
	      const metrics = portsMetrics[portId];
	      const cached = this._portElementsCache[portId] || {};
	      const portTransformation = metrics.portTransformation;
	      const labelTransformation = metrics.labelTransformation;
	      if (labelTransformation && cached.portLabelElement) {
	        this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {
	          rootBBox: new Rect(metrics.labelSize),
	          selectors: cached.portLabelSelectors
	        });
	        this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);
	      }
	      this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {
	        rootBBox: new Rect(metrics.portSize),
	        selectors: cached.portSelectors
	      });
	      this.applyPortTransform(cached.portElement, portTransformation);
	    }
	  },
	  /**
	   * @param {Vectorizer} element
	   * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData
	   * @param {number=} initialAngle
	   * @constructor
	   */
	  applyPortTransform: function (element, transformData, initialAngle) {
	    var matrix = V.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);
	    element.transform(matrix, {
	      absolute: true
	    });
	  },
	  /**
	   * @param {Port} port
	   * @returns {string}
	   * @private
	   */
	  _getPortMarkup: function (port) {
	    return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;
	  },
	  /**
	   * @param {Object} label
	   * @returns {string}
	   * @private
	   */
	  _getPortLabelMarkup: function (label) {
	    return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;
	  }
	};

	// Element base model.
	// -----------------------------

	const Element$1 = Cell.extend({
	  defaults: {
	    position: {
	      x: 0,
	      y: 0
	    },
	    size: {
	      width: 1,
	      height: 1
	    },
	    angle: 0
	  },
	  initialize: function (attributes, options) {
	    this._initializePorts(options);
	    Cell.prototype.initialize.apply(this, arguments);
	  },
	  /**
	   * @abstract
	   */
	  _initializePorts: function () {
	    // implemented in ports.js
	  },
	  _refreshPorts: function () {
	    // implemented in ports.js
	  },
	  isElement: function () {
	    return true;
	  },
	  position: function (x, y, opt) {
	    const isSetter = isNumber(y);
	    opt = (isSetter ? opt : x) || {};
	    const {
	      parentRelative,
	      deep,
	      restrictedArea
	    } = opt;

	    // option `parentRelative` for setting the position relative to the element's parent.
	    let parentPosition;
	    if (parentRelative) {
	      // Getting the parent's position requires the collection.
	      // Cell.parent() holds cell id only.
	      if (!this.graph) throw new Error('Element must be part of a graph.');
	      const parent = this.getParentCell();
	      if (parent && !parent.isLink()) {
	        parentPosition = parent.get('position');
	      }
	    }
	    if (isSetter) {
	      if (parentPosition) {
	        x += parentPosition.x;
	        y += parentPosition.y;
	      }
	      if (deep || restrictedArea) {
	        const {
	          x: x0,
	          y: y0
	        } = this.get('position');
	        this.translate(x - x0, y - y0, opt);
	      } else {
	        this.set('position', {
	          x,
	          y
	        }, opt);
	      }
	      return this;
	    } else {
	      // Getter returns a geometry point.

	      const elementPosition = Point(this.get('position'));
	      return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;
	    }
	  },
	  translate: function (tx, ty, opt) {
	    tx = tx || 0;
	    ty = ty || 0;
	    if (tx === 0 && ty === 0) {
	      // Like nothing has happened.
	      return this;
	    }
	    opt = opt || {};
	    // Pass the initiator of the translation.
	    opt.translateBy = opt.translateBy || this.id;
	    var position = this.get('position') || {
	      x: 0,
	      y: 0
	    };
	    var ra = opt.restrictedArea;
	    if (ra && opt.translateBy === this.id) {
	      if (typeof ra === 'function') {
	        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);
	        tx = newPosition.x - position.x;
	        ty = newPosition.y - position.y;
	      } else {
	        // We are restricting the translation for the element itself only. We get
	        // the bounding box of the element including all its embeds.
	        // All embeds have to be translated the exact same way as the element.
	        var bbox = this.getBBox({
	          deep: true
	        });
	        //- - - - - - - - - - - - -> ra.x + ra.width
	        // - - - -> position.x      |
	        // -> bbox.x
	        //                âââââââ   |
	        //         ââââââââââââââ
	        //         âââââââââ        |
	        //   âââââââââââââââ
	        //   ââââââââ               |
	        //   <-dx->                     | restricted area right border
	        //         <-width->        |   â translated element
	        //   <- - bbox.width - ->       â embedded element
	        var dx = position.x - bbox.x;
	        var dy = position.y - bbox.y;
	        // Find the maximal/minimal coordinates that the element can be translated
	        // while complies the restrictions.
	        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
	        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
	        // recalculate the translation taking the restrictions into account.
	        tx = x - position.x;
	        ty = y - position.y;
	      }
	    }
	    var translatedPosition = {
	      x: position.x + tx,
	      y: position.y + ty
	    };

	    // To find out by how much an element was translated in event 'change:position' handlers.
	    opt.tx = tx;
	    opt.ty = ty;
	    if (opt.transition) {
	      if (!isObject(opt.transition)) opt.transition = {};
	      this.transition('position', translatedPosition, assign({}, opt.transition, {
	        valueFunction: interpolate.object
	      }));

	      // Recursively call `translate()` on all the embeds cells.
	      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);
	    } else {
	      this.startBatch('translate', opt);
	      this.set('position', translatedPosition, opt);
	      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);
	      this.stopBatch('translate', opt);
	    }
	    return this;
	  },
	  size: function (width, height, opt) {
	    var currentSize = this.get('size');
	    // Getter
	    // () signature
	    if (width === undefined) {
	      return {
	        width: currentSize.width,
	        height: currentSize.height
	      };
	    }
	    // Setter
	    // (size, opt) signature
	    if (isObject(width)) {
	      opt = height;
	      height = isNumber(width.height) ? width.height : currentSize.height;
	      width = isNumber(width.width) ? width.width : currentSize.width;
	    }
	    return this.resize(width, height, opt);
	  },
	  resize: function (width, height, opt) {
	    opt = opt || {};
	    this.startBatch('resize', opt);
	    if (opt.direction) {
	      var currentSize = this.get('size');
	      switch (opt.direction) {
	        case 'left':
	        case 'right':
	          // Don't change height when resizing horizontally.
	          height = currentSize.height;
	          break;
	        case 'top':
	        case 'bottom':
	          // Don't change width when resizing vertically.
	          width = currentSize.width;
	          break;
	      }

	      // Get the angle and clamp its value between 0 and 360 degrees.
	      var angle = normalizeAngle(this.get('angle') || 0);

	      // This is a rectangle in size of the un-rotated element.
	      var bbox = this.getBBox();
	      var origin;
	      if (angle) {
	        var quadrant = {
	          'top-right': 0,
	          'right': 0,
	          'top-left': 1,
	          'top': 1,
	          'bottom-left': 2,
	          'left': 2,
	          'bottom-right': 3,
	          'bottom': 3
	        }[opt.direction];
	        if (opt.absolute) {
	          // We are taking the element's rotation into account
	          quadrant += Math.floor((angle + 45) / 90);
	          quadrant %= 4;
	        }

	        // Pick the corner point on the element, which meant to stay on its place before and
	        // after the rotation.
	        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();

	        // Find  an image of the previous indent point. This is the position, where is the
	        // point actually located on the screen.
	        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);

	        // Every point on the element rotates around a circle with the centre of rotation
	        // in the middle of the element while the whole element is being rotated. That means
	        // that the distance from a point in the corner of the element (supposed its always rect) to
	        // the center of the element doesn't change during the rotation and therefore it equals
	        // to a distance on un-rotated element.
	        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
	        var radius = Math.sqrt(width * width + height * height) / 2;

	        // Now we are looking for an angle between x-axis and the line starting at image of fixed point
	        // and ending at the center of the element. We call this angle `alpha`.

	        // The image of a fixed point is located in n-th quadrant. For each quadrant passed
	        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.
	        //
	        // 3 | 2
	        // --c-- Quadrant positions around the element's center `c`
	        // 0 | 1
	        //
	        var alpha = quadrant * Math.PI / 2;

	        // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis
	        // going through the center of the element) and line crossing the indent of the fixed point and the center
	        // of the element. This is the angle we need but on the un-rotated element.
	        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);

	        // Lastly we have to deduct the original angle the element was rotated by and that's it.
	        alpha -= toRad(angle);

	        // With this angle and distance we can easily calculate the centre of the un-rotated element.
	        // Note that fromPolar constructor accepts an angle in radians.
	        var center = Point.fromPolar(radius, alpha, imageFixedPoint);

	        // The top left corner on the un-rotated element has to be half a width on the left
	        // and half a height to the top from the center. This will be the origin of rectangle
	        // we were looking for.
	        origin = Point(center).offset(width / -2, height / -2);
	      } else {
	        // calculation for the origin Point when there is no rotation of the element
	        origin = bbox.topLeft();
	        switch (opt.direction) {
	          case 'top':
	          case 'top-right':
	            origin.offset(0, bbox.height - height);
	            break;
	          case 'left':
	          case 'bottom-left':
	            origin.offset(bbox.width - width, 0);
	            break;
	          case 'top-left':
	            origin.offset(bbox.width - width, bbox.height - height);
	            break;
	        }
	      }

	      // Resize the element (before re-positioning it).
	      this.set('size', {
	        width: width,
	        height: height
	      }, opt);

	      // Finally, re-position the element.
	      this.position(origin.x, origin.y, opt);
	    } else {
	      // Resize the element.
	      this.set('size', {
	        width: width,
	        height: height
	      }, opt);
	    }
	    this.stopBatch('resize', opt);
	    return this;
	  },
	  scale: function (sx, sy, origin, opt) {
	    var scaledBBox = this.getBBox().scale(sx, sy, origin);
	    this.startBatch('scale', opt);
	    this.position(scaledBBox.x, scaledBBox.y, opt);
	    this.resize(scaledBBox.width, scaledBBox.height, opt);
	    this.stopBatch('scale');
	    return this;
	  },
	  fitEmbeds: function (opt) {
	    return this.fitToChildren(opt);
	  },
	  fitToChildren: function (opt = {}) {
	    // Getting the children's size and position requires the collection.
	    // Cell.get('embeds') holds an array of cell ids only.
	    const {
	      graph
	    } = this;
	    if (!graph) throw new Error('Element must be part of a graph.');

	    // Get element children, optionally filtered according to `opt.filter`.
	    const filteredChildElements = this._getFilteredChildElements(opt.filter);
	    this.startBatch('fit-embeds', opt);
	    if (opt.deep) {
	      // `opt.deep = true` means "fit to all descendants".
	      // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.
	      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element)
	      // - omit `opt.minRect` - it only makes sense for the first level of recursion if there are no filtered children, but in this case we do have filtered children
	      invoke(filteredChildElements, 'fitToChildren', omit(opt, 'minRect'));
	    }

	    // Set new size and position of this element, based on:
	    // - union of bboxes of filtered element children
	    // - inflated by given `opt.padding`
	    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered children)
	    this._fitToElements(Object.assign({
	      elements: filteredChildElements
	    }, opt));
	    this.stopBatch('fit-embeds');
	    return this;
	  },
	  fitParent: function (opt = {}) {
	    const {
	      graph
	    } = this;
	    if (!graph) throw new Error('Element must be part of a graph.');

	    // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.
	    // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.
	    if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;

	    // If this element has no parent, there is nothing for us to do.
	    const parentElement = this.getParentCell();
	    if (!parentElement || !parentElement.isElement()) return this;

	    // Get element children of parent element (i.e. this element + any sibling elements), optionally filtered according to `opt.filter`.
	    const filteredSiblingElements = parentElement._getFilteredChildElements(opt.filter);
	    this.startBatch('fit-parent', opt);

	    // Set new size and position of parent element, based on:
	    // - union of bboxes of filtered element children of parent element (i.e. this element + any sibling elements)
	    // - inflated by given `opt.padding`
	    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered siblings)
	    parentElement._fitToElements(Object.assign({
	      elements: filteredSiblingElements
	    }, opt));
	    if (opt.deep) {
	      // `opt.deep = true` means "fit all ancestors to their respective children".
	      // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.
	      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up
	      // - omit `opt.minRect` - `minRect` is not relevant for the parent of parent element (and upwards)
	      parentElement.fitParent(omit(opt, 'minRect'));
	    }
	    this.stopBatch('fit-parent');
	    return this;
	  },
	  _getFilteredChildElements: function (filter) {
	    let filterFn;
	    if (typeof filter === 'function') {
	      filterFn = cell => cell.isElement() && filter(cell);
	    } else {
	      filterFn = cell => cell.isElement();
	    }
	    return this.getEmbeddedCells().filter(filterFn);
	  },
	  // Assumption: This element is part of a graph.
	  _fitToElements: function (opt = {}) {
	    let minBBox = null;
	    if (opt.minRect) {
	      // Coerce `opt.minRect` to g.Rect
	      // (missing properties are taken from this element's current bbox).
	      const minRect = assign(this.getBBox(), opt.minRect);
	      minBBox = new Rect(minRect);
	    }
	    const elementsBBox = this.graph.getCellsBBox(opt.elements);
	    // If no `opt.elements` were provided, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).
	    if (!elementsBBox) {
	      this._setBBox(minBBox, opt);
	      return;
	    }
	    const {
	      expandOnly,
	      shrinkOnly
	    } = opt;
	    // This combination is meaningless, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).
	    if (expandOnly && shrinkOnly) {
	      this._setBBox(minBBox, opt);
	      return;
	    }

	    // Calculate new size and position of this element based on:
	    // - union of bboxes of `opt.elements`
	    // - inflated by normalized `opt.padding` (missing sides = 0)
	    let {
	      x,
	      y,
	      width,
	      height
	    } = elementsBBox;
	    const {
	      left,
	      right,
	      top,
	      bottom
	    } = normalizeSides(opt.padding);
	    x -= left;
	    y -= top;
	    width += left + right;
	    height += bottom + top;
	    let contentBBox = new Rect(x, y, width, height);
	    if (expandOnly) {
	      // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.
	      contentBBox = this.getBBox().union(contentBBox);
	    } else if (shrinkOnly) {
	      // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.
	      const intersectionBBox = this.getBBox().intersect(contentBBox);
	      // If all children are outside this element's current bbox, then `intersectionBBox` is `null`.
	      // That does not make sense, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).
	      if (!intersectionBBox) {
	        this._setBBox(minBBox, opt);
	        return;
	      }
	      contentBBox = intersectionBBox;
	    }

	    // Set the new size and position of this element.
	    // - if `opt.minRect` was provided, add it via union to calculated bbox
	    let resultBBox = contentBBox;
	    if (minBBox) {
	      resultBBox = resultBBox.union(minBBox);
	    }
	    this._setBBox(resultBBox, opt);
	  },
	  _setBBox: function (bbox, opt) {
	    if (!bbox) return;
	    const {
	      x,
	      y,
	      width,
	      height
	    } = bbox;
	    this.set({
	      position: {
	        x,
	        y
	      },
	      size: {
	        width,
	        height
	      }
	    }, opt);
	  },
	  // Rotate element by `angle` degrees, optionally around `origin` point.
	  // If `origin` is not provided, it is considered to be the center of the element.
	  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not
	  // the difference from the previous angle.
	  rotate: function (angle, absolute, origin, opt) {
	    if (origin) {
	      var center = this.getCenter();
	      var size = this.get('size');
	      var position = this.get('position');
	      center.rotate(origin, this.get('angle') - angle);
	      var dx = center.x - size.width / 2 - position.x;
	      var dy = center.y - size.height / 2 - position.y;
	      this.startBatch('rotate', {
	        angle: angle,
	        absolute: absolute,
	        origin: origin
	      });
	      this.position(position.x + dx, position.y + dy, opt);
	      this.rotate(angle, absolute, null, opt);
	      this.stopBatch('rotate');
	    } else {
	      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);
	    }
	    return this;
	  },
	  angle: function () {
	    return normalizeAngle(this.get('angle') || 0);
	  },
	  getBBox: function (opt = {}) {
	    const {
	      graph,
	      attributes
	    } = this;
	    const {
	      deep,
	      rotate
	    } = opt;
	    if (deep && graph) {
	      // Get all the embedded elements using breadth first algorithm.
	      const elements = this.getEmbeddedCells({
	        deep: true,
	        breadthFirst: true
	      });
	      // Add the model itself.
	      elements.push(this);
	      // Note: the default of getCellsBBox() is rotate=true and can't be
	      // changed without a breaking change
	      return graph.getCellsBBox(elements, opt);
	    }
	    const {
	      angle = 0,
	      position: {
	        x,
	        y
	      },
	      size: {
	        width,
	        height
	      }
	    } = attributes;
	    const bbox = new Rect(x, y, width, height);
	    if (rotate) {
	      bbox.rotateAroundCenter(angle);
	    }
	    return bbox;
	  },
	  getCenter: function () {
	    const {
	      position: {
	        x,
	        y
	      },
	      size: {
	        width,
	        height
	      }
	    } = this.attributes;
	    return new Point(x + width / 2, y + height / 2);
	  },
	  getPointFromConnectedLink: function (link, endType) {
	    // Center of the model
	    var bbox = this.getBBox();
	    var center = bbox.center();
	    // Center of a port
	    var endDef = link.get(endType);
	    if (!endDef) return center;
	    var portId = endDef.port;
	    if (!portId || !this.hasPort(portId)) return center;
	    return this.getPortCenter(portId);
	  }
	});
	assign(Element$1.prototype, elementPortPrototype);

	// Link base model.
	// --------------------------

	const Link$1 = Cell.extend({
	  // may be overwritten by user to change default label (its markup, size, attrs, position)
	  defaultLabel: undefined,
	  // deprecated
	  // may be overwritten by user to change default label markup
	  // lower priority than defaultLabel.markup
	  labelMarkup: undefined,
	  // private
	  _builtins: {
	    defaultLabel: {
	      // builtin default markup:
	      // used if neither defaultLabel.markup
	      // nor label.markup is set
	      markup: [{
	        tagName: 'rect',
	        selector: 'rect' // faster than tagName CSS selector
	      }, {
	        tagName: 'text',
	        selector: 'text' // faster than tagName CSS selector
	      }],
	      // builtin default attributes:
	      // applied only if builtin default markup is used
	      attrs: {
	        text: {
	          fill: '#000000',
	          fontSize: 14,
	          textAnchor: 'middle',
	          textVerticalAnchor: 'middle',
	          pointerEvents: 'none'
	        },
	        rect: {
	          ref: 'text',
	          fill: '#ffffff',
	          rx: 3,
	          ry: 3,
	          x: 'calc(x)',
	          y: 'calc(y)',
	          width: 'calc(w)',
	          height: 'calc(h)'
	        }
	      },
	      // builtin default position:
	      // used if neither defaultLabel.position
	      // nor label.position is set
	      position: {
	        distance: 0.5
	      }
	    }
	  },
	  defaults: {
	    source: {},
	    target: {}
	  },
	  isLink: function () {
	    return true;
	  },
	  disconnect: function (opt) {
	    return this.set({
	      source: {
	        x: 0,
	        y: 0
	      },
	      target: {
	        x: 0,
	        y: 0
	      }
	    }, opt);
	  },
	  source: function (source, args, opt) {
	    // getter
	    if (source === undefined) {
	      return clone$1(this.get('source'));
	    }

	    // setter
	    var setSource;
	    var setOpt;

	    // `source` is a cell
	    // take only its `id` and combine with `args`
	    var isCellProvided = source instanceof Cell;
	    if (isCellProvided) {
	      // three arguments
	      setSource = clone$1(args) || {};
	      setSource.id = source.id;
	      setOpt = opt;
	      return this.set('source', setSource, setOpt);
	    }

	    // `source` is a point-like object
	    // for example, a g.Point
	    // take only its `x` and `y` and combine with `args`
	    var isPointProvided = !isPlainObject(source);
	    if (isPointProvided) {
	      // three arguments
	      setSource = clone$1(args) || {};
	      setSource.x = source.x;
	      setSource.y = source.y;
	      setOpt = opt;
	      return this.set('source', setSource, setOpt);
	    }

	    // `source` is an object
	    // no checking
	    // two arguments
	    setSource = source;
	    setOpt = args;
	    return this.set('source', setSource, setOpt);
	  },
	  target: function (target, args, opt) {
	    // getter
	    if (target === undefined) {
	      return clone$1(this.get('target'));
	    }

	    // setter
	    var setTarget;
	    var setOpt;

	    // `target` is a cell
	    // take only its `id` argument and combine with `args`
	    var isCellProvided = target instanceof Cell;
	    if (isCellProvided) {
	      // three arguments
	      setTarget = clone$1(args) || {};
	      setTarget.id = target.id;
	      setOpt = opt;
	      return this.set('target', setTarget, setOpt);
	    }

	    // `target` is a point-like object
	    // for example, a g.Point
	    // take only its `x` and `y` and combine with `args`
	    var isPointProvided = !isPlainObject(target);
	    if (isPointProvided) {
	      // three arguments
	      setTarget = clone$1(args) || {};
	      setTarget.x = target.x;
	      setTarget.y = target.y;
	      setOpt = opt;
	      return this.set('target', setTarget, setOpt);
	    }

	    // `target` is an object
	    // no checking
	    // two arguments
	    setTarget = target;
	    setOpt = args;
	    return this.set('target', setTarget, setOpt);
	  },
	  router: function (name, args, opt) {
	    // getter
	    if (name === undefined) {
	      var router = this.get('router');
	      if (!router) {
	        return null;
	      }
	      if (typeof router === 'object') return clone$1(router);
	      return router; // e.g. a function
	    }

	    // setter
	    var isRouterProvided = typeof name === 'object' || typeof name === 'function';
	    var localRouter = isRouterProvided ? name : {
	      name: name,
	      args: args
	    };
	    var localOpt = isRouterProvided ? args : opt;
	    return this.set('router', localRouter, localOpt);
	  },
	  connector: function (name, args, opt) {
	    // getter
	    if (name === undefined) {
	      var connector = this.get('connector');
	      if (!connector) {
	        return null;
	      }
	      if (typeof connector === 'object') return clone$1(connector);
	      return connector; // e.g. a function
	    }

	    // setter
	    var isConnectorProvided = typeof name === 'object' || typeof name === 'function';
	    var localConnector = isConnectorProvided ? name : {
	      name: name,
	      args: args
	    };
	    var localOpt = isConnectorProvided ? args : opt;
	    return this.set('connector', localConnector, localOpt);
	  },
	  // Labels API

	  // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.
	  label: function (idx, label, opt) {
	    var labels = this.labels();
	    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
	    if (idx < 0) idx = labels.length + idx;

	    // getter
	    if (arguments.length <= 1) return this.prop(['labels', idx]);
	    // setter
	    return this.prop(['labels', idx], label, opt);
	  },
	  labels: function (labels, opt) {
	    // getter
	    if (arguments.length === 0) {
	      labels = this.get('labels');
	      if (!Array.isArray(labels)) return [];
	      return labels.slice();
	    }
	    // setter
	    if (!Array.isArray(labels)) labels = [];
	    return this.set('labels', labels, opt);
	  },
	  hasLabels: function () {
	    const {
	      labels
	    } = this.attributes;
	    return Array.isArray(labels) && labels.length > 0;
	  },
	  insertLabel: function (idx, label, opt) {
	    if (!label) throw new Error('dia.Link: no label provided');
	    var labels = this.labels();
	    var n = labels.length;
	    idx = isFinite(idx) && idx !== null ? idx | 0 : n;
	    if (idx < 0) idx = n + idx + 1;
	    labels.splice(idx, 0, label);
	    return this.labels(labels, opt);
	  },
	  // convenience function
	  // add label to end of labels array
	  appendLabel: function (label, opt) {
	    return this.insertLabel(-1, label, opt);
	  },
	  removeLabel: function (idx, opt) {
	    var labels = this.labels();
	    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
	    labels.splice(idx, 1);
	    return this.labels(labels, opt);
	  },
	  // Vertices API

	  vertex: function (idx, vertex, opt) {
	    var vertices = this.vertices();
	    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
	    if (idx < 0) idx = vertices.length + idx;

	    // getter
	    if (arguments.length <= 1) return this.prop(['vertices', idx]);

	    // setter
	    var setVertex = this._normalizeVertex(vertex);
	    return this.prop(['vertices', idx], setVertex, opt);
	  },
	  vertices: function (vertices, opt) {
	    // getter
	    if (arguments.length === 0) {
	      vertices = this.get('vertices');
	      if (!Array.isArray(vertices)) return [];
	      return vertices.slice();
	    }

	    // setter
	    if (!Array.isArray(vertices)) vertices = [];
	    var setVertices = [];
	    for (var i = 0; i < vertices.length; i++) {
	      var vertex = vertices[i];
	      var setVertex = this._normalizeVertex(vertex);
	      setVertices.push(setVertex);
	    }
	    return this.set('vertices', setVertices, opt);
	  },
	  insertVertex: function (idx, vertex, opt) {
	    if (!vertex) throw new Error('dia.Link: no vertex provided');
	    var vertices = this.vertices();
	    var n = vertices.length;
	    idx = isFinite(idx) && idx !== null ? idx | 0 : n;
	    if (idx < 0) idx = n + idx + 1;
	    var setVertex = this._normalizeVertex(vertex);
	    vertices.splice(idx, 0, setVertex);
	    return this.vertices(vertices, opt);
	  },
	  removeVertex: function (idx, opt) {
	    var vertices = this.vertices();
	    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
	    vertices.splice(idx, 1);
	    return this.vertices(vertices, opt);
	  },
	  _normalizeVertex: function (vertex) {
	    // is vertex a point-like object?
	    // for example, a g.Point
	    var isPointProvided = !isPlainObject(vertex);
	    if (isPointProvided) return {
	      x: vertex.x,
	      y: vertex.y
	    };

	    // else: return vertex unchanged
	    return vertex;
	  },
	  // Transformations

	  translate: function (tx, ty, opt) {
	    // enrich the option object
	    opt = opt || {};
	    opt.translateBy = opt.translateBy || this.id;
	    opt.tx = tx;
	    opt.ty = ty;
	    return this.applyToPoints(function (p) {
	      return {
	        x: (p.x || 0) + tx,
	        y: (p.y || 0) + ty
	      };
	    }, opt);
	  },
	  scale: function (sx, sy, origin, opt) {
	    return this.applyToPoints(function (p) {
	      return Point(p).scale(sx, sy, origin).toJSON();
	    }, opt);
	  },
	  applyToPoints: function (fn, opt) {
	    if (!isFunction(fn)) {
	      throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');
	    }
	    var attrs = {};
	    var {
	      source,
	      target
	    } = this.attributes;
	    if (!source.id) {
	      attrs.source = fn(source);
	    }
	    if (!target.id) {
	      attrs.target = fn(target);
	    }
	    var vertices = this.vertices();
	    if (vertices.length > 0) {
	      attrs.vertices = vertices.map(fn);
	    }
	    return this.set(attrs, opt);
	  },
	  getSourcePoint: function () {
	    var sourceCell = this.getSourceCell();
	    if (!sourceCell) return new Point(this.source());
	    return sourceCell.getPointFromConnectedLink(this, 'source');
	  },
	  getTargetPoint: function () {
	    var targetCell = this.getTargetCell();
	    if (!targetCell) return new Point(this.target());
	    return targetCell.getPointFromConnectedLink(this, 'target');
	  },
	  getPointFromConnectedLink: function /* link, endType */
	  () {
	    return this.getPolyline().pointAt(0.5);
	  },
	  getPolyline: function () {
	    const points = [this.getSourcePoint(), ...this.vertices().map(Point), this.getTargetPoint()];
	    return new Polyline$1(points);
	  },
	  getBBox: function () {
	    return this.getPolyline().bbox();
	  },
	  reparent: function (opt) {
	    var newParent;
	    if (this.graph) {
	      var source = this.getSourceElement();
	      var target = this.getTargetElement();
	      var prevParent = this.getParentCell();
	      if (source && target) {
	        if (source === target || source.isEmbeddedIn(target)) {
	          newParent = target;
	        } else if (target.isEmbeddedIn(source)) {
	          newParent = source;
	        } else {
	          newParent = this.graph.getCommonAncestor(source, target);
	        }
	      }
	      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
	        // Unembed the link if source and target has no common ancestor
	        // or common ancestor changed
	        prevParent.unembed(this, opt);
	      }
	      if (newParent) {
	        newParent.embed(this, opt);
	      }
	    }
	    return newParent;
	  },
	  hasLoop: function (opt) {
	    opt = opt || {};
	    var {
	      source,
	      target
	    } = this.attributes;
	    var sourceId = source.id;
	    var targetId = target.id;
	    if (!sourceId || !targetId) {
	      // Link "pinned" to the paper does not have a loop.
	      return false;
	    }
	    var loop = sourceId === targetId;

	    // Note that there in the deep mode a link can have a loop,
	    // even if it connects only a parent and its embed.
	    // A loop "target equals source" is valid in both shallow and deep mode.
	    if (!loop && opt.deep && this.graph) {
	      var sourceElement = this.getSourceCell();
	      var targetElement = this.getTargetCell();
	      loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);
	    }
	    return loop;
	  },
	  // unlike source(), this method returns null if source is a point
	  getSourceCell: function () {
	    const {
	      graph,
	      attributes
	    } = this;
	    var source = attributes.source;
	    return source && source.id && graph && graph.getCell(source.id) || null;
	  },
	  getSourceElement: function () {
	    var cell = this;
	    var visited = {};
	    do {
	      if (visited[cell.id]) return null;
	      visited[cell.id] = true;
	      cell = cell.getSourceCell();
	    } while (cell && cell.isLink());
	    return cell;
	  },
	  // unlike target(), this method returns null if target is a point
	  getTargetCell: function () {
	    const {
	      graph,
	      attributes
	    } = this;
	    var target = attributes.target;
	    return target && target.id && graph && graph.getCell(target.id) || null;
	  },
	  getTargetElement: function () {
	    var cell = this;
	    var visited = {};
	    do {
	      if (visited[cell.id]) return null;
	      visited[cell.id] = true;
	      cell = cell.getTargetCell();
	    } while (cell && cell.isLink());
	    return cell;
	  },
	  // Returns the common ancestor for the source element,
	  // target element and the link itself.
	  getRelationshipAncestor: function () {
	    var connectionAncestor;
	    if (this.graph) {
	      var cells = [this, this.getSourceElement(),
	      // null if source is a point
	      this.getTargetElement() // null if target is a point
	      ].filter(function (item) {
	        return !!item;
	      });
	      connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);
	    }
	    return connectionAncestor || null;
	  },
	  // Is source, target and the link itself embedded in a given cell?
	  isRelationshipEmbeddedIn: function (cell) {
	    var cellId = isString(cell) || isNumber(cell) ? cell : cell.id;
	    var ancestor = this.getRelationshipAncestor();
	    return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));
	  },
	  // Get resolved default label.
	  _getDefaultLabel: function () {
	    var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};
	    var label = {};
	    label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;
	    label.position = defaultLabel.position;
	    label.attrs = defaultLabel.attrs;
	    label.size = defaultLabel.size;
	    return label;
	  }
	}, {
	  endsEqual: function (a, b) {
	    var portsEqual = a.port === b.port || !a.port && !b.port;
	    return a.id === b.id && portsEqual;
	  }
	});

	const env = {
	  _results: {},
	  _tests: {
	    svgforeignobject: function () {
	      return !!document.createElementNS && /SVGForeignObject/.test({}.toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));
	    },
	    // works for: (1) macOS Safari, (2) any WKWebView, (3) any iOS browser (including Safari, CriOS, EdgiOS, OPR, FxiOS)
	    isAppleWebKit: function () {
	      const userAgent = navigator.userAgent;
	      const isAppleWebKit = /applewebkit/i.test(userAgent);
	      const isChromium = /chrome/i.test(userAgent); // e.g. Chrome, Edge, Opera, SamsungBrowser
	      return isAppleWebKit && !isChromium;
	    }
	  },
	  addTest: function (name, fn) {
	    return this._tests[name] = fn;
	  },
	  test: function (name) {
	    var fn = this._tests[name];
	    if (!fn) {
	      throw new Error('Test not defined ("' + name + '"). Use `joint.env.addTest(name, fn) to add a new test.`');
	    }
	    var result = this._results[name];
	    if (typeof result !== 'undefined') {
	      return result;
	    }
	    try {
	      result = fn();
	    } catch {
	      result = false;
	    }

	    // Cache the test result.
	    this._results[name] = result;
	    return result;
	  }
	};

	// ELEMENTS

	const Rectangle = Element$1.define('standard.Rectangle', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      width: 'calc(w)',
	      height: 'calc(h)',
	      strokeWidth: 2,
	      stroke: '#000000',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'rect',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Circle = Element$1.define('standard.Circle', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      cx: 'calc(s/2)',
	      cy: 'calc(s/2)',
	      r: 'calc(s/2)',
	      strokeWidth: 2,
	      stroke: '#333333',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'circle',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Ellipse = Element$1.define('standard.Ellipse', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      cx: 'calc(w/2)',
	      cy: 'calc(h/2)',
	      rx: 'calc(w/2)',
	      ry: 'calc(h/2)',
	      strokeWidth: 2,
	      stroke: '#333333',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'ellipse',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Path = Element$1.define('standard.Path', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      d: 'M 0 0 H calc(w) V calc(h) H 0 Z',
	      strokeWidth: 2,
	      stroke: '#333333',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'path',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Polygon = Element$1.define('standard.Polygon', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',
	      strokeWidth: 2,
	      stroke: '#333333',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'polygon',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Polyline = Element$1.define('standard.Polyline', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',
	      strokeWidth: 2,
	      stroke: '#333333',
	      fill: '#FFFFFF'
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'polyline',
	    selector: 'body'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const Image = Element$1.define('standard.Image', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    image: {
	      width: 'calc(w)',
	      height: 'calc(h)'
	      // xlinkHref: '[URL]'
	    },
	    label: {
	      textVerticalAnchor: 'top',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h+10)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'image',
	    selector: 'image'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const BorderedImage = Element$1.define('standard.BorderedImage', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    border: {
	      width: 'calc(w)',
	      height: 'calc(h)',
	      stroke: '#333333',
	      strokeWidth: 2
	    },
	    background: {
	      width: 'calc(w-1)',
	      height: 'calc(h-1)',
	      x: 0.5,
	      y: 0.5,
	      fill: '#FFFFFF'
	    },
	    image: {
	      // xlinkHref: '[URL]'
	      width: 'calc(w-1)',
	      height: 'calc(h-1)',
	      x: 0.5,
	      y: 0.5
	    },
	    label: {
	      textVerticalAnchor: 'top',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h+10)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'rect',
	    selector: 'background',
	    attributes: {
	      'stroke': 'none'
	    }
	  }, {
	    tagName: 'image',
	    selector: 'image'
	  }, {
	    tagName: 'rect',
	    selector: 'border',
	    attributes: {
	      'fill': 'none'
	    }
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const EmbeddedImage = Element$1.define('standard.EmbeddedImage', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      width: 'calc(w)',
	      height: 'calc(h)',
	      stroke: '#333333',
	      fill: '#FFFFFF',
	      strokeWidth: 2
	    },
	    image: {
	      // xlinkHref: '[URL]'
	      width: 'calc(0.3*w)',
	      height: 'calc(h-20)',
	      x: 10,
	      y: 10,
	      preserveAspectRatio: 'xMidYMin'
	    },
	    label: {
	      textVerticalAnchor: 'top',
	      textAnchor: 'left',
	      x: 'calc(0.3*w+20)',
	      // 10 + 10
	      y: 10,
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'rect',
	    selector: 'body'
	  }, {
	    tagName: 'image',
	    selector: 'image'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const InscribedImage = Element$1.define('standard.InscribedImage', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    border: {
	      rx: 'calc(w/2)',
	      ry: 'calc(h/2)',
	      cx: 'calc(w/2)',
	      cy: 'calc(h/2)',
	      stroke: '#333333',
	      strokeWidth: 2
	    },
	    background: {
	      rx: 'calc(w/2)',
	      ry: 'calc(h/2)',
	      cx: 'calc(w/2)',
	      cy: 'calc(h/2)',
	      fill: '#FFFFFF'
	    },
	    image: {
	      // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
	      width: 'calc(0.68*w)',
	      height: 'calc(0.68*h)',
	      // The image offset is calculated as (100% - 68%) / 2
	      x: 'calc(0.16*w)',
	      y: 'calc(0.16*h)',
	      preserveAspectRatio: 'xMidYMid'
	      // xlinkHref: '[URL]'
	    },
	    label: {
	      textVerticalAnchor: 'top',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h+10)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'ellipse',
	    selector: 'background'
	  }, {
	    tagName: 'image',
	    selector: 'image'
	  }, {
	    tagName: 'ellipse',
	    selector: 'border',
	    attributes: {
	      'fill': 'none'
	    }
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }]
	});
	const HeaderedRectangle = Element$1.define('standard.HeaderedRectangle', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      width: 'calc(w)',
	      height: 'calc(h)',
	      strokeWidth: 2,
	      stroke: '#000000',
	      fill: '#FFFFFF'
	    },
	    header: {
	      width: 'calc(w)',
	      height: 30,
	      strokeWidth: 2,
	      stroke: '#000000',
	      fill: '#FFFFFF'
	    },
	    headerText: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 15,
	      fontSize: 16,
	      fill: '#333333'
	    },
	    bodyText: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h/2+15)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'rect',
	    selector: 'body'
	  }, {
	    tagName: 'rect',
	    selector: 'header'
	  }, {
	    tagName: 'text',
	    selector: 'headerText'
	  }, {
	    tagName: 'text',
	    selector: 'bodyText'
	  }]
	});
	var CYLINDER_TILT = 10;
	const Cylinder = Element$1.define('standard.Cylinder', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      lateralArea: CYLINDER_TILT,
	      fill: '#FFFFFF',
	      stroke: '#333333',
	      strokeWidth: 2
	    },
	    top: {
	      cx: 'calc(w/2)',
	      cy: CYLINDER_TILT,
	      rx: 'calc(w/2)',
	      ry: CYLINDER_TILT,
	      fill: '#FFFFFF',
	      stroke: '#333333',
	      strokeWidth: 2
	    },
	    label: {
	      textVerticalAnchor: 'middle',
	      textAnchor: 'middle',
	      x: 'calc(w/2)',
	      y: 'calc(h+15)',
	      fontSize: 14,
	      fill: '#333333'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'path',
	    selector: 'body'
	  }, {
	    tagName: 'ellipse',
	    selector: 'top'
	  }, {
	    tagName: 'text',
	    selector: 'label'
	  }],
	  topRy: function (t, opt) {
	    // getter
	    if (t === undefined) return this.attr('body/lateralArea');

	    // setter
	    var bodyAttrs = {
	      lateralArea: t
	    };
	    var isPercentageSetter = isPercentage(t);
	    var ty = isPercentageSetter ? `calc(${parseFloat(t) / 100}*h)` : t;
	    var topAttrs = {
	      cy: ty,
	      ry: ty
	    };
	    return this.attr({
	      body: bodyAttrs,
	      top: topAttrs
	    }, opt);
	  }
	}, {
	  attributes: {
	    'lateral-area': {
	      set: function (t, refBBox) {
	        var isPercentageSetter = isPercentage(t);
	        if (isPercentageSetter) t = parseFloat(t) / 100;
	        var x = refBBox.x;
	        var y = refBBox.y;
	        var w = refBBox.width;
	        var h = refBBox.height;

	        // curve control point variables
	        var rx = w / 2;
	        var ry = isPercentageSetter ? h * t : t;
	        var kappa = V.KAPPA;
	        var cx = kappa * rx;
	        var cy = kappa * (isPercentageSetter ? h * t : t);

	        // shape variables
	        var xLeft = x;
	        var xCenter = x + w / 2;
	        var xRight = x + w;
	        var ySideTop = y + ry;
	        var yCurveTop = ySideTop - ry;
	        var ySideBottom = y + h - ry;
	        var yCurveBottom = y + h;

	        // return calculated shape
	        var data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];
	        return {
	          d: data.join(' ')
	        };
	      },
	      unset: 'd'
	    }
	  }
	});
	var foLabelMarkup = {
	  tagName: 'foreignObject',
	  selector: 'foreignObject',
	  attributes: {
	    'overflow': 'hidden'
	  },
	  children: [{
	    tagName: 'div',
	    namespaceURI: 'http://www.w3.org/1999/xhtml',
	    selector: 'label',
	    style: {
	      width: '100%',
	      height: '100%',
	      position: 'static',
	      backgroundColor: 'transparent',
	      textAlign: 'center',
	      margin: 0,
	      padding: '0px 5px',
	      boxSizing: 'border-box',
	      display: 'flex',
	      alignItems: 'center',
	      justifyContent: 'center'
	    }
	  }]
	};
	var svgLabelMarkup = {
	  tagName: 'text',
	  selector: 'label',
	  attributes: {
	    'text-anchor': 'middle'
	  }
	};
	var labelMarkup = env.test('svgforeignobject') ? foLabelMarkup : svgLabelMarkup;
	const TextBlock = Element$1.define('standard.TextBlock', {
	  attrs: {
	    root: {
	      cursor: 'move'
	    },
	    body: {
	      width: 'calc(w)',
	      height: 'calc(h)',
	      stroke: '#333333',
	      fill: '#ffffff',
	      strokeWidth: 2
	    },
	    foreignObject: {
	      width: 'calc(w)',
	      height: 'calc(h)'
	    },
	    label: {
	      style: {
	        fontSize: 14
	      }
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'rect',
	    selector: 'body'
	  }, labelMarkup]
	}, {
	  attributes: {
	    text: {
	      set: function (text, refBBox, node, attrs) {
	        if (node instanceof HTMLElement) {
	          node.textContent = text;
	        } else {
	          // No foreign object
	          var style = attrs['style'] || {};
	          var wrapValue = {
	            text,
	            width: -5,
	            height: '100%'
	          };
	          var wrapAttrs = assign({
	            'text-vertical-anchor': 'middle'
	          }, style);
	          attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);
	          return {
	            fill: style.color || null
	          };
	        }
	      },
	      unset: function (node) {
	        node.textContent = '';
	        if (node instanceof SVGElement) {
	          return 'fill';
	        }
	      },
	      position: function (text, refBBox, node) {
	        // No foreign object
	        if (node instanceof SVGElement) return refBBox.center();
	      }
	    }
	  }
	});

	// LINKS

	const Link = Link$1.define('standard.Link', {
	  attrs: {
	    line: {
	      connection: true,
	      stroke: '#333333',
	      strokeWidth: 2,
	      strokeLinejoin: 'round',
	      targetMarker: {
	        'type': 'path',
	        'd': 'M 10 -5 0 0 10 5 z'
	      }
	    },
	    wrapper: {
	      connection: true,
	      strokeWidth: 10,
	      strokeLinejoin: 'round'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'path',
	    selector: 'wrapper',
	    attributes: {
	      'fill': 'none',
	      'cursor': 'pointer',
	      'stroke': 'transparent',
	      'stroke-linecap': 'round'
	    }
	  }, {
	    tagName: 'path',
	    selector: 'line',
	    attributes: {
	      'fill': 'none',
	      'pointer-events': 'none'
	    }
	  }]
	});
	const DoubleLink = Link$1.define('standard.DoubleLink', {
	  attrs: {
	    line: {
	      connection: true,
	      stroke: '#DDDDDD',
	      strokeWidth: 4,
	      strokeLinejoin: 'round',
	      targetMarker: {
	        type: 'path',
	        stroke: '#000000',
	        d: 'M 10 -3 10 -10 -2 0 10 10 10 3'
	      }
	    },
	    outline: {
	      connection: true,
	      stroke: '#000000',
	      strokeWidth: 6,
	      strokeLinejoin: 'round'
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'path',
	    selector: 'outline',
	    attributes: {
	      'fill': 'none',
	      'cursor': 'pointer'
	    }
	  }, {
	    tagName: 'path',
	    selector: 'line',
	    attributes: {
	      'fill': 'none',
	      'pointer-events': 'none'
	    }
	  }]
	});
	const ShadowLink = Link$1.define('standard.ShadowLink', {
	  attrs: {
	    line: {
	      connection: true,
	      stroke: '#FF0000',
	      strokeWidth: 20,
	      strokeLinejoin: 'round',
	      targetMarker: {
	        'type': 'path',
	        'stroke': 'none',
	        'd': 'M 0 -10 -10 0 0 10 z'
	      },
	      sourceMarker: {
	        'type': 'path',
	        'stroke': 'none',
	        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
	      }
	    },
	    shadow: {
	      connection: true,
	      transform: 'translate(3,6)',
	      stroke: '#000000',
	      strokeOpacity: 0.2,
	      strokeWidth: 20,
	      strokeLinejoin: 'round',
	      targetMarker: {
	        'type': 'path',
	        'd': 'M 0 -10 -10 0 0 10 z',
	        'stroke': 'none'
	      },
	      sourceMarker: {
	        'type': 'path',
	        'stroke': 'none',
	        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
	      }
	    }
	  }
	}, {
	  markup: [{
	    tagName: 'path',
	    selector: 'shadow',
	    attributes: {
	      'fill': 'none',
	      'pointer-events': 'none'
	    }
	  }, {
	    tagName: 'path',
	    selector: 'line',
	    attributes: {
	      'fill': 'none',
	      'cursor': 'pointer'
	    }
	  }]
	});

	var standard = {
		__proto__: null,
		BorderedImage: BorderedImage,
		Circle: Circle,
		Cylinder: Cylinder,
		DoubleLink: DoubleLink,
		Ellipse: Ellipse,
		EmbeddedImage: EmbeddedImage,
		HeaderedRectangle: HeaderedRectangle,
		Image: Image,
		InscribedImage: InscribedImage,
		Link: Link,
		Path: Path,
		Polygon: Polygon,
		Polyline: Polyline,
		Rectangle: Rectangle,
		ShadowLink: ShadowLink,
		TextBlock: TextBlock
	};

	var index$5 = {
		__proto__: null,
		standard: standard
	};

	const CornerTypes = {
	  POINT: 'point',
	  CUBIC: 'cubic',
	  LINE: 'line',
	  GAP: 'gap'
	};
	const DEFINED_CORNER_TYPES = Object.values(CornerTypes);
	const CORNER_RADIUS$1 = 10;
	const PRECISION$1 = 1;
	const straight = function (sourcePoint, targetPoint, routePoints = [], opt = {}) {
	  const {
	    cornerType = CornerTypes.POINT,
	    cornerRadius = CORNER_RADIUS$1,
	    cornerPreserveAspectRatio = false,
	    precision = PRECISION$1,
	    raw = false
	  } = opt;
	  if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {
	    // unknown `cornerType` provided => error
	    throw new Error('Invalid `cornerType` provided to `straight` connector.');
	  }
	  let path;
	  if (cornerType === CornerTypes.POINT || !cornerRadius) {
	    // default option => normal connector
	    // simply connect all points with straight lines
	    const points = [sourcePoint].concat(routePoints).concat([targetPoint]);
	    const polyline = new Polyline$1(points);
	    path = new Path$1(polyline);
	  } else {
	    // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types
	    path = new Path$1();

	    // add initial gap segment = to source point
	    path.appendSegment(Path$1.createSegment('M', sourcePoint));
	    let nextDistance;
	    const routePointsLength = routePoints.length;
	    for (let i = 0; i < routePointsLength; i++) {
	      const curr = new Point(routePoints[i]);
	      const prev = routePoints[i - 1] || sourcePoint;
	      const next = routePoints[i + 1] || targetPoint;
	      const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`
	      nextDistance = curr.distance(next) / 2;
	      let startMove, endMove;
	      if (!cornerPreserveAspectRatio) {
	        // `startMove` and `endMove` may be different
	        // (this happens when next or previous path point is closer than `2 * cornerRadius`)
	        startMove = -Math.min(cornerRadius, prevDistance);
	        endMove = -Math.min(cornerRadius, nextDistance);
	      } else {
	        // force `startMove` and `endMove` to be the same
	        startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);
	      }

	      // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):
	      // - find a point lying on the line `prev - startMove` such that...
	      // - ...the point lies `abs(startMove)` distance away from `curr`...
	      // - ...and its coordinates are rounded to whole numbers
	      const cornerStart = curr.clone().move(prev, startMove).round(precision);
	      const cornerEnd = curr.clone().move(next, endMove).round(precision);

	      // add in-between straight segment = from previous route point to corner start point
	      // (may have zero length)
	      path.appendSegment(Path$1.createSegment('L', cornerStart));

	      // add corner segment = from corner start point to corner end point
	      switch (cornerType) {
	        case CornerTypes.CUBIC:
	          {
	            // corner is rounded
	            const _13 = 1 / 3;
	            const _23 = 2 / 3;
	            const control1 = new Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);
	            const control2 = new Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);
	            path.appendSegment(Path$1.createSegment('C', control1, control2, cornerEnd));
	            break;
	          }
	        case CornerTypes.LINE:
	          {
	            // corner has bevel
	            path.appendSegment(Path$1.createSegment('L', cornerEnd));
	            break;
	          }
	        case CornerTypes.GAP:
	          {
	            // corner has empty space
	            path.appendSegment(Path$1.createSegment('M', cornerEnd));
	            break;
	          }
	        // default: no segment is created
	      }
	    }

	    // add final straight segment = from last corner end point to target point
	    // (= or from start point to end point, if there are no route points)
	    // (may have zero length)
	    path.appendSegment(Path$1.createSegment('L', targetPoint));
	  }
	  return raw ? path : path.serialize();
	};

	// default size of jump if not specified in options
	var JUMP_SIZE = 5;

	// available jump types
	// first one taken as default
	var JUMP_TYPES = ['arc', 'gap', 'cubic'];

	// default radius
	var RADIUS = 0;

	// takes care of math. error for case when jump is too close to end of line
	var CLOSE_PROXIMITY_PADDING = 1;

	// list of connector types not to jump over.
	var IGNORED_CONNECTORS = ['smooth'];

	// internal constants for round segment
	var _13 = 1 / 3;
	var _23 = 2 / 3;
	function sortPointsAscending(p1, p2) {
	  let {
	    x: x1,
	    y: y1
	  } = p1;
	  let {
	    x: x2,
	    y: y2
	  } = p2;
	  if (x1 > x2) {
	    let swap = x1;
	    x1 = x2;
	    x2 = swap;
	    swap = y1;
	    y1 = y2;
	    y2 = swap;
	  }
	  if (y1 > y2) {
	    let swap = x1;
	    x1 = x2;
	    x2 = swap;
	    swap = y1;
	    y1 = y2;
	    y2 = swap;
	  }
	  return [new Point(x1, y1), new Point(x2, y2)];
	}
	function overlapExists(line1, line2) {
	  const [{
	    x: x1,
	    y: y1
	  }, {
	    x: x2,
	    y: y2
	  }] = sortPointsAscending(line1.start, line1.end);
	  const [{
	    x: x3,
	    y: y3
	  }, {
	    x: x4,
	    y: y4
	  }] = sortPointsAscending(line2.start, line2.end);
	  const xMatch = x1 <= x4 && x3 <= x2;
	  const yMatch = y1 <= y4 && y3 <= y2;
	  return xMatch && yMatch;
	}

	/**
	 * Transform start/end and route into series of lines
	 * @param {g.point} sourcePoint start point
	 * @param {g.point} targetPoint end point
	 * @param {g.point[]} route optional list of route
	 * @return {g.line[]} [description]
	 */
	function createLines(sourcePoint, targetPoint, route) {
	  // make a flattened array of all points
	  var points = [].concat(sourcePoint, route, targetPoint);
	  return points.reduce(function (resultLines, point, idx) {
	    // if there is a next point, make a line with it
	    var nextPoint = points[idx + 1];
	    if (nextPoint != null) {
	      resultLines[idx] = line$1(point, nextPoint);
	    }
	    return resultLines;
	  }, []);
	}
	function setupUpdating(jumpOverLinkView) {
	  var paper = jumpOverLinkView.paper;
	  var updateList = paper._jumpOverUpdateList;

	  // first time setup for this paper
	  if (updateList == null) {
	    updateList = paper._jumpOverUpdateList = [];
	    var graph = paper.model;
	    graph.on('batch:stop', function () {
	      if (this.hasActiveBatch()) return;
	      updateJumpOver(paper);
	    });
	    graph.on('reset', function () {
	      updateList = paper._jumpOverUpdateList = [];
	    });
	  }

	  // add this link to a list so it can be updated when some other link is updated
	  if (updateList.indexOf(jumpOverLinkView) < 0) {
	    updateList.push(jumpOverLinkView);

	    // watch for change of connector type or removal of link itself
	    // to remove the link from a list of jump over connectors
	    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {
	      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);
	    });
	  }
	}

	/**
	 * Handler for a batch:stop event to force
	 * update of all registered links with jump over connector
	 * @param {object} batchEvent optional object with info about batch
	 */
	function updateJumpOver(paper) {
	  var updateList = paper._jumpOverUpdateList;
	  for (var i = 0; i < updateList.length; i++) {
	    const linkView = updateList[i];
	    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);
	    linkView.requestUpdate(updateFlag);
	  }
	}

	/**
	 * Utility function to collect all intersection points of a single
	 * line against group of other lines.
	 * @param {g.line} line where to find points
	 * @param {g.line[]} crossCheckLines lines to cross
	 * @return {g.point[]} list of intersection points
	 */
	function findLineIntersections(line, crossCheckLines) {
	  return toArray$1(crossCheckLines).reduce(function (res, crossCheckLine) {
	    var intersection = line.intersection(crossCheckLine);
	    if (intersection) {
	      res.push(intersection);
	    }
	    return res;
	  }, []);
	}

	/**
	 * Sorting function for list of points by their distance.
	 * @param {g.point} p1 first point
	 * @param {g.point} p2 second point
	 * @return {number} squared distance between points
	 */
	function sortPoints(p1, p2) {
	  return line$1(p1, p2).squaredLength();
	}

	/**
	 * Split input line into multiple based on intersection points.
	 * @param {g.line} line input line to split
	 * @param {g.point[]} intersections points where to split the line
	 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
	 * @return {g.line[]} list of lines being split
	 */
	function createJumps(line, intersections, jumpSize) {
	  return intersections.reduce(function (resultLines, point$1, idx) {
	    // skipping points that were merged with the previous line
	    // to make bigger arc over multiple lines that are close to each other
	    if (point$1.skip === true) {
	      return resultLines;
	    }

	    // always grab the last line from buffer and modify it
	    var lastLine = resultLines.pop() || line;

	    // calculate start and end of jump by moving by a given size of jump
	    var jumpStart = point(point$1).move(lastLine.start, -jumpSize);
	    var jumpEnd = point(point$1).move(lastLine.start, +jumpSize);

	    // now try to look at the next intersection point
	    var nextPoint = intersections[idx + 1];
	    if (nextPoint != null) {
	      var distance = jumpEnd.distance(nextPoint);
	      if (distance <= jumpSize) {
	        // next point is close enough, move the jump end by this
	        // difference and mark the next point to be skipped
	        jumpEnd = nextPoint.move(lastLine.start, distance);
	        nextPoint.skip = true;
	      }
	    } else {
	      // this block is inside of `else` as an optimization so the distance is
	      // not calculated when we know there are no other intersection points
	      var endDistance = jumpStart.distance(lastLine.end);
	      // if the end is too close to possible jump, draw remaining line instead of a jump
	      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
	        resultLines.push(lastLine);
	        return resultLines;
	      }
	    }
	    var startDistance = jumpEnd.distance(lastLine.start);
	    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
	      // if the start of line is too close to jump, draw that line instead of a jump
	      resultLines.push(lastLine);
	      return resultLines;
	    }

	    // finally create a jump line
	    var jumpLine = line$1(jumpStart, jumpEnd);
	    // it's just simple line but with a `isJump` property
	    jumpLine.isJump = true;
	    resultLines.push(line$1(lastLine.start, jumpStart), jumpLine, line$1(jumpEnd, lastLine.end));
	    return resultLines;
	  }, []);
	}

	/**
	 * Assemble `D` attribute of a SVG path by iterating given lines.
	 * @param {g.line[]} lines source lines to use
	 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
	 * @param {number} radius the radius
	 * @return {string}
	 */
	function buildPath(lines, jumpSize, jumpType, radius) {
	  var path = new Path$1();
	  var segment;

	  // first move to the start of a first line
	  segment = Path$1.createSegment('M', lines[0].start);
	  path.appendSegment(segment);

	  // make a paths from lines
	  toArray$1(lines).forEach(function (line, index) {
	    if (line.isJump) {
	      var angle, diff;
	      var control1, control2;
	      if (jumpType === 'arc') {
	        // approximates semicircle with 2 curves
	        angle = -90;
	        // determine rotation of arc based on difference between points
	        diff = line.start.difference(line.end);
	        // make sure the arc always points up (or right)
	        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
	        if (xAxisRotate) angle += 180;
	        var midpoint = line.midpoint();
	        var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);
	        var halfLine;

	        // first half
	        halfLine = new Line(line.start, midpoint);
	        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);
	        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);
	        segment = Path$1.createSegment('C', control1, control2, centerLine.end);
	        path.appendSegment(segment);

	        // second half
	        halfLine = new Line(midpoint, line.end);
	        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);
	        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);
	        segment = Path$1.createSegment('C', control1, control2, line.end);
	        path.appendSegment(segment);
	      } else if (jumpType === 'gap') {
	        segment = Path$1.createSegment('M', line.end);
	        path.appendSegment(segment);
	      } else if (jumpType === 'cubic') {
	        // approximates semicircle with 1 curve
	        angle = line.start.theta(line.end);
	        var xOffset = jumpSize * 0.6;
	        var yOffset = jumpSize * 1.35;

	        // determine rotation of arc based on difference between points
	        diff = line.start.difference(line.end);
	        // make sure the arc always points up (or right)
	        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
	        if (xAxisRotate) yOffset *= -1;
	        control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);
	        control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);
	        segment = Path$1.createSegment('C', control1, control2, line.end);
	        path.appendSegment(segment);
	      }
	    } else {
	      var nextLine = lines[index + 1];
	      if (radius == 0 || !nextLine || nextLine.isJump) {
	        segment = Path$1.createSegment('L', line.end);
	        path.appendSegment(segment);
	      } else {
	        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
	      }
	    }
	  });
	  return path;
	}
	function buildRoundedSegment(offset, path, curr, prev, next) {
	  var prevDistance = curr.distance(prev) / 2;
	  var nextDistance = curr.distance(next) / 2;
	  var startMove = -Math.min(offset, prevDistance);
	  var endMove = -Math.min(offset, nextDistance);
	  var roundedStart = curr.clone().move(prev, startMove).round();
	  var roundedEnd = curr.clone().move(next, endMove).round();
	  var control1 = new Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);
	  var control2 = new Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);
	  var segment;
	  segment = Path$1.createSegment('L', roundedStart);
	  path.appendSegment(segment);
	  segment = Path$1.createSegment('C', control1, control2, roundedEnd);
	  path.appendSegment(segment);
	}

	/**
	 * Actual connector function that will be run on every update.
	 * @param {g.point} sourcePoint start point of this link
	 * @param {g.point} targetPoint end point of this link
	 * @param {g.point[]} route of this link
	 * @param {object} opt options
	 * @property {number} size optional size of a jump arc
	 * @return {string} created `D` attribute of SVG path
	 */
	const jumpover = function (sourcePoint, targetPoint, route, opt) {
	  setupUpdating(this);
	  var raw = opt.raw;
	  var jumpSize = opt.size || JUMP_SIZE;
	  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();
	  var radius = opt.radius || RADIUS;
	  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;

	  // grab the first jump type as a default if specified one is invalid
	  if (JUMP_TYPES.indexOf(jumpType) === -1) {
	    jumpType = JUMP_TYPES[0];
	  }
	  var paper = this.paper;
	  var graph = paper.model;
	  var allLinks = graph.getLinks();

	  // there is just one link, draw it directly
	  if (allLinks.length === 1) {
	    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);
	  }
	  var thisModel = this.model;
	  var thisIndex = allLinks.indexOf(thisModel);
	  var defaultConnector = paper.options.defaultConnector || {};

	  // not all links are meant to be jumped over.
	  var links = allLinks.filter(function (link, idx) {
	    var connector = link.get('connector') || defaultConnector;

	    // avoid jumping over links with connector type listed in `ignored connectors`.
	    if (toArray$1(ignoreConnectors).includes(connector.name)) {
	      return false;
	    }
	    // filter out links that are above this one and  have the same connector type
	    // otherwise there would double hoops for each intersection
	    if (idx > thisIndex) {
	      return connector.name !== 'jumpover';
	    }
	    return true;
	  });

	  // find views for all links
	  var linkViews = links.map(function (link) {
	    return paper.findViewByModel(link);
	  });

	  // create lines for this link
	  var thisLines = createLines(sourcePoint, targetPoint, route);

	  // create lines for all other links
	  var linkLines = linkViews.map(function (linkView) {
	    if (linkView == null) {
	      return [];
	    }
	    if (linkView === this) {
	      return thisLines;
	    }
	    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);
	  }, this);

	  // transform lines for this link by splitting with jump lines at
	  // points of intersection with other links
	  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {
	    // iterate all links and grab the intersections with this line
	    // these are then sorted by distance so the line can be split more easily
	    var intersections = links.reduce(function (res, link, i) {
	      // don't intersection with itself
	      if (link !== thisModel) {
	        const linkLinesToTest = linkLines[i].slice();
	        const overlapIndex = linkLinesToTest.findIndex(line => overlapExists(thisLine, line));

	        // Overlap occurs and the end point of one segment lies on thisLine
	        if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {
	          // Remove the next segment because there will never be a jump
	          linkLinesToTest.splice(overlapIndex + 1, 1);
	        }
	        const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);
	        res.push.apply(res, lineIntersections);
	      }
	      return res;
	    }, []).sort(function (a, b) {
	      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);
	    });
	    if (intersections.length > 0) {
	      // split the line based on found intersection points
	      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));
	    } else {
	      // without any intersection the line goes uninterrupted
	      resultLines.push(thisLine);
	    }
	    return resultLines;
	  }, []);
	  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);
	  return raw ? path : path.serialize();
	};

	const normal$1 = function (sourcePoint, targetPoint, route = [], opt = {}) {
	  const {
	    raw
	  } = opt;
	  const localOpt = {
	    cornerType: 'point',
	    raw
	  };
	  return straight(sourcePoint, targetPoint, route, localOpt);
	};

	const CORNER_RADIUS = 10;
	const PRECISION = 0;
	const rounded = function (sourcePoint, targetPoint, route = [], opt = {}) {
	  const {
	    radius = CORNER_RADIUS,
	    raw
	  } = opt;
	  const localOpt = {
	    cornerType: 'cubic',
	    cornerRadius: radius,
	    precision: PRECISION,
	    raw
	  };
	  return straight(sourcePoint, targetPoint, route, localOpt);
	};

	const smooth = function (sourcePoint, targetPoint, route, opt) {
	  var raw = opt && opt.raw;
	  var path;
	  if (route && route.length !== 0) {
	    var points = [sourcePoint].concat(route).concat([targetPoint]);
	    var curves = Curve.throughPoints(points);
	    path = new Path$1(curves);
	  } else {
	    // if we have no route, use a default cubic bezier curve
	    // cubic bezier requires two control points
	    // the control points have `x` midway between source and target
	    // this produces an S-like curve

	    path = new Path$1();
	    var segment;
	    segment = Path$1.createSegment('M', sourcePoint);
	    path.appendSegment(segment);
	    if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {
	      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;
	      segment = Path$1.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);
	      path.appendSegment(segment);
	    } else {
	      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;
	      segment = Path$1.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);
	      path.appendSegment(segment);
	    }
	  }
	  return raw ? path : path.serialize();
	};

	const Directions$2 = {
	  AUTO: 'auto',
	  HORIZONTAL: 'horizontal',
	  VERTICAL: 'vertical',
	  CLOSEST_POINT: 'closest-point',
	  OUTWARDS: 'outwards'
	};
	const TangentDirections = {
	  UP: 'up',
	  DOWN: 'down',
	  LEFT: 'left',
	  RIGHT: 'right',
	  AUTO: 'auto',
	  CLOSEST_POINT: 'closest-point',
	  OUTWARDS: 'outwards'
	};
	const curve = function (sourcePoint, targetPoint, route = [], opt = {}, linkView) {
	  const raw = Boolean(opt.raw);
	  // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.
	  // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.
	  // tension - a Catmull-Rom curve tension parameter.
	  // sourceTangent - a tangent vector along the curve at the sourcePoint.
	  // sourceDirection - a unit direction vector along the curve at the sourcePoint.
	  // targetTangent - a tangent vector along the curve at the targetPoint.
	  // targetDirection - a unit direction vector along the curve at the targetPoint.
	  // precision - a rounding precision for path values.
	  const {
	    direction = Directions$2.AUTO,
	    precision = 3
	  } = opt;
	  const options = {
	    coeff: opt.distanceCoefficient || 0.6,
	    angleTangentCoefficient: opt.angleTangentCoefficient || 80,
	    tau: opt.tension || 0.5,
	    sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,
	    targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,
	    rotate: Boolean(opt.rotate)
	  };
	  if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;
	  if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;else if (typeof opt.targetDirection === 'number') options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;
	  const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));

	  // The calculation of a sourceTangent
	  let sourceTangent;
	  if (options.sourceTangent) {
	    sourceTangent = options.sourceTangent;
	  } else {
	    const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);
	    const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;
	    const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();
	    const angle = angleBetweenVectors(sourceDirection, pointsVector);
	    if (angle > Math.PI / 4) {
	      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
	      sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);
	    } else {
	      sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);
	    }
	  }

	  // The calculation of a targetTangent
	  let targetTangent;
	  if (options.targetTangent) {
	    targetTangent = options.targetTangent;
	  } else {
	    const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);
	    const last = completeRoute.length - 1;
	    const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;
	    const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();
	    const angle = angleBetweenVectors(targetDirection, pointsVector);
	    if (angle > Math.PI / 4) {
	      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
	      targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);
	    } else {
	      targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);
	    }
	  }
	  const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);
	  const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));
	  const path = new Path$1(bezierCurves).round(precision);
	  return raw ? path : path.serialize();
	};
	curve.Directions = Directions$2;
	curve.TangentDirections = TangentDirections;
	function getHorizontalSourceDirection(linkView, route, options) {
	  const {
	    sourceBBox
	  } = linkView;
	  let sourceSide;
	  let rotation;
	  if (!linkView.sourceView) {
	    if (sourceBBox.x > route[1].x) sourceSide = 'right';else sourceSide = 'left';
	  } else {
	    rotation = linkView.sourceView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
	      const sourcePoint = route[0].clone();
	      sourcePoint.rotate(sourceBBox.center(), rotation);
	      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
	    } else {
	      sourceSide = sourceBBox.sideNearestToPoint(route[0]);
	    }
	  }
	  let direction;
	  switch (sourceSide) {
	    case 'left':
	      direction = new Point(-1, 0);
	      break;
	    case 'right':
	    default:
	      direction = new Point(1, 0);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getHorizontalTargetDirection(linkView, route, options) {
	  const {
	    targetBBox
	  } = linkView;
	  let targetSide;
	  let rotation;
	  if (!linkView.targetView) {
	    if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';else targetSide = 'right';
	  } else {
	    rotation = linkView.targetView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
	      const targetPoint = route[route.length - 1].clone();
	      targetPoint.rotate(targetBBox.center(), rotation);
	      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
	    } else {
	      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
	    }
	  }
	  let direction;
	  switch (targetSide) {
	    case 'left':
	      direction = new Point(-1, 0);
	      break;
	    case 'right':
	    default:
	      direction = new Point(1, 0);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getVerticalSourceDirection(linkView, route, options) {
	  const {
	    sourceBBox
	  } = linkView;
	  let sourceSide;
	  let rotation;
	  if (!linkView.sourceView) {
	    if (sourceBBox.y > route[1].y) sourceSide = 'bottom';else sourceSide = 'top';
	  } else {
	    rotation = linkView.sourceView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
	      const sourcePoint = route[0].clone();
	      sourcePoint.rotate(sourceBBox.center(), rotation);
	      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
	    } else {
	      sourceSide = sourceBBox.sideNearestToPoint(route[0]);
	    }
	  }
	  let direction;
	  switch (sourceSide) {
	    case 'top':
	      direction = new Point(0, -1);
	      break;
	    case 'bottom':
	    default:
	      direction = new Point(0, 1);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getVerticalTargetDirection(linkView, route, options) {
	  const {
	    targetBBox
	  } = linkView;
	  let targetSide;
	  let rotation;
	  if (!linkView.targetView) {
	    if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';else targetSide = 'bottom';
	  } else {
	    rotation = linkView.targetView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
	      const targetPoint = route[route.length - 1].clone();
	      targetPoint.rotate(targetBBox.center(), rotation);
	      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
	    } else {
	      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
	    }
	  }
	  let direction;
	  switch (targetSide) {
	    case 'top':
	      direction = new Point(0, -1);
	      break;
	    case 'bottom':
	    default:
	      direction = new Point(0, 1);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getAutoSourceDirection(linkView, route, options) {
	  const {
	    sourceBBox
	  } = linkView;
	  let sourceSide;
	  let rotation;
	  if (!linkView.sourceView) {
	    sourceSide = sourceBBox.sideNearestToPoint(route[1]);
	  } else {
	    rotation = linkView.sourceView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
	      const sourcePoint = route[0].clone();
	      sourcePoint.rotate(sourceBBox.center(), rotation);
	      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
	    } else {
	      sourceSide = sourceBBox.sideNearestToPoint(route[0]);
	    }
	  }
	  let direction;
	  switch (sourceSide) {
	    case 'top':
	      direction = new Point(0, -1);
	      break;
	    case 'bottom':
	      direction = new Point(0, 1);
	      break;
	    case 'right':
	      direction = new Point(1, 0);
	      break;
	    case 'left':
	      direction = new Point(-1, 0);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getAutoTargetDirection(linkView, route, options) {
	  const {
	    targetBBox
	  } = linkView;
	  let targetSide;
	  let rotation;
	  if (!linkView.targetView) {
	    targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);
	  } else {
	    rotation = linkView.targetView.model.angle();
	    if (options.rotate && rotation) {
	      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
	      const targetPoint = route[route.length - 1].clone();
	      targetPoint.rotate(targetBBox.center(), rotation);
	      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
	    } else {
	      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
	    }
	  }
	  let direction;
	  switch (targetSide) {
	    case 'top':
	      direction = new Point(0, -1);
	      break;
	    case 'bottom':
	      direction = new Point(0, 1);
	      break;
	    case 'right':
	      direction = new Point(1, 0);
	      break;
	    case 'left':
	      direction = new Point(-1, 0);
	      break;
	  }
	  if (options.rotate && rotation) {
	    direction.rotate(null, -rotation);
	  }
	  return direction;
	}
	function getClosestPointSourceDirection(linkView, route, options) {
	  return route[1].difference(route[0]).normalize();
	}
	function getClosestPointTargetDirection(linkView, route, options) {
	  const last = route.length - 1;
	  return route[last - 1].difference(route[last]).normalize();
	}
	function getOutwardsSourceDirection(linkView, route, options) {
	  const {
	    sourceBBox
	  } = linkView;
	  const sourceCenter = sourceBBox.center();
	  return route[0].difference(sourceCenter).normalize();
	}
	function getOutwardsTargetDirection(linkView, route, options) {
	  const {
	    targetBBox
	  } = linkView;
	  const targetCenter = targetBBox.center();
	  return route[route.length - 1].difference(targetCenter).normalize();
	}
	function getSourceTangentDirection(linkView, route, direction, options) {
	  if (options.sourceDirection) {
	    switch (options.sourceDirection) {
	      case TangentDirections.UP:
	        return new Point(0, -1);
	      case TangentDirections.DOWN:
	        return new Point(0, 1);
	      case TangentDirections.LEFT:
	        return new Point(-1, 0);
	      case TangentDirections.RIGHT:
	        return new Point(1, 0);
	      case TangentDirections.AUTO:
	        return getAutoSourceDirection(linkView, route, options);
	      case TangentDirections.CLOSEST_POINT:
	        return getClosestPointSourceDirection(linkView, route, options);
	      case TangentDirections.OUTWARDS:
	        return getOutwardsSourceDirection(linkView, route, options);
	      default:
	        return options.sourceDirection;
	    }
	  }
	  switch (direction) {
	    case Directions$2.HORIZONTAL:
	      return getHorizontalSourceDirection(linkView, route, options);
	    case Directions$2.VERTICAL:
	      return getVerticalSourceDirection(linkView, route, options);
	    case Directions$2.CLOSEST_POINT:
	      return getClosestPointSourceDirection(linkView, route, options);
	    case Directions$2.OUTWARDS:
	      return getOutwardsSourceDirection(linkView, route, options);
	    case Directions$2.AUTO:
	    default:
	      return getAutoSourceDirection(linkView, route, options);
	  }
	}
	function getTargetTangentDirection(linkView, route, direction, options) {
	  if (options.targetDirection) {
	    switch (options.targetDirection) {
	      case TangentDirections.UP:
	        return new Point(0, -1);
	      case TangentDirections.DOWN:
	        return new Point(0, 1);
	      case TangentDirections.LEFT:
	        return new Point(-1, 0);
	      case TangentDirections.RIGHT:
	        return new Point(1, 0);
	      case TangentDirections.AUTO:
	        return getAutoTargetDirection(linkView, route, options);
	      case TangentDirections.CLOSEST_POINT:
	        return getClosestPointTargetDirection(linkView, route, options);
	      case TangentDirections.OUTWARDS:
	        return getOutwardsTargetDirection(linkView, route, options);
	      default:
	        return options.targetDirection;
	    }
	  }
	  switch (direction) {
	    case Directions$2.HORIZONTAL:
	      return getHorizontalTargetDirection(linkView, route, options);
	    case Directions$2.VERTICAL:
	      return getVerticalTargetDirection(linkView, route, options);
	    case Directions$2.CLOSEST_POINT:
	      return getClosestPointTargetDirection(linkView, route, options);
	    case Directions$2.OUTWARDS:
	      return getOutwardsTargetDirection(linkView, route, options);
	    case Directions$2.AUTO:
	    default:
	      return getAutoTargetDirection(linkView, route, options);
	  }
	}
	function rotateVector(vector, angle) {
	  const cos = Math.cos(angle);
	  const sin = Math.sin(angle);
	  const x = cos * vector.x - sin * vector.y;
	  const y = sin * vector.x + cos * vector.y;
	  vector.x = x;
	  vector.y = y;
	}
	function angleBetweenVectors(v1, v2) {
	  let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());
	  if (cos < -1) cos = -1;
	  if (cos > 1) cos = 1;
	  return Math.acos(cos);
	}
	function determinant(v1, v2) {
	  return v1.x * v2.y - v1.y * v2.x;
	}
	function createCatmullRomCurves(points, sourceTangent, targetTangent, options) {
	  const {
	    tau,
	    coeff
	  } = options;
	  const distances = [];
	  const tangents = [];
	  const catmullRomCurves = [];
	  const n = points.length - 1;
	  for (let i = 0; i < n; i++) {
	    distances[i] = points[i].distance(points[i + 1]);
	  }
	  tangents[0] = sourceTangent;
	  tangents[n] = targetTangent;

	  // The calculation of tangents of vertices
	  for (let i = 1; i < n; i++) {
	    let tpPrev;
	    let tpNext;
	    if (i === 1) {
	      tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);
	    } else {
	      tpPrev = points[i - 1].clone();
	    }
	    if (i === n - 1) {
	      tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);
	    } else {
	      tpNext = points[i + 1].clone();
	    }
	    const v1 = tpPrev.difference(points[i]).normalize();
	    const v2 = tpNext.difference(points[i]).normalize();
	    const vAngle = angleBetweenVectors(v1, v2);
	    let rot = (Math.PI - vAngle) / 2;
	    let t;
	    const vectorDeterminant = determinant(v1, v2);
	    let pointsDeterminant;
	    pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));
	    if (vectorDeterminant < 0) {
	      rot = -rot;
	    }
	    if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {
	      rot = rot - Math.PI;
	    }
	    t = v2.clone();
	    rotateVector(t, rot);
	    const t1 = t.clone();
	    const t2 = t.clone();
	    const scaleFactor1 = distances[i - 1] * coeff;
	    const scaleFactor2 = distances[i] * coeff;
	    t1.scale(scaleFactor1, scaleFactor1);
	    t2.scale(scaleFactor2, scaleFactor2);
	    tangents[i] = [t1, t2];
	  }

	  // The building of a Catmull-Rom curve based of tangents of points
	  for (let i = 0; i < n; i++) {
	    let p0;
	    let p3;
	    if (i === 0) {
	      p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);
	    } else {
	      p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);
	    }
	    if (i === n - 1) {
	      p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);
	    } else {
	      p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);
	    }
	    catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];
	  }
	  return catmullRomCurves;
	}

	// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)
	function catmullRomToBezier(points, options) {
	  const {
	    tau
	  } = options;
	  const bcp1 = new Point();
	  bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);
	  bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);
	  const bcp2 = new Point();
	  bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);
	  bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);
	  return new Curve(points[1], bcp1, bcp2, points[2]);
	}

	var connectors = {
		__proto__: null,
		curve: curve,
		jumpover: jumpover,
		normal: normal$1,
		rounded: rounded,
		smooth: smooth,
		straight: straight
	};

	// ViewBase
	// -------------

	// ViewBases are almost more convention than they are actual code. A View
	// is simply a JavaScript object that represents a logical chunk of UI in the
	// DOM. This might be a single item, an entire list, a sidebar or panel, or
	// even the surrounding frame which wraps your whole app. Defining a chunk of
	// UI as a **View** allows you to define your DOM events declaratively, without
	// having to worry about render order ... and makes it easy for the view to
	// react to specific changes in the state of your models.

	// Creating a ViewBase creates its initial element outside of the DOM,
	// if an existing element is not provided...
	var ViewBase = function (options) {
	  this.cid = options && options.cid || uniqueId('view');
	  this.preinitialize.apply(this, arguments);
	  assign(this, pick(options, viewOptions));
	  this._ensureElement();
	  this.initialize.apply(this, arguments);
	};

	// Cached regex to split keys for `delegate`.
	var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	// List of view options to be set as properties.
	// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.
	var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];

	// Set up all inheritable **ViewBase** properties and methods.
	assign(ViewBase.prototype, Events, {
	  // The default `tagName` of a View's element is `"div"`.
	  tagName: 'div',
	  // mvc.$ delegate for element lookup, scoped to DOM elements within the
	  // current view. This should be preferred to global lookups where possible.
	  $: function (selector) {
	    return this.$el.find(selector);
	  },
	  // preinitialize is an empty function by default. You can override it with a function
	  // or object.  preinitialize will run before any instantiation logic is run in the View
	  preinitialize: function () {
	    // No implementation.
	  },
	  // Initialize is an empty function by default. Override it with your own
	  // initialization logic.
	  initialize: function () {
	    // No implementation.
	  },
	  // **render** is the core function that your view should override, in order
	  // to populate its element (`this.el`), with the appropriate HTML. The
	  // convention is for **render** to always return `this`.
	  render: function () {
	    return this;
	  },
	  // Remove this view by taking the element out of the DOM, and removing any
	  // applicable Events listeners.
	  remove: function () {
	    this._removeElement();
	    this.stopListening();
	    return this;
	  },
	  // Remove this view's element from the document and all event listeners
	  // attached to it. Exposed for subclasses using an alternative DOM
	  // manipulation API.
	  _removeElement: function () {
	    this.$el.remove();
	  },
	  // Change the view's element (`this.el` property) and re-delegate the
	  // view's events on the new element.
	  setElement: function (element) {
	    this.undelegateEvents();
	    this._setElement(element);
	    this.delegateEvents();
	    return this;
	  },
	  // Creates the `this.el` and `this.$el` references for this view using the
	  // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$
	  // context or an element. Subclasses can override this to utilize an
	  // alternative DOM manipulation API and are only required to set the
	  // `this.el` property.
	  _setElement: function (el) {
	    this.$el = el instanceof $ ? el : $(el);
	    this.el = this.$el[0];
	  },
	  // Set callbacks, where `this.events` is a hash of
	  //
	  // *{"event selector": "callback"}*
	  //
	  //     {
	  //       'mousedown .title':  'edit',
	  //       'click .button':     'save',
	  //       'click .open':       function(e) { ... }
	  //     }
	  //
	  // pairs. Callbacks will be bound to the view, with `this` set properly.
	  // Uses event delegation for efficiency.
	  // Omitting the selector binds the event to `this.el`.
	  delegateEvents: function (events) {
	    events || (events = result(this, 'events'));
	    if (!events) return this;
	    this.undelegateEvents();
	    for (var key in events) {
	      var method = events[key];
	      if (!isFunction(method)) method = this[method];
	      if (!method) continue;
	      var match = key.match(delegateEventSplitter);
	      this.delegate(match[1], match[2], method.bind(this));
	    }
	    return this;
	  },
	  // Add a single event listener to the view's element (or a child element
	  // using `selector`). This only works for delegate-able events: not `focus`,
	  // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	  delegate: function (eventName, selector, listener) {
	    this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
	    return this;
	  },
	  // Clears all callbacks previously bound to the view by `delegateEvents`.
	  // You usually don't need to use this, but may wish to if you have multiple
	  // viewbases attached to the same DOM element.
	  undelegateEvents: function () {
	    if (this.$el) this.$el.off('.delegateEvents' + this.cid);
	    return this;
	  },
	  // A finer-grained `undelegateEvents` for removing a single delegated event.
	  // `selector` and `listener` are both optional.
	  undelegate: function (eventName, selector, listener) {
	    this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
	    return this;
	  },
	  // Produces a DOM element to be assigned to your view. Exposed for
	  // subclasses using an alternative DOM manipulation API.
	  _createElement: function (tagName) {
	    return document.createElement(tagName);
	  },
	  // Ensure that the View has a DOM element to render into.
	  // If `this.el` is a string, pass it through `$()`, take the first
	  // matching element, and re-assign it to `el`. Otherwise, create
	  // an element from the `id`, `className` and `tagName` properties.
	  _ensureElement: function () {
	    if (!this.el) {
	      var attrs = assign({}, result(this, 'attributes'));
	      if (this.id) attrs.id = result(this, 'id');
	      if (this.className) attrs['class'] = result(this, 'className');
	      this.setElement(this._createElement(result(this, 'tagName')));
	      this._setAttributes(attrs);
	    } else {
	      this.setElement(result(this, 'el'));
	    }
	  },
	  // Set attributes from a hash on this view's element.  Exposed for
	  // subclasses using an alternative DOM manipulation API.
	  _setAttributes: function (attributes) {
	    this.$el.attr(attributes);
	  }
	});

	// Set up inheritance for the view.
	ViewBase.extend = extend;

	const views = {};
	const View = ViewBase.extend({
	  options: {},
	  theme: null,
	  themeClassNamePrefix: addClassNamePrefix('theme-'),
	  requireSetThemeOverride: false,
	  defaultTheme: config$3.defaultTheme,
	  children: null,
	  childNodes: null,
	  DETACHABLE: true,
	  UPDATE_PRIORITY: 2,
	  /** @deprecated is no longer used (moved to Paper) */
	  FLAG_INSERT: 1 << 30,
	  /** @deprecated is no longer used */
	  FLAG_REMOVE: 1 << 29,
	  /** @deprecated is no longer used */
	  FLAG_INIT: 1 << 28,
	  constructor: function (options) {
	    this.requireSetThemeOverride = options && !!options.theme;
	    this.options = assign({}, this.options, options);
	    ViewBase.call(this, options);
	  },
	  initialize: function () {
	    views[this.cid] = this;
	    this.setTheme(this.options.theme || this.defaultTheme);
	    this.init();
	  },
	  unmount: function () {
	    if (this.svgElement) {
	      this.vel.remove();
	    } else {
	      this.$el.remove();
	    }
	  },
	  isMounted: function () {
	    return this.el.parentNode !== null;
	  },
	  renderChildren: function (children) {
	    children || (children = result(this, 'children'));
	    if (children) {
	      var isSVG = this.svgElement;
	      var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];
	      var doc = parseDOMJSON(children, namespace);
	      (isSVG ? this.vel : this.$el).empty().append(doc.fragment);
	      this.childNodes = doc.selectors;
	    }
	    return this;
	  },
	  findAttributeNode: function (attributeName, node) {
	    let currentNode = node;
	    while (currentNode && currentNode.nodeType === 1) {
	      // attribute found
	      // (empty value does not count as attribute found)
	      if (currentNode.getAttribute(attributeName)) return currentNode;
	      // do not climb up the DOM
	      if (currentNode === this.el) return null;
	      // try parent node
	      currentNode = currentNode.parentNode;
	    }
	    return null;
	  },
	  findAttribute: function (attributeName, node) {
	    const matchedNode = this.findAttributeNode(attributeName, node);
	    return matchedNode && matchedNode.getAttribute(attributeName);
	  },
	  // Override the mvc ViewBase `_ensureElement()` method in order to create an
	  // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.
	  // Expose class name setter as a separate method.
	  _ensureElement: function () {
	    if (!this.el) {
	      var tagName = result(this, 'tagName');
	      var attrs = assign({}, result(this, 'attributes'));
	      var style = assign({}, result(this, 'style'));
	      if (this.id) attrs.id = result(this, 'id');
	      this.setElement(this._createElement(tagName));
	      this._setAttributes(attrs);
	      this._setStyle(style);
	    } else {
	      this.setElement(result(this, 'el'));
	    }
	    this._ensureElClassName();
	  },
	  _setAttributes: function (attrs) {
	    if (this.svgElement) {
	      this.vel.attr(attrs);
	    } else {
	      this.$el.attr(attrs);
	    }
	  },
	  _setStyle: function (style) {
	    this.$el.css(style);
	  },
	  _createElement: function (tagName) {
	    if (this.svgElement) {
	      return document.createElementNS(V.namespace.svg, tagName);
	    } else {
	      return document.createElement(tagName);
	    }
	  },
	  // Utilize an alternative DOM manipulation API by
	  // adding an element reference wrapped in Vectorizer.
	  _setElement: function (el) {
	    this.$el = el instanceof $ ? el : $(el);
	    this.el = this.$el[0];
	    if (this.svgElement) this.vel = V(this.el);
	  },
	  _ensureElClassName: function () {
	    var className = result(this, 'className');
	    if (!className) return;
	    var prefixedClassName = addClassNamePrefix(className);
	    // Note: className removal here kept for backwards compatibility only
	    if (this.svgElement) {
	      this.vel.removeClass(className).addClass(prefixedClassName);
	    } else {
	      this.$el.removeClass(className).addClass(prefixedClassName);
	    }
	  },
	  init: function () {
	    // Intentionally empty.
	    // This method is meant to be overridden.
	  },
	  onRender: function () {
	    // Intentionally empty.
	    // This method is meant to be overridden.
	  },
	  confirmUpdate: function () {
	    // Intentionally empty.
	    // This method is meant to be overridden.
	    return 0;
	  },
	  setTheme: function (theme, opt) {
	    opt = opt || {};

	    // Theme is already set, override is required, and override has not been set.
	    // Don't set the theme.
	    if (this.theme && this.requireSetThemeOverride && !opt.override) {
	      return this;
	    }
	    this.removeThemeClassName();
	    this.addThemeClassName(theme);
	    this.onSetTheme(this.theme /* oldTheme */, theme /* newTheme */);
	    this.theme = theme;
	    return this;
	  },
	  addThemeClassName: function (theme) {
	    theme = theme || this.theme;
	    if (!theme) return this;
	    var className = this.themeClassNamePrefix + theme;
	    if (this.svgElement) {
	      this.vel.addClass(className);
	    } else {
	      this.$el.addClass(className);
	    }
	    return this;
	  },
	  removeThemeClassName: function (theme) {
	    theme = theme || this.theme;
	    var className = this.themeClassNamePrefix + theme;
	    if (this.svgElement) {
	      this.vel.removeClass(className);
	    } else {
	      this.$el.removeClass(className);
	    }
	    return this;
	  },
	  onSetTheme: function (oldTheme, newTheme) {
	    // Intentionally empty.
	    // This method is meant to be overridden.
	  },
	  remove: function () {
	    this.onRemove();
	    this.undelegateDocumentEvents();
	    views[this.cid] = null;
	    ViewBase.prototype.remove.apply(this, arguments);
	    return this;
	  },
	  onRemove: function () {
	    // Intentionally empty.
	    // This method is meant to be overridden.
	  },
	  getEventNamespace: function () {
	    // Returns a per-session unique namespace
	    return '.joint-event-ns-' + this.cid;
	  },
	  delegateElementEvents: function (element, events, data) {
	    if (!events) return this;
	    data || (data = {});
	    var eventNS = this.getEventNamespace();
	    for (var eventName in events) {
	      var method = events[eventName];
	      if (typeof method !== 'function') method = this[method];
	      if (!method) continue;
	      $(element).on(eventName + eventNS, data, method.bind(this));
	    }
	    return this;
	  },
	  undelegateElementEvents: function (element) {
	    $(element).off(this.getEventNamespace());
	    return this;
	  },
	  delegateDocumentEvents: function (events, data) {
	    events || (events = result(this, 'documentEvents'));
	    return this.delegateElementEvents(document, events, data);
	  },
	  undelegateDocumentEvents: function () {
	    return this.undelegateElementEvents(document);
	  },
	  eventData: function (evt, data) {
	    if (!evt) throw new Error('eventData(): event object required.');
	    var currentData = evt.data;
	    var key = '__' + this.cid + '__';
	    if (data === undefined) {
	      if (!currentData) return {};
	      return currentData[key] || {};
	    }
	    currentData || (currentData = evt.data = {});
	    currentData[key] || (currentData[key] = {});
	    assign(currentData[key], data);
	    return this;
	  },
	  stopPropagation: function (evt) {
	    this.eventData(evt, {
	      propagationStopped: true
	    });
	    return this;
	  },
	  isPropagationStopped: function (evt) {
	    return !!this.eventData(evt).propagationStopped;
	  }
	}, {
	  extend: function () {
	    var args = Array.from(arguments);

	    // Deep clone the prototype and static properties objects.
	    // This prevents unexpected behavior where some properties are overwritten outside of this function.
	    var protoProps = args[0] && assign({}, args[0]) || {};
	    var staticProps = args[1] && assign({}, args[1]) || {};

	    // Need the real render method so that we can wrap it and call it later.
	    var renderFn = protoProps.render || this.prototype && this.prototype.render || null;

	    /*
	        Wrap the real render method so that:
	            .. `onRender` is always called.
	            .. `this` is always returned.
	    */
	    protoProps.render = function () {
	      if (typeof renderFn === 'function') {
	        // Call the original render method.
	        renderFn.apply(this, arguments);
	      }
	      if (this.render.__render__ === renderFn) {
	        // Should always call onRender() method.
	        // Should call it only once when renderFn is actual prototype method i.e. not the wrapper
	        this.onRender();
	      }

	      // Should always return itself.
	      return this;
	    };
	    protoProps.render.__render__ = renderFn;
	    return ViewBase.extend.call(this, protoProps, staticProps);
	  }
	});

	class Listener {
	  constructor(...callbackArguments) {
	    this.callbackArguments = callbackArguments;
	  }
	  listenTo(object, evt, ...args) {
	    const {
	      callbackArguments
	    } = this;
	    // signature 1 - (object, eventHashMap, context)
	    if (evt && typeof evt === 'object') {
	      const [context = null] = args;
	      Object.entries(evt).forEach(([eventName, cb]) => {
	        if (typeof cb !== 'function') return;
	        // Invoke the callback with callbackArguments passed first
	        if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);
	        Events.listenTo.call(this, object, eventName, cb);
	      });
	    }
	    // signature 2 - (object, event, callback, context)
	    else if (typeof evt === 'string' && typeof args[0] === 'function') {
	      let [cb, context = null] = args;
	      // Invoke the callback with callbackArguments passed first
	      if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);
	      Events.listenTo.call(this, object, evt, cb);
	    }
	  }
	  stopListening() {
	    Events.stopListening.call(this);
	  }
	}

	// Collection
	// -------------------

	// If models tend to represent a single row of data, a Collection is
	// more analogous to a table full of data ... or a small slice or page of that
	// table, or a collection of rows that belong together for a particular reason
	// -- all of the messages in this particular folder, all of the documents
	// belonging to this particular author, and so on. Collections maintain
	// indexes of their models, both in order, and for lookup by `id`.

	// Create a new **Collection**, perhaps to contain a specific type of `model`.
	// If a `comparator` is specified, the Collection will maintain
	// its models in sort order, as they're added and removed.
	var Collection = function (models, options) {
	  options || (options = {});
	  this.preinitialize.apply(this, arguments);
	  if (options.model) this.model = options.model;
	  if (options.comparator !== void 0) this.comparator = options.comparator;
	  this._reset();
	  this.initialize.apply(this, arguments);
	  if (models) this.reset(models, assign({
	    silent: true
	  }, options));
	};

	// Default options for `Collection#set`.
	var setOptions = {
	  add: true,
	  remove: true,
	  merge: true
	};
	var addOptions = {
	  add: true,
	  remove: false
	};

	// Splices `insert` into `array` at index `at`.
	var splice = function (array, insert, at) {
	  at = Math.min(Math.max(at, 0), array.length);
	  var tail = Array(array.length - at);
	  var length = insert.length;
	  var i;
	  for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
	  for (i = 0; i < length; i++) array[i + at] = insert[i];
	  for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	};

	// Define the Collection's inheritable methods.
	assign(Collection.prototype, Events, {
	  // The default model for a collection is just a **Model**.
	  // This should be overridden in most cases.
	  model: Model,
	  // preinitialize is an empty function by default. You can override it with a function
	  // or object.  preinitialize will run before any instantiation logic is run in the Collection.
	  preinitialize: function () {
	    // No implementation.
	  },
	  // Initialize is an empty function by default. Override it with your own
	  // initialization logic.
	  initialize: function () {
	    // No implementation.
	  },
	  // The JSON representation of a Collection is an array of the
	  // models' attributes.
	  toJSON: function (options) {
	    return this.map(function (model) {
	      return model.toJSON(options);
	    });
	  },
	  // Add a model, or list of models to the set. `models` may be
	  // Models or raw JavaScript objects to be converted to Models, or any
	  // combination of the two.
	  add: function (models, options) {
	    return this.set(models, assign({
	      merge: false
	    }, options, addOptions));
	  },
	  // Remove a model, or a list of models from the set.
	  remove: function (models, options) {
	    options = assign({}, options);
	    var singular = !Array.isArray(models);
	    models = singular ? [models] : models.slice();
	    var removed = this._removeModels(models, options);
	    if (!options.silent && removed.length) {
	      options.changes = {
	        added: [],
	        merged: [],
	        removed: removed
	      };
	      this.trigger('update', this, options);
	    }
	    return singular ? removed[0] : removed;
	  },
	  // Update a collection by `set`-ing a new list of models, adding new ones,
	  // removing models that are no longer present, and merging models that
	  // already exist in the collection, as necessary. Similar to **Model#set**,
	  // the core operation for updating the data contained by the collection.
	  set: function (models, options) {
	    if (models == null) return;
	    options = assign({}, setOptions, options);
	    var singular = !Array.isArray(models);
	    models = singular ? [models] : models.slice();
	    var at = options.at;
	    if (at != null) at = +at;
	    if (at > this.length) at = this.length;
	    if (at < 0) at += this.length + 1;
	    var set = [];
	    var toAdd = [];
	    var toMerge = [];
	    var toRemove = [];
	    var modelMap = {};
	    var add = options.add;
	    var merge = options.merge;
	    var remove = options.remove;
	    var sort = false;
	    var sortable = this.comparator && at == null && options.sort !== false;
	    var sortAttr = isString(this.comparator) ? this.comparator : null;

	    // Turn bare objects into model references, and prevent invalid models
	    // from being added.
	    var model, i;
	    for (i = 0; i < models.length; i++) {
	      model = models[i];

	      // If a duplicate is found, prevent it from being added and
	      // optionally merge it into the existing model.
	      var existing = this.get(model);
	      if (existing) {
	        if (merge && model !== existing) {
	          var attrs = this._isModel(model) ? model.attributes : model;
	          existing.set(attrs, options);
	          toMerge.push(existing);
	          if (sortable && !sort) sort = existing.hasChanged(sortAttr);
	        }
	        if (!modelMap[existing.cid]) {
	          modelMap[existing.cid] = true;
	          set.push(existing);
	        }
	        models[i] = existing;

	        // If this is a new, valid model, push it to the `toAdd` list.
	      } else if (add) {
	        model = models[i] = this._prepareModel(model, options);
	        if (model) {
	          toAdd.push(model);
	          this._addReference(model, options);
	          modelMap[model.cid] = true;
	          set.push(model);
	        }
	      }
	    }

	    // Remove stale models.
	    if (remove) {
	      for (i = 0; i < this.length; i++) {
	        model = this.models[i];
	        if (!modelMap[model.cid]) toRemove.push(model);
	      }
	      if (toRemove.length) this._removeModels(toRemove, options);
	    }

	    // See if sorting is needed, update `length` and splice in new models.
	    var orderChanged = false;
	    var replace = !sortable && add && remove;
	    if (set.length && replace) {
	      orderChanged = this.length !== set.length || this.models.some(function (m, index) {
	        return m !== set[index];
	      });
	      this.models.length = 0;
	      splice(this.models, set, 0);
	      this.length = this.models.length;
	    } else if (toAdd.length) {
	      if (sortable) sort = true;
	      splice(this.models, toAdd, at == null ? this.length : at);
	      this.length = this.models.length;
	    }

	    // Silently sort the collection if appropriate.
	    if (sort) this.sort({
	      silent: true
	    });

	    // Unless silenced, it's time to fire all appropriate add/sort/update events.
	    if (!options.silent) {
	      for (i = 0; i < toAdd.length; i++) {
	        if (at != null) options.index = at + i;
	        model = toAdd[i];
	        model.trigger(model.eventPrefix + 'add', model, this, options);
	      }
	      if (sort || orderChanged) this.trigger('sort', this, options);
	      if (toAdd.length || toRemove.length || toMerge.length) {
	        options.changes = {
	          added: toAdd,
	          removed: toRemove,
	          merged: toMerge
	        };
	        this.trigger('update', this, options);
	      }
	    }

	    // Return the added (or merged) model (or models).
	    return singular ? models[0] : models;
	  },
	  // When you have more items than you want to add or remove individually,
	  // you can reset the entire set with a new list of models, without firing
	  // any granular `add` or `remove` events. Fires `reset` when finished.
	  // Useful for bulk operations and optimizations.
	  reset: function (models, options) {
	    options = options ? clone$1(options) : {};
	    for (var i = 0; i < this.models.length; i++) {
	      this._removeReference(this.models[i], options);
	    }
	    options.previousModels = this.models;
	    this._reset();
	    models = this.add(models, assign({
	      silent: true
	    }, options));
	    if (!options.silent) this.trigger('reset', this, options);
	    return models;
	  },
	  // Add a model to the end of the collection.
	  push: function (model, options) {
	    return this.add(model, assign({
	      at: this.length
	    }, options));
	  },
	  // Remove a model from the end of the collection.
	  pop: function (options) {
	    var model = this.at(this.length - 1);
	    return this.remove(model, options);
	  },
	  // Add a model to the beginning of the collection.
	  unshift: function (model, options) {
	    return this.add(model, assign({
	      at: 0
	    }, options));
	  },
	  // Remove a model from the beginning of the collection.
	  shift: function (options) {
	    var model = this.at(0);
	    return this.remove(model, options);
	  },
	  // Slice out a sub-array of models from the collection.
	  slice: function () {
	    return Array.prototype.slice.apply(this.models, arguments);
	  },
	  // Get a model from the set by id, cid, model object with id or cid
	  // properties, or an attributes object that is transformed through modelId.
	  get: function (obj) {
	    if (obj == null) return void 0;
	    return this._byId.get(obj) || this._byId.get(this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)) || obj.cid && this._byId.get(obj.cid);
	  },
	  // Returns `true` if the model is in the collection.
	  has: function (obj) {
	    return this.get(obj) != null;
	  },
	  // Get the model at the given index.
	  at: function (index) {
	    if (index < 0) index += this.length;
	    return this.models[index];
	  },
	  // Force the collection to re-sort itself. You don't need to call this under
	  // normal circumstances, as the set will maintain sort order as each item
	  // is added.
	  sort: function (options) {
	    var comparator = this.comparator;
	    if (!comparator) throw new Error('Cannot sort a set without a comparator');
	    options || (options = {});
	    var length = comparator.length;
	    if (isFunction(comparator)) comparator = comparator.bind(this);

	    // Run sort based on type of `comparator`.
	    if (length === 1 || isString(comparator)) {
	      this.models = this.sortBy(comparator);
	    } else {
	      this.models.sort(comparator);
	    }
	    if (!options.silent) this.trigger('sort', this, options);
	    return this;
	  },
	  // Create a new collection with an identical list of models as this one.
	  clone: function () {
	    return new this.constructor(this.models, {
	      model: this.model,
	      comparator: this.comparator
	    });
	  },
	  // Define how to uniquely identify models in the collection.
	  modelId: function (attrs, idAttribute) {
	    var _this$model$prototype;
	    return attrs[idAttribute || ((_this$model$prototype = this.model.prototype) === null || _this$model$prototype === void 0 ? void 0 : _this$model$prototype.idAttribute) || 'id'];
	  },
	  // Get an iterator of all models in this collection.
	  values: function () {
	    return new CollectionIterator(this, ITERATOR_VALUES);
	  },
	  // Get an iterator of all model IDs in this collection.
	  keys: function () {
	    return new CollectionIterator(this, ITERATOR_KEYS);
	  },
	  // Get an iterator of all [ID, model] tuples in this collection.
	  entries: function () {
	    return new CollectionIterator(this, ITERATOR_KEYSVALUES);
	  },
	  // Iterate over elements of the collection, and invoke fn for each element
	  each: function (fn, context) {
	    this.models.forEach(fn, context);
	  },
	  // Iterate over elements of collection, and return an array of all elements fn returns truthy for
	  filter: function (fn, context) {
	    return this.models.filter(fn, context);
	  },
	  find: function (fn, context) {
	    return this.models.find(fn, context);
	  },
	  findIndex: function (fn, context) {
	    return this.models.findIndex(fn, context);
	  },
	  // Return the first model of the collection
	  first: function () {
	    return this.models[0];
	  },
	  // Return true if value is in the collection
	  includes: function (value) {
	    return this.models.includes(value);
	  },
	  // Return the last model of the collection
	  last: function () {
	    return this.models[this.models.length - 1];
	  },
	  // Return true if collection has no elements
	  isEmpty: function () {
	    return !this.models.length;
	  },
	  // Create an array of values by running each element in the collection through fn
	  map: function (fn, context) {
	    return this.models.map(fn, context);
	  },
	  // Runs "reducer" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value
	  reduce: function (fn, initAcc = this.first()) {
	    return this.models.reduce(fn, initAcc);
	  },
	  // Private method to reset all internal state. Called when the collection
	  // is first initialized or reset.
	  _reset: function () {
	    this.length = 0;
	    this.models = [];
	    this._byId = new Map();
	  },
	  // Prepare a hash of attributes (or other model) to be added to this
	  // collection.
	  _prepareModel: function (attrs, options) {
	    if (this._isModel(attrs)) {
	      if (!options.dry && !attrs.collection) attrs.collection = this;
	      return attrs;
	    }
	    options = options ? clone$1(options) : {};
	    if (!options.dry) options.collection = this;
	    var model;
	    if (this.model.prototype) {
	      model = new this.model(attrs, options);
	    } else {
	      // ES class methods didn't have prototype
	      model = this.model(attrs, options);
	    }
	    if (!model.validationError) return model;
	    this.trigger('invalid', this, model.validationError, options);
	    return false;
	  },
	  // Internal method called by both remove and set.
	  _removeModels: function (models, options) {
	    var removed = [];
	    for (var i = 0; i < models.length; i++) {
	      var model = this.get(models[i]);
	      if (!model) continue;
	      var index = this.models.indexOf(model);
	      this.models.splice(index, 1);
	      this.length--;

	      // Remove references before triggering 'remove' event to prevent an
	      // infinite loop. #3693
	      this._byId.delete(model.cid);
	      var id = this.modelId(model.attributes, model.idAttribute);
	      if (id != null) this._byId.delete(id);
	      if (!options.silent) {
	        options.index = index;
	        model.trigger(model.eventPrefix + 'remove', model, this, options);
	      }
	      removed.push(model);
	      this._removeReference(model, options);
	    }
	    if (models.length > 0 && !options.silent) delete options.index;
	    return removed;
	  },
	  // Method for checking whether an object should be considered a model for
	  // the purposes of adding to the collection.
	  _isModel: function (model) {
	    return model instanceof Model;
	  },
	  // Internal method to create a model's ties to a collection.
	  _addReference: function (model, options) {
	    this._byId.set(model.cid, model);
	    var id = this.modelId(model.attributes, model.idAttribute);
	    if (id != null) this._byId.set(id, model);
	    model.on('all', this._onModelEvent, this);
	  },
	  // Internal method to sever a model's ties to a collection.
	  _removeReference: function (model, options) {
	    this._byId.delete(model.cid);
	    var id = this.modelId(model.attributes, model.idAttribute);
	    if (id != null) this._byId.delete(id);
	    if (!options.dry && this === model.collection) delete model.collection;
	    model.off('all', this._onModelEvent, this);
	  },
	  // Internal method called every time a model in the set fires an event.
	  // Sets need to update their indexes when models change ids. All other
	  // events simply proxy through. "add" and "remove" events that originate
	  // in other collections are ignored.
	  _onModelEvent: function (event, model, collection, options) {
	    if (model) {
	      if ((event === model.eventPrefix + 'add' || event === model.eventPrefix + 'remove') && collection !== this) return;
	      if (event === 'changeId') {
	        var prevId = this.modelId(model.previousAttributes(), model.idAttribute);
	        var id = this.modelId(model.attributes, model.idAttribute);
	        if (prevId != null) this._byId.delete(prevId);
	        if (id != null) this._byId.set(id, model);
	      }
	    }
	    this.trigger.apply(this, arguments);
	  }
	});

	// Defining an @@iterator method implements JavaScript's Iterable protocol.
	// In modern ES2015 browsers, this value is found at Symbol.iterator.
	var $$iterator = typeof Symbol === 'function' && Symbol.iterator;
	if ($$iterator) {
	  Collection.prototype[$$iterator] = Collection.prototype.values;
	}

	// CollectionIterator
	// ------------------

	// A CollectionIterator implements JavaScript's Iterator protocol, allowing the
	// use of `for of` loops in modern browsers and interoperation between
	// Collection and other JavaScript functions and third-party libraries
	// which can operate on Iterables.
	var CollectionIterator = function (collection, kind) {
	  this._collection = collection;
	  this._kind = kind;
	  this._index = 0;
	};

	// This "enum" defines the three possible kinds of values which can be emitted
	// by a CollectionIterator that correspond to the values(), keys() and entries()
	// methods on Collection, respectively.
	var ITERATOR_VALUES = 1;
	var ITERATOR_KEYS = 2;
	var ITERATOR_KEYSVALUES = 3;

	// All Iterators should themselves be Iterable.
	if ($$iterator) {
	  CollectionIterator.prototype[$$iterator] = function () {
	    return this;
	  };
	}
	CollectionIterator.prototype.next = function () {
	  if (this._collection) {
	    // Only continue iterating if the iterated collection is long enough.
	    if (this._index < this._collection.length) {
	      var model = this._collection.at(this._index);
	      this._index++;

	      // Construct a value depending on what kind of values should be iterated.
	      var value;
	      if (this._kind === ITERATOR_VALUES) {
	        value = model;
	      } else {
	        var id = this._collection.modelId(model.attributes, model.idAttribute);
	        if (this._kind === ITERATOR_KEYS) {
	          value = id;
	        } else {
	          // ITERATOR_KEYSVALUES
	          value = [id, model];
	        }
	      }
	      return {
	        value: value,
	        done: false
	      };
	    }

	    // Once exhausted, remove the reference to the collection so future
	    // calls to the next method always return done.
	    this._collection = void 0;
	  }
	  return {
	    value: void 0,
	    done: true
	  };
	};

	//  Methods that we want to implement on the Collection.
	var collectionMethods = {
	  toArray: 1,
	  sortBy: 3
	};

	// Mix in each method as a proxy to `Collection#models`.

	var config$2 = [Collection, collectionMethods, 'models'];
	function addMethods(config) {
	  var Base = config[0],
	    methods = config[1],
	    attribute = config[2];
	  const methodsToAdd = {
	    sortBy,
	    toArray: toArray$1
	  };
	  addMethodsUtil(Base, methodsToAdd, methods, attribute);
	}
	addMethods(config$2);

	// Set up inheritance for the collection.
	Collection.extend = extend;

	var index$4 = {
		__proto__: null,
		$: $,
		Collection: Collection,
		Data: Data,
		Event: Event,
		Events: Events,
		Listener: Listener,
		Model: Model,
		View: View,
		ViewBase: ViewBase,
		views: views
	};

	function toArray(obj) {
	  if (!obj) return [];
	  if (Array.isArray(obj)) return obj;
	  return [obj];
	}
	const HighlighterView = View.extend({
	  tagName: 'g',
	  svgElement: true,
	  className: 'highlight',
	  HIGHLIGHT_FLAG: 1,
	  UPDATE_PRIORITY: 3,
	  DETACHABLE: false,
	  UPDATABLE: true,
	  MOUNTABLE: true,
	  cellView: null,
	  nodeSelector: null,
	  node: null,
	  updateRequested: false,
	  postponedUpdate: false,
	  transformGroup: null,
	  detachedTransformGroup: null,
	  requestUpdate(cellView, nodeSelector) {
	    const {
	      paper
	    } = cellView;
	    this.cellView = cellView;
	    this.nodeSelector = nodeSelector;
	    if (paper) {
	      this.updateRequested = true;
	      paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
	    }
	  },
	  confirmUpdate() {
	    // The cellView is now rendered/updated since it has a higher update priority.
	    this.updateRequested = false;
	    const {
	      cellView,
	      nodeSelector
	    } = this;
	    if (cellView.isMounted()) {
	      this.update(cellView, nodeSelector);
	      this.mount();
	      this.transform();
	    } else {
	      this.postponedUpdate = true;
	    }
	    return 0;
	  },
	  findNode(cellView, nodeSelector = null) {
	    let el;
	    if (typeof nodeSelector === 'string') {
	      el = cellView.findNode(nodeSelector);
	    } else if (isPlainObject(nodeSelector)) {
	      const isLink = cellView.model.isLink();
	      const {
	        label = null,
	        port,
	        selector
	      } = nodeSelector;
	      if (isLink && label !== null) {
	        // Link Label Selector
	        el = cellView.findLabelNode(label, selector);
	      } else if (!isLink && port) {
	        // Element Port Selector
	        el = cellView.findPortNode(port, selector);
	      } else {
	        // Cell Selector
	        el = cellView.findNode(selector);
	      }
	    } else if (nodeSelector) {
	      el = V.toNode(nodeSelector);
	      if (!(el instanceof SVGElement) || !cellView.el.contains(el)) el = null;
	    }
	    return el ? el : null;
	  },
	  getNodeMatrix(cellView, node) {
	    const {
	      options
	    } = this;
	    const {
	      layer
	    } = options;
	    const {
	      rotatableNode
	    } = cellView;
	    const nodeMatrix = cellView.getNodeMatrix(node);
	    if (rotatableNode) {
	      if (layer) {
	        if (rotatableNode.contains(node)) {
	          return nodeMatrix;
	        }
	        // The node is outside of the rotatable group.
	        // Compensate the rotation set by transformGroup.
	        return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);
	      } else {
	        return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);
	      }
	    }
	    return nodeMatrix;
	  },
	  mount() {
	    const {
	      MOUNTABLE,
	      cellView,
	      el,
	      options,
	      transformGroup,
	      detachedTransformGroup,
	      postponedUpdate,
	      nodeSelector
	    } = this;
	    if (!MOUNTABLE || transformGroup) return;
	    if (postponedUpdate) {
	      // The cellView was not mounted when the update was requested.
	      // The update was postponed until the cellView is mounted.
	      this.update(cellView, nodeSelector);
	      this.transform();
	      return;
	    }
	    const {
	      paper
	    } = cellView;
	    const {
	      layer: layerName,
	      z
	    } = options;
	    if (layerName) {
	      let vGroup;
	      if (detachedTransformGroup) {
	        vGroup = detachedTransformGroup;
	        this.detachedTransformGroup = null;
	      } else {
	        vGroup = V('g').addClass('highlight-transform').append(el);
	      }
	      this.transformGroup = vGroup;
	      paper.getLayerView(layerName).insertSortedNode(vGroup.node, z);
	    } else {
	      const children = cellView.el.children;
	      const index = Math.max(z, 0);
	      const beforeChild = children[index];

	      // If the provided `z` is a number and there is an element on the index,
	      // we need to insert the highlighter before the element on the index.
	      // Otherwise, the highlighter will be appended as the last child.
	      const toBeInserted = isNumber(z) && beforeChild;
	      const isElementAtTargetPosition = toBeInserted
	      // If the element is being inserted, check if it is not already at the correct position.
	      ? el === beforeChild
	      // If the element is being appended, check if it is not already last child.
	      : !el.nextElementSibling;

	      // If the element is already mounted and does not require repositioning, do nothing.
	      if (el.parentNode && isElementAtTargetPosition) return;
	      if (toBeInserted) {
	        cellView.el.insertBefore(el, beforeChild);
	      } else {
	        cellView.el.appendChild(el);
	      }
	    }
	  },
	  unmount() {
	    const {
	      MOUNTABLE,
	      transformGroup,
	      vel,
	      options
	    } = this;
	    if (!MOUNTABLE) return;
	    if (options.layer) {
	      if (!transformGroup) return;
	      // else: if `transformGroup` is not null, it means the highlighter
	      // has not been mounted yet
	      this.transformGroup = null;
	      this.detachedTransformGroup = transformGroup;
	      transformGroup.remove();
	    } else {
	      vel.remove();
	    }
	  },
	  transform() {
	    const {
	      transformGroup,
	      cellView,
	      updateRequested
	    } = this;
	    if (!transformGroup || cellView.model.isLink() || updateRequested) return;
	    const translateMatrix = cellView.getRootTranslateMatrix();
	    const rotateMatrix = cellView.getRootRotateMatrix();
	    const transformMatrix = translateMatrix.multiply(rotateMatrix);
	    transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));
	  },
	  update() {
	    const {
	      node: prevNode,
	      cellView,
	      nodeSelector,
	      updateRequested,
	      id
	    } = this;
	    if (updateRequested) return;
	    this.postponedUpdate = false;
	    const node = this.node = this.findNode(cellView, nodeSelector);
	    if (prevNode) {
	      this.unhighlight(cellView, prevNode);
	    }
	    if (node) {
	      this.highlight(cellView, node);
	      this.mount();
	    } else {
	      this.unmount();
	      cellView.notify('cell:highlight:invalid', id, this);
	    }
	  },
	  onRemove() {
	    const {
	      node,
	      cellView,
	      id,
	      constructor
	    } = this;
	    if (node) {
	      this.unhighlight(cellView, node);
	    }
	    this.unmount();
	    constructor._removeRef(cellView, id);
	  },
	  highlight(_cellView, _node) {
	    // to be overridden
	  },
	  unhighlight(_cellView, _node) {
	    // to be overridden
	  },
	  // Update Attributes

	  listenToUpdateAttributes(cellView) {
	    const attributes = result(this, 'UPDATE_ATTRIBUTES');
	    if (!Array.isArray(attributes) || attributes.length === 0) return;
	    this.listenTo(cellView.model, 'change', this.onCellAttributeChange);
	  },
	  onCellAttributeChange() {
	    const {
	      cellView
	    } = this;
	    if (!cellView) return;
	    const {
	      model,
	      paper
	    } = cellView;
	    const attributes = result(this, 'UPDATE_ATTRIBUTES');
	    if (!attributes.some(attribute => model.hasChanged(attribute))) return;
	    paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
	  }
	}, {
	  _views: {},
	  // Used internally by CellView highlight()
	  highlight: function (cellView, node, opt) {
	    const id = this.uniqueId(node, opt);
	    this.add(cellView, node, id, opt);
	  },
	  // Used internally by CellView unhighlight()
	  unhighlight: function (cellView, node, opt) {
	    const id = this.uniqueId(node, opt);
	    this.remove(cellView, id);
	  },
	  get(cellView, id = null) {
	    const {
	      cid
	    } = cellView;
	    const {
	      _views
	    } = this;
	    const refs = _views[cid];
	    if (id === null) {
	      // all highlighters
	      const views = [];
	      if (!refs) return views;
	      for (let hid in refs) {
	        const ref = refs[hid];
	        if (ref instanceof this) {
	          views.push(ref);
	        }
	      }
	      return views;
	    } else {
	      // single highlighter
	      if (!refs) return null;
	      if (id in refs) {
	        const ref = refs[id];
	        if (ref instanceof this) return ref;
	      }
	      return null;
	    }
	  },
	  // Check if the cellView has a highlighter with the given `id`.
	  // If no `id` is provided, it checks if the cellView has any highlighter.
	  has(cellView, id = null) {
	    const {
	      cid
	    } = cellView;
	    const {
	      _views
	    } = this;
	    const refs = _views[cid];
	    if (!refs) return false;
	    if (id === null) {
	      // any highlighter
	      for (let hid in refs) {
	        if (refs[hid] instanceof this) return true;
	      }
	      return false;
	    } else {
	      // single highlighter
	      if (id in refs) {
	        if (refs[id] instanceof this) return true;
	      }
	      return false;
	    }
	  },
	  add(cellView, nodeSelector, id, opt = {}) {
	    if (!id) throw new Error('dia.HighlighterView: An ID required.');
	    // Search the existing view amongst all the highlighters
	    const previousView = HighlighterView.get(cellView, id);
	    if (previousView) previousView.remove();
	    const view = new this(opt);
	    view.id = id;
	    this._addRef(cellView, id, view);
	    view.requestUpdate(cellView, nodeSelector);
	    view.listenToUpdateAttributes(cellView);
	    return view;
	  },
	  _addRef(cellView, id, view) {
	    const {
	      cid
	    } = cellView;
	    const {
	      _views
	    } = this;
	    let refs = _views[cid];
	    if (!refs) refs = _views[cid] = {};
	    refs[id] = view;
	  },
	  _removeRef(cellView, id) {
	    const {
	      cid
	    } = cellView;
	    const {
	      _views
	    } = this;
	    const refs = _views[cid];
	    if (!refs) return;
	    if (id) delete refs[id];
	    for (let _ in refs) return;
	    delete _views[cid];
	  },
	  remove(cellView, id = null) {
	    toArray(this.get(cellView, id)).forEach(view => {
	      view.remove();
	    });
	  },
	  getAll(paper, id = null) {
	    const views = [];
	    const {
	      _views
	    } = this;
	    for (let cid in _views) {
	      for (let hid in _views[cid]) {
	        const view = _views[cid][hid];
	        if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {
	          views.push(view);
	        }
	      }
	    }
	    return views;
	  },
	  removeAll(paper, id = null) {
	    this.getAll(paper, id).forEach(view => view.remove());
	  },
	  update(cellView, id = null, dirty = false) {
	    toArray(this.get(cellView, id)).forEach(view => {
	      if (dirty || view.UPDATABLE) view.update();
	    });
	  },
	  transform(cellView, id = null) {
	    toArray(this.get(cellView, id)).forEach(view => {
	      if (view.UPDATABLE) view.transform();
	    });
	  },
	  unmount(cellView, id = null) {
	    toArray(this.get(cellView, id)).forEach(view => view.unmount());
	  },
	  mount(cellView, id = null) {
	    toArray(this.get(cellView, id)).forEach(view => view.mount());
	  },
	  uniqueId(node, opt = '') {
	    return V.ensureId(node) + JSON.stringify(opt);
	  }
	});

	const stroke$1 = HighlighterView.extend({
	  tagName: 'path',
	  className: 'highlight-stroke',
	  attributes: {
	    'pointer-events': 'none',
	    'fill': 'none'
	  },
	  options: {
	    padding: 3,
	    rx: 0,
	    ry: 0,
	    useFirstSubpath: false,
	    attrs: {
	      'stroke-width': 3,
	      'stroke': '#FEB663'
	    }
	  },
	  getPathData(cellView, node) {
	    const {
	      options
	    } = this;
	    const {
	      useFirstSubpath
	    } = options;
	    let d;
	    try {
	      const vNode = V(node);
	      d = vNode.convertToPathData().trim();
	      if (vNode.tagName() === 'PATH' && useFirstSubpath) {
	        const secondSubpathIndex = d.search(/.M/i) + 1;
	        if (secondSubpathIndex > 0) {
	          d = d.substr(0, secondSubpathIndex);
	        }
	      }
	    } catch {
	      // Failed to get path data from magnet element.
	      // Draw a rectangle around the node instead.
	      const nodeBBox = cellView.getNodeBoundingRect(node);
	      d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));
	    }
	    return d;
	  },
	  highlightConnection(cellView) {
	    this.vel.attr('d', cellView.getSerializedConnection());
	  },
	  highlightNode(cellView, node) {
	    const {
	      vel,
	      options
	    } = this;
	    const {
	      padding,
	      layer
	    } = options;
	    let highlightMatrix = this.getNodeMatrix(cellView, node);
	    // Add padding to the highlight element.
	    if (padding) {
	      if (!layer && node === cellView.el) {
	        // If the highlighter is appended to the cellView
	        // and we measure the size of the cellView wrapping group
	        // it's necessary to remove the highlighter first
	        vel.remove();
	      }
	      let nodeBBox = cellView.getNodeBoundingRect(node);
	      const cx = nodeBBox.x + nodeBBox.width / 2;
	      const cy = nodeBBox.y + nodeBBox.height / 2;
	      nodeBBox = V.transformRect(nodeBBox, highlightMatrix);
	      const width = Math.max(nodeBBox.width, 1);
	      const height = Math.max(nodeBBox.height, 1);
	      const sx = (width + padding) / width;
	      const sy = (height + padding) / height;
	      const paddingMatrix = V.createSVGMatrix({
	        a: sx,
	        b: 0,
	        c: 0,
	        d: sy,
	        e: cx - sx * cx,
	        f: cy - sy * cy
	      });
	      highlightMatrix = highlightMatrix.multiply(paddingMatrix);
	    }
	    vel.attr({
	      'd': this.getPathData(cellView, node),
	      'transform': V.matrixToTransformString(highlightMatrix)
	    });
	  },
	  highlight(cellView, node) {
	    const {
	      vel,
	      options
	    } = this;
	    vel.attr(options.attrs);
	    if (options.nonScalingStroke) {
	      vel.attr('vector-effect', 'non-scaling-stroke');
	    }
	    if (cellView.isNodeConnection(node)) {
	      this.highlightConnection(cellView);
	    } else {
	      this.highlightNode(cellView, node);
	    }
	  }
	});

	const MASK_CLIP = 20;
	function forEachDescendant(vel, fn) {
	  const descendants = vel.children();
	  while (descendants.length > 0) {
	    const descendant = descendants.shift();
	    if (fn(descendant)) {
	      descendants.push(...descendant.children());
	    }
	  }
	}
	const mask = HighlighterView.extend({
	  tagName: 'rect',
	  className: 'highlight-mask',
	  attributes: {
	    'pointer-events': 'none'
	  },
	  options: {
	    padding: 3,
	    maskClip: MASK_CLIP,
	    deep: false,
	    attrs: {
	      'stroke': '#FEB663',
	      'stroke-width': 3,
	      'stroke-linecap': 'butt',
	      'stroke-linejoin': 'miter'
	    }
	  },
	  VISIBLE: 'white',
	  INVISIBLE: 'black',
	  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray', 'class'],
	  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid', 'class'],
	  // TODO: change the list to a function callback
	  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],
	  // TODO: change the list to a function callback
	  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],
	  transformMaskChild(cellView, childEl) {
	    const {
	      MASK_CHILD_ATTRIBUTE_BLACKLIST,
	      MASK_REPLACE_TAGS,
	      MASK_REMOVE_TAGS
	    } = this;
	    const childTagName = childEl.tagName();
	    // Do not include the element in the mask's image
	    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {
	      childEl.remove();
	      return false;
	    }
	    // Replace the element with a rectangle
	    if (MASK_REPLACE_TAGS.includes(childTagName)) {
	      // Note: clone() method does not change the children ids
	      const originalChild = cellView.vel.findOne(`#${childEl.id}`);
	      if (originalChild) {
	        const {
	          node: originalNode
	        } = originalChild;
	        let childBBox = cellView.getNodeBoundingRect(originalNode);
	        if (cellView.model.isElement()) {
	          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));
	        }
	        const replacement = V('rect', childBBox.toJSON());
	        const {
	          x: ox,
	          y: oy
	        } = childBBox.center();
	        const {
	          angle,
	          cx = ox,
	          cy = oy
	        } = originalChild.rotate();
	        if (angle) replacement.rotate(angle, cx, cy);
	        // Note: it's not important to keep the same sibling index since all subnodes are filled
	        childEl.parent().append(replacement);
	      }
	      childEl.remove();
	      return false;
	    }
	    // Keep the element, but clean it from certain attributes
	    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {
	      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;
	      childEl.removeAttr(attrName);
	    });
	    return true;
	  },
	  transformMaskRoot(_cellView, rootEl) {
	    const {
	      MASK_ROOT_ATTRIBUTE_BLACKLIST
	    } = this;
	    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {
	      rootEl.removeAttr(attrName);
	    });
	  },
	  getMaskShape(cellView, vel) {
	    const {
	      options,
	      MASK_REPLACE_TAGS
	    } = this;
	    const {
	      deep
	    } = options;
	    const tagName = vel.tagName();
	    let maskRoot;
	    if (tagName === 'G') {
	      if (!deep) return null;
	      maskRoot = vel.clone();
	      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));
	    } else {
	      if (MASK_REPLACE_TAGS.includes(tagName)) return null;
	      maskRoot = vel.clone();
	    }
	    this.transformMaskRoot(cellView, maskRoot);
	    return maskRoot;
	  },
	  getMaskId() {
	    return `highlight-mask-${this.cid}`;
	  },
	  getMask(cellView, vNode) {
	    const {
	      VISIBLE,
	      INVISIBLE,
	      options
	    } = this;
	    const {
	      padding,
	      attrs
	    } = options;
	    // support both `strokeWidth` and `stroke-width` attribute names
	    const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));
	    const hasNodeFill = vNode.attr('fill') !== 'none';
	    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));
	    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;
	    // stroke of the invisible shape
	    const minStrokeWidth = magnetStrokeWidth + padding * 2;
	    // stroke of the visible shape
	    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;
	    let maskEl = this.getMaskShape(cellView, vNode);
	    if (!maskEl) {
	      const nodeBBox = cellView.getNodeBoundingRect(vNode.node);
	      // Make sure the rect is visible
	      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);
	      maskEl = V('rect', nodeBBox.toJSON());
	    }
	    maskEl.attr(attrs);
	    return V('mask', {
	      'id': this.getMaskId()
	    }).append([maskEl.clone().attr({
	      'fill': hasNodeFill ? VISIBLE : 'none',
	      'stroke': VISIBLE,
	      'stroke-width': maxStrokeWidth
	    }), maskEl.clone().attr({
	      'fill': hasNodeFill ? INVISIBLE : 'none',
	      'stroke': INVISIBLE,
	      'stroke-width': minStrokeWidth
	    })]);
	  },
	  removeMask(paper) {
	    const maskNode = paper.svg.getElementById(this.getMaskId());
	    if (maskNode) {
	      paper.defs.removeChild(maskNode);
	    }
	  },
	  addMask(paper, maskEl) {
	    paper.defs.appendChild(maskEl.node);
	  },
	  highlight(cellView, node) {
	    const {
	      options,
	      vel
	    } = this;
	    const {
	      padding,
	      attrs,
	      maskClip = MASK_CLIP,
	      layer
	    } = options;
	    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';
	    if (!layer && node === cellView.el) {
	      // If the highlighter is appended to the cellView
	      // and we measure the size of the cellView wrapping group
	      // it's necessary to remove the highlighter first
	      vel.remove();
	    }
	    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);
	    const highlightMatrix = this.getNodeMatrix(cellView, node);
	    const maskEl = this.getMask(cellView, V(node));
	    this.addMask(cellView.paper, maskEl);
	    vel.attr(highlighterBBox.toJSON());
	    vel.attr({
	      'transform': V.matrixToTransformString(highlightMatrix),
	      'mask': `url(#${maskEl.id})`,
	      'fill': color
	    });
	  },
	  unhighlight(cellView) {
	    this.removeMask(cellView.paper);
	  }
	});

	const opacity = HighlighterView.extend({
	  UPDATABLE: false,
	  MOUNTABLE: false,
	  highlight: function (_cellView, node) {
	    const {
	      alphaValue = 0.3
	    } = this.options;
	    node.style.opacity = alphaValue;
	  },
	  unhighlight: function (_cellView, node) {
	    node.style.opacity = '';
	  }
	});

	const className = addClassNamePrefix('highlighted');
	const addClass = HighlighterView.extend({
	  UPDATABLE: false,
	  MOUNTABLE: false,
	  options: {
	    className
	  },
	  highlight: function (_cellView, node) {
	    V(node).addClass(this.options.className);
	  },
	  unhighlight: function (_cellView, node) {
	    V(node).removeClass(this.options.className);
	  }
	}, {
	  // Backwards Compatibility
	  className
	});

	const Directions$1 = {
	  ROW: 'row',
	  COLUMN: 'column'
	};
	const list = HighlighterView.extend({
	  tagName: 'g',
	  MOUNTABLE: true,
	  UPDATE_ATTRIBUTES: function () {
	    return [this.options.attribute];
	  },
	  _prevItems: null,
	  highlight(elementView, node) {
	    const element = elementView.model;
	    const {
	      attribute,
	      size = 20,
	      gap = 5,
	      direction = Directions$1.ROW
	    } = this.options;
	    if (!attribute) throw new Error('List: attribute is required');
	    const normalizedSize = typeof size === 'number' ? {
	      width: size,
	      height: size
	    } : size;
	    const isRowDirection = direction === Directions$1.ROW;
	    const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;
	    let items = element.get(attribute);
	    if (!Array.isArray(items)) items = [];
	    const prevItems = this._prevItems || [];
	    const comparison = items.map((item, index) => isEqual(prevItems[index], items[index]));
	    if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {
	      const prevEls = this.vel.children();
	      const itemsEls = items.map((item, index) => {
	        const prevEl = index in prevEls ? prevEls[index].node : null;
	        if (comparison[index]) return prevEl;
	        const itemEl = this.createListItem(item, normalizedSize, prevEl);
	        if (!itemEl) return null;
	        if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');
	        itemEl.dataset.index = index;
	        itemEl.dataset.attribute = attribute;
	        const offset = index * (itemWidth + gap);
	        itemEl.setAttribute('transform', isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);
	        return itemEl;
	      });
	      this.vel.empty().append(itemsEls);
	      this._prevItems = items;
	    }
	    const itemsCount = items.length;
	    const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;
	    const listSize = isRowDirection ? {
	      width: length,
	      height: normalizedSize.height
	    } : {
	      width: normalizedSize.width,
	      height: length
	    };
	    this.position(element, listSize);
	  },
	  position(element, listSize) {
	    const {
	      vel,
	      options
	    } = this;
	    const {
	      margin = 5,
	      position = 'top-left'
	    } = options;
	    const {
	      width,
	      height
	    } = element.size();
	    const {
	      left,
	      right,
	      top,
	      bottom
	    } = normalizeSides(margin);
	    const bbox = new Rect(left, top, width - (left + right), height - (top + bottom));
	    let {
	      x,
	      y
	    } = getRectPoint(bbox, position);
	    // x
	    switch (position) {
	      case Positions.CENTER:
	      case Positions.TOP:
	      case Positions.BOTTOM:
	        {
	          x -= listSize.width / 2;
	          break;
	        }
	      case Positions.RIGHT:
	      case Positions.BOTTOM_RIGHT:
	      case Positions.TOP_RIGHT:
	        {
	          x -= listSize.width;
	          break;
	        }
	    }
	    // y
	    switch (position) {
	      case Positions.CENTER:
	      case Positions.RIGHT:
	      case Positions.LEFT:
	        {
	          y -= listSize.height / 2;
	          break;
	        }
	      case Positions.BOTTOM:
	      case Positions.BOTTOM_RIGHT:
	      case Positions.BOTTOM_LEFT:
	        {
	          y -= listSize.height;
	          break;
	        }
	    }
	    vel.attr('transform', `translate(${x}, ${y})`);
	  }
	}, {
	  Directions: Directions$1,
	  Positions
	});

	var highlighters = {
		__proto__: null,
		addClass: addClass,
		list: list,
		mask: mask,
		opacity: opacity,
		stroke: stroke$1
	};

	function offsetPoint(p1, p2, offset) {
	  if (isPlainObject(offset)) {
	    const {
	      x,
	      y
	    } = offset;
	    if (isFinite(y)) {
	      const line = new Line(p2, p1);
	      const {
	        start,
	        end
	      } = line.parallel(y);
	      p2 = start;
	      p1 = end;
	    }
	    offset = x;
	  }
	  if (!isFinite(offset)) return p1;
	  var length = p1.distance(p2);
	  if (offset === 0 && length > 0) return p1;
	  return p1.move(p2, -Math.min(offset, length - 1));
	}
	function stroke(magnet) {
	  var stroke = magnet.getAttribute('stroke-width');
	  if (stroke === null) return 0;
	  return parseFloat(stroke) || 0;
	}
	function alignLine(line, type, offset = 0) {
	  let coordinate, a, b, direction;
	  const {
	    start,
	    end
	  } = line;
	  switch (type) {
	    case 'left':
	      coordinate = 'x';
	      a = end;
	      b = start;
	      direction = -1;
	      break;
	    case 'right':
	      coordinate = 'x';
	      a = start;
	      b = end;
	      direction = 1;
	      break;
	    case 'top':
	      coordinate = 'y';
	      a = end;
	      b = start;
	      direction = -1;
	      break;
	    case 'bottom':
	      coordinate = 'y';
	      a = start;
	      b = end;
	      direction = 1;
	      break;
	    default:
	      return;
	  }
	  if (start[coordinate] < end[coordinate]) {
	    a[coordinate] = b[coordinate];
	  } else {
	    b[coordinate] = a[coordinate];
	  }
	  if (isFinite(offset)) {
	    a[coordinate] += direction * offset;
	    b[coordinate] += direction * offset;
	  }
	}

	// Connection Points

	function anchorConnectionPoint(line, _view, _magnet, opt) {
	  let {
	    offset,
	    alignOffset,
	    align
	  } = opt;
	  if (align) alignLine(line, align, alignOffset);
	  return offsetPoint(line.end, line.start, offset);
	}
	function bboxIntersection(line, view, magnet, opt) {
	  const bbox = opt.useModelGeometry ? getNodeModelBBox(view, magnet, true) : view.getNodeBBox(magnet);
	  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);
	  const intersections = line.intersect(bbox);
	  const cp = intersections ? line.start.chooseClosest(intersections) : line.end;
	  return offsetPoint(cp, line.start, opt.offset);
	}
	function rectangleIntersection(line, view, magnet, opt) {
	  const angle = view.model.angle();
	  if (angle === 0) {
	    return bboxIntersection(line, view, magnet, opt);
	  }
	  const bboxWORotation = opt.useModelGeometry ? getNodeModelBBox(view, magnet, false) : view.getNodeUnrotatedBBox(magnet);
	  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);
	  const center = bboxWORotation.center();
	  const lineWORotation = line.clone().rotate(center, angle);
	  const intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);
	  const cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;
	  return offsetPoint(cp, line.start, opt.offset);
	}
	function getNodeModelBBox(elementView, magnet, rotate) {
	  const element = elementView.model;
	  const portId = elementView.findAttribute('port', magnet);
	  if (element.hasPort(portId)) {
	    return element.getPortBBox(portId, {
	      rotate
	    });
	  }
	  return element.getBBox({
	    rotate
	  });
	}
	function findShapeNode(magnet) {
	  if (!magnet) return null;
	  var node = magnet;
	  do {
	    var tagName = node.tagName;
	    if (typeof tagName !== 'string') return null;
	    tagName = tagName.toUpperCase();
	    if (tagName === 'G') {
	      node = node.firstElementChild;
	    } else if (tagName === 'TITLE') {
	      node = node.nextElementSibling;
	    } else break;
	  } while (node);
	  return node;
	}
	var BNDR_SUBDIVISIONS = 'segmentSubdivisons';
	var BNDR_SHAPE_BBOX = 'shapeBBox';
	function boundaryIntersection(line, view, magnet, opt) {
	  var node, intersection;
	  var selector = opt.selector;
	  var anchor = line.end;
	  if (typeof selector === 'string') {
	    node = view.findNode(selector);
	  } else if (selector === false) {
	    node = magnet;
	  } else if (Array.isArray(selector)) {
	    node = getByPath(magnet, selector);
	  } else {
	    node = findShapeNode(magnet);
	  }
	  if (!V.isSVGGraphicsElement(node)) {
	    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;
	    node = magnet;
	  }
	  var localShape = view.getNodeShape(node);
	  var magnetMatrix = view.getNodeMatrix(node);
	  var translateMatrix = view.getRootTranslateMatrix();
	  var rotateMatrix = view.getRootRotateMatrix();
	  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
	  var localMatrix = targetMatrix.inverse();
	  var localLine = V.transformLine(line, localMatrix);
	  var localRef = localLine.start.clone();
	  var data = view.getNodeData(node);
	  if (opt.insideout === false) {
	    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();
	    var localBBox = data[BNDR_SHAPE_BBOX];
	    if (localBBox.containsPoint(localRef)) return anchor;
	  }

	  // Caching segment subdivisions for paths
	  var pathOpt;
	  if (localShape instanceof Path$1) {
	    var precision = opt.precision || 2;
	    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({
	      precision: precision
	    });
	    pathOpt = {
	      precision: precision,
	      segmentSubdivisions: data[BNDR_SUBDIVISIONS]
	    };
	  }
	  if (opt.extrapolate === true) localLine.setLength(1e6);
	  intersection = localLine.intersect(localShape, pathOpt);
	  if (intersection) {
	    // More than one intersection
	    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);
	  } else if (opt.sticky === true) {
	    // No intersection, find the closest point instead
	    if (localShape instanceof Rect) {
	      intersection = localShape.pointNearestToPoint(localRef);
	    } else if (localShape instanceof Ellipse$1) {
	      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);
	    } else {
	      intersection = localShape.closestPoint(localRef, pathOpt);
	    }
	  }
	  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;
	  var cpOffset = opt.offset || 0;
	  if (opt.stroke) cpOffset += stroke(node) / 2;
	  return offsetPoint(cp, line.start, cpOffset);
	}
	const anchor = anchorConnectionPoint;
	const bbox = bboxIntersection;
	const rectangle = rectangleIntersection;
	const boundary = boundaryIntersection;

	var connectionPoints = {
		__proto__: null,
		anchor: anchor,
		bbox: bbox,
		boundary: boundary,
		rectangle: rectangle
	};

	function abs2rel(absolute, max) {
	  if (max === 0) return '0%';
	  // round to 3 decimal places
	  const dp = 1000;
	  const relative = Math.round(absolute / max * 100 * dp) / dp;
	  return `${relative}%`;
	}
	function pin(relative) {
	  return function (end, view, magnet, coords) {
	    var fn = view.isNodeConnection(magnet) ? pinnedLinkEnd : pinnedElementEnd;
	    return fn(relative, end, view, magnet, coords);
	  };
	}
	function pinnedElementEnd(relative, end, view, magnet, coords) {
	  var angle = view.model.angle();
	  var bbox = view.getNodeUnrotatedBBox(magnet);
	  var origin = view.model.getCenter();
	  coords.rotate(origin, angle);
	  var dx = coords.x - bbox.x;
	  var dy = coords.y - bbox.y;
	  if (relative) {
	    dx = abs2rel(dx, bbox.width);
	    dy = abs2rel(dy, bbox.height);
	  }
	  end.anchor = {
	    name: 'topLeft',
	    args: {
	      dx: dx,
	      dy: dy,
	      rotate: true
	    }
	  };
	  return end;
	}
	function pinnedLinkEnd(relative, end, view, _magnet, coords) {
	  var connection = view.getConnection();
	  if (!connection) return end;
	  var length = connection.closestPointLength(coords);
	  if (relative) {
	    var totalLength = connection.length();
	    end.anchor = {
	      name: 'connectionRatio',
	      args: {
	        ratio: length / totalLength
	      }
	    };
	  } else {
	    end.anchor = {
	      name: 'connectionLength',
	      args: {
	        length: length
	      }
	    };
	  }
	  return end;
	}
	const useDefaults = noop;
	const pinAbsolute = pin(false);
	const pinRelative = pin(true);

	var index$3 = {
		__proto__: null,
		pinAbsolute: pinAbsolute,
		pinRelative: pinRelative,
		useDefaults: useDefaults
	};

	// Does not make any changes to vertices.
	// Returns the arguments that are passed to it, unchanged.
	const normal = function (vertices, opt, linkView) {
	  return vertices;
	};

	// Routes the link always to/from a certain side
	//
	// Arguments:
	//   padding ... gap between the element and the first vertex. :: Default 40.
	//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.
	//
	const oneSide = function (vertices, opt, linkView) {
	  var side = opt.side || 'bottom';
	  var padding = normalizeSides(opt.padding || 40);

	  // LinkView contains cached source an target bboxes.
	  // Note that those are Geometry rectangle objects.
	  var sourceBBox = linkView.sourceBBox;
	  var targetBBox = linkView.targetBBox;
	  var sourcePoint = sourceBBox.center();
	  var targetPoint = targetBBox.center();
	  var coordinate, dimension, direction;
	  switch (side) {
	    case 'bottom':
	      direction = 1;
	      coordinate = 'y';
	      dimension = 'height';
	      break;
	    case 'top':
	      direction = -1;
	      coordinate = 'y';
	      dimension = 'height';
	      break;
	    case 'left':
	      direction = -1;
	      coordinate = 'x';
	      dimension = 'width';
	      break;
	    case 'right':
	      direction = 1;
	      coordinate = 'x';
	      dimension = 'width';
	      break;
	    default:
	      throw new Error('Router: invalid side');
	  }

	  // move the points from the center of the element to outside of it.
	  sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);
	  targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);

	  // make link orthogonal (at least the first and last vertex).
	  if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {
	    targetPoint[coordinate] = sourcePoint[coordinate];
	  } else {
	    sourcePoint[coordinate] = targetPoint[coordinate];
	  }
	  return [sourcePoint].concat(vertices, targetPoint);
	};

	// bearing -> opposite bearing
	var opposites = {
	  N: 'S',
	  S: 'N',
	  E: 'W',
	  W: 'E'
	};

	// bearing -> radians
	var radians = {
	  N: -Math.PI / 2 * 3,
	  S: -Math.PI / 2,
	  E: 0,
	  W: Math.PI
	};

	// HELPERS //

	// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained
	// in the given box
	function freeJoin(p1, p2, bbox) {
	  var p = new Point(p1.x, p2.y);
	  if (bbox.containsPoint(p)) p = new Point(p2.x, p1.y);
	  // kept for reference
	  // if (bbox.containsPoint(p)) p = null;

	  return p;
	}

	// returns either width or height of a bbox based on the given bearing
	function getBBoxSize(bbox, bearing) {
	  return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
	}

	// simple bearing method (calculates only orthogonal cardinals)
	function getBearing(from, to) {
	  if (from.x === to.x) return from.y > to.y ? 'N' : 'S';
	  if (from.y === to.y) return from.x > to.x ? 'W' : 'E';
	  return null;
	}

	// transform point to a rect
	function getPointBox(p) {
	  return new Rect(p.x, p.y, 0, 0);
	}
	function getPaddingBox(opt) {
	  // if both provided, opt.padding wins over opt.elementPadding
	  var sides = normalizeSides(opt.padding || opt.elementPadding || 20);
	  return {
	    x: -sides.left,
	    y: -sides.top,
	    width: sides.left + sides.right,
	    height: sides.top + sides.bottom
	  };
	}

	// return source bbox
	function getSourceBBox$1(linkView, opt) {
	  return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));
	}

	// return target bbox
	function getTargetBBox$1(linkView, opt) {
	  return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));
	}

	// return source anchor
	function getSourceAnchor$1(linkView, opt) {
	  if (linkView.sourceAnchor) return linkView.sourceAnchor;

	  // fallback: center of bbox
	  var sourceBBox = getSourceBBox$1(linkView, opt);
	  return sourceBBox.center();
	}

	// return target anchor
	function getTargetAnchor$1(linkView, opt) {
	  if (linkView.targetAnchor) return linkView.targetAnchor;

	  // fallback: center of bbox
	  var targetBBox = getTargetBBox$1(linkView, opt);
	  return targetBBox.center(); // default
	}

	// PARTIAL ROUTERS //

	function vertexVertex(from, to, bearing) {
	  var p1 = new Point(from.x, to.y);
	  var p2 = new Point(to.x, from.y);
	  var d1 = getBearing(from, p1);
	  var d2 = getBearing(from, p2);
	  var opposite = opposites[bearing];
	  var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
	  return {
	    points: [p],
	    direction: getBearing(p, to)
	  };
	}
	function elementVertex(from, to, fromBBox) {
	  var p = freeJoin(from, to, fromBBox);
	  return {
	    points: [p],
	    direction: getBearing(p, to)
	  };
	}
	function vertexElement(from, to, toBBox, bearing) {
	  var route = {};
	  var points = [new Point(from.x, to.y), new Point(to.x, from.y)];
	  var freePoints = points.filter(function (pt) {
	    return !toBBox.containsPoint(pt);
	  });
	  var freeBearingPoints = freePoints.filter(function (pt) {
	    return getBearing(pt, from) !== bearing;
	  });
	  var p;
	  if (freeBearingPoints.length > 0) {
	    // Try to pick a point which bears the same direction as the previous segment.

	    p = freeBearingPoints.filter(function (pt) {
	      return getBearing(from, pt) === bearing;
	    }).pop();
	    p = p || freeBearingPoints[0];
	    route.points = [p];
	    route.direction = getBearing(p, to);
	  } else {
	    // Here we found only points which are either contained in the element or they would create
	    // a link segment going in opposite direction from the previous one.
	    // We take the point inside element and move it outside the element in the direction the
	    // route is going. Now we can join this point with the current end (using freeJoin).

	    p = difference(points, freePoints)[0];
	    var p2 = new Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
	    var p1 = freeJoin(p2, from, toBBox);
	    route.points = [p1, p2];
	    route.direction = getBearing(p2, to);
	  }
	  return route;
	}
	function elementElement(from, to, fromBBox, toBBox) {
	  var route = elementVertex(to, from, toBBox);
	  var p1 = route.points[0];
	  if (fromBBox.containsPoint(p1)) {
	    route = elementVertex(from, to, fromBBox);
	    var p2 = route.points[0];
	    if (toBBox.containsPoint(p2)) {
	      var fromBorder = new Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
	      var toBorder = new Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
	      var mid = new Line(fromBorder, toBorder).midpoint();
	      var startRoute = elementVertex(from, mid, fromBBox);
	      var endRoute = vertexVertex(mid, to, startRoute.direction);
	      route.points = [startRoute.points[0], endRoute.points[0]];
	      route.direction = endRoute.direction;
	    }
	  }
	  return route;
	}

	// Finds route for situations where one element is inside the other.
	// Typically the route is directed outside the outer element first and
	// then back towards the inner element.
	function insideElement(from, to, fromBBox, toBBox, bearing) {
	  var route = {};
	  var boundary = fromBBox.union(toBBox).inflate(1);

	  // start from the point which is closer to the boundary
	  var reversed = boundary.center().distance(to) > boundary.center().distance(from);
	  var start = reversed ? to : from;
	  var end = reversed ? from : to;
	  var p1, p2, p3;
	  if (bearing) {
	    // Points on circle with radius equals 'W + H` are always outside the rectangle
	    // with width W and height H if the center of that circle is the center of that rectangle.
	    p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
	    p1 = boundary.pointNearestToPoint(p1).move(p1, -1);
	  } else {
	    p1 = boundary.pointNearestToPoint(start).move(start, 1);
	  }
	  p2 = freeJoin(p1, end, boundary);
	  if (p1.round().equals(p2.round())) {
	    p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);
	    p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();
	    p3 = freeJoin(p1, p2, boundary);
	    route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];
	  } else {
	    route.points = reversed ? [p2, p1] : [p1, p2];
	  }
	  route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
	  return route;
	}

	// MAIN ROUTER //

	// Return points through which a connection needs to be drawn in order to obtain an orthogonal link
	// routing from source to target going through `vertices`.
	function orthogonal(vertices, opt, linkView) {
	  var sourceBBox = getSourceBBox$1(linkView, opt);
	  var targetBBox = getTargetBBox$1(linkView, opt);
	  var sourceAnchor = getSourceAnchor$1(linkView, opt);
	  var targetAnchor = getTargetAnchor$1(linkView, opt);

	  // if anchor lies outside of bbox, the bbox expands to include it
	  sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));
	  targetBBox = targetBBox.union(getPointBox(targetAnchor));
	  vertices = toArray$1(vertices).map(Point);
	  vertices.unshift(sourceAnchor);
	  vertices.push(targetAnchor);
	  var bearing; // bearing of previous route segment

	  var orthogonalVertices = []; // the array of found orthogonal vertices to be returned
	  for (var i = 0, max = vertices.length - 1; i < max; i++) {
	    var route = null;
	    var from = vertices[i];
	    var to = vertices[i + 1];
	    var isOrthogonal = !!getBearing(from, to);
	    if (i === 0) {
	      // source

	      if (i + 1 === max) {
	        // route source -> target

	        // Expand one of the elements by 1px to detect situations when the two
	        // elements are positioned next to each other with no gap in between.
	        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {
	          route = insideElement(from, to, sourceBBox, targetBBox);
	        } else if (!isOrthogonal) {
	          route = elementElement(from, to, sourceBBox, targetBBox);
	        }
	      } else {
	        // route source -> vertex

	        if (sourceBBox.containsPoint(to)) {
	          route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));
	        } else if (!isOrthogonal) {
	          route = elementVertex(from, to, sourceBBox);
	        }
	      }
	    } else if (i + 1 === max) {
	      // route vertex -> target

	      // prevent overlaps with previous line segment
	      var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;
	      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
	        route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);
	      } else if (!isOrthogonal) {
	        route = vertexElement(from, to, targetBBox, bearing);
	      }
	    } else if (!isOrthogonal) {
	      // route vertex -> vertex
	      route = vertexVertex(from, to, bearing);
	    }

	    // applicable to all routes:

	    // set bearing for next iteration
	    if (route) {
	      Array.prototype.push.apply(orthogonalVertices, route.points);
	      bearing = route.direction;
	    } else {
	      // orthogonal route and not looped
	      bearing = getBearing(from, to);
	    }

	    // push `to` point to identified orthogonal vertices array
	    if (i + 1 < max) {
	      orthogonalVertices.push(to);
	    }
	  }
	  return orthogonalVertices;
	}

	var config$1 = {
	  // size of the step to find a route (the grid of the manhattan pathfinder)
	  step: 10,
	  // the number of route finding loops that cause the router to abort
	  // returns fallback route instead
	  maximumLoops: 2000,
	  // the number of decimal places to round floating point coordinates
	  precision: 1,
	  // maximum change of direction
	  maxAllowedDirectionChange: 90,
	  // should the router use perpendicular linkView option?
	  // does not connect anchor of element but rather a point close-by that is orthogonal
	  // this looks much better
	  perpendicular: true,
	  // should the source and/or target not be considered as obstacles?
	  excludeEnds: [],
	  // 'source', 'target'

	  // should certain types of elements not be considered as obstacles?
	  excludeTypes: [],
	  // possible starting directions from an element
	  startDirections: ['top', 'right', 'bottom', 'left'],
	  // possible ending directions to an element
	  endDirections: ['top', 'right', 'bottom', 'left'],
	  // specify the directions used above and what they mean
	  directionMap: {
	    top: {
	      x: 0,
	      y: -1
	    },
	    right: {
	      x: 1,
	      y: 0
	    },
	    bottom: {
	      x: 0,
	      y: 1
	    },
	    left: {
	      x: -1,
	      y: 0
	    }
	  },
	  // cost of an orthogonal step
	  cost: function () {
	    return this.step;
	  },
	  // an array of directions to find next points on the route
	  // different from start/end directions
	  directions: function () {
	    var step = this.step;
	    var cost = this.cost();
	    return [{
	      offsetX: step,
	      offsetY: 0,
	      cost: cost
	    }, {
	      offsetX: -step,
	      offsetY: 0,
	      cost: cost
	    }, {
	      offsetX: 0,
	      offsetY: step,
	      cost: cost
	    }, {
	      offsetX: 0,
	      offsetY: -step,
	      cost: cost
	    }];
	  },
	  // a penalty received for direction change
	  penalties: function () {
	    return {
	      0: 0,
	      45: this.step / 2,
	      90: this.step / 2
	    };
	  },
	  // padding applied on the element bounding boxes
	  paddingBox: function () {
	    var step = this.step;
	    return {
	      x: -step,
	      y: -step,
	      width: 2 * step,
	      height: 2 * step
	    };
	  },
	  // A function that determines whether a given point is an obstacle or not.
	  // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.
	  // (point: dia.Point) => boolean;
	  isPointObstacle: null,
	  // a router to use when the manhattan router fails
	  // (one of the partial routes returns null)
	  fallbackRouter: function (vertices, opt, linkView) {
	    if (!isFunction(orthogonal)) {
	      throw new Error('Manhattan requires the orthogonal router as default fallback.');
	    }
	    return orthogonal(vertices, assign({}, config$1, opt), linkView);
	  },
	  /* Deprecated */
	  // a simple route used in situations when main routing method fails
	  // (exceed max number of loop iterations, inaccessible)
	  fallbackRoute: function (from, to, opt) {
	    return null; // null result will trigger the fallbackRouter

	    // left for reference:
	    /*// Find an orthogonal route ignoring obstacles.
	     var point = ((opt.previousDirAngle || 0) % 180 === 0)
	            ? new g.Point(from.x, to.y)
	            : new g.Point(to.x, from.y);
	     return [point];*/
	  },
	  // if a function is provided, it's used to route the link while dragging an end
	  // i.e. function(from, to, opt) { return []; }
	  draggingRoute: null
	};

	// HELPER CLASSES //

	// Map of obstacles
	// Helper structure to identify whether a point lies inside an obstacle.
	function ObstacleMap(opt) {
	  this.map = {};
	  this.options = opt;
	  // tells how to divide the paper when creating the elements map
	  this.mapGridSize = 100;
	}
	ObstacleMap.prototype.build = function (graph, link) {
	  var opt = this.options;

	  // source or target element could be excluded from set of obstacles
	  var excludedEnds = toArray$1(opt.excludeEnds).reduce(function (res, item) {
	    var end = link.get(item);
	    if (end) {
	      var cell = graph.getCell(end.id);
	      if (cell) {
	        res.push(cell);
	      }
	    }
	    return res;
	  }, []);

	  // Exclude any embedded elements from the source and the target element.
	  var excludedAncestors = [];
	  var source = graph.getCell(link.get('source').id);
	  if (source) {
	    excludedAncestors = union(excludedAncestors, source.getAncestors().map(function (cell) {
	      return cell.id;
	    }));
	  }
	  var target = graph.getCell(link.get('target').id);
	  if (target) {
	    excludedAncestors = union(excludedAncestors, target.getAncestors().map(function (cell) {
	      return cell.id;
	    }));
	  }

	  // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained
	  // in any obstacle?) (a simplified grid search).
	  // The paper is divided into smaller cells, where each holds information about which
	  // elements belong to it. When we query whether a point lies inside an obstacle we
	  // don't need to go through all obstacles, we check only those in a particular cell.
	  var mapGridSize = this.mapGridSize;
	  graph.getElements().reduce(function (map, element) {
	    var isExcludedType = toArray$1(opt.excludeTypes).includes(element.get('type'));
	    var isExcludedEnd = excludedEnds.find(function (excluded) {
	      return excluded.id === element.id;
	    });
	    var isExcludedAncestor = excludedAncestors.includes(element.id);
	    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;
	    if (!isExcluded) {
	      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);
	      var origin = bbox.origin().snapToGrid(mapGridSize);
	      var corner = bbox.corner().snapToGrid(mapGridSize);
	      for (var x = origin.x; x <= corner.x; x += mapGridSize) {
	        for (var y = origin.y; y <= corner.y; y += mapGridSize) {
	          var gridKey = x + '@' + y;
	          map[gridKey] = map[gridKey] || [];
	          map[gridKey].push(bbox);
	        }
	      }
	    }
	    return map;
	  }, this.map);
	  return this;
	};
	ObstacleMap.prototype.isPointAccessible = function (point) {
	  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();
	  return toArray$1(this.map[mapKey]).every(function (obstacle) {
	    return !obstacle.containsPoint(point);
	  });
	};

	// Sorted Set
	// Set of items sorted by given value.
	function SortedSet() {
	  this.items = [];
	  this.hash = {};
	  this.values = {};
	  this.OPEN = 1;
	  this.CLOSE = 2;
	}
	SortedSet.prototype.add = function (item, value) {
	  if (this.hash[item]) {
	    // item removal
	    this.items.splice(this.items.indexOf(item), 1);
	  } else {
	    this.hash[item] = this.OPEN;
	  }
	  this.values[item] = value;
	  var index = sortedIndex(this.items, item, function (i) {
	    return this.values[i];
	  }.bind(this));
	  this.items.splice(index, 0, item);
	};
	SortedSet.prototype.remove = function (item) {
	  this.hash[item] = this.CLOSE;
	};
	SortedSet.prototype.isOpen = function (item) {
	  return this.hash[item] === this.OPEN;
	};
	SortedSet.prototype.isClose = function (item) {
	  return this.hash[item] === this.CLOSE;
	};
	SortedSet.prototype.isEmpty = function () {
	  return this.items.length === 0;
	};
	SortedSet.prototype.pop = function () {
	  var item = this.items.shift();
	  this.remove(item);
	  return item;
	};

	// HELPERS //

	// return source bbox
	function getSourceBBox(linkView, opt) {
	  // expand by padding box
	  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);
	  return linkView.sourceBBox.clone();
	}

	// return target bbox
	function getTargetBBox(linkView, opt) {
	  // expand by padding box
	  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);
	  return linkView.targetBBox.clone();
	}

	// return source anchor
	function getSourceAnchor(linkView, opt) {
	  if (linkView.sourceAnchor) return linkView.sourceAnchor;

	  // fallback: center of bbox
	  var sourceBBox = getSourceBBox(linkView, opt);
	  return sourceBBox.center();
	}

	// return target anchor
	function getTargetAnchor(linkView, opt) {
	  if (linkView.targetAnchor) return linkView.targetAnchor;

	  // fallback: center of bbox
	  var targetBBox = getTargetBBox(linkView, opt);
	  return targetBBox.center(); // default
	}

	// returns a direction index from start point to end point
	// corrects for grid deformation between start and end
	function getDirectionAngle(start, end, numDirections, grid, opt) {
	  var quadrant = 360 / numDirections;
	  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));
	  var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);
	  return quadrant * Math.floor(normalizedAngle / quadrant);
	}

	// helper function for getDirectionAngle()
	// corrects for grid deformation
	// (if a point is one grid steps away from another in both dimensions,
	// it is considered to be 45 degrees away, even if the real angle is different)
	// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`
	function fixAngleEnd(start, end, grid, opt) {
	  var step = opt.step;
	  var diffX = end.x - start.x;
	  var diffY = end.y - start.y;
	  var gridStepsX = diffX / grid.x;
	  var gridStepsY = diffY / grid.y;
	  var distanceX = gridStepsX * step;
	  var distanceY = gridStepsY * step;
	  return new Point(start.x + distanceX, start.y + distanceY);
	}

	// return the change in direction between two direction angles
	function getDirectionChange(angle1, angle2) {
	  var directionChange = Math.abs(angle1 - angle2);
	  return directionChange > 180 ? 360 - directionChange : directionChange;
	}

	// fix direction offsets according to current grid
	function getGridOffsets(directions, grid, opt) {
	  var step = opt.step;
	  toArray$1(opt.directions).forEach(function (direction) {
	    direction.gridOffsetX = direction.offsetX / step * grid.x;
	    direction.gridOffsetY = direction.offsetY / step * grid.y;
	  });
	}

	// get grid size in x and y dimensions, adapted to source and target positions
	function getGrid(step, source, target) {
	  return {
	    source: source.clone(),
	    x: getGridDimension(target.x - source.x, step),
	    y: getGridDimension(target.y - source.y, step)
	  };
	}

	// helper function for getGrid()
	function getGridDimension(diff, step) {
	  // return step if diff = 0
	  if (!diff) return step;
	  var absDiff = Math.abs(diff);
	  var numSteps = Math.round(absDiff / step);

	  // return absDiff if less than one step apart
	  if (!numSteps) return absDiff;

	  // otherwise, return corrected step
	  var roundedDiff = numSteps * step;
	  var remainder = absDiff - roundedDiff;
	  var stepCorrection = remainder / numSteps;
	  return step + stepCorrection;
	}

	// return a clone of point snapped to grid
	function snapToGrid(point, grid) {
	  var source = grid.source;
	  var snappedX = snapToGrid$1(point.x - source.x, grid.x) + source.x;
	  var snappedY = snapToGrid$1(point.y - source.y, grid.y) + source.y;
	  return new Point(snappedX, snappedY);
	}

	// round the point to opt.precision
	function round(point, precision) {
	  return point.round(precision);
	}

	// snap to grid and then round the point
	function align(point, grid, precision) {
	  return round(snapToGrid(point.clone(), grid), precision);
	}

	// return a string representing the point
	// string is rounded in both dimensions
	function getKey(point) {
	  return point.clone().toString();
	}

	// return a normalized vector from given point
	// used to determine the direction of a difference of two points
	function normalizePoint(point) {
	  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
	}

	// PATHFINDING //

	// reconstructs a route by concatenating points with their parents
	function reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {
	  var route = [];
	  var prevDiff = normalizePoint(to.difference(tailPoint));

	  // tailPoint is assumed to be aligned already
	  var currentKey = getKey(tailPoint);
	  var parent = parents[currentKey];
	  var point;
	  while (parent) {
	    // point is assumed to be aligned already
	    point = points[currentKey];
	    var diff = normalizePoint(point.difference(parent));
	    if (!diff.equals(prevDiff)) {
	      route.unshift(point);
	      prevDiff = diff;
	    }

	    // parent is assumed to be aligned already
	    currentKey = getKey(parent);
	    parent = parents[currentKey];
	  }

	  // leadPoint is assumed to be aligned already
	  var leadPoint = points[currentKey];
	  var fromDiff = normalizePoint(leadPoint.difference(from));
	  if (!fromDiff.equals(prevDiff)) {
	    route.unshift(leadPoint);
	  }
	  return route;
	}

	// heuristic method to determine the distance between two points
	function estimateCost(from, endPoints) {
	  var min = Infinity;
	  for (var i = 0, len = endPoints.length; i < len; i++) {
	    var cost = from.manhattanDistance(endPoints[i]);
	    if (cost < min) min = cost;
	  }
	  return min;
	}

	// find points around the bbox taking given directions into account
	// lines are drawn from anchor in given directions, intersections recorded
	// if anchor is outside bbox, only those directions that intersect get a rect point
	// the anchor itself is returned as rect point (representing some directions)
	// (since those directions are unobstructed by the bbox)
	function getRectPoints(anchor, bbox, directionList, grid, opt) {
	  var precision = opt.precision;
	  var directionMap = opt.directionMap;
	  var anchorCenterVector = anchor.difference(bbox.center());
	  var keys = isObject(directionMap) ? Object.keys(directionMap) : [];
	  var dirList = toArray$1(directionList);
	  var rectPoints = keys.reduce(function (res, key) {
	    if (dirList.includes(key)) {
	      var direction = directionMap[key];

	      // create a line that is guaranteed to intersect the bbox if bbox is in the direction
	      // even if anchor lies outside of bbox
	      var endpoint = new Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));
	      var intersectionLine = new Line(anchor, endpoint);

	      // get the farther intersection, in case there are two
	      // (that happens if anchor lies next to bbox)
	      var intersections = intersectionLine.intersect(bbox) || [];
	      var numIntersections = intersections.length;
	      var farthestIntersectionDistance;
	      var farthestIntersection = null;
	      for (var i = 0; i < numIntersections; i++) {
	        var currentIntersection = intersections[i];
	        var distance = anchor.squaredDistance(currentIntersection);
	        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {
	          farthestIntersectionDistance = distance;
	          farthestIntersection = currentIntersection;
	        }
	      }

	      // if an intersection was found in this direction, it is our rectPoint
	      if (farthestIntersection) {
	        var point = align(farthestIntersection, grid, precision);

	        // if the rectPoint lies inside the bbox, offset it by one more step
	        if (bbox.containsPoint(point)) {
	          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);
	        }

	        // then add the point to the result array
	        // aligned
	        res.push(point);
	      }
	    }
	    return res;
	  }, []);

	  // if anchor lies outside of bbox, add it to the array of points
	  if (!bbox.containsPoint(anchor)) {
	    // aligned
	    rectPoints.push(align(anchor, grid, precision));
	  }
	  return rectPoints;
	}

	// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm
	// rectangles get rect points assigned by getRectPoints()
	function findRoute(from, to, isPointObstacle, opt) {
	  var precision = opt.precision;

	  // Get grid for this route.

	  var sourceAnchor, targetAnchor;
	  if (from instanceof Rect) {
	    // `from` is sourceBBox
	    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);
	  } else {
	    sourceAnchor = round(from.clone(), precision);
	  }
	  if (to instanceof Rect) {
	    // `to` is targetBBox
	    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);
	  } else {
	    targetAnchor = round(to.clone(), precision);
	  }
	  var grid = getGrid(opt.step, sourceAnchor, targetAnchor);

	  // Get pathfinding points.

	  var start, end; // aligned with grid by definition
	  var startPoints, endPoints; // assumed to be aligned with grid already

	  // set of points we start pathfinding from
	  if (from instanceof Rect) {
	    // `from` is sourceBBox
	    start = sourceAnchor;
	    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);
	  } else {
	    start = sourceAnchor;
	    startPoints = [start];
	  }

	  // set of points we want the pathfinding to finish at
	  if (to instanceof Rect) {
	    // `to` is targetBBox
	    end = targetAnchor;
	    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);
	  } else {
	    end = targetAnchor;
	    endPoints = [end];
	  }

	  // take into account only accessible rect points (those not under obstacles)
	  startPoints = startPoints.filter(p => !isPointObstacle(p));
	  endPoints = endPoints.filter(p => !isPointObstacle(p));

	  // Check that there is an accessible route point on both sides.
	  // Otherwise, use fallbackRoute().
	  if (startPoints.length > 0 && endPoints.length > 0) {
	    // The set of tentative points to be evaluated, initially containing the start points.
	    // Rounded to nearest integer for simplicity.
	    var openSet = new SortedSet();
	    // Keeps reference to actual points for given elements of the open set.
	    var points = {};
	    // Keeps reference to a point that is immediate predecessor of given element.
	    var parents = {};
	    // Cost from start to a point along best known path.
	    var costs = {};
	    for (var i = 0, n = startPoints.length; i < n; i++) {
	      // startPoint is assumed to be aligned already
	      var startPoint = startPoints[i];
	      var key = getKey(startPoint);
	      openSet.add(key, estimateCost(startPoint, endPoints));
	      points[key] = startPoint;
	      costs[key] = 0;
	    }
	    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route
	    var isPathBeginning = previousRouteDirectionAngle === undefined;

	    // directions
	    var direction, directionChange;
	    var directions = opt.directions;
	    getGridOffsets(directions, grid, opt);
	    var numDirections = directions.length;
	    var endPointsKeys = toArray$1(endPoints).reduce(function (res, endPoint) {
	      // endPoint is assumed to be aligned already

	      var key = getKey(endPoint);
	      res.push(key);
	      return res;
	    }, []);

	    // main route finding loop
	    var loopsRemaining = opt.maximumLoops;
	    while (!openSet.isEmpty() && loopsRemaining > 0) {
	      // remove current from the open list
	      var currentKey = openSet.pop();
	      var currentPoint = points[currentKey];
	      var currentParent = parents[currentKey];
	      var currentCost = costs[currentKey];
	      var isRouteBeginning = currentParent === undefined; // undefined for route starts
	      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction

	      var previousDirectionAngle;
	      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route
	      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path
	      else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point
	      else previousDirectionAngle = null; // beginning of path, source anchor or `from` point

	      // check if we reached any endpoint
	      var samePoints = startPoints.length === endPoints.length;
	      if (samePoints) {
	        for (var j = 0; j < startPoints.length; j++) {
	          if (!startPoints[j].equals(endPoints[j])) {
	            samePoints = false;
	            break;
	          }
	        }
	      }
	      var skipEndCheck = isRouteBeginning && samePoints;
	      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
	        opt.previousDirectionAngle = previousDirectionAngle;
	        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);
	      }

	      // go over all possible directions and find neighbors
	      for (i = 0; i < numDirections; i++) {
	        direction = directions[i];
	        var directionAngle = direction.angle;
	        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);

	        // if the direction changed rapidly, don't use this point
	        // any direction is allowed for starting points
	        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;
	        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);
	        var neighborKey = getKey(neighborPoint);

	        // Closed points from the openSet were already evaluated.
	        if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;

	        // We can only enter end points at an acceptable angle.
	        if (endPointsKeys.indexOf(neighborKey) >= 0) {
	          // neighbor is an end point

	          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction

	          if (!isNeighborEnd) {
	            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);
	            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
	            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;
	          }
	        }

	        // The current direction is ok.

	        var neighborCost = direction.cost;
	        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point
	        var costFromStart = currentCost + neighborCost + neighborPenalty;
	        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
	          // neighbor point has not been processed yet
	          // or the cost of the path from start is lower than previously calculated

	          points[neighborKey] = neighborPoint;
	          parents[neighborKey] = currentPoint;
	          costs[neighborKey] = costFromStart;
	          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
	        }
	      }
	      loopsRemaining--;
	    }
	  }

	  // no route found (`to` point either wasn't accessible or finding route took
	  // way too much calculation)
	  return opt.fallbackRoute.call(this, start, end, opt);
	}

	// resolve some of the options
	function resolveOptions(opt) {
	  opt.directions = result(opt, 'directions');
	  opt.penalties = result(opt, 'penalties');
	  opt.paddingBox = result(opt, 'paddingBox');
	  opt.padding = result(opt, 'padding');
	  if (opt.padding) {
	    // if both provided, opt.padding wins over opt.paddingBox
	    var sides = normalizeSides(opt.padding);
	    opt.paddingBox = {
	      x: -sides.left,
	      y: -sides.top,
	      width: sides.left + sides.right,
	      height: sides.top + sides.bottom
	    };
	  }
	  toArray$1(opt.directions).forEach(function (direction) {
	    var point1 = new Point(0, 0);
	    var point2 = new Point(direction.offsetX, direction.offsetY);
	    direction.angle = normalizeAngle(point1.theta(point2));
	  });
	}

	// initialization of the route finding
	function router(vertices, opt, linkView) {
	  resolveOptions(opt);

	  // enable/disable linkView perpendicular option
	  linkView.options.perpendicular = !!opt.perpendicular;
	  var sourceBBox = getSourceBBox(linkView, opt);
	  var targetBBox = getTargetBBox(linkView, opt);
	  var sourceAnchor = getSourceAnchor(linkView, opt);
	  //var targetAnchor = getTargetAnchor(linkView, opt);

	  // pathfinding
	  let isPointObstacle;
	  if (typeof opt.isPointObstacle === 'function') {
	    isPointObstacle = opt.isPointObstacle;
	  } else {
	    const map = new ObstacleMap(opt);
	    map.build(linkView.paper.model, linkView.model);
	    isPointObstacle = point => !map.isPointAccessible(point);
	  }
	  var oldVertices = toArray$1(vertices).map(Point);
	  var newVertices = [];
	  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping

	  // find a route by concatenating all partial routes (routes need to pass through vertices)
	  // source -> vertex[1] -> ... -> vertex[n] -> target
	  var to, from;
	  for (var i = 0, len = oldVertices.length; i <= len; i++) {
	    var partialRoute = null;
	    from = to || sourceBBox;
	    to = oldVertices[i];
	    if (!to) {
	      // this is the last iteration
	      // we ran through all vertices in oldVertices
	      // 'to' is not a vertex.

	      to = targetBBox;

	      // If the target is a point (i.e. it's not an element), we
	      // should use dragging route instead of main routing method if it has been provided.
	      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;
	      if (isEndingAtPoint && isFunction(opt.draggingRoute)) {
	        // Make sure we are passing points only (not rects).
	        var dragFrom = from === sourceBBox ? sourceAnchor : from;
	        var dragTo = to.origin();
	        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);
	      }
	    }

	    // if partial route has not been calculated yet use the main routing method to find one
	    partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);
	    if (partialRoute === null) {
	      // the partial route cannot be found
	      return opt.fallbackRouter(vertices, opt, linkView);
	    }
	    var leadPoint = partialRoute[0];

	    // remove the first point if the previous partial route had the same point as last
	    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();

	    // save tailPoint for next iteration
	    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
	    Array.prototype.push.apply(newVertices, partialRoute);
	  }
	  return newVertices;
	}

	// public function
	const manhattan = function (vertices, opt, linkView) {
	  return router(vertices, assign({}, config$1, opt), linkView);
	};

	var config = {
	  maxAllowedDirectionChange: 45,
	  // cost of a diagonal step
	  diagonalCost: function () {
	    var step = this.step;
	    return Math.ceil(Math.sqrt(step * step << 1));
	  },
	  // an array of directions to find next points on the route
	  // different from start/end directions
	  directions: function () {
	    var step = this.step;
	    var cost = this.cost();
	    var diagonalCost = this.diagonalCost();
	    return [{
	      offsetX: step,
	      offsetY: 0,
	      cost: cost
	    }, {
	      offsetX: step,
	      offsetY: step,
	      cost: diagonalCost
	    }, {
	      offsetX: 0,
	      offsetY: step,
	      cost: cost
	    }, {
	      offsetX: -step,
	      offsetY: step,
	      cost: diagonalCost
	    }, {
	      offsetX: -step,
	      offsetY: 0,
	      cost: cost
	    }, {
	      offsetX: -step,
	      offsetY: -step,
	      cost: diagonalCost
	    }, {
	      offsetX: 0,
	      offsetY: -step,
	      cost: cost
	    }, {
	      offsetX: step,
	      offsetY: -step,
	      cost: diagonalCost
	    }];
	  },
	  // a simple route used in situations when main routing method fails
	  // (exceed max number of loop iterations, inaccessible)
	  fallbackRoute: function (from, to, opt) {
	    // Find a route which breaks by 45 degrees ignoring all obstacles.

	    var theta = from.theta(to);
	    var route = [];
	    var a = {
	      x: to.x,
	      y: from.y
	    };
	    var b = {
	      x: from.x,
	      y: to.y
	    };
	    if (theta % 180 > 90) {
	      var t = a;
	      a = b;
	      b = t;
	    }
	    var p1 = theta % 90 < 45 ? a : b;
	    var l1 = new Line(from, p1);
	    var alpha = 90 * Math.ceil(theta / 90);
	    var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);
	    var l2 = new Line(to, p2);
	    var intersectionPoint = l1.intersection(l2);
	    var point = intersectionPoint ? intersectionPoint : to;
	    var directionFrom = intersectionPoint ? point : from;
	    var quadrant = 360 / opt.directions.length;
	    var angleTheta = directionFrom.theta(to);
	    var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);
	    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
	    opt.previousDirectionAngle = directionAngle;
	    if (point) route.push(point.round());
	    route.push(to);
	    return route;
	  }
	};

	// public function
	const metro = function (vertices, opt, linkView) {
	  if (!isFunction(manhattan)) {
	    throw new Error('Metro requires the manhattan router.');
	  }
	  return manhattan(vertices, assign({}, config, opt), linkView);
	};

	const Directions = {
	  AUTO: 'auto',
	  LEFT: 'left',
	  RIGHT: 'right',
	  TOP: 'top',
	  BOTTOM: 'bottom',
	  ANCHOR_SIDE: 'anchor-side',
	  MAGNET_SIDE: 'magnet-side'
	};
	const DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];
	const OPPOSITE_DIRECTIONS = {
	  [Directions.LEFT]: Directions.RIGHT,
	  [Directions.RIGHT]: Directions.LEFT,
	  [Directions.TOP]: Directions.BOTTOM,
	  [Directions.BOTTOM]: Directions.TOP
	};
	const VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];
	const ANGLE_DIRECTION_MAP = {
	  0: Directions.RIGHT,
	  180: Directions.LEFT,
	  270: Directions.TOP,
	  90: Directions.BOTTOM
	};
	function getSegmentAngle(line) {
	  // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links
	  return line.angle();
	}
	function simplifyPoints(points) {
	  // TODO: use own more efficient implementation (filter points that do not change direction).
	  // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.
	  return new Polyline$1(points).simplify({
	    threshold: 1
	  }).points;
	}
	function resolveSides(source, target) {
	  const {
	    point: sourcePoint,
	    x0: sx0,
	    y0: sy0,
	    view: sourceView,
	    bbox: sourceBBox,
	    direction: sourceDirection
	  } = source;
	  const {
	    point: targetPoint,
	    x0: tx0,
	    y0: ty0,
	    view: targetView,
	    bbox: targetBBox,
	    direction: targetDirection
	  } = target;
	  let sourceSide;
	  if (!sourceView) {
	    const sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);
	    sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);
	  } else if (sourceView.model.isLink()) {
	    sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);
	  } else if (sourceDirection === Directions.ANCHOR_SIDE) {
	    sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);
	  } else if (sourceDirection === Directions.MAGNET_SIDE) {
	    sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);
	  } else {
	    sourceSide = sourceDirection;
	  }
	  let targetSide;
	  if (!targetView) {
	    const targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);
	    targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);
	  } else if (targetView.model.isLink()) {
	    targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);
	  } else if (targetDirection === Directions.ANCHOR_SIDE) {
	    targetSide = targetBBox.sideNearestToPoint(targetPoint);
	  } else if (targetDirection === Directions.MAGNET_SIDE) {
	    targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);
	  } else {
	    targetSide = targetDirection;
	  }
	  return [sourceSide, targetSide];
	}
	function resolveForTopSourceSide(source, target, nextInLine) {
	  const {
	    x0: sx0,
	    y0: sy0,
	    width,
	    height,
	    point: anchor,
	    margin
	  } = source;
	  const sx1 = sx0 + width;
	  const sy1 = sy0 + height;
	  const smx0 = sx0 - margin;
	  const smx1 = sx1 + margin;
	  const smy0 = sy0 - margin;
	  const {
	    x: ax
	  } = anchor;
	  const {
	    x0: tx,
	    y0: ty
	  } = target;
	  if (tx === ax && ty < sy0) return Directions.BOTTOM;
	  if (tx < ax && ty < smy0) {
	    if (nextInLine.point.x === ax) return Directions.BOTTOM;
	    return Directions.RIGHT;
	  }
	  if (tx > ax && ty < smy0) {
	    if (nextInLine.point.x === ax) return Directions.BOTTOM;
	    return Directions.LEFT;
	  }
	  if (tx < smx0 && ty > smy0) return Directions.TOP;
	  if (tx > smx1 && ty > smy0) return Directions.TOP;
	  if (tx >= smx0 && tx <= ax && ty > sy1) {
	    if (nextInLine.point.x < tx) {
	      return Directions.RIGHT;
	    }
	    return Directions.LEFT;
	  }
	  if (tx <= smx1 && tx >= ax && ty > sy1) {
	    if (nextInLine.point.x < tx) {
	      return Directions.RIGHT;
	    }
	    return Directions.LEFT;
	  }
	  return Directions.BOTTOM;
	}
	function resolveForBottomSourceSide(source, target, nextInLine) {
	  const {
	    x0: sx0,
	    y0: sy0,
	    width,
	    height,
	    point: anchor,
	    margin
	  } = source;
	  const sx1 = sx0 + width;
	  const sy1 = sy0 + height;
	  const smx0 = sx0 - margin;
	  const smx1 = sx1 + margin;
	  const smy1 = sy1 + margin;
	  const {
	    x: ax
	  } = anchor;
	  const {
	    x0: tx,
	    y0: ty
	  } = target;
	  if (tx === ax && ty > sy1) return Directions.TOP;
	  if (tx < ax && ty > smy1) {
	    if (nextInLine.point.x === ax) return Directions.TOP;
	    return Directions.RIGHT;
	  }
	  if (tx > ax && ty > smy1) {
	    if (nextInLine.point.x === ax) return Directions.TOP;
	    return Directions.LEFT;
	  }
	  if (tx < smx0 && ty < smy1) return Directions.BOTTOM;
	  if (tx > smx1 && ty < smy1) return Directions.BOTTOM;
	  if (tx >= smx0 && tx <= ax && ty < sy0) {
	    if (nextInLine.point.x < tx) {
	      return Directions.RIGHT;
	    }
	    return Directions.LEFT;
	  }
	  if (tx <= smx1 && tx >= ax && ty < sy0) {
	    if (nextInLine.point.x < tx) {
	      return Directions.RIGHT;
	    }
	    return Directions.LEFT;
	  }
	  return Directions.TOP;
	}
	function resolveForLeftSourceSide(source, target, nextInLine) {
	  const {
	    y0: sy0,
	    x0: sx0,
	    width,
	    height,
	    point: anchor,
	    margin
	  } = source;
	  const sx1 = sx0 + width;
	  const sy1 = sy0 + height;
	  const smx0 = sx0 - margin;
	  const smy0 = sy0 - margin;
	  const smy1 = sy1 + margin;
	  const {
	    x: ax,
	    y: ay
	  } = anchor;
	  const {
	    x0: tx,
	    y0: ty
	  } = target;
	  if (tx < ax && ty === ay) return Directions.RIGHT;
	  if (tx <= smx0 && ty < ay) return Directions.BOTTOM;
	  if (tx <= smx0 && ty > ay) return Directions.TOP;
	  if (tx >= smx0 && ty < smy0) return Directions.LEFT;
	  if (tx >= smx0 && ty > smy1) return Directions.LEFT;
	  if (tx > sx1 && ty >= smy0 && ty <= ay) {
	    if (nextInLine.point.y < ty) {
	      return Directions.BOTTOM;
	    }
	    return Directions.TOP;
	  }
	  if (tx > sx1 && ty <= smy1 && ty >= ay) {
	    if (nextInLine.point.y < ty) {
	      return Directions.BOTTOM;
	    }
	    return Directions.TOP;
	  }
	  return Directions.RIGHT;
	}
	function resolveForRightSourceSide(source, target, nextInLine) {
	  const {
	    y0: sy0,
	    x0: sx0,
	    width,
	    height,
	    point: anchor,
	    margin
	  } = source;
	  const sx1 = sx0 + width;
	  const sy1 = sy0 + height;
	  const smx1 = sx1 + margin;
	  const smy0 = sy0 - margin;
	  const smy1 = sy1 + margin;
	  const {
	    x: ax,
	    y: ay
	  } = anchor;
	  const {
	    x0: tx,
	    y0: ty
	  } = target;
	  if (tx > ax && ty === ay) return Directions.LEFT;
	  if (tx >= smx1 && ty < ay) return Directions.BOTTOM;
	  if (tx >= smx1 && ty > ay) return Directions.TOP;
	  if (tx <= smx1 && ty < smy0) return Directions.RIGHT;
	  if (tx <= smx1 && ty > smy1) return Directions.RIGHT;
	  if (tx < sx0 && ty >= smy0 && ty <= ay) {
	    if (nextInLine.point.y < ty) {
	      return Directions.BOTTOM;
	    }
	    return Directions.TOP;
	  }
	  if (tx < sx0 && ty <= smy1 && ty >= ay) {
	    if (nextInLine.point.y < ty) {
	      return Directions.BOTTOM;
	    }
	    return Directions.TOP;
	  }
	  return Directions.LEFT;
	}
	function resolveInitialDirection(source, target, nextInLine) {
	  const [sourceSide] = resolveSides(source, target);
	  switch (sourceSide) {
	    case Directions.TOP:
	      return resolveForTopSourceSide(source, target, nextInLine);
	    case Directions.RIGHT:
	      return resolveForRightSourceSide(source, target, nextInLine);
	    case Directions.BOTTOM:
	      return resolveForBottomSourceSide(source, target, nextInLine);
	    case Directions.LEFT:
	      return resolveForLeftSourceSide(source, target, nextInLine);
	  }
	}
	function getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {
	  const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));
	  const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;
	  if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {
	    return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
	  } else if (linkOrigin.x === connectionPoint.x) {
	    return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
	  }
	  switch (roundedAngle) {
	    case 0:
	    case 180:
	    case 360:
	      return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
	    case 90:
	    case 270:
	      return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
	  }
	}
	function pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {
	  if (direction === Directions.AUTO) {
	    direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;
	  }
	  const isElement = view && view.model.isElement();
	  const {
	    x: x0,
	    y: y0,
	    width = 0,
	    height = 0
	  } = isElement ? Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;
	  return {
	    point,
	    x0,
	    y0,
	    view,
	    bbox,
	    width,
	    height,
	    direction,
	    margin: isElement ? margin : 0
	  };
	}
	function pointDataFromVertex({
	  x,
	  y
	}) {
	  const point = new Point(x, y);
	  return {
	    point,
	    x0: point.x,
	    y0: point.y,
	    view: null,
	    bbox: new Rect(x, y, 0, 0),
	    width: 0,
	    height: 0,
	    direction: null,
	    margin: 0
	  };
	}
	function getOutsidePoint(side, pointData, margin) {
	  const outsidePoint = pointData.point.clone();
	  const {
	    x0,
	    y0,
	    width,
	    height
	  } = pointData;
	  switch (side) {
	    case 'left':
	      outsidePoint.x = x0 - margin;
	      break;
	    case 'right':
	      outsidePoint.x = x0 + width + margin;
	      break;
	    case 'top':
	      outsidePoint.y = y0 - margin;
	      break;
	    case 'bottom':
	      outsidePoint.y = y0 + height + margin;
	      break;
	  }
	  return outsidePoint;
	}
	function createLoop(from, to, {
	  dx = 0,
	  dy = 0
	}) {
	  const p1 = {
	    x: from.point.x + dx,
	    y: from.point.y + dy
	  };
	  const p2 = {
	    x: to.point.x + dx,
	    y: to.point.y + dy
	  };
	  return [from.point, p1, p2, to.point];
	}
	function loopSegment(from, to, connectionSegmentAngle, margin) {
	  // Find out the loop coordinates.
	  const angle = normalizeAngle(connectionSegmentAngle - 90);
	  let dx = 0;
	  let dy = 0;
	  if (angle === 90) {
	    dy = -margin;
	  } else if (angle === 180) {
	    dx = -margin;
	  } else if (angle === 270) {
	    dy = margin;
	  } else if (angle === 0) {
	    dx = margin;
	  }
	  const loopRoute = createLoop(from, to, {
	    dx,
	    dy
	  });
	  const secondCreatedPoint = loopRoute[2];
	  const loopEndSegment = new Line(to.point, secondCreatedPoint);
	  // The direction in which the loop should continue.
	  const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
	  return {
	    loopRoute,
	    continueDirection
	  };
	}

	// Calculates the distances along the horizontal axis for the left and right route.
	function getHorizontalDistance(source, target) {
	  const {
	    x0: sx0,
	    x1: sx1,
	    outsidePoint: sourcePoint
	  } = source;
	  const {
	    x0: tx0,
	    x1: tx1,
	    outsidePoint: targetPoint
	  } = target;

	  // Furthest left boundary
	  let leftBoundary = Math.min(sx0, tx0);
	  // Furthest right boundary
	  let rightBoundary = Math.max(sx1, tx1);

	  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.
	  if (source.direction === target.direction) {
	    const aboveShape = source.y0 < target.y0 ? source : target;
	    const belowShape = aboveShape === source ? target : source;

	    // The source and target anchors are on the top => then the `aboveShape` defines the boundary.
	    // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.
	    const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;
	    leftBoundary = boundaryDefiningShape.x0;
	    rightBoundary = boundaryDefiningShape.x1;
	  }
	  const {
	    x: sox
	  } = sourcePoint;
	  const {
	    x: tox
	  } = targetPoint;

	  // Calculate the distances for the left route
	  const leftDistance1 = Math.abs(sox - leftBoundary);
	  const leftDistance2 = Math.abs(tox - leftBoundary);
	  const leftD = leftDistance1 + leftDistance2;

	  // Calculate the distances for the right route
	  const rightDistance1 = Math.abs(sox - rightBoundary);
	  const rightDistance2 = Math.abs(tox - rightBoundary);
	  const rightD = rightDistance1 + rightDistance2;
	  return [leftD, rightD];
	}

	// Calculates the distances along the vertical axis for the top and bottom route.
	function getVerticalDistance(source, target) {
	  const {
	    y0: sy0,
	    y1: sy1,
	    outsidePoint: sourcePoint
	  } = source;
	  const {
	    y0: ty0,
	    y1: ty1,
	    outsidePoint: targetPoint
	  } = target;

	  // Furthest top boundary
	  let topBoundary = Math.min(sy0, ty0);
	  // Furthest bottom boundary
	  let bottomBoundary = Math.max(sy1, ty1);

	  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.
	  if (source.direction === target.direction) {
	    const leftShape = source.x0 < target.x0 ? source : target;
	    const rightShape = leftShape === source ? target : source;

	    // The source and target anchors are on the left => then the `leftShape` defines the boundary.
	    // The source and target anchors are on the right => then the `rightShape` defines the boundary.
	    const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;
	    topBoundary = boundaryDefiningShape.y0;
	    bottomBoundary = boundaryDefiningShape.y1;
	  }
	  const {
	    y: soy
	  } = sourcePoint;
	  const {
	    y: toy
	  } = targetPoint;

	  // Calculate the distances for the top route
	  const topDistance1 = Math.abs(soy - topBoundary);
	  const topDistance2 = Math.abs(toy - topBoundary);
	  const topD = topDistance1 + topDistance2;

	  // Calculate the distances for the bottom route
	  const bottomDistance1 = Math.abs(soy - bottomBoundary);
	  const bottomDistance2 = Math.abs(toy - bottomBoundary);
	  const bottomD = bottomDistance1 + bottomDistance2;
	  return [topD, bottomD];
	}

	// Inflate bbox in 3 directions depending on the direction of the anchor
	// don't inflate in the opposite direction of the anchor
	function moveAndExpandBBox(bbox, direction, margin) {
	  switch (direction) {
	    case Directions.LEFT:
	      bbox.inflate(0, margin).moveAndExpand({
	        x: -margin,
	        width: margin
	      });
	      break;
	    case Directions.RIGHT:
	      bbox.inflate(0, margin).moveAndExpand({
	        width: margin
	      });
	      break;
	    case Directions.TOP:
	      bbox.inflate(margin, 0).moveAndExpand({
	        y: -margin,
	        height: margin
	      });
	      break;
	    case Directions.BOTTOM:
	      bbox.inflate(margin, 0).moveAndExpand({
	        height: margin
	      });
	      break;
	  }
	  return bbox;
	}
	function routeBetweenPoints(source, target, opt = {}) {
	  const {
	    point: sourcePoint,
	    x0: sx0,
	    y0: sy0,
	    width: sourceWidth,
	    height: sourceHeight,
	    margin: sourceMargin
	  } = source;
	  const {
	    point: targetPoint,
	    x0: tx0,
	    y0: ty0,
	    width: targetWidth,
	    height: targetHeight,
	    margin: targetMargin
	  } = target;
	  const {
	    targetInSourceBBox = false
	  } = opt;
	  const tx1 = tx0 + targetWidth;
	  const ty1 = ty0 + targetHeight;
	  const sx1 = sx0 + sourceWidth;
	  const sy1 = sy0 + sourceHeight;

	  // Key coordinates including the margin
	  const smx0 = sx0 - sourceMargin;
	  const smx1 = sx1 + sourceMargin;
	  const smy0 = sy0 - sourceMargin;
	  const smy1 = sy1 + sourceMargin;
	  const tmx0 = tx0 - targetMargin;
	  const tmx1 = tx1 + targetMargin;
	  const tmy0 = ty0 - targetMargin;
	  const tmy1 = ty1 + targetMargin;
	  const [sourceSide, targetSide] = resolveSides(source, target);
	  const sourceOutsidePoint = getOutsidePoint(sourceSide, {
	    point: sourcePoint,
	    x0: sx0,
	    y0: sy0,
	    width: sourceWidth,
	    height: sourceHeight
	  }, sourceMargin);
	  const targetOutsidePoint = getOutsidePoint(targetSide, {
	    point: targetPoint,
	    x0: tx0,
	    y0: ty0,
	    width: targetWidth,
	    height: targetHeight
	  }, targetMargin);
	  const {
	    x: sox,
	    y: soy
	  } = sourceOutsidePoint;
	  const {
	    x: tox,
	    y: toy
	  } = targetOutsidePoint;
	  const tcx = (tx0 + tx1) / 2;
	  const tcy = (ty0 + ty1) / 2;
	  const scx = (sx0 + sx1) / 2;
	  const scy = (sy0 + sy1) / 2;
	  const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;
	  const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;
	  const sourceBBox = new Rect(sx0, sy0, sourceWidth, sourceHeight);
	  const targetBBox = new Rect(tx0, ty0, targetWidth, targetHeight);
	  const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);
	  const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);
	  const sourceForDistance = Object.assign({}, source, {
	    x1: sx1,
	    y1: sy1,
	    outsidePoint: sourceOutsidePoint,
	    direction: sourceSide
	  });
	  const targetForDistance = Object.assign({}, target, {
	    x1: tx1,
	    y1: ty1,
	    outsidePoint: targetOutsidePoint,
	    direction: targetSide
	  });

	  // Distances used to determine the shortest route along the connections on horizontal sides for
	  // bottom => bottom
	  // top => bottom
	  // bottom => top
	  // top => top
	  const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);

	  // Distances used to determine the shortest route along the connection on vertical sides for
	  // left => left
	  // left => right
	  // right => right
	  // right => left
	  const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);

	  // All possible combinations of source and target sides
	  if (sourceSide === 'left' && targetSide === 'right') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
	    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);

	    // Use S-shaped connection
	    if (isPointInsideSource || isPointInsideTarget) {
	      const middleOfAnchors = (soy + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: middleOfAnchors
	      }, {
	        x: tox,
	        y: middleOfAnchors
	      }, {
	        x: tox,
	        y: toy
	      }];
	    }
	    if (smx0 < tox) {
	      let y = middleOfHorizontalSides;
	      let x1 = sox;
	      let x2 = tox;
	      const isUpwardsShorter = topD < bottomD;

	      // If the source and target elements overlap, we need to make sure the connection
	      // goes around the target element.
	      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
	        if (smy1 >= tmy0 && isUpwardsShorter) {
	          y = Math.min(tmy0, smy0);
	        } else if (smy0 <= tmy1 && !isUpwardsShorter) {
	          y = Math.max(tmy1, smy1);
	        }

	        // This handles the case when the source and target elements overlap as well as
	        // the case when the source is to the left of the target element.
	        x1 = Math.min(sox, tmx0);
	        x2 = Math.max(tox, smx1);

	        // This is an edge case when the source and target intersect and
	        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
	          // the path should no longer rely on minimal x boundary in `x1`
	          x1 = sox;
	        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
	          // the path should no longer rely on maximal x boundary in `x2`
	          x2 = tox;
	        }
	      }
	      return [{
	        x: x1,
	        y: soy
	      }, {
	        x: x1,
	        y
	      }, {
	        x: x2,
	        y
	      }, {
	        x: x2,
	        y: toy
	      }];
	    }
	    const x = (sox + tox) / 2;
	    return [{
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'right' && targetSide === 'left') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
	    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);

	    // Use S-shaped connection
	    if (isPointInsideSource || isPointInsideTarget) {
	      const middleOfAnchors = (soy + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: middleOfAnchors
	      }, {
	        x: tox,
	        y: middleOfAnchors
	      }, {
	        x: tox,
	        y: toy
	      }];
	    }
	    if (smx1 > tox) {
	      let y = middleOfHorizontalSides;
	      let x1 = sox;
	      let x2 = tox;
	      const isUpwardsShorter = topD < bottomD;

	      // If the source and target elements overlap, we need to make sure the connection
	      // goes around the target element.
	      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
	        if (smy1 >= tmy0 && isUpwardsShorter) {
	          y = Math.min(tmy0, smy0);
	        } else if (smy0 <= tmy1 && !isUpwardsShorter) {
	          y = Math.max(tmy1, smy1);
	        }

	        // This handles the case when the source and target elements overlap as well as
	        // the case when the source is to the left of the target element.
	        x1 = Math.max(sox, tmx1);
	        x2 = Math.min(tox, smx0);

	        // This is an edge case when the source and target intersect and
	        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
	          // the path should no longer rely on maximal x boundary in `x1`
	          x1 = sox;
	        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
	          // the path should no longer rely on minimal x boundary in `x2`
	          x2 = tox;
	        }
	      }
	      return [{
	        x: x1,
	        y: soy
	      }, {
	        x: x1,
	        y
	      }, {
	        x: x2,
	        y
	      }, {
	        x: x2,
	        y: toy
	      }];
	    }
	    const x = (sox + tox) / 2;
	    return [{
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'top' && targetSide === 'bottom') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
	    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);

	    // Use S-shaped connection
	    if (isPointInsideSource || isPointInsideTarget) {
	      const middleOfAnchors = (sox + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: middleOfAnchors,
	        y: soy
	      }, {
	        x: middleOfAnchors,
	        y: toy
	      }, {
	        x: tox,
	        y: toy
	      }];
	    }
	    if (smy0 < toy) {
	      let x = middleOfVerticalSides;
	      let y1 = soy;
	      let y2 = toy;
	      const isLeftShorter = leftD < rightD;

	      // If the source and target elements overlap, we need to make sure the connection
	      // goes around the target element.
	      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
	        if (smx1 >= tmx0 && isLeftShorter) {
	          x = Math.min(tmx0, smx0);
	        } else if (smx0 <= tmx1 && !isLeftShorter) {
	          x = Math.max(tmx1, smx1);
	        }

	        // This handles the case when the source and target elements overlap as well as
	        // the case when the source is to the left of the target element.
	        y1 = Math.min(soy, tmy0);
	        y2 = Math.max(toy, smy1);

	        // This is an edge case when the source and target intersect and
	        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
	          // the path should no longer rely on minimal y boundary in `y1`
	          y1 = soy;
	        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
	          // the path should no longer rely on maximal y boundary in `y2`
	          y2 = toy;
	        }
	      }
	      return [{
	        x: sox,
	        y: y1
	      }, {
	        x,
	        y: y1
	      }, {
	        x,
	        y: y2
	      }, {
	        x: tox,
	        y: y2
	      }];
	    }
	    const y = (soy + toy) / 2;
	    return [{
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  } else if (sourceSide === 'bottom' && targetSide === 'top') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
	    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);

	    // Use S-shaped connection
	    if (isPointInsideSource || isPointInsideTarget) {
	      const middleOfAnchors = (sox + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: middleOfAnchors,
	        y: soy
	      }, {
	        x: middleOfAnchors,
	        y: toy
	      }, {
	        x: tox,
	        y: toy
	      }];
	    }
	    if (smy1 > toy) {
	      let x = middleOfVerticalSides;
	      let y1 = soy;
	      let y2 = toy;
	      const isLeftShorter = leftD < rightD;

	      // If the source and target elements overlap, we need to make sure the connection
	      // goes around the target element.
	      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
	        if (smx1 >= tmx0 && isLeftShorter) {
	          x = Math.min(tmx0, smx0);
	        } else if (smx0 <= tmx1 && !isLeftShorter) {
	          x = Math.max(tmx1, smx1);
	        }

	        // This handles the case when the source and target elements overlap as well as
	        // the case when the source is to the left of the target element.
	        y1 = Math.max(soy, tmy1);
	        y2 = Math.min(toy, smy0);

	        // This is an edge case when the source and target intersect and
	        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
	          // the path should no longer rely on maximal y boundary in `y1`
	          y1 = soy;
	        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
	          // the path should no longer rely on minimal y boundary in `y2`
	          y2 = toy;
	        }
	      }
	      return [{
	        x: sox,
	        y: y1
	      }, {
	        x,
	        y: y1
	      }, {
	        x,
	        y: y2
	      }, {
	        x: tox,
	        y: y2
	      }];
	    }
	    const y = (soy + toy) / 2;
	    return [{
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  } else if (sourceSide === 'top' && targetSide === 'top') {
	    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);

	    // U-shape connection is a straight line if `sox` and `tox` are the same
	    if (useUShapeConnection && sox !== tox) {
	      return [{
	        x: sox,
	        y: Math.min(soy, toy)
	      }, {
	        x: tox,
	        y: Math.min(soy, toy)
	      }];
	    }
	    let x;
	    let y1 = Math.min((sy1 + ty0) / 2, toy);
	    let y2 = Math.min((sy0 + ty1) / 2, soy);
	    if (toy < soy) {
	      // Use the shortest path along the connections on horizontal sides
	      if (rightD > leftD) {
	        x = Math.min(sox, tmx0);
	      } else {
	        x = Math.max(sox, tmx1);
	      }
	    } else {
	      if (rightD > leftD) {
	        x = Math.min(tox, smx0);
	      } else {
	        x = Math.max(tox, smx1);
	      }
	    }
	    return [{
	      x: sox,
	      y: y2
	    }, {
	      x,
	      y: y2
	    }, {
	      x,
	      y: y1
	    }, {
	      x: tox,
	      y: y1
	    }];
	  } else if (sourceSide === 'bottom' && targetSide === 'bottom') {
	    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);

	    // U-shape connection is a straight line if `sox` and `tox` are the same
	    if (useUShapeConnection && sox !== tox) {
	      return [{
	        x: sox,
	        y: Math.max(soy, toy)
	      }, {
	        x: tox,
	        y: Math.max(soy, toy)
	      }];
	    }
	    let x;
	    let y1 = Math.max((sy0 + ty1) / 2, toy);
	    let y2 = Math.max((sy1 + ty0) / 2, soy);
	    if (toy > soy) {
	      // Use the shortest path along the connections on horizontal sides
	      if (rightD > leftD) {
	        x = Math.min(sox, tmx0);
	      } else {
	        x = Math.max(sox, tmx1);
	      }
	    } else {
	      if (rightD > leftD) {
	        x = Math.min(tox, smx0);
	      } else {
	        x = Math.max(tox, smx1);
	      }
	    }
	    return [{
	      x: sox,
	      y: y2
	    }, {
	      x,
	      y: y2
	    }, {
	      x,
	      y: y1
	    }, {
	      x: tox,
	      y: y1
	    }];
	  } else if (sourceSide === 'left' && targetSide === 'left') {
	    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);

	    // U-shape connection is a straight line if `soy` and `toy` are the same
	    if (useUShapeConnection && soy !== toy) {
	      return [{
	        x: Math.min(sox, tox),
	        y: soy
	      }, {
	        x: Math.min(sox, tox),
	        y: toy
	      }];
	    }
	    let y;
	    let x1 = Math.min((sx1 + tx0) / 2, tox);
	    let x2 = Math.min((sx0 + tx1) / 2, sox);
	    if (tox > sox) {
	      if (topD <= bottomD) {
	        y = Math.min(smy0, toy);
	      } else {
	        y = Math.max(smy1, toy);
	      }
	    } else {
	      if (topD <= bottomD) {
	        y = Math.min(tmy0, soy);
	      } else {
	        y = Math.max(tmy1, soy);
	      }
	    }
	    return [{
	      x: x2,
	      y: soy
	    }, {
	      x: x2,
	      y
	    }, {
	      x: x1,
	      y
	    }, {
	      x: x1,
	      y: toy
	    }];
	  } else if (sourceSide === 'right' && targetSide === 'right') {
	    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);

	    // U-shape connection is a straight line if `soy` and `toy` are the same
	    if (useUShapeConnection && soy !== toy) {
	      return [{
	        x: Math.max(sox, tox),
	        y: soy
	      }, {
	        x: Math.max(sox, tox),
	        y: toy
	      }];
	    }
	    let y;
	    let x1 = Math.max((sx0 + tx1) / 2, tox);
	    let x2 = Math.max((sx1 + tx0) / 2, sox);
	    if (tox <= sox) {
	      if (topD <= bottomD) {
	        y = Math.min(smy0, toy);
	      } else {
	        y = Math.max(smy1, toy);
	      }
	    } else {
	      if (topD <= bottomD) {
	        y = Math.min(tmy0, soy);
	      } else {
	        y = Math.max(tmy1, soy);
	      }
	    }
	    return [{
	      x: x2,
	      y: soy
	    }, {
	      x: x2,
	      y
	    }, {
	      x: x1,
	      y
	    }, {
	      x: x1,
	      y: toy
	    }];
	  } else if (sourceSide === 'top' && targetSide === 'right') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (sox <= tmx1) {
	        const x = Math.max(sox + sourceMargin, tox);
	        const y = Math.min(smy0, tmy0);

	        // Target anchor is on the right side of the source anchor
	        return [{
	          x: sox,
	          y
	        }, {
	          x: x,
	          y
	        }, {
	          x: x,
	          y: toy
	        }];
	      }

	      // Target anchor is on the left side of the source anchor
	      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor
	      const anchorMiddleX = (sox - sourceMargin + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: toy
	      }];
	    }
	    if (smy0 > toy) {
	      if (sox < tox) {
	        let y = tmy0;
	        if (tmy1 <= smy0 && tmx1 >= sox) {
	          y = middleOfHorizontalSides;
	        }
	        return [{
	          x: sox,
	          y
	        }, {
	          x: tox,
	          y
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: sox,
	        y: toy
	      }];
	    }
	    const x = Math.max(middleOfVerticalSides, tmx1);
	    if (sox > tox && sy1 >= toy) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x,
	        y: soy
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    if (x > smx0 && soy < ty1) {
	      const y = Math.min(smy0, tmy0);
	      const x = Math.max(smx1, tmx1);
	      return [{
	        x: sox,
	        y
	      }, {
	        x,
	        y
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'top' && targetSide === 'left') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (sox >= tmx0) {
	        const x = Math.min(sox - sourceMargin, tox);
	        const y = Math.min(smy0, tmy0);

	        // Target anchor is on the left side of the source anchor
	        return [{
	          x: sox,
	          y
	        }, {
	          x: x,
	          y
	        }, {
	          x: x,
	          y: toy
	        }];
	      }

	      // Target anchor is on the right side of the source anchor
	      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor
	      const anchorMiddleX = (sox + sourceMargin + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: toy
	      }];
	    }
	    if (smy0 > toy) {
	      if (sox > tox) {
	        let y = tmy0;
	        if (tmy1 <= smy0 && tmx0 <= sox) {
	          y = middleOfHorizontalSides;
	        }
	        return [{
	          x: sox,
	          y
	        }, {
	          x: tox,
	          y
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: sox,
	        y: toy
	      }];
	    }
	    const x = Math.min(tmx0, middleOfVerticalSides);
	    if (sox < tox && sy1 >= toy) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x,
	        y: soy
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    if (x < smx1 && soy < ty1) {
	      const y = Math.min(smy0, tmy0);
	      const x = Math.min(smx0, tmx0);
	      return [{
	        x: sox,
	        y
	      }, {
	        x,
	        y
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'bottom' && targetSide === 'right') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (sox <= tmx1) {
	        const x = Math.max(sox + sourceMargin, tox);
	        const y = Math.max(smy1, tmy1);

	        // Target anchor is on the right side of the source anchor
	        return [{
	          x: sox,
	          y
	        }, {
	          x,
	          y
	        }, {
	          x,
	          y: toy
	        }];
	      }

	      // Target anchor is on the left side of the source anchor
	      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor
	      const anchorMiddleX = (sox - sourceMargin + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: toy
	      }];
	    }
	    if (smy1 < toy) {
	      if (sox < tox) {
	        let y = tmy1;
	        if (tmy0 >= smy1 && tmx1 >= sox) {
	          y = middleOfHorizontalSides;
	        }
	        return [{
	          x: sox,
	          y
	        }, {
	          x: tox,
	          y
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: sox,
	        y: toy
	      }];
	    }
	    const x = Math.max(middleOfVerticalSides, tmx1);
	    if (sox > tox && sy0 <= toy) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x,
	        y: soy
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    if (x > smx0 && soy > ty0) {
	      const y = Math.max(smy1, tmy1);
	      const x = Math.max(smx1, tmx1);
	      return [{
	        x: sox,
	        y
	      }, {
	        x,
	        y
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'bottom' && targetSide === 'left') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (sox >= tmx0) {
	        const x = Math.min(sox - sourceMargin, tox);
	        const y = Math.max(smy1, tmy1);

	        // Target anchor is on the left side of the source anchor
	        return [{
	          x: sox,
	          y
	        }, {
	          x,
	          y
	        }, {
	          x,
	          y: toy
	        }];
	      }

	      // Target anchor is on the right side of the source anchor
	      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor
	      const anchorMiddleX = (sox + sourceMargin + tox) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: soy
	      }, {
	        x: anchorMiddleX,
	        y: toy
	      }];
	    }
	    if (smy1 < toy) {
	      if (sox > tox) {
	        let y = tmy1;
	        if (tmy0 >= smy1 && tmx0 <= sox) {
	          y = middleOfHorizontalSides;
	        }
	        return [{
	          x: sox,
	          y
	        }, {
	          x: tox,
	          y
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: sox,
	        y: toy
	      }];
	    }
	    const x = Math.min(tmx0, middleOfVerticalSides);
	    if (sox < tox && sy0 <= toy) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x,
	        y: soy
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    if (x < smx1 && soy > ty0) {
	      const y = Math.max(smy1, tmy1);
	      const x = Math.min(smx0, tmx0);
	      return [{
	        x: sox,
	        y
	      }, {
	        x,
	        y
	      }, {
	        x,
	        y: toy
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x,
	      y: soy
	    }, {
	      x,
	      y: toy
	    }];
	  } else if (sourceSide === 'left' && targetSide === 'bottom') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (soy <= tmy1) {
	        const x = Math.min(smx0, tmx0);
	        const y = Math.max(soy + sourceMargin, toy);
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y
	        }, {
	          x: tox,
	          y
	        }];
	      }

	      // Target anchor is above the source anchor
	      const anchorMiddleY = (soy - sourceMargin + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: anchorMiddleY
	      }, {
	        x: tox,
	        y: anchorMiddleY
	      }];
	    }
	    if (smx0 > tox) {
	      if (soy < toy) {
	        let x = tmx0;
	        if (tmx1 <= smx0 && tmy1 >= soy) {
	          x = middleOfVerticalSides;
	        }
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y: toy
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: tox,
	        y: soy
	      }];
	    }
	    const y = Math.max(tmy1, middleOfHorizontalSides);
	    if (soy > toy && sx1 >= tox) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    if (y > smy0 && sox < tx1) {
	      const x = Math.min(smx0, tmx0);
	      const y = Math.max(smy1, tmy1);
	      return [{
	        x,
	        y: soy
	      }, {
	        x,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  } else if (sourceSide === 'left' && targetSide === 'top') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (soy >= tmy0) {
	        const y = Math.min(soy - sourceMargin, toy);
	        const x = Math.min(smx0, tmx0);

	        // Target anchor is on the top side of the source anchor
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y
	        }, {
	          x: tox,
	          y
	        }];
	      }

	      // Target anchor is below the source anchor
	      // Add the `sourceMargin` since the source anchor is above the target anchor
	      const anchorMiddleY = (soy + sourceMargin + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: anchorMiddleY
	      }, {
	        x: tox,
	        y: anchorMiddleY
	      }];
	    }
	    if (smx0 > tox) {
	      if (soy > toy) {
	        let x = tmx0;
	        if (tmx1 <= smx0 && tmy0 <= soy) {
	          x = middleOfVerticalSides;
	        }
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y: toy
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: tox,
	        y: soy
	      }];
	    }
	    const y = Math.min(tmy0, middleOfHorizontalSides);
	    if (soy < toy && sx1 >= tox) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    if (y < smy1 && sox < tx1) {
	      const x = Math.min(smx0, tmx0);
	      const y = Math.min(smy0, tmy0);
	      return [{
	        x,
	        y: soy
	      }, {
	        x,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  } else if (sourceSide === 'right' && targetSide === 'top') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (soy >= tmy0) {
	        const x = Math.max(smx1, tmx1);
	        const y = Math.min(soy - sourceMargin, toy);

	        // Target anchor is on the top side of the source anchor
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y
	        },
	        // Path adjustment for right side start
	        {
	          x: tox,
	          y
	        }];
	      }

	      // Target anchor is below the source anchor
	      // Adjust sourceMargin calculation since the source anchor is now on the right
	      const anchorMiddleY = (soy + sourceMargin + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: anchorMiddleY
	      }, {
	        x: tox,
	        y: anchorMiddleY
	      }];
	    }
	    if (smx1 < tox) {
	      if (soy > toy) {
	        let x = tmx1;
	        if (tmx0 >= smx1 && tmy0 <= soy) {
	          x = middleOfVerticalSides;
	        }
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y: toy
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: tox,
	        y: soy
	      }];
	    }
	    const y = Math.min(tmy0, middleOfHorizontalSides);
	    if (soy < toy && sx0 <= tox) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    if (y < smy1 && sox > tx0) {
	      const x = Math.max(smx1, tmx1);
	      const y = Math.min(smy0, tmy0);
	      return [{
	        x,
	        y: soy
	      }, {
	        x,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  } else if (sourceSide === 'right' && targetSide === 'bottom') {
	    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);

	    // The target point is inside the source element
	    if (isPointInsideSource) {
	      if (soy <= tmy1) {
	        const x = Math.max(smx1, tmx1);
	        const y = Math.max(soy + sourceMargin, toy);
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y
	        }, {
	          x: tox,
	          y
	        }];
	      }

	      // Target anchor is above the source anchor
	      const anchorMiddleY = (soy - sourceMargin + toy) / 2;
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y: anchorMiddleY
	      }, {
	        x: tox,
	        y: anchorMiddleY
	      }];
	    }
	    if (smx1 < tox) {
	      if (soy < toy) {
	        let x = tmx1;
	        if (tmx0 >= smx1 && tmy1 >= soy) {
	          x = middleOfVerticalSides;
	        }
	        return [{
	          x,
	          y: soy
	        }, {
	          x,
	          y: toy
	        }, {
	          x: tox,
	          y: toy
	        }];
	      }
	      return [{
	        x: tox,
	        y: soy
	      }];
	    }
	    const y = Math.max(tmy1, middleOfHorizontalSides);
	    if (soy > toy && sx0 <= tox) {
	      return [{
	        x: sox,
	        y: soy
	      }, {
	        x: sox,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    if (y > smy0 && sox > tx0) {
	      const x = Math.max(smx1, tmx1);
	      const y = Math.max(smy1, tmy1);
	      return [{
	        x,
	        y: soy
	      }, {
	        x,
	        y
	      }, {
	        x: tox,
	        y
	      }];
	    }
	    return [{
	      x: sox,
	      y: soy
	    }, {
	      x: sox,
	      y
	    }, {
	      x: tox,
	      y
	    }];
	  }
	}
	function getLoopCoordinates(direction, angle, margin) {
	  const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;
	  let dx = 0;
	  let dy = 0;
	  switch (normalizeAngle(Math.round(angle))) {
	    case 0:
	    case 90:
	      dx = isHorizontal ? 0 : margin;
	      dy = isHorizontal ? margin : 0;
	      break;
	    case 180:
	    case 270:
	      dx = isHorizontal ? 0 : -margin;
	      dy = isHorizontal ? -margin : 0;
	      break;
	  }
	  return {
	    dx,
	    dy
	  };
	}
	function rightAngleRouter(vertices, opt, linkView) {
	  const {
	    sourceDirection = Directions.AUTO,
	    targetDirection = Directions.AUTO
	  } = opt;
	  const margin = opt.margin || 20;
	  const useVertices = opt.useVertices || false;
	  const isSourcePort = !!linkView.model.source().port;
	  const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);
	  const isTargetPort = !!linkView.model.target().port;
	  const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);
	  let resultVertices = [];
	  if (!useVertices || vertices.length === 0) {
	    return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));
	  }
	  const verticesData = vertices.map(v => pointDataFromVertex(v));
	  const [firstVertex] = verticesData;
	  const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);
	  const isElement = sourcePoint.view && sourcePoint.view.model.isElement();
	  const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;
	  const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;
	  if (isVertexInside) {
	    const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);
	    const firstPointOverlap = outsidePoint.equals(firstVertex.point);
	    const alignsVertically = sourcePoint.point.x === firstVertex.point.x;
	    const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;
	    const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);
	    const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);
	    const firstSegment = new Line(sourcePoint.point, outsidePoint);
	    const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);
	    const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);
	    if (firstPointOverlap) {
	      resultVertices.push(sourcePoint.point, firstVertex.point);
	      // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex
	      firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];
	    } else if (isVertexOnSegment || isVertexAlignedAndInside) {
	      // Case where there is a need to create a loop
	      const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new Line(sourcePoint.point, firstVertex.point));
	      const {
	        dx,
	        dy
	      } = getLoopCoordinates(resolvedSourceDirection, angle, margin);
	      const loop = createLoop({
	        point: outsidePoint
	      }, firstVertex, {
	        dx,
	        dy
	      });
	      const secondCreatedPoint = loop[2];
	      const loopEndSegment = new Line(firstVertex.point, secondCreatedPoint);
	      const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
	      firstVertex.direction = accessDirection;
	      resultVertices.push(...loop);
	    } else {
	      // No need to create a route, use the `routeBetweenPoints` to construct a route
	      firstVertex.direction = resolvedSourceDirection;
	      firstVertex.margin = margin;
	      resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, {
	        targetInSourceBBox: true
	      }), firstVertex.point);
	    }
	  } else {
	    // The first point responsible for the initial direction of the route
	    const next = verticesData[1] || targetPoint;
	    const direction = resolveInitialDirection(sourcePoint, firstVertex, next);
	    firstVertex.direction = direction;
	    resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);
	  }
	  for (let i = 0; i < verticesData.length - 1; i++) {
	    const from = verticesData[i];
	    const to = verticesData[i + 1];
	    const connectionSegment = new Line(from.point, to.point);
	    const connectionSegmentAngle = getSegmentAngle(connectionSegment);
	    if (connectionSegmentAngle % 90 === 0) {
	      // Segment is horizontal or vertical
	      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
	      const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);
	      // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);
	      // Find out the direction that is used to connect the current route with the next vertex
	      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);
	      // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);
	      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
	      // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];
	      // console.log(accessDirection);
	      // console.log(accessDirection2);
	      // if (accessDirection !== accessDirection2) {
	      //     console.log('error');
	      // }
	      // console.log('------------------');

	      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
	        // The directions are not opposite, so we can connect the vertices directly
	        resultVertices.push(from.point, to.point);
	        const [, toDirection] = resolveSides(from, to);
	        to.direction = toDirection;
	      } else {
	        // The directions are overlapping, so we need to create a loop
	        const {
	          loopRoute,
	          continueDirection
	        } = loopSegment(from, to, connectionSegmentAngle, margin);
	        to.direction = continueDirection;
	        // Constructing a loop
	        resultVertices.push(...loopRoute);
	      }
	      continue;
	    }

	    // Vertices are not aligned vertically nor horizontally
	    // so we need to route between them

	    const [fromDirection, toDirection] = resolveDirection(from, to);
	    from.direction = fromDirection;
	    to.direction = toDirection;
	    resultVertices.push(...routeBetweenPoints(from, to), to.point);
	  }
	  const lastVertex = verticesData[verticesData.length - 1];
	  if (targetPoint.view && targetPoint.view.model.isElement()) {
	    const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);
	    const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);

	    // the last point of `simplified` array is the last defined vertex
	    // this will ensure that the last segment continues in a straight line
	    const simplified = simplifyPoints([...resultVertices, lastVertex.point]);
	    const simplifiedSegment = new Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);
	    const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));
	    const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];
	    const lastPointOverlap = outsidePoint.equals(lastVertex.point);
	    if (!lastPointOverlap || lastPointOverlap && definedDirection === resolvedTargetDirection) {
	      lastVertex.direction = definedDirection;
	      let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
	      const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);
	      const lastSegment = new Line(p1, p2);
	      const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));
	      const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];
	      const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);
	      const alignsVertically = lastVertex.point.x === targetPoint.point.x;
	      const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;
	      const isVertexInside = targetBBox.containsPoint(lastVertex.point);
	      const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);
	      const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);
	      if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {
	        // Handle special cases when the last vertex is inside the target element
	        // and in is aligned with the connection point => construct a loop
	        const {
	          dx,
	          dy
	        } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);
	        lastSegmentRoute = createLoop(lastVertex, {
	          point: outsidePoint
	        }, {
	          dx,
	          dy
	        });
	      } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {
	        lastVertex.margin = margin;
	        lastVertex.direction = resolvedTargetDirection;
	        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
	      } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {
	        lastVertex.margin = margin;
	        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
	      }
	      resultVertices.push(...lastSegmentRoute);
	    }
	  } else {
	    // since the target is only a point we can apply the same logic as if we connected two verticesData
	    const from = lastVertex;
	    const to = targetPoint;
	    const connectionSegment = new Line(from.point, to.point);
	    const connectionSegmentAngle = getSegmentAngle(connectionSegment);
	    if (connectionSegmentAngle % 90 === 0) {
	      // Segment is horizontal or vertical
	      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
	      const simplifiedRoute = simplifyPoints(resultVertices);
	      // Find out the direction that is used to connect the current route with the next vertex
	      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);
	      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
	      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
	        // The directions are not opposite, so we can connect the vertices directly by adding the first point
	        // the target point is handled separately
	        resultVertices.push(from.point);
	      } else {
	        // The directions are overlapping, so we need to create a loop
	        const {
	          loopRoute
	        } = loopSegment(from, to, connectionSegmentAngle, margin);
	        // Remove the last point since it is the target that is handled separately
	        loopRoute.pop();
	        // Constructing a loop
	        resultVertices.push(...loopRoute);
	      }
	    } else {
	      // The last vertex and the target are not aligned vertically nor horizontally
	      // so we need to route between them
	      const [fromDirection, toDirection] = resolveDirection(from, to);
	      from.direction = fromDirection;
	      to.direction = toDirection;
	      resultVertices.push(...routeBetweenPoints(from, to));
	    }
	  }
	  return simplifyPoints(resultVertices);
	}
	function resolveDirection(from, to) {
	  const accessDirection = from.direction;
	  const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);
	  let sourceDirection = from.direction;
	  let targetDirection = to.direction;
	  if (isDirectionVertical) {
	    const isToAbove = from.point.y > to.point.y;
	    const dx = to.point.x - from.point.x;
	    if (accessDirection === Directions.BOTTOM) {
	      // If isToAbove === false and we need figure out if to go left or right
	      sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;
	      if (dx > 0) {
	        targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;
	      } else if (dx < 0) {
	        targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;
	      }
	    } else {
	      // If isToAbove === true and we need figure out if to go left or right
	      sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];
	      if (dx > 0) {
	        targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;
	      } else if (dx < 0) {
	        targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;
	      }
	    }
	  } else {
	    const isToLeft = from.point.x > to.point.x;
	    const dy = to.point.y - from.point.y;
	    if (accessDirection === Directions.RIGHT) {
	      sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;
	      if (dy > 0) {
	        targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;
	      } else if (dy < 0) {
	        targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;
	      }
	    } else {
	      sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];
	      if (dy > 0) {
	        targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;
	      } else if (dy < 0) {
	        targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;
	      }
	    }
	  }
	  return [sourceDirection, targetDirection];
	}
	rightAngleRouter.Directions = Directions;
	const rightAngle = rightAngleRouter;

	var routers = {
		__proto__: null,
		manhattan: manhattan,
		metro: metro,
		normal: normal,
		oneSide: oneSide,
		orthogonal: orthogonal,
		rightAngle: rightAngle
	};

	function connectionRatio(view, _magnet, _refPoint, opt) {
	  var ratio = 'ratio' in opt ? opt.ratio : 0.5;
	  return view.getPointAtRatio(ratio);
	}
	function connectionLength(view, _magnet, _refPoint, opt) {
	  var length = 'length' in opt ? opt.length : 20;
	  return view.getPointAtLength(length);
	}
	function _connectionPerpendicular(view, _magnet, refPoint, opt) {
	  var OFFSET = 1e6;
	  var path = view.getConnection();
	  var segmentSubdivisions = view.getConnectionSubdivisions();
	  var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));
	  var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));
	  var verticalIntersections = verticalLine.intersect(path, {
	    segmentSubdivisions: segmentSubdivisions
	  });
	  var horizontalIntersections = horizontalLine.intersect(path, {
	    segmentSubdivisions: segmentSubdivisions
	  });
	  var intersections = [];
	  if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);
	  if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);
	  if (intersections.length > 0) return refPoint.chooseClosest(intersections);
	  if ('fallbackAt' in opt) {
	    return getPointAtLink(view, opt.fallbackAt);
	  }
	  return connectionClosest(view, _magnet, refPoint, opt);
	}
	function _connectionClosest(view, _magnet, refPoint, _opt) {
	  var closestPoint = view.getClosestPoint(refPoint);
	  if (!closestPoint) return new Point();
	  return closestPoint;
	}
	function resolveRef(fn) {
	  return function (view, magnet, ref, opt, endType, linkView) {
	    if (ref instanceof Element) {
	      var refView = this.paper.findView(ref);
	      var refPoint;
	      if (refView) {
	        if (refView.isNodeConnection(ref)) {
	          var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';
	          refPoint = getPointAtLink(refView, distance);
	        } else {
	          refPoint = refView.getNodeBBox(ref).center();
	        }
	      } else {
	        // Something went wrong
	        refPoint = new Point();
	      }
	      return fn.call(this, view, magnet, refPoint, opt, endType, linkView);
	    }
	    return fn.apply(this, arguments);
	  };
	}
	function getPointAtLink(view, value) {
	  var parsedValue = parseFloat(value);
	  if (isPercentage(value)) {
	    return view.getPointAtRatio(parsedValue / 100);
	  } else {
	    return view.getPointAtLength(parsedValue);
	  }
	}
	const connectionPerpendicular = resolveRef(_connectionPerpendicular);
	const connectionClosest = resolveRef(_connectionClosest);

	var linkAnchors = {
		__proto__: null,
		connectionClosest: connectionClosest,
		connectionLength: connectionLength,
		connectionPerpendicular: connectionPerpendicular,
		connectionRatio: connectionRatio,
		resolveRef: resolveRef
	};

	const Side = {
	  LEFT: 'left',
	  RIGHT: 'right',
	  TOP: 'top',
	  BOTTOM: 'bottom'
	};
	const SideMode = {
	  PREFER_HORIZONTAL: 'prefer-horizontal',
	  PREFER_VERTICAL: 'prefer-vertical',
	  HORIZONTAL: 'horizontal',
	  VERTICAL: 'vertical',
	  AUTO: 'auto'
	};
	function getModelBBoxFromConnectedLink(element, link, endType, rotate) {
	  const portId = link.get(endType).port;
	  if (element.hasPort(portId)) {
	    return element.getPortBBox(portId, {
	      rotate
	    });
	  }
	  return element.getBBox({
	    rotate
	  });
	}
	function getMiddleSide(rect, point, opt) {
	  const {
	    preferenceThreshold = 0,
	    mode
	  } = opt;
	  const {
	    x,
	    y
	  } = point;
	  const {
	    x: left,
	    y: top,
	    width,
	    height
	  } = rect;
	  switch (mode) {
	    case SideMode.PREFER_VERTICAL:
	      {
	        const {
	          top: topThreshold,
	          bottom: bottomThreshold
	        } = normalizeSides(preferenceThreshold);
	        const bottom = top + height;
	        if (y > top - topThreshold && y < bottom + bottomThreshold) {
	          const cx = left + width / 2;
	          return x < cx ? Side.LEFT : Side.RIGHT;
	        }
	      }
	    // eslint-disable-next-line no-fallthrough
	    case SideMode.VERTICAL:
	      {
	        const cy = top + height / 2;
	        return y < cy ? Side.TOP : Side.BOTTOM;
	      }
	    case SideMode.PREFER_HORIZONTAL:
	      {
	        const {
	          left: leftThreshold,
	          right: rightThreshold
	        } = normalizeSides(preferenceThreshold);
	        const right = left + width;
	        if (x > left - leftThreshold && x < right + rightThreshold) {
	          const cy = top + height / 2;
	          return y < cy ? Side.TOP : Side.BOTTOM;
	        }
	      }
	    // eslint-disable-next-line no-fallthrough
	    case SideMode.HORIZONTAL:
	      {
	        const cx = left + width / 2;
	        return x < cx ? Side.LEFT : Side.RIGHT;
	      }
	    case SideMode.AUTO:
	    default:
	      {
	        return rect.sideNearestToPoint(point);
	      }
	  }
	}
	function bboxWrapper(method) {
	  return function (elementView, magnet, ref, opt, endType, linkView) {
	    const rotate = !!opt.rotate;
	    const element = elementView.model;
	    const link = linkView.model;
	    const angle = element.angle();
	    let bbox, center;
	    if (opt.useModelGeometry) {
	      bbox = getModelBBoxFromConnectedLink(element, link, endType, !rotate);
	      center = bbox.center();
	    } else {
	      center = element.getCenter();
	      bbox = rotate ? elementView.getNodeUnrotatedBBox(magnet) : elementView.getNodeBBox(magnet);
	    }
	    const anchor = bbox[method]();
	    let dx = opt.dx;
	    if (dx) {
	      const isDxPercentage = isPercentage(dx);
	      if (!isDxPercentage && isCalcExpression(dx)) {
	        // calc expression
	        dx = Number(evalCalcExpression(dx, bbox));
	      } else {
	        // percentage or a number
	        dx = parseFloat(dx);
	      }
	      if (isFinite(dx)) {
	        if (isDxPercentage) {
	          dx /= 100;
	          dx *= bbox.width;
	        }
	        anchor.x += dx;
	      }
	    }
	    let dy = opt.dy;
	    if (dy) {
	      const isDyPercentage = isPercentage(dy);
	      if (!isDyPercentage && isCalcExpression(dy)) {
	        // calc expression
	        dy = Number(evalCalcExpression(dy, bbox));
	      } else {
	        // percentage or a number
	        dy = parseFloat(dy);
	      }
	      if (isFinite(dy)) {
	        if (isDyPercentage) {
	          dy /= 100;
	          dy *= bbox.height;
	        }
	        anchor.y += dy;
	      }
	    }
	    return rotate ? anchor.rotate(center, -angle) : anchor;
	  };
	}
	function _perpendicular(elementView, magnet, refPoint, opt, endType, linkView) {
	  const element = elementView.model;
	  const angle = element.angle();
	  let bbox;
	  if (opt.useModelGeometry) {
	    bbox = getModelBBoxFromConnectedLink(element, linkView.model, endType, true);
	  } else {
	    bbox = elementView.getNodeBBox(magnet);
	  }
	  const anchor = bbox.center();
	  const topLeft = bbox.origin();
	  const bottomRight = bbox.corner();
	  let padding = opt.padding;
	  if (!isFinite(padding)) padding = 0;
	  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {
	    var dy = refPoint.y - anchor.y;
	    anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));
	    anchor.y += dy;
	  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {
	    var dx = refPoint.x - anchor.x;
	    anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));
	    anchor.x += dx;
	  }
	  return anchor;
	}
	function _midSide(view, magnet, refPoint, opt, endType, linkView) {
	  var rotate = !!opt.rotate;
	  var angle = view.model.angle();
	  var center = view.model.getCenter();
	  var bbox;
	  if (opt.useModelGeometry) {
	    bbox = getModelBBoxFromConnectedLink(view.model, linkView.model, endType, !rotate);
	    center = bbox.center();
	  } else {
	    bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);
	  }
	  var padding = opt.padding;
	  if (isFinite(padding)) bbox.inflate(padding);
	  if (rotate) refPoint.rotate(center, angle);
	  var side = getMiddleSide(bbox, refPoint, opt);
	  var anchor;
	  switch (side) {
	    case Side.LEFT:
	      anchor = bbox.leftMiddle();
	      break;
	    case Side.RIGHT:
	      anchor = bbox.rightMiddle();
	      break;
	    case Side.TOP:
	      anchor = bbox.topMiddle();
	      break;
	    case Side.BOTTOM:
	      anchor = bbox.bottomMiddle();
	      break;
	  }
	  return rotate ? anchor.rotate(center, -angle) : anchor;
	}

	// Can find anchor from model, when there is no selector or the link end
	// is connected to a port
	function _modelCenter(view, _magnet, _refPoint, opt, endType) {
	  return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);
	}

	//joint.anchors
	const center = bboxWrapper('center');
	const top = bboxWrapper('topMiddle');
	const bottom = bboxWrapper('bottomMiddle');
	const left = bboxWrapper('leftMiddle');
	const right = bboxWrapper('rightMiddle');
	const topLeft = bboxWrapper('origin');
	const topRight = bboxWrapper('topRight');
	const bottomLeft = bboxWrapper('bottomLeft');
	const bottomRight = bboxWrapper('corner');
	const perpendicular = resolveRef(_perpendicular);
	const midSide = resolveRef(_midSide);
	const modelCenter = _modelCenter;

	var anchors = {
		__proto__: null,
		bottom: bottom,
		bottomLeft: bottomLeft,
		bottomRight: bottomRight,
		center: center,
		left: left,
		midSide: midSide,
		modelCenter: modelCenter,
		perpendicular: perpendicular,
		right: right,
		top: top,
		topLeft: topLeft,
		topRight: topRight
	};

	/**
	 * @class GraphLayersController
	 * @description Coordinates interactions between the graph and its layers.
	 * Automatically moves cells between layers when the layer attribute changes.
	 */
	class GraphLayersController extends Listener {
	  constructor(options) {
	    super(options);

	    // Make sure there are no arguments passed to the callbacks.
	    // See the `mvc.Listener` documentation for more details.
	    this.callbackArguments = [];
	    const graph = options.graph;
	    if (!graph) {
	      throw new Error('GraphLayersController: "graph" option is required.');
	    }
	    this.graph = graph;
	    this.layerCollection = graph.layerCollection;
	    this.startListening();
	  }
	  startListening() {
	    // Handle all events from the layer collection and its inner cell collections.
	    this.listenTo(this.layerCollection, 'all', this.onLayerCollectionEvent);
	  }

	  /**
	   * @description When a cell changes its layer attribute,
	   * move the cell to the target layer.
	   */
	  onCellChange(cell, options) {
	    if (!cell.hasChanged(config$3.layerAttribute)) return;
	    // Move the cell to the appropriate layer
	    const targetLayerId = this.graph.getCellLayerId(cell);
	    this.layerCollection.moveCellBetweenLayers(cell, targetLayerId, options);
	  }

	  /**
	   * @description When a cell is removed from a layer,
	   * also remove its embeds and connected links from the graph.
	   * Note: an embedded cell might come from a different layer,
	   * so we can not use the layer's cell collection to remove it.
	   */
	  onCellRemove(cell, options) {
	    // If the cell is being moved from one layer to another,
	    // no further action is needed.
	    if (options.fromLayer) return;

	    // When replacing a cell, we do not want to remove its embeds or
	    // unembed it from its parent.
	    if (options.replace) return;

	    // First, unembed this cell from its parent cell if there is one.
	    const parentCell = cell.getParentCell();
	    if (parentCell) {
	      parentCell.unembed(cell, options);
	    }

	    // Remove also all the cells, which were embedded into this cell
	    const embeddedCells = cell.getEmbeddedCells();
	    for (let i = 0, n = embeddedCells.length; i < n; i++) {
	      const embed = embeddedCells[i];
	      if (embed) {
	        this.layerCollection.removeCell(embed, options);
	      }
	    }

	    // When not clearing the whole graph or replacing the cell,
	    // we don't want to remove the connected links.
	    if (!options.clear) {
	      // Applications might provide a `disconnectLinks` option set to `true` in order to
	      // disconnect links when a cell is removed rather then removing them. The default
	      // is to remove all the associated links.
	      if (options.disconnectLinks) {
	        this.graph.disconnectLinks(cell, options);
	      } else {
	        this.graph.removeLinks(cell, options);
	      }
	    }
	  }
	  onLayerCollectionEvent(eventName, model) {
	    if (!model) return;
	    if (model[CELL_MARKER]) {
	      // First handle cell-specific cases that require custom processing,
	      // then forward the event to the graph.
	      // For example, when a cell is removed from a layer, its embeds and
	      // connected links must be removed as well. Listeners on the graph
	      // should receive removal notifications in the following order:
	      // embeds â links â cell.
	      switch (eventName) {
	        case 'change':
	          /* ('change', cell, options) */
	          this.onCellChange.call(this, model, arguments[2]);
	          break;
	        case 'remove':
	          /* ('remove', cell, collection, options) */
	          // When a cell is removed from a layer,
	          // ensure it is also removed from the graph.
	          this.onCellRemove.call(this, model, arguments[3]);
	          break;
	      }
	      // Notify the graph about cell events.
	      this.forwardCellEvent.apply(this, arguments);
	      return;
	    }
	    if (model[CELL_COLLECTION_MARKER]) {
	      this.forwardCellCollectionEvent.apply(this, arguments);
	      return;
	    }
	    if (model[GRAPH_LAYER_MARKER]) {
	      this.forwardLayerEvent.apply(this, arguments);
	      return;
	    }
	    if (model[GRAPH_LAYER_COLLECTION_MARKER]) {
	      this.forwardLayerCollectionEvent.apply(this, arguments);
	      return;
	    }
	  }
	  forwardLayerEvent() {
	    // Note: the layer event prefix is `layer:`
	    this.graph.trigger.apply(this.graph, arguments);
	  }
	  forwardCellEvent(eventName, cell) {
	    var _arguments$;
	    // Moving a cell from one layer to another is an internal operation
	    // that should not be exposed at the graph level.
	    // The single `move` event is triggered instead.
	    if ((eventName === 'remove' || eventName === 'add') && (_arguments$ = arguments[3]) !== null && _arguments$ !== void 0 && _arguments$.fromLayer) return;
	    this.graph.trigger.apply(this.graph, arguments);
	  }
	  forwardCellCollectionEvent(eventName) {
	    // Do not forward `layer:remove` or `layer:sort` events to the graph
	    if (eventName !== 'sort') return;
	    // Backwards compatibility:
	    // Trigger 'sort' event for cell collection 'sort' events
	    this.graph.trigger.apply(this.graph, arguments);
	  }
	  forwardLayerCollectionEvent(eventName) {
	    if (eventName === 'reset') {
	      // Currently, there is no need to forward `layers:reset` event.
	      // The graph `fromJSON()` triggers a single `reset` event after
	      // resetting cells, layers and attributes.
	      return;
	    }
	    // Forward layer collection events with `layers:` prefix.
	    // For example `layers:reset` event when the layer collection is reset
	    arguments[0] = 'layers:' + arguments[0];
	    this.graph.trigger.apply(this.graph, arguments);
	  }
	}

	/**
	 * @class CellCollection
	 * @description A CellCollection is a collection of cells which supports z-index management.
	 * Additionally, it facilitates creating cell models from JSON using cellNamespace
	 * and stores a reference to the graph when the cell model has been added.
	 */
	class CellCollection extends Collection {
	  [CELL_COLLECTION_MARKER] = true;
	  initialize(_models, opt) {
	    this.layer = opt.layer;
	  }

	  // Method for checking whether an object should be considered a model for
	  // the purposes of adding to the collection.
	  _isModel(model) {
	    return Boolean(model[CELL_MARKER]);
	  }

	  // Overriding the default `model` method to create cell models
	  // based on their `type` attribute and the `cellNamespace` option.
	  model(attrs, opt) {
	    const namespace = this.cellNamespace;
	    if (!namespace) {
	      throw new Error('dia.CellCollection: cellNamespace is required to instantiate a Cell from JSON.');
	    }
	    const {
	      type
	    } = attrs;

	    // Find the model class based on the `type` attribute in the cell namespace
	    const ModelClass = getByPath(namespace, type, '.');
	    if (!ModelClass) {
	      throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);
	    }
	    return new ModelClass(attrs, opt);
	  }

	  // Override to set graph reference
	  _addReference(model, options) {
	    super._addReference(model, options);

	    // If not in `dry` mode and the model does not have a graph reference yet,
	    // set the reference.
	    if (!options.dry && !model.graph) {
	      model.graph = this.layer.graph;
	    }
	  }

	  // Override to remove graph reference
	  _removeReference(model, options) {
	    super._removeReference(model, options);

	    // If not in `dry` mode and the model has a reference to this exact graph,
	    // remove the reference.
	    // Note: graph reference is removed from the layer after the `remove` event is fired.
	    // Due to this, event handlers can still access the graph during the `remove` event.
	    if (!options.dry && model.graph === this.layer.graph) {
	      model.graph = null;
	    }
	  }

	  // remove graph reference additionally
	  _removeReferenceFast(model, options) {
	    model.off('all', this._onModelEvent, this);
	    if (!options.dry) {
	      // If not in `dry` mode and the model has a reference
	      // to this exact graph/collection, remove the reference.
	      if (this === model.collection) {
	        delete model.collection;
	      }
	      if (model.graph === this.layer.graph) {
	        model.graph = null;
	      }
	    }
	  }

	  // `comparator` makes it easy to sort cells based on their `z` index.
	  comparator(model) {
	    return model.get('z') || 0;
	  }

	  // This method overrides base mvc.Collection implementation
	  // in a way that improves performance of resetting large collections.
	  // For layers specifically, there is an option where we put references
	  // from the main collection in order to improve performance when
	  // there is only one layer
	  reset(models, options) {
	    options = assign({}, {
	      add: true,
	      remove: false,
	      merge: false
	    }, options);
	    for (let i = 0; i < this.models.length; i++) {
	      this._removeReferenceFast(this.models[i], options);
	    }
	    options.previousModels = this.models;
	    this._reset();
	    for (let i = 0; i < models.length; i++) {
	      const model = this._prepareModel(models[i], options);
	      if (model) {
	        this.models.push(model);
	        this._addReference(model, options);
	      }
	    }
	    this.length = this.models.length;
	    const sort = this.comparator && options.sort !== false;
	    if (sort) {
	      this.sort({
	        silent: true
	      });
	    }
	    if (!options.silent) {
	      this.trigger('reset', this, options);
	    }
	    return this.models;
	  }
	  minZIndex() {
	    var _this$first;
	    return ((_this$first = this.first()) === null || _this$first === void 0 ? void 0 : _this$first.get('z')) || 0;
	  }
	  maxZIndex() {
	    var _this$last;
	    return ((_this$last = this.last()) === null || _this$last === void 0 ? void 0 : _this$last.get('z')) || 0;
	  }
	}

	const DEFAULT_GRAPH_LAYER_TYPE = 'GraphLayer';

	/**
	 * @class GraphLayer
	 * @description A GraphLayer is a model representing a single layer in a dia.Graph.
	 */
	class GraphLayer extends Model {
	  [GRAPH_LAYER_MARKER] = true;
	  preinitialize() {
	    // This allows for propagating events from the inner `cellCollection` collection
	    // without any prefix and therefore distinguish them from the events
	    // fired by the GraphLayer model itself.
	    this.eventPrefix = 'layer:';
	  }
	  defaults() {
	    return {
	      type: DEFAULT_GRAPH_LAYER_TYPE
	    };
	  }
	  initialize(attrs, options = {}) {
	    super.initialize(attrs, options);
	    this.cellCollection = new CellCollection([], {
	      layer: this
	    });

	    // Forward all events from the inner `cellCollection` collection
	    this.cellCollection.on('all', this.trigger, this);
	    // Listen to cell changes to manage z-index sorting
	    this.cellCollection.on('change', this.onCellChange, this);
	  }
	  onCellChange(cell, opt) {
	    if (opt.sort === false || !cell.hasChanged('z')) return;
	    this.cellCollection.sort();
	  }

	  /**
	   * @public
	   * @description Returns all cells in this layer.
	   */
	  getCells() {
	    return this.cellCollection.toArray();
	  }
	}

	/**
	 * @class GraphLayerCollection
	 * @description A collection of layers used in dia.Graph. It facilitates creating layers from JSON using layerNamespace.
	 */
	const GraphLayerCollection = Collection.extend({
	  defaultLayerNamespace: {
	    GraphLayer
	  },
	  /**
	   * @override
	   * @description Initializes the collection and sets up the layer and cell namespaces.
	   */
	  initialize: function (_models, options = {}) {
	    const {
	      layerNamespace,
	      cellNamespace,
	      graph
	    } = options;

	    // Initialize the namespace that holds all available layer classes.
	    // Custom namespaces are merged with the default ones.
	    this.layerNamespace = assign({}, this.defaultLayerNamespace, layerNamespace);

	    // Initialize the namespace for all cell model classes, if provided.
	    if (cellNamespace) {
	      this.cellNamespace = cellNamespace;
	    } else {
	      /* eslint-disable no-undef */
	      this.cellNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;
	      /* eslint-enable no-undef */
	    }
	    this.graph = graph;
	  },
	  /**
	   * @override
	   * @description Overrides the default `model` method
	   * to create layer models based on their `type` attribute.
	   */
	  model: function (attrs, opt) {
	    const collection = opt.collection;
	    const namespace = collection.layerNamespace;
	    const {
	      type
	    } = attrs;

	    // Find the model class based on the `type` attribute in the cell namespace
	    const GraphLayerClass = getByPath(namespace, type, '.');
	    if (!GraphLayerClass) {
	      throw new Error(`dia.Graph: Could not find layer constructor for type: '${type}'. Make sure to add the constructor to 'layerNamespace'.`);
	    }
	    return new GraphLayerClass(attrs, opt);
	  },
	  // Override to set graph reference
	  _addReference(layer, options) {
	    Collection.prototype._addReference.call(this, layer, options);

	    // assign graph and cellNamespace references
	    // to the added layer
	    layer.graph = this.graph;
	    layer.cellCollection.cellNamespace = this.cellNamespace;
	  },
	  // Override to remove graph reference
	  _removeReference(layer, options) {
	    Collection.prototype._removeReference.call(this, layer, options);

	    // remove graph and cellNamespace references
	    // from the removed layer
	    layer.graph = null;
	    layer.cellCollection.cellNamespace = null;
	  },
	  /**
	   * @override
	   * @description Overrides the default `_prepareModel` method
	   * to set default layer type if missing.
	   */
	  _prepareModel: function (attrs, options) {
	    if (!attrs[GRAPH_LAYER_MARKER]) {
	      // Add a mandatory `type` attribute if missing
	      if (!attrs.type) {
	        const preparedAttributes = clone$1(attrs);
	        preparedAttributes.type = DEFAULT_GRAPH_LAYER_TYPE;
	        arguments[0] = preparedAttributes;
	      }
	    }
	    return Collection.prototype._prepareModel.apply(this, arguments);
	  },
	  /**
	   * @override
	   * @description Add an assertion to prevent direct resetting of the collection.
	   */
	  reset(models, options) {
	    this._assertInternalCall(options);
	    return Collection.prototype.reset.apply(this, arguments);
	  },
	  /**
	   * @override
	   * @description Add an assertion to prevent direct addition of layers.
	   */
	  add(models, options) {
	    this._assertInternalCall(options);
	    return Collection.prototype.add.apply(this, arguments);
	  },
	  /**
	   * @override
	   * @description Add an assertion to prevent direct removal of layers.
	   */
	  remove(models, options) {
	    this._assertInternalCall(options);
	    return Collection.prototype.remove.apply(this, arguments);
	  },
	  /**
	   * @override
	   * @description Overrides the default `_onModelEvent` method
	   * to distinguish between events coming from different model types.
	   */
	  _onModelEvent(_, model) {
	    if (model && model[CELL_MARKER]) {
	      // Do not filter cell `add` and `remove` events
	      // See `mvc.Collection` for more details
	      this.trigger.apply(this, arguments);
	      return;
	    }

	    // For other events, use the default behavior
	    Collection.prototype._onModelEvent.apply(this, arguments);
	  },
	  /**
	   * @protected
	   * @description Asserts that the collection manipulation
	   * is done via internal graph methods. Otherwise, it throws an error.
	   * This is a temporary measure until layers API is stabilized.
	   */
	  _assertInternalCall(options) {
	    if (options && !options.graph && !options.silent) {
	      throw new Error('dia.GraphLayerCollection: direct manipulation of the collection is not supported, use graph methods instead.');
	    }
	  },
	  /**
	   * @public
	   * @description Inserts a layer before another layer or at the end if `beforeLayerId` is null.
	   */
	  insert(layerInit, beforeLayerId = null, options = {}) {
	    const id = layerInit.id;
	    if (id === beforeLayerId) {
	      // Inserting before itself is a no-op
	      return;
	    }
	    if (beforeLayerId && !this.has(beforeLayerId)) {
	      throw new Error(`dia.GraphLayerCollection: Layer "${beforeLayerId}" does not exist`);
	    }

	    // See if the layer is already in the collection
	    let currentIndex = -1;
	    if (this.has(id)) {
	      currentIndex = this.findIndex(l => l.id === id);
	      if (currentIndex === this.length - 1 && !beforeLayerId) {
	        // The layer is already at the end
	        return;
	      }
	      // Remove the layer from its current position
	      this.remove(id, {
	        silent: true
	      });
	    }

	    // At what index to insert the layer?
	    let insertAt;
	    if (!beforeLayerId) {
	      insertAt = this.length;
	    } else {
	      insertAt = this.findIndex(l => l.id === beforeLayerId);
	    }
	    if (currentIndex !== -1) {
	      // Re-insert the layer at the new position.
	      this.add(layerInit, {
	        at: insertAt,
	        silent: true
	      });
	      // Trigger `sort` event manually
	      // since we are not using collection sorting workflow
	      this.trigger('sort', this, options);
	    } else {
	      // Add to the collection and trigger an event
	      // when new layer has been added
	      this.add(layerInit, {
	        ...options,
	        at: insertAt
	      });
	    }
	  },
	  /**
	   * @public
	   * @description Finds and returns a cell by its id from all layers.
	   */
	  getCell(cellRef) {
	    // TODO: should we create a map of cells for faster lookup?
	    for (const layer of this.models) {
	      const cell = layer.cellCollection.get(cellRef);
	      if (cell) {
	        return cell;
	      }
	    }
	    // Backward compatibility: return undefined if cell is not found
	    return undefined;
	  },
	  /**
	   * @public
	   * @description Returns all cells in all layers in the correct order.
	   */
	  getCells() {
	    const layers = this.models;
	    if (layers.length === 1) {
	      // Single layer:
	      // Fast path, just return the copy of the only layer's cells
	      return layers[0].getCells();
	    }
	    // Multiple layers:
	    // Each layer has its models sorted already, so we can just concatenate
	    // them in the order of layers.
	    const cells = [];
	    for (const layer of layers) {
	      Array.prototype.push.apply(cells, layer.cellCollection.models);
	    }
	    return cells;
	  },
	  /**
	   * @public
	   * @description Removes a cell from its current layer.
	   */
	  removeCell(cell, options = {}) {
	    var _cell$collection;
	    const cellCollection = (_cell$collection = cell.collection) === null || _cell$collection === void 0 || (_cell$collection = _cell$collection.layer) === null || _cell$collection === void 0 ? void 0 : _cell$collection.cellCollection;
	    if (!cellCollection) return;
	    cellCollection.remove(cell, options);
	  },
	  /**
	   * @public
	   * @description Move a cell from its current layer to a target layer.
	   */
	  moveCellBetweenLayers(cell, targetLayerId, options = {}) {
	    var _cell$collection2;
	    const sourceLayer = (_cell$collection2 = cell.collection) === null || _cell$collection2 === void 0 ? void 0 : _cell$collection2.layer;
	    if (!sourceLayer) {
	      throw new Error('dia.GraphLayerCollection: cannot move a cell that is not part of any layer.');
	    }
	    const targetLayer = this.get(targetLayerId);
	    if (!targetLayer) {
	      throw new Error(`dia.GraphLayerCollection: cannot move cell to layer '${targetLayerId}' because such layer does not exist.`);
	    }
	    if (sourceLayer === targetLayer) {
	      // 1. The provided cell is already in the target layer
	      // 2. Implicit default layer vs. explicit default (or vice versa)
	      // No follow-up action needed
	      return;
	    }
	    const moveOptions = {
	      ...options,
	      fromLayer: sourceLayer.id,
	      toLayer: targetLayer.id
	    };
	    // Move the cell between the two layer collections
	    sourceLayer.cellCollection.remove(cell, moveOptions);
	    targetLayer.cellCollection.add(cell, moveOptions);
	    // Trigger a single `move` event to ease distinguishing layer moves
	    // from add/remove operations
	    cell.trigger('move', cell, moveOptions);
	  },
	  /**
	   * @public
	   * @description Adds a cell to the specified layer.
	   */
	  addCellToLayer(cell, layerId, options = {}) {
	    const targetLayer = this.get(layerId);
	    if (!targetLayer) {
	      throw new Error(`dia.GraphLayerCollection: layer "${layerId}" does not exist.`);
	    }
	    const addOptions = {
	      ...options,
	      toLayer: targetLayer.id
	    };
	    // Add the cell to the target layer collection
	    targetLayer.cellCollection.add(cell, addOptions);
	  }
	});
	Object.defineProperty(GraphLayerCollection.prototype, GRAPH_LAYER_COLLECTION_MARKER, {
	  value: true
	});

	/**
	 * @class GraphTopologyIndex
	 * @description Maintains an index of the graph topology (adjacency list)
	 * for fast graph queries.
	 */
	class GraphTopologyIndex extends Listener {
	  constructor(options) {
	    super(options);

	    // Make sure there are no arguments passed to the callbacks.
	    // See the `mvc.Listener` documentation for more details.
	    this.callbackArguments = [];
	    this.layerCollection = options.layerCollection;
	    if (!this.layerCollection) {
	      throw new Error('GraphTopologyIndex: "layerCollection" option is required.');
	    }
	    this.initializeIndex();
	    this.startListening();
	  }

	  /**
	   * @public
	   * @description Start listening to graph and layer collection events
	   * to maintain the topology index.
	   */
	  startListening() {
	    this.listenTo(this.layerCollection.graph, {
	      'add': this._restructureOnAdd,
	      'remove': this._restructureOnRemove,
	      'reset': this._restructureOnReset
	    });
	    // Listening to the collection instead of the graph
	    // to avoid reacting to graph attribute change events
	    // e.g. graph.set('source', ...);
	    this.listenTo(this.layerCollection, {
	      'change:source': this._restructureOnChangeSource,
	      'change:target': this._restructureOnChangeTarget
	    });
	  }

	  /**
	   * @protected
	   * @description Initialize the internal data structures.
	   */
	  initializeIndex() {
	    // Outgoing edges per node. Note that we use a hash-table for the list
	    // of outgoing edges for a faster lookup.
	    // [nodeId] -> Object [edgeId] -> true
	    this._out = {};
	    // Ingoing edges per node.
	    // [nodeId] -> Object [edgeId] -> true
	    this._in = {};
	    // `_nodes` is useful for quick lookup of all the elements in the graph, without
	    // having to go through the whole cells array.
	    // [node ID] -> true
	    this._nodes = {};
	    // `_edges` is useful for quick lookup of all the links in the graph, without
	    // having to go through the whole cells array.
	    // [edgeId] -> true
	    this._edges = {};
	  }

	  /**
	   * @protected
	   * @description Restructure the topology index on graph reset.
	   * E.g. when fromJSON or resetCells is called.
	   */
	  _restructureOnReset() {
	    this.initializeIndex();
	    this.layerCollection.getCells().forEach(this._restructureOnAdd, this);
	  }

	  /**
	   * @protected
	   * @description Restructure the topology index on cell addition.
	   * @param {dia.Cell} cell - The cell being added.
	   */
	  _restructureOnAdd(cell) {
	    if (cell.isLink()) {
	      this._edges[cell.id] = true;
	      const {
	        source,
	        target
	      } = cell.attributes;
	      if (source.id) {
	        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;
	      }
	      if (target.id) {
	        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;
	      }
	    } else {
	      this._nodes[cell.id] = true;
	    }
	  }

	  /**
	   * @protected
	   * @description Restructure the topology index on cell removal.
	   * @param {dia.Cell} cell - The cell being removed.
	   */
	  _restructureOnRemove(cell) {
	    if (cell.isLink()) {
	      delete this._edges[cell.id];
	      const {
	        source,
	        target
	      } = cell.attributes;
	      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {
	        delete this._out[source.id][cell.id];
	      }
	      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {
	        delete this._in[target.id][cell.id];
	      }
	    } else {
	      delete this._nodes[cell.id];
	    }
	  }

	  /**
	   * @protected
	   * @description Restructure the topology index on link source change.
	   * @param {dia.Link} link - The link being changed.
	   */
	  _restructureOnChangeSource(link) {
	    const prevSource = link.previous('source');
	    if (prevSource.id && this._out[prevSource.id]) {
	      delete this._out[prevSource.id][link.id];
	    }
	    const source = link.attributes.source;
	    if (source.id) {
	      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;
	    }
	  }

	  /**
	   * @protected
	   * @description Restructure the topology index on link target change.
	   * @param {dia.Link} link - The link being changed.
	   */
	  _restructureOnChangeTarget(link) {
	    const prevTarget = link.previous('target');
	    if (prevTarget.id && this._in[prevTarget.id]) {
	      delete this._in[prevTarget.id][link.id];
	    }
	    const target = link.get('target');
	    if (target.id) {
	      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;
	    }
	  }

	  /**
	   * @public
	   * @description Get all outbound edges for the node. Time complexity: O(1).
	   * @param {string} nodeId - The id of the node.
	   * @returns {Object} - An object of the form: [edgeId] -> true.
	   */
	  getOutboundEdges(nodeId) {
	    return this._out[nodeId] || {};
	  }

	  /**
	   * @public
	   * @description Get all inbound edges for the node. Time complexity: O(1).
	   * @param {string} nodeId - The id of the node.
	   * @returns {Object} - An object of the form: [edgeId] -> true.
	   */
	  getInboundEdges(nodeId) {
	    return this._in[nodeId] || {};
	  }

	  /**
	   * @public
	   * @description Get all sink nodes (leafs) in the graph. Time complexity: O(|V|).
	   * @returns {string[]} - Array of node ids.
	   */
	  getSinkNodes() {
	    const sinks = [];
	    for (const nodeId in this._nodes) {
	      if (!this._out[nodeId] || isEmpty(this._out[nodeId])) {
	        sinks.push(nodeId);
	      }
	    }
	    return sinks;
	  }

	  /**
	   * @public
	   * @description Get all source nodes (roots) in the graph. Time complexity: O(|V|).
	   * @returns {string[]} - Array of node ids.
	   */
	  getSourceNodes() {
	    const sources = [];
	    for (const nodeId in this._nodes) {
	      if (!this._in[nodeId] || isEmpty(this._in[nodeId])) {
	        sources.push(nodeId);
	      }
	    }
	    return sources;
	  }

	  /**
	   * @public
	   * @description Return `true` if `nodeId` is a source node (root). Time complexity: O(1).
	   * @param {string} nodeId - The id of the node to check.
	   * @returns {boolean}
	   */
	  isSourceNode(nodeId) {
	    return !this._in[nodeId] || isEmpty(this._in[nodeId]);
	  }

	  /**
	   * @public
	   * @description Return `true` if `nodeId` is a sink node (leaf). Time complexity: O(1).
	   * @param {string} nodeId - The id of the node to check.
	   * @returns {boolean}
	   */
	  isSinkNode(nodeId) {
	    return !this._out[nodeId] || isEmpty(this._out[nodeId]);
	  }
	}

	// The ID of the default graph layer.
	const DEFAULT_LAYER_ID = 'cells';
	const Graph = Model.extend({
	  /**
	   * @todo Remove in v5.0.0
	   * @description In legacy mode, the information about layers is not
	   * exported into JSON.
	   */
	  legacyMode: true,
	  /**
	   * @protected
	   * @description The ID of the default layer.
	   */
	  defaultLayerId: DEFAULT_LAYER_ID,
	  initialize: function (attrs, options = {}) {
	    const layerCollection = this.layerCollection = new GraphLayerCollection([], {
	      layerNamespace: options.layerNamespace,
	      cellNamespace: options.cellNamespace,
	      graph: this,
	      /** @deprecated use cellNamespace instead */
	      model: options.cellModel
	    });

	    // The default setup includes a single default layer.
	    layerCollection.add({
	      id: DEFAULT_LAYER_ID
	    }, {
	      graph: this.cid
	    });

	    /**
	     * @todo Remove in v5.0.0
	     * @description Retain legacy 'cells' collection in attributes for backward compatibility.
	     * Applicable only when the default layer setup is used.
	     */
	    this.attributes.cells = this.getLayer(DEFAULT_LAYER_ID).cellCollection;

	    // Controller that manages communication between the graph and its layers.
	    this.layersController = new GraphLayersController({
	      graph: this
	    });

	    // `Graph` keeps an internal data structure (an adjacency list)
	    // for fast graph queries. All changes that affect the structure of the graph
	    // must be reflected in the `al` object. This object provides fast answers to
	    // questions such as "what are the neighbors of this node" or "what
	    // are the sibling links of this link".
	    this.topologyIndex = new GraphTopologyIndex({
	      layerCollection
	    });
	    this._batches = {};
	  },
	  toJSON: function (opt = {}) {
	    const {
	      layerCollection
	    } = this;
	    // Get the graph model attributes as a base JSON.
	    const json = Model.prototype.toJSON.apply(this, arguments);

	    // Add `cells` array holding all the cells in the graph.
	    json.cells = this.getCells().map(cell => cell.toJSON(opt.cellAttributes));
	    if (this.legacyMode) {
	      // Backwards compatibility for legacy setup
	      // with single default layer 'cells'.
	      // In this case, we do not need to export layers.
	      return json;
	    }

	    // Add `layers` array holding all the layers in the graph.
	    json.layers = layerCollection.toJSON();

	    // Add `defaultLayer` property indicating the default layer ID.
	    json.defaultLayer = this.defaultLayerId;
	    return json;
	  },
	  fromJSON: function (json, opt) {
	    const {
	      cells,
	      layers,
	      defaultLayer,
	      ...attributes
	    } = json;
	    if (!cells) {
	      throw new Error('Graph JSON must contain cells array.');
	    }

	    // The `fromJSON` should trigger a single 'reset' event at the end.
	    // Set all attributes silently for now.
	    this.set(attributes, {
	      silent: true
	    });
	    if (layers) {
	      // Reset the layers collection
	      // (`layers:reset` is not forwarded to the graph).
	      this._resetLayers(layers, defaultLayer, opt);
	    }
	    if (cells) {
	      // Reset the cells collection and trigger the 'reset' event.
	      this.resetCells(cells, opt);
	    }
	    return this;
	  },
	  /** @deprecated  */
	  clear: function (opt) {
	    opt = assign({}, opt, {
	      clear: true
	    });
	    const cells = this.getCells();
	    if (cells.length === 0) return this;
	    this.startBatch('clear', opt);
	    const sortedCells = sortBy(cells, cell => {
	      return cell.isLink() ? 1 : 2;
	    });
	    do {
	      // Remove all the cells one by one.
	      // Note that all the links are removed first, so it's
	      // safe to remove the elements without removing the connected
	      // links first.
	      this.layerCollection.removeCell(sortedCells.shift(), opt);
	    } while (sortedCells.length > 0);
	    this.stopBatch('clear');
	    return this;
	  },
	  _prepareCell: function (cellInit, opt) {
	    let cellAttributes;
	    if (cellInit[CELL_MARKER]) {
	      cellAttributes = cellInit.attributes;
	    } else {
	      cellAttributes = cellInit;
	    }
	    if (!isString(cellAttributes.type)) {
	      throw new TypeError('dia.Graph: cell type must be a string.');
	    }

	    // Backward compatibility: prior v4.2, z-index was not set during reset.
	    if (opt && opt.ensureZIndex) {
	      if (cellAttributes.z === undefined) {
	        const layerId = cellAttributes[config$3.layerAttribute] || this.defaultLayerId;
	        const zIndex = this.maxZIndex(layerId) + 1;
	        if (cellInit[CELL_MARKER]) {
	          // Set with event in case there is a listener
	          // directly on the cell instance
	          // (the cell is not part of graph yet)
	          cellInit.set('z', zIndex, opt);
	        } else {
	          cellAttributes.z = zIndex;
	        }
	      }
	    }
	    return cellInit;
	  },
	  minZIndex: function (layerId = this.defaultLayerId) {
	    const layer = this.getLayer(layerId);
	    return layer.cellCollection.minZIndex();
	  },
	  maxZIndex: function (layerId = this.defaultLayerId) {
	    const layer = this.getLayer(layerId);
	    return layer.cellCollection.maxZIndex();
	  },
	  addCell: function (cellInit, options) {
	    if (Array.isArray(cellInit)) {
	      return this.addCells(cellInit, options);
	    }
	    this._prepareCell(cellInit, {
	      ...options,
	      ensureZIndex: true
	    });
	    this.layerCollection.addCellToLayer(cellInit, this.getCellLayerId(cellInit), options);
	    return this;
	  },
	  addCells: function (cells, opt) {
	    if (cells.length === 0) return this;
	    cells = flattenDeep(cells);
	    opt.maxPosition = opt.position = cells.length - 1;
	    this.startBatch('add', opt);
	    cells.forEach(cell => {
	      this.addCell(cell, opt);
	      opt.position--;
	    });
	    this.stopBatch('add', opt);
	    return this;
	  },
	  /**
	   * @public
	   * @description Reset the cells in the graph.
	   * Useful for bulk operations and optimizations.
	   */
	  resetCells: function (cellInits, options) {
	    const {
	      layerCollection
	    } = this;
	    // Note: `cellInits` is always an array and `options` is always an object.
	    // See `wrappers.cells` at the end of this file.

	    // When resetting cells, do not set z-index if not provided.
	    const prepareOptions = {
	      ...options,
	      ensureZIndex: false
	    };

	    // Initialize a map of layer IDs to arrays of cells
	    const layerCellsMap = layerCollection.reduce((map, layer) => {
	      map[layer.id] = [];
	      return map;
	    }, {});

	    // Distribute cells into their respective layers
	    for (let i = 0; i < cellInits.length; i++) {
	      const cellInit = cellInits[i];
	      const layerId = this.getCellLayerId(cellInit);
	      if (layerId in layerCellsMap) {
	        this._prepareCell(cellInit, prepareOptions);
	        layerCellsMap[layerId].push(cellInit);
	      } else {
	        throw new Error(`dia.Graph: Layer "${layerId}" does not exist.`);
	      }
	    }

	    // Reset each layer's cell collection with the corresponding cells.
	    layerCollection.each(layer => {
	      layer.cellCollection.reset(layerCellsMap[layer.id], options);
	    });

	    // Trigger a single `reset` event on the graph
	    // (while multiple `reset` events are triggered on layers).
	    // Backwards compatibility: use default layer collection
	    // The `collection` parameter is retained for backwards compatibility,
	    // and it is subject to removal in future releases.
	    this.trigger('reset', this.getDefaultLayer().cellCollection, options);
	    return this;
	  },
	  /**
	   * @public
	   * @description Get the layer ID in which the cell resides.
	   * Cells without an explicit layer are assigned to the default layer.
	   * @param {dia.Cell | Object} cellInit - Cell model or attributes.
	   * @returns {string} - The layer ID.
	   */
	  getCellLayerId: function (cellInit) {
	    if (!cellInit) {
	      throw new Error('dia.Graph: No cell provided.');
	    }
	    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;
	    return cellAttributes[config$3.layerAttribute] || this.defaultLayerId;
	  },
	  /**
	   * @protected
	   * @description Reset the layers in the graph.
	   * It assumes the existing cells have been removed beforehand
	   * or can be discarded.
	   */
	  _resetLayers: function (layers, defaultLayerId, options = {}) {
	    if (!Array.isArray(layers) || layers.length === 0) {
	      throw new Error('dia.Graph: At least one layer must be defined.');
	    }

	    // Resetting layers disables legacy mode
	    this.legacyMode = false;
	    this.layerCollection.reset(layers, {
	      ...options,
	      graph: this.cid
	    });

	    // If no default layer is specified, use the first layer as default
	    if (defaultLayerId) {
	      // The default layer must be one of the defined layers
	      if (!this.hasLayer(defaultLayerId)) {
	        throw new Error(`dia.Graph: default layer "${defaultLayerId}" does not exist.`);
	      }
	      this.defaultLayerId = defaultLayerId;
	    } else {
	      this.defaultLayerId = this.layerCollection.at(0).id;
	    }
	    return this;
	  },
	  /**
	   * @public
	   * @description Remove multiple cells from the graph.
	   * @param {Array<dia.Cell | dia.Cell.ID>} cellRefs - Array of cell references (models or IDs) to remove.
	   * @param {Object} [options] - Removal options. See {@link dia.Graph#removeCell}.
	   */
	  removeCells: function (cellRefs, options) {
	    if (!cellRefs.length) return this;
	    // Remove multiple cells in a single batch
	    this.startBatch('remove');
	    for (const cellRef of cellRefs) {
	      if (!cellRef) continue;
	      let cell;
	      if (cellRef[CELL_MARKER]) {
	        cell = cellRef;
	      } else {
	        cell = this.getCell(cellRef);
	        if (!cell) {
	          // The cell might have been already removed (embedded cell, connected link, etc.)
	          continue;
	        }
	      }
	      this.layerCollection.removeCell(cell, options);
	    }
	    this.stopBatch('remove');
	    return this;
	  },
	  /**
	   * @protected
	   * @description Replace an existing cell with a new cell.
	   */
	  _replaceCell: function (currentCell, newCellInit, opt = {}) {
	    const batchName = 'replace-cell';
	    const replaceOptions = {
	      ...opt,
	      replace: true
	    };
	    this.startBatch(batchName, opt);
	    // 1. Remove the cell without removing connected links or embedded cells.
	    this.layerCollection.removeCell(currentCell, replaceOptions);
	    const newCellInitAttributes = newCellInit[CELL_MARKER] ? newCellInit.attributes : newCellInit;
	    // 2. Combine the current cell attributes with the new cell attributes
	    const replacementCellAttributes = Object.assign({}, currentCell.attributes, newCellInitAttributes);
	    let replacement;
	    if (newCellInit[CELL_MARKER]) {
	      // If the new cell is a model, set the merged attributes on the model
	      newCellInit.set(replacementCellAttributes, replaceOptions);
	      replacement = newCellInit;
	    } else {
	      replacement = replacementCellAttributes;
	    }

	    // 3. Add the replacement cell
	    this.addCell(replacement, replaceOptions);
	    this.stopBatch(batchName);
	  },
	  /**
	   * @protected
	   * @description Synchronize a single graph cell with the provided cell (model or attributes).
	   * If the cell with the same `id` exists, it is updated. If the cell does not exist, it is added.
	   * If the existing cell type is different from the incoming cell type, the existing cell is replaced.
	   */
	  _syncCell: function (cellInit, opt = {}) {
	    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;
	    const currentCell = this.getCell(cellInit.id);
	    if (currentCell) {
	      // `cellInit` is either a model or attributes object
	      if ('type' in cellAttributes && currentCell.get('type') !== cellAttributes.type) {
	        // Replace the cell if the type has changed
	        this._replaceCell(currentCell, cellInit, opt);
	      } else {
	        // Update existing cell
	        // Note: the existing cell attributes are not removed,
	        // if they're missing in `cellAttributes`.
	        currentCell.set(cellAttributes, opt);
	      }
	    } else {
	      // The cell does not exist yet, add it
	      this.addCell(cellInit, opt);
	    }
	  },
	  /**
	   * @public
	   * @description Synchronize the graph cells with the provided array of cells (models or attributes).
	   */
	  syncCells: function (cellInits, opt = {}) {
	    const batchName = 'sync-cells';
	    const {
	      remove = false,
	      ...setOpt
	    } = opt;
	    let currentCells, newCellsMap;
	    if (remove) {
	      // We need to track existing cells to remove the missing ones later
	      currentCells = this.getCells();
	      newCellsMap = new Map();
	    }

	    // Observe changes to the graph cells
	    let changeObserver, changedLayers;
	    const shouldSort = opt.sort !== false;
	    if (shouldSort) {
	      changeObserver = new Listener();
	      changedLayers = new Set();
	      changeObserver.listenTo(this, {
	        'add': cell => {
	          changedLayers.add(this.getCellLayerId(cell));
	        },
	        'change': cell => {
	          if (cell.hasChanged(config$3.layerAttribute) || cell.hasChanged('z')) {
	            changedLayers.add(this.getCellLayerId(cell));
	          }
	        }
	      });
	    }
	    this.startBatch(batchName, opt);

	    // Prevent multiple sorts during sync
	    setOpt.sort = false;

	    // Add or update incoming cells
	    for (const cellInit of cellInits) {
	      if (remove) {
	        // only track existence
	        newCellsMap.set(cellInit.id, true);
	      }
	      this._syncCell(cellInit, setOpt);
	    }
	    if (remove) {
	      // Remove cells not present in the incoming array
	      for (const cell of currentCells) {
	        if (!newCellsMap.has(cell.id)) {
	          this.layerCollection.removeCell(cell, setOpt);
	        }
	      }
	    }
	    if (shouldSort) {
	      // Sort layers that had changes affecting z-index or layer
	      changeObserver.stopListening();
	      for (const layerId of changedLayers) {
	        this.getLayer(layerId).cellCollection.sort(opt);
	      }
	    }
	    this.stopBatch(batchName);
	  },
	  /**
	   * @public
	   * @description Remove a cell from the graph.
	   * @param {dia.Cell} cell
	   * @param {Object} [options]
	   * @param {boolean} [options.disconnectLinks=false] - If `true`, the connected links are
	   * disconnected instead of removed.
	   * @param {boolean} [options.clear=false] - If `true`, the connected links
	   * are kept. @internal
	   * @param {boolean} [options.replace=false] - If `true`, the connected links and
	   * embedded cells are kept. @internal
	   * @throws Will throw an error if no cell is provided
	   * @throws Will throw an error if the ID of the cell to remove
	   * does not exist in the graph
	   **/
	  removeCell: function (cellRef, options) {
	    if (!cellRef) {
	      throw new Error('dia.Graph: no cell provided.');
	    }
	    const cell = cellRef[CELL_MARKER] ? cellRef : this.getCell(cellRef);
	    if (!cell) {
	      throw new Error('dia.Graph: cell to remove does not exist in the graph.');
	    }
	    if (cell.graph !== this) return;
	    this.startBatch('remove');
	    cell.collection.remove(cell, options);
	    this.stopBatch('remove');
	  },
	  transferCellEmbeds: function (sourceCell, targetCell, opt = {}) {
	    const batchName = 'transfer-embeds';
	    this.startBatch(batchName);

	    // Embed children of the source cell in the target cell.
	    const children = sourceCell.getEmbeddedCells();
	    targetCell.embed(children, {
	      ...opt,
	      reparent: true
	    });
	    this.stopBatch(batchName);
	  },
	  transferCellConnectedLinks: function (sourceCell, targetCell, opt = {}) {
	    const batchName = 'transfer-connected-links';
	    this.startBatch(batchName);

	    // Reconnect all the links connected to the old cell to the new cell.
	    const connectedLinks = this.getConnectedLinks(sourceCell, opt);
	    connectedLinks.forEach(link => {
	      if (link.getSourceCell() === sourceCell) {
	        link.prop(['source', 'id'], targetCell.id, opt);
	      }
	      if (link.getTargetCell() === sourceCell) {
	        link.prop(['target', 'id'], targetCell.id, opt);
	      }
	    });
	    this.stopBatch(batchName);
	  },
	  /**
	   * @private
	   * Helper method for addLayer and moveLayer methods
	   */
	  _getBeforeLayerIdFromOptions(options, layer = null) {
	    let {
	      before = null,
	      index
	    } = options;
	    if (before && index !== undefined) {
	      throw new Error('dia.Graph: Options "before" and "index" are mutually exclusive.');
	    }
	    let computedBefore;
	    if (index !== undefined) {
	      const layersArray = this.getLayers();
	      if (index >= layersArray.length) {
	        // If index is greater than the number of layers,
	        // return before as null (move to the end).
	        computedBefore = null;
	      } else if (index < 0) {
	        // If index is negative, move to the beginning.
	        computedBefore = layersArray[0].id;
	      } else {
	        var _layersArray$index;
	        const originalIndex = layersArray.indexOf(layer);
	        if (originalIndex !== -1 && index > originalIndex) {
	          // If moving a layer upwards in the stack, we need to adjust the index
	          // to account for the layer being removed from its original position.
	          index += 1;
	        }
	        // Otherwise, get the layer ID at the specified index.
	        computedBefore = ((_layersArray$index = layersArray[index]) === null || _layersArray$index === void 0 ? void 0 : _layersArray$index.id) || null;
	      }
	    } else {
	      computedBefore = before;
	    }
	    return computedBefore;
	  },
	  /**
	   * @public
	   * Adds a new layer to the graph.
	   * @param {GraphLayer | GraphLayerJSON} layerInit
	   * @param {*} options
	   * @param {string | null} [options.before] - ID of the layer
	   * before which to insert the new layer. If `null`, the layer is added at the end.
	   * @param {number} [options.index] - Zero-based index to which to add the layer.
	   * @throws Will throw an error if the layer to add is invalid
	   * @throws Will throw an error if a layer with the same ID already exists
	   * @throws Will throw if `before` reference is invalid
	   */
	  addLayer(layerInit, options = {}) {
	    if (!layerInit || !layerInit.id) {
	      throw new Error('dia.Graph: Layer to add is invalid.');
	    }
	    if (this.hasLayer(layerInit.id)) {
	      throw new Error(`dia.Graph: Layer "${layerInit.id}" already exists.`);
	    }
	    const {
	      before = null,
	      index,
	      ...insertOptions
	    } = options;
	    insertOptions.graph = this.cid;

	    // Adding a new layer disables legacy mode
	    this.legacyMode = false;
	    const beforeId = this._getBeforeLayerIdFromOptions({
	      before,
	      index
	    });
	    this.layerCollection.insert(layerInit, beforeId, insertOptions);
	  },
	  /**
	   * @public
	   * Moves an existing layer to a new position in the layer stack.
	   * @param {string | GraphLayer} layerRef - ID or reference of the layer to move.
	   * @param {*} options
	   * @param {string | null} [options.before] - ID of the layer
	   * before which to insert the moved layer. If `null`, the layer is moved to the end.
	   * @param {number} [options.index] - Zero-based index to which to move the layer.
	   * @throws Will throw an error if the layer to move does not exist
	   * @throws Will throw an error if `before` reference is invalid
	   * @throws Will throw an error if both `before` and `index` options are provided
	   */
	  moveLayer(layerRef, options = {}) {
	    if (!layerRef || !this.hasLayer(layerRef)) {
	      throw new Error('dia.Graph: Layer to move does not exist.');
	    }
	    const layer = this.getLayer(layerRef);
	    const {
	      before = null,
	      index,
	      ...insertOptions
	    } = options;
	    insertOptions.graph = this.cid;

	    // Moving a layer disables legacy mode
	    this.legacyMode = false;
	    const beforeId = this._getBeforeLayerIdFromOptions({
	      before,
	      index
	    }, layer);
	    this.layerCollection.insert(layer, beforeId, insertOptions);
	  },
	  /**
	   * @public
	   * Removes an existing layer from the graph.
	   * @param {string | GraphLayer} layerRef - ID or reference of the layer to remove.
	   * @param {*} options
	   * @throws Will throw an error if no layer is provided
	   * @throws Will throw an error if the layer to remove does not exist
	   */
	  removeLayer(layerRef, options = {}) {
	    if (!layerRef) {
	      throw new Error('dia.Graph: No layer provided.');
	    }

	    // The layer must exist
	    const layerId = layerRef.id ? layerRef.id : layerRef;
	    const layer = this.getLayer(layerId);

	    // Prevent removing the default layer
	    // Note: if there is only one layer, it is also the default layer.
	    const {
	      id: defaultLayerId
	    } = this.getDefaultLayer();
	    if (layerId === defaultLayerId) {
	      throw new Error('dia.Graph: default layer cannot be removed.');
	    }

	    // A layer with cells cannot be removed
	    if (layer.cellCollection.length > 0) {
	      throw new Error(`dia.Graph: Layer "${layerId}" cannot be removed because it is not empty.`);
	    }
	    this.layerCollection.remove(layerId, {
	      ...options,
	      graph: this.cid
	    });
	  },
	  getDefaultLayer() {
	    return this.layerCollection.get(this.defaultLayerId);
	  },
	  setDefaultLayer(layerRef, options = {}) {
	    if (!layerRef) {
	      throw new Error('dia.Graph: No default layer ID provided.');
	    }

	    // Make sure the layer exists
	    const defaultLayerId = layerRef.id ? layerRef.id : layerRef;
	    const defaultLayer = this.getLayer(defaultLayerId);

	    // If the default layer is not changing, do nothing
	    const currentDefaultLayerId = this.defaultLayerId;
	    if (defaultLayerId === currentDefaultLayerId) {
	      // The default layer stays the same
	      return;
	    }

	    // Get all cells that belong to the current default layer implicitly
	    const implicitLayerCells = this.getImplicitLayerCells();

	    // Set the new default layer ID
	    this.defaultLayerId = defaultLayerId;
	    const batchName = 'default-layer-change';
	    this.startBatch(batchName, options);
	    if (implicitLayerCells.length > 0) {
	      // Reassign any cells lacking an explicit layer to the new default layer.
	      // Do not sort yet, wait until all cells are moved.
	      const moveOptions = {
	        ...options,
	        sort: false
	      };
	      for (const cell of implicitLayerCells) {
	        this.layerCollection.moveCellBetweenLayers(cell, defaultLayerId, moveOptions);
	      }
	      // Now sort the new default layer
	      if (options.sort !== false) {
	        defaultLayer.cellCollection.sort(options);
	      }
	    }

	    // Pretend to trigger the event on the layer itself.
	    // It will bubble up as `layer:default` event on the graph.
	    defaultLayer.trigger(defaultLayer.eventPrefix + 'default', defaultLayer, {
	      ...options,
	      previousDefaultLayerId: currentDefaultLayerId
	    });
	    this.stopBatch(batchName, options);
	  },
	  /**
	   * @protected
	   * @description Get all cells that do not have an explicit layer assigned.
	   * These cells belong to the default layer implicitly.
	   * @return {Array<dia.Cell>} Array of cells without an explicit layer.
	   */
	  getImplicitLayerCells() {
	    return this.getDefaultLayer().cellCollection.filter(cell => {
	      return cell.get(config$3.layerAttribute) == null;
	    });
	  },
	  getLayer(layerId) {
	    if (!this.hasLayer(layerId)) {
	      throw new Error(`dia.Graph: Layer "${layerId}" does not exist.`);
	    }
	    return this.layerCollection.get(layerId);
	  },
	  hasLayer(layerRef) {
	    return this.layerCollection.has(layerRef);
	  },
	  getLayers() {
	    return this.layerCollection.toArray();
	  },
	  getCell: function (cellRef) {
	    return this.layerCollection.getCell(cellRef);
	  },
	  getCells: function () {
	    return this.layerCollection.getCells();
	  },
	  getElements: function () {
	    return this.getCells().filter(cell => cell.isElement());
	  },
	  getLinks: function () {
	    return this.getCells().filter(cell => cell.isLink());
	  },
	  getFirstCell: function (layerId) {
	    let layer;
	    if (!layerId) {
	      // Get the first cell from the bottom-most layer
	      layer = this.getLayers().at(0);
	    } else {
	      layer = this.getLayer(layerId);
	    }
	    return layer.cellCollection.models.at(0);
	  },
	  getLastCell: function (layerId) {
	    let layer;
	    if (!layerId) {
	      // Get the last cell from the top-most layer
	      layer = this.getLayers().at(-1);
	    } else {
	      layer = this.getLayer(layerId);
	    }
	    return layer.cellCollection.models.at(-1);
	  },
	  // Get all inbound and outbound links connected to the cell `model`.
	  getConnectedLinks: function (model, opt) {
	    opt = opt || {};
	    var indirect = opt.indirect;
	    var inbound = opt.inbound;
	    var outbound = opt.outbound;
	    if (inbound === undefined && outbound === undefined) {
	      inbound = outbound = true;
	    }

	    // the final array of connected link models
	    var links = [];
	    // a hash table of connected edges of the form: [edgeId] -> true
	    // used for quick lookups to check if we already added a link
	    var edges = {};
	    if (outbound) {
	      addOutbounds(this, model);
	    }
	    if (inbound) {
	      addInbounds(this, model);
	    }
	    function addOutbounds(graph, model) {
	      forIn(graph.topologyIndex.getOutboundEdges(model.id), function (_, edge) {
	        // skip links that were already added
	        // (those must be self-loop links)
	        // (because they are inbound and outbound edges of the same two elements)
	        if (edges[edge]) return;
	        var link = graph.getCell(edge);
	        if (!link) return;
	        links.push(link);
	        edges[edge] = true;
	        if (indirect) {
	          if (inbound) addInbounds(graph, link);
	          if (outbound) addOutbounds(graph, link);
	        }
	      }.bind(graph));
	      if (indirect && model.isLink()) {
	        var outCell = model.getTargetCell();
	        if (outCell && outCell.isLink()) {
	          if (!edges[outCell.id]) {
	            links.push(outCell);
	            addOutbounds(graph, outCell);
	          }
	        }
	      }
	    }
	    function addInbounds(graph, model) {
	      forIn(graph.topologyIndex.getInboundEdges(model.id), function (_, edge) {
	        // skip links that were already added
	        // (those must be self-loop links)
	        // (because they are inbound and outbound edges of the same two elements)
	        if (edges[edge]) return;
	        var link = graph.getCell(edge);
	        if (!link) return;
	        links.push(link);
	        edges[edge] = true;
	        if (indirect) {
	          if (inbound) addInbounds(graph, link);
	          if (outbound) addOutbounds(graph, link);
	        }
	      }.bind(graph));
	      if (indirect && model.isLink()) {
	        var inCell = model.getSourceCell();
	        if (inCell && inCell.isLink()) {
	          if (!edges[inCell.id]) {
	            links.push(inCell);
	            addInbounds(graph, inCell);
	          }
	        }
	      }
	    }

	    // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells
	    if (opt.deep) {
	      var embeddedCells = model.getEmbeddedCells({
	        deep: true
	      });

	      // in the first round, we collect all the embedded elements
	      var embeddedElements = {};
	      embeddedCells.forEach(function (cell) {
	        if (cell.isElement()) {
	          embeddedElements[cell.id] = true;
	        }
	      });
	      embeddedCells.forEach(function (cell) {
	        if (cell.isLink()) return;
	        if (outbound) {
	          forIn(this.topologyIndex.getOutboundEdges(cell.id), function (exists, edge) {
	            if (!edges[edge]) {
	              var edgeCell = this.getCell(edge);
	              var {
	                source,
	                target
	              } = edgeCell.attributes;
	              var sourceId = source.id;
	              var targetId = target.id;

	              // if `includeEnclosed` option is falsy, skip enclosed links
	              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
	                return;
	              }
	              links.push(this.getCell(edge));
	              edges[edge] = true;
	            }
	          }.bind(this));
	        }
	        if (inbound) {
	          forIn(this.topologyIndex.getInboundEdges(cell.id), function (exists, edge) {
	            if (!edges[edge]) {
	              var edgeCell = this.getCell(edge);
	              var {
	                source,
	                target
	              } = edgeCell.attributes;
	              var sourceId = source.id;
	              var targetId = target.id;

	              // if `includeEnclosed` option is falsy, skip enclosed links
	              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
	                return;
	              }
	              links.push(this.getCell(edge));
	              edges[edge] = true;
	            }
	          }.bind(this));
	        }
	      }, this);
	    }
	    return links;
	  },
	  getNeighbors: function (model, opt) {
	    opt || (opt = {});
	    var inbound = opt.inbound;
	    var outbound = opt.outbound;
	    if (inbound === undefined && outbound === undefined) {
	      inbound = outbound = true;
	    }
	    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {
	      var {
	        source,
	        target
	      } = link.attributes;
	      var loop = link.hasLoop(opt);

	      // Discard if it is a point, or if the neighbor was already added.
	      if (inbound && has(source, 'id') && !res[source.id]) {
	        var sourceElement = this.getCell(source.id);
	        if (sourceElement.isElement()) {
	          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {
	            res[source.id] = sourceElement;
	          }
	        }
	      }

	      // Discard if it is a point, or if the neighbor was already added.
	      if (outbound && has(target, 'id') && !res[target.id]) {
	        var targetElement = this.getCell(target.id);
	        if (targetElement.isElement()) {
	          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {
	            res[target.id] = targetElement;
	          }
	        }
	      }
	      return res;
	    }.bind(this), {});
	    if (model.isLink()) {
	      if (inbound) {
	        var sourceCell = model.getSourceCell();
	        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {
	          neighbors[sourceCell.id] = sourceCell;
	        }
	      }
	      if (outbound) {
	        var targetCell = model.getTargetCell();
	        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {
	          neighbors[targetCell.id] = targetCell;
	        }
	      }
	    }
	    return toArray$1(neighbors);
	  },
	  getCommonAncestor: function /* cells */
	  () {
	    var cellsAncestors = Array.from(arguments).map(function (cell) {
	      var ancestors = [];
	      var parentId = cell.get('parent');
	      while (parentId) {
	        ancestors.push(parentId);
	        parentId = this.getCell(parentId).get('parent');
	      }
	      return ancestors;
	    }, this);
	    cellsAncestors = cellsAncestors.sort(function (a, b) {
	      return a.length - b.length;
	    });
	    var commonAncestor = toArray$1(cellsAncestors.shift()).find(function (ancestor) {
	      return cellsAncestors.every(function (cellAncestors) {
	        return cellAncestors.includes(ancestor);
	      });
	    });
	    return this.getCell(commonAncestor);
	  },
	  // Find the whole branch starting at `element`.
	  // If `opt.deep` is `true`, take into account embedded elements too.
	  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
	  getSuccessors: function (element, opt) {
	    opt = opt || {};
	    var res = [];
	    // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.
	    this.search(element, function (el) {
	      if (el !== element) {
	        res.push(el);
	      }
	    }, assign({}, opt, {
	      outbound: true
	    }));
	    return res;
	  },
	  cloneCells: cloneCells,
	  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).
	  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.
	  // Return a map of the form: [original cell ID] -> [clone].
	  cloneSubgraph: function (cells, opt) {
	    var subgraph = this.getSubgraph(cells, opt);
	    return this.cloneCells(subgraph);
	  },
	  // Return `cells` and all the connected links that connect cells in the `cells` array.
	  // If `opt.deep` is `true`, return all the cells including all their embedded cells
	  // and all the links that connect any of the returned cells.
	  // For example, for a single shallow element, the result is that very same element.
	  // For two elements connected with a link: `A --- L ---> B`, the result for
	  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.
	  getSubgraph: function (cells, opt) {
	    opt = opt || {};
	    var subgraph = [];
	    // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.
	    var cellMap = {};
	    var elements = [];
	    var links = [];
	    toArray$1(cells).forEach(function (cell) {
	      if (!cellMap[cell.id]) {
	        subgraph.push(cell);
	        cellMap[cell.id] = cell;
	        if (cell.isLink()) {
	          links.push(cell);
	        } else {
	          elements.push(cell);
	        }
	      }
	      if (opt.deep) {
	        var embeds = cell.getEmbeddedCells({
	          deep: true
	        });
	        embeds.forEach(function (embed) {
	          if (!cellMap[embed.id]) {
	            subgraph.push(embed);
	            cellMap[embed.id] = embed;
	            if (embed.isLink()) {
	              links.push(embed);
	            } else {
	              elements.push(embed);
	            }
	          }
	        });
	      }
	    });
	    links.forEach(function (link) {
	      // For links, return their source & target (if they are elements - not points).
	      var {
	        source,
	        target
	      } = link.attributes;
	      if (source.id && !cellMap[source.id]) {
	        var sourceElement = this.getCell(source.id);
	        subgraph.push(sourceElement);
	        cellMap[sourceElement.id] = sourceElement;
	        elements.push(sourceElement);
	      }
	      if (target.id && !cellMap[target.id]) {
	        var targetElement = this.getCell(target.id);
	        subgraph.push(this.getCell(target.id));
	        cellMap[targetElement.id] = targetElement;
	        elements.push(targetElement);
	      }
	    }, this);
	    elements.forEach(function (element) {
	      // For elements, include their connected links if their source/target is in the subgraph;
	      var links = this.getConnectedLinks(element, opt);
	      links.forEach(function (link) {
	        var {
	          source,
	          target
	        } = link.attributes;
	        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {
	          subgraph.push(link);
	          cellMap[link.id] = link;
	        }
	      });
	    }, this);
	    return subgraph;
	  },
	  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.
	  // If `opt.deep` is `true`, take into account embedded elements too.
	  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
	  getPredecessors: function (element, opt) {
	    opt = opt || {};
	    var res = [];
	    // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.
	    this.search(element, function (el) {
	      if (el !== element) {
	        res.push(el);
	      }
	    }, assign({}, opt, {
	      inbound: true
	    }));
	    return res;
	  },
	  // Perform search on the graph.
	  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.
	  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.
	  // If `opt.deep` is `true`, take into account embedded elements too.
	  // `iteratee` is a function of the form `function(element) {}`.
	  // If `iteratee` explicitly returns `false`, the searching stops.
	  search: function (element, iteratee, opt) {
	    opt = opt || {};
	    if (opt.breadthFirst) {
	      this.bfs(element, iteratee, opt);
	    } else {
	      this.dfs(element, iteratee, opt);
	    }
	  },
	  // Breadth-first search.
	  // If `opt.deep` is `true`, take into account embedded elements too.
	  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
	  // `iteratee` is a function of the form `function(element, distance) {}`.
	  // where `element` is the currently visited element and `distance` is the distance of that element
	  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.
	  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels
	  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.
	  // If `iteratee` explicitly returns `false`, the searching stops.
	  bfs: function (element, iteratee, opt = {}) {
	    const visited = {};
	    const distance = {};
	    const queue = [];
	    queue.push(element);
	    distance[element.id] = 0;
	    while (queue.length > 0) {
	      var next = queue.shift();
	      if (visited[next.id]) continue;
	      visited[next.id] = true;
	      if (iteratee.call(this, next, distance[next.id]) === false) continue;
	      const neighbors = this.getNeighbors(next, opt);
	      for (let i = 0, n = neighbors.length; i < n; i++) {
	        const neighbor = neighbors[i];
	        distance[neighbor.id] = distance[next.id] + 1;
	        queue.push(neighbor);
	      }
	    }
	  },
	  // Depth-first search.
	  // If `opt.deep` is `true`, take into account embedded elements too.
	  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
	  // `iteratee` is a function of the form `function(element, distance) {}`.
	  // If `iteratee` explicitly returns `false`, the search stops.
	  dfs: function (element, iteratee, opt = {}) {
	    const visited = {};
	    const distance = {};
	    const queue = [];
	    queue.push(element);
	    distance[element.id] = 0;
	    while (queue.length > 0) {
	      const next = queue.pop();
	      if (visited[next.id]) continue;
	      visited[next.id] = true;
	      if (iteratee.call(this, next, distance[next.id]) === false) continue;
	      const neighbors = this.getNeighbors(next, opt);
	      const lastIndex = queue.length;
	      for (let i = 0, n = neighbors.length; i < n; i++) {
	        const neighbor = neighbors[i];
	        distance[neighbor.id] = distance[next.id] + 1;
	        queue.splice(lastIndex, 0, neighbor);
	      }
	    }
	  },
	  // Get all the roots of the graph. Time complexity: O(|V|).
	  getSources: function () {
	    return this.topologyIndex.getSourceNodes().map(nodeId => this.getCell(nodeId));
	  },
	  // Get all the leafs of the graph. Time complexity: O(|V|).
	  getSinks: function () {
	    return this.topologyIndex.getSinkNodes().map(nodeId => this.getCell(nodeId));
	  },
	  // Return `true` if `element` is a root. Time complexity: O(1).
	  isSource: function (element) {
	    return this.topologyIndex.isSourceNode(element.id);
	  },
	  // Return `true` if `element` is a leaf. Time complexity: O(1).
	  isSink: function (element) {
	    return this.topologyIndex.isSinkNode(element.id);
	  },
	  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.
	  isSuccessor: function (elementA, elementB) {
	    var isSuccessor = false;
	    this.search(elementA, function (element) {
	      if (element === elementB && element !== elementA) {
	        isSuccessor = true;
	        return false;
	      }
	    }, {
	      outbound: true
	    });
	    return isSuccessor;
	  },
	  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.
	  isPredecessor: function (elementA, elementB) {
	    var isPredecessor = false;
	    this.search(elementA, function (element) {
	      if (element === elementB && element !== elementA) {
	        isPredecessor = true;
	        return false;
	      }
	    }, {
	      inbound: true
	    });
	    return isPredecessor;
	  },
	  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.
	  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`
	  // for more details.
	  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.
	  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.
	  isNeighbor: function (elementA, elementB, opt) {
	    opt = opt || {};
	    var inbound = opt.inbound;
	    var outbound = opt.outbound;
	    if (inbound === undefined && outbound === undefined) {
	      inbound = outbound = true;
	    }
	    var isNeighbor = false;
	    this.getConnectedLinks(elementA, opt).forEach(function (link) {
	      var {
	        source,
	        target
	      } = link.attributes;

	      // Discard if it is a point.
	      if (inbound && has(source, 'id') && source.id === elementB.id) {
	        isNeighbor = true;
	        return false;
	      }

	      // Discard if it is a point, or if the neighbor was already added.
	      if (outbound && has(target, 'id') && target.id === elementB.id) {
	        isNeighbor = true;
	        return false;
	      }
	    });
	    return isNeighbor;
	  },
	  // Disconnect links connected to the cell `model`.
	  disconnectLinks: function (model, opt) {
	    this.getConnectedLinks(model).forEach(function (link) {
	      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {
	        x: 0,
	        y: 0
	      }, opt);
	    });
	  },
	  // Remove links connected to the cell `model` completely.
	  removeLinks: function (cell, opt) {
	    this.getConnectedLinks(cell).forEach(link => {
	      this.layerCollection.removeCell(link, opt);
	    });
	  },
	  // Find all cells at given point

	  findElementsAtPoint: function (point, opt) {
	    return this._filterAtPoint(this.getElements(), point, opt);
	  },
	  findLinksAtPoint: function (point, opt) {
	    return this._filterAtPoint(this.getLinks(), point, opt);
	  },
	  findCellsAtPoint: function (point, opt) {
	    return this._filterAtPoint(this.getCells(), point, opt);
	  },
	  _filterAtPoint: function (cells, point, opt = {}) {
	    return cells.filter(el => el.getBBox({
	      rotate: true
	    }).containsPoint(point, opt));
	  },
	  // Find all cells in given area

	  findElementsInArea: function (area, opt = {}) {
	    return this._filterInArea(this.getElements(), area, opt);
	  },
	  findLinksInArea: function (area, opt = {}) {
	    return this._filterInArea(this.getLinks(), area, opt);
	  },
	  findCellsInArea: function (area, opt = {}) {
	    return this._filterInArea(this.getCells(), area, opt);
	  },
	  _filterInArea: function (cells, area, opt = {}) {
	    const r = new Rect(area);
	    const {
	      strict = false
	    } = opt;
	    const method = strict ? 'containsRect' : 'intersect';
	    return cells.filter(el => r[method](el.getBBox({
	      rotate: true
	    })));
	  },
	  // Find all cells under the given element.

	  findElementsUnderElement: function (element, opt) {
	    return this._filterCellsUnderElement(this.getElements(), element, opt);
	  },
	  findLinksUnderElement: function (element, opt) {
	    return this._filterCellsUnderElement(this.getLinks(), element, opt);
	  },
	  findCellsUnderElement: function (element, opt) {
	    return this._filterCellsUnderElement(this.getCells(), element, opt);
	  },
	  _isValidElementUnderElement: function (el1, el2) {
	    return el1.id !== el2.id && !el1.isEmbeddedIn(el2);
	  },
	  _isValidLinkUnderElement: function (link, el) {
	    return link.source().id !== el.id && link.target().id !== el.id && !link.isEmbeddedIn(el);
	  },
	  _validateCellsUnderElement: function (cells, element) {
	    return cells.filter(cell => {
	      return cell.isLink() ? this._isValidLinkUnderElement(cell, element) : this._isValidElementUnderElement(cell, element);
	    });
	  },
	  _getFindUnderElementGeometry: function (element, searchBy = 'bbox') {
	    const bbox = element.getBBox({
	      rotate: true
	    });
	    return searchBy !== 'bbox' ? getRectPoint(bbox, searchBy) : bbox;
	  },
	  _filterCellsUnderElement: function (cells, element, opt = {}) {
	    const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);
	    const filteredCells = geometry.type === types.Point ? this._filterAtPoint(cells, geometry) : this._filterInArea(cells, geometry, opt);
	    return this._validateCellsUnderElement(filteredCells, element);
	  },
	  // @deprecated use `findElementsInArea` instead
	  findModelsInArea: function (area, opt) {
	    return this.findElementsInArea(area, opt);
	  },
	  // @deprecated use `findElementsAtPoint` instead
	  findModelsFromPoint: function (point) {
	    return this.findElementsAtPoint(point);
	  },
	  // @deprecated use `findModelsUnderElement` instead
	  findModelsUnderElement: function (element, opt) {
	    return this.findElementsUnderElement(element, opt);
	  },
	  // Return bounding box of all elements.
	  getBBox: function () {
	    return this.getCellsBBox(this.getCells());
	  },
	  // Return the bounding box of all cells in array provided.
	  getCellsBBox: function (cells, opt = {}) {
	    const {
	      rotate = true
	    } = opt;
	    return toArray$1(cells).reduce(function (memo, cell) {
	      const rect = cell.getBBox({
	        rotate
	      });
	      if (!rect) return memo;
	      if (memo) {
	        return memo.union(rect);
	      }
	      return rect;
	    }, null);
	  },
	  translate: function (dx, dy, opt) {
	    // Don't translate cells that are embedded in any other cell.
	    var cells = this.getCells().filter(function (cell) {
	      return !cell.isEmbedded();
	    });
	    invoke(cells, 'translate', dx, dy, opt);
	    return this;
	  },
	  resize: function (width, height, opt) {
	    return this.resizeCells(width, height, this.getCells(), opt);
	  },
	  resizeCells: function (width, height, cells, opt) {
	    // `getBBox` method returns `null` if no elements provided.
	    // i.e. cells can be an array of links
	    var bbox = this.getCellsBBox(cells);
	    if (bbox) {
	      var sx = Math.max(width / bbox.width, 0);
	      var sy = Math.max(height / bbox.height, 0);
	      invoke(cells, 'scale', sx, sy, bbox.origin(), opt);
	    }
	    return this;
	  },
	  startBatch: function (name, data) {
	    data = data || {};
	    this._batches[name] = (this._batches[name] || 0) + 1;
	    return this.trigger('batch:start', assign({}, data, {
	      batchName: name
	    }));
	  },
	  stopBatch: function (name, data) {
	    data = data || {};
	    this._batches[name] = (this._batches[name] || 0) - 1;
	    return this.trigger('batch:stop', assign({}, data, {
	      batchName: name
	    }));
	  },
	  hasActiveBatch: function (name) {
	    const batches = this._batches;
	    let names;
	    if (arguments.length === 0) {
	      names = Object.keys(batches);
	    } else if (Array.isArray(name)) {
	      names = name;
	    } else {
	      names = [name];
	    }
	    return names.some(batch => batches[batch] > 0);
	  }
	}, {
	  validations: {
	    multiLinks: function (graph, link) {
	      // Do not allow multiple links to have the same source and target.
	      var {
	        source,
	        target
	      } = link.attributes;
	      if (source.id && target.id) {
	        var sourceModel = link.getSourceCell();
	        if (sourceModel) {
	          var connectedLinks = graph.getConnectedLinks(sourceModel, {
	            outbound: true
	          });
	          var sameLinks = connectedLinks.filter(function (_link) {
	            var {
	              source: _source,
	              target: _target
	            } = _link.attributes;
	            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);
	          });
	          if (sameLinks.length > 1) {
	            return false;
	          }
	        }
	      }
	      return true;
	    },
	    linkPinning: function (_graph, link) {
	      var {
	        source,
	        target
	      } = link.attributes;
	      return source.id && target.id;
	    }
	  }
	});
	wrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);

	const calcAttributesList = ['transform', 'x', 'y', 'cx', 'cy', 'dx', 'dy', 'x1', 'y1', 'x2', 'y2', 'points', 'd', 'r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];
	const positiveValueList = ['r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];
	const calcAttributes = calcAttributesList.reduce((acc, attrName) => {
	  acc[attrName] = true;
	  return acc;
	}, {});
	const positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {
	  acc[attrName] = true;
	  return acc;
	}, {});
	function evalAttributes(attrs, refBBox) {
	  const evalAttrs = {};
	  for (let attrName in attrs) {
	    if (!attrs.hasOwnProperty(attrName)) continue;
	    evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);
	  }
	  return evalAttrs;
	}
	function evalAttribute(attrName, attrValue, refBBox) {
	  if (attrName in calcAttributes && isCalcExpression(attrValue)) {
	    let evalAttrValue = evalCalcExpression(attrValue, refBBox);
	    if (attrName in positiveValueAttributes) {
	      evalAttrValue = Math.max(0, evalAttrValue);
	    }
	    return evalAttrValue;
	  }
	  return attrValue;
	}

	const HighlightingTypes$1 = {
	  DEFAULT: 'default',
	  EMBEDDING: 'embedding',
	  CONNECTING: 'connecting',
	  MAGNET_AVAILABILITY: 'magnetAvailability',
	  ELEMENT_AVAILABILITY: 'elementAvailability'
	};
	const Flags$2 = {
	  TOOLS: 'TOOLS'
	};

	// CellView base view and controller.
	// --------------------------------------------

	// This is the base view and controller for `ElementView` and `LinkView`.
	const CellView = View.extend({
	  tagName: 'g',
	  svgElement: true,
	  selector: 'root',
	  metrics: null,
	  className: function () {
	    var classNames = ['cell'];
	    var type = this.model.get('type');
	    if (type) {
	      type.toLowerCase().split('.').forEach(function (value, index, list) {
	        classNames.push('type-' + list.slice(0, index + 1).join('-'));
	      });
	    }
	    return classNames.join(' ');
	  },
	  _presentationAttributes: null,
	  _flags: null,
	  setFlags: function () {
	    var flags = {};
	    var attributes = {};
	    var shift = 0;
	    var i, n, label;
	    var presentationAttributes = result(this, 'presentationAttributes');
	    for (var attribute in presentationAttributes) {
	      if (!presentationAttributes.hasOwnProperty(attribute)) continue;
	      var labels = presentationAttributes[attribute];
	      if (!Array.isArray(labels)) labels = [labels];
	      for (i = 0, n = labels.length; i < n; i++) {
	        label = labels[i];
	        var flag = flags[label];
	        if (!flag) {
	          flag = flags[label] = 1 << shift++;
	        }
	        attributes[attribute] |= flag;
	      }
	    }
	    var initFlag = result(this, 'initFlag');
	    if (!Array.isArray(initFlag)) initFlag = [initFlag];
	    for (i = 0, n = initFlag.length; i < n; i++) {
	      label = initFlag[i];
	      if (!flags[label]) flags[label] = 1 << shift++;
	    }

	    // 26 - 30 are reserved for paper flags
	    // 31+ overflows maximal number
	    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');
	    this._flags = flags;
	    this._presentationAttributes = attributes;
	  },
	  hasFlag: function (flag, label) {
	    return flag & this.getFlag(label);
	  },
	  removeFlag: function (flag, label) {
	    return flag ^ flag & this.getFlag(label);
	  },
	  getFlag: function (label) {
	    var flags = this._flags;
	    if (!flags) return 0;
	    var flag = 0;
	    if (Array.isArray(label)) {
	      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];
	    } else {
	      flag |= flags[label];
	    }
	    return flag;
	  },
	  attributes: function () {
	    var cell = this.model;
	    return {
	      'model-id': cell.id,
	      'data-type': cell.attributes.type
	    };
	  },
	  constructor: function (options) {
	    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.
	    // The global unique id makes sure that the same view can be rendered on e.g. different machines and
	    // still be associated to the same object among all those clients. This is necessary for real-time
	    // collaboration mechanism.
	    options.id = options.id || guid(this);
	    View.call(this, options);
	  },
	  initialize: function () {
	    this.setFlags();
	    View.prototype.initialize.apply(this, arguments);
	    this.cleanNodesCache();
	    this.startListening();
	  },
	  startListening: function () {
	    this.listenTo(this.model, 'change', this.onAttributesChange);
	  },
	  onAttributesChange: function (model, opt) {
	    var flag = model.getChangeFlag(this._presentationAttributes);
	    if (opt.updateHandled || !flag) return;
	    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');
	    // TODO: tool changes does not need to be sync
	    // Fix Segments tools
	    if (opt.tool) opt.async = false;
	    this.requestUpdate(flag, opt);
	  },
	  requestUpdate: function (flags, opt) {
	    const {
	      paper
	    } = this;
	    if (paper && flags > 0) {
	      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);
	    }
	  },
	  parseDOMJSON: function (markup, root) {
	    var doc = parseDOMJSON(markup);
	    var selectors = doc.selectors;
	    var groups = doc.groupSelectors;
	    for (var group in groups) {
	      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');
	      selectors[group] = groups[group];
	    }
	    if (root) {
	      var rootSelector = this.selector;
	      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');
	      selectors[rootSelector] = root;
	    }
	    return {
	      fragment: doc.fragment,
	      selectors: selectors
	    };
	  },
	  // Return `true` if cell link is allowed to perform a certain UI `feature`.
	  // Example: `can('labelMove')`.
	  can: function (feature) {
	    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;
	    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;
	  },
	  findBySelector: function (selector, root, selectors) {
	    // These are either descendants of `this.$el` of `this.$el` itself.
	    // `.` is a special selector used to select the wrapping `<g>` element.
	    if (!selector || selector === '.') return [root];
	    if (selectors) {
	      var nodes = selectors[selector];
	      if (nodes) {
	        if (Array.isArray(nodes)) return nodes;
	        return [nodes];
	      }
	    }

	    // Maintaining backwards compatibility
	    // e.g. `circle:first` would fail with querySelector() call
	    if (this.useCSSSelectors) return $(root).find(selector).toArray();
	    return [];
	  },
	  findNodes: function (selector) {
	    return this.findBySelector(selector, this.el, this.selectors);
	  },
	  findNode: function (selector) {
	    const [node = null] = this.findNodes(selector);
	    return node;
	  },
	  notify: function (eventName) {
	    if (this.paper) {
	      var args = Array.prototype.slice.call(arguments, 1);

	      // Trigger the event on both the element itself and also on the paper.
	      this.trigger.apply(this, [eventName].concat(args));

	      // Paper event handlers receive the view object as the first argument.
	      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));
	    }
	  },
	  getBBox: function (opt) {
	    var bbox;
	    if (opt && opt.useModelGeometry) {
	      var model = this.model;
	      bbox = model.getBBox().bbox(model.angle());
	    } else {
	      bbox = this.getNodeBBox(this.el);
	    }
	    return this.paper.localToPaperRect(bbox);
	  },
	  getNodeBBox: function (magnet) {
	    const rect = this.getNodeBoundingRect(magnet);
	    const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));
	    const magnetMatrix = this.getNodeMatrix(magnet);
	    return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));
	  },
	  getNodeRotateMatrix(node) {
	    if (!this.rotatableNode || this.rotatableNode.contains(node)) {
	      // Rotate transformation is applied to all nodes when no rotatableGroup
	      // is present or to nodes inside the rotatableGroup only.
	      return this.getRootRotateMatrix();
	    }
	    // Nodes outside the rotatable group
	    return V.createSVGMatrix();
	  },
	  getNodeUnrotatedBBox: function (magnet) {
	    var rect = this.getNodeBoundingRect(magnet);
	    var magnetMatrix = this.getNodeMatrix(magnet);
	    var translateMatrix = this.getRootTranslateMatrix();
	    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));
	  },
	  getRootTranslateMatrix: function () {
	    var model = this.model;
	    var position = model.position();
	    var mt = V.createSVGMatrix().translate(position.x, position.y);
	    return mt;
	  },
	  getRootRotateMatrix: function () {
	    var mr = V.createSVGMatrix();
	    var model = this.model;
	    var angle = model.angle();
	    if (angle) {
	      var bbox = model.getBBox();
	      var cx = bbox.width / 2;
	      var cy = bbox.height / 2;
	      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);
	    }
	    return mr;
	  },
	  _notifyHighlight: function (eventName, el, opt = {}) {
	    const {
	      el: rootNode
	    } = this;
	    let node;
	    if (typeof el === 'string') {
	      node = this.findNode(el) || rootNode;
	    } else {
	      [node = rootNode] = this.$(el);
	    }
	    // set partial flag if the highlighted element is not the entire view.
	    opt.partial = node !== rootNode;
	    // translate type flag into a type string
	    if (opt.type === undefined) {
	      let type;
	      switch (true) {
	        case opt.embedding:
	          type = HighlightingTypes$1.EMBEDDING;
	          break;
	        case opt.connecting:
	          type = HighlightingTypes$1.CONNECTING;
	          break;
	        case opt.magnetAvailability:
	          type = HighlightingTypes$1.MAGNET_AVAILABILITY;
	          break;
	        case opt.elementAvailability:
	          type = HighlightingTypes$1.ELEMENT_AVAILABILITY;
	          break;
	        default:
	          type = HighlightingTypes$1.DEFAULT;
	          break;
	      }
	      opt.type = type;
	    }
	    this.notify(eventName, node, opt);
	    return this;
	  },
	  highlight: function (el, opt) {
	    return this._notifyHighlight('cell:highlight', el, opt);
	  },
	  unhighlight: function (el, opt = {}) {
	    return this._notifyHighlight('cell:unhighlight', el, opt);
	  },
	  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such
	  // an element found, return the root element of the cell view.
	  findMagnet: function (el) {
	    const root = this.el;
	    let magnet = this.$(el)[0];
	    if (!magnet) {
	      magnet = root;
	    }
	    do {
	      const magnetAttribute = magnet.getAttribute('magnet');
	      const isMagnetRoot = magnet === root;
	      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {
	        return magnet;
	      }
	      if (isMagnetRoot) {
	        // If the overall cell has set `magnet === false`, then return `undefined` to
	        // announce there is no magnet found for this cell.
	        // This is especially useful to set on cells that have 'ports'. In this case,
	        // only the ports have set `magnet === true` and the overall element has `magnet === false`.
	        return undefined;
	      }
	      magnet = magnet.parentNode;
	    } while (magnet);
	    return undefined;
	  },
	  findProxyNode: function (el, type) {
	    el || (el = this.el);
	    const nodeSelector = el.getAttribute(`${type}-selector`);
	    if (nodeSelector) {
	      const proxyNode = this.findNode(nodeSelector);
	      if (proxyNode) return proxyNode;
	    }
	    return el;
	  },
	  // Construct a unique selector for the `el` element within this view.
	  // `prevSelector` is being collected through the recursive call.
	  // No value for `prevSelector` is expected when using this method.
	  getSelector: function (el, prevSelector) {
	    var selector;
	    if (el === this.el) {
	      if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;
	      return selector;
	    }
	    if (el) {
	      var nthChild = V(el).index() + 1;
	      selector = el.tagName + ':nth-child(' + nthChild + ')';
	      if (prevSelector) {
	        selector += ' > ' + prevSelector;
	      }
	      selector = this.getSelector(el.parentNode, selector);
	    }
	    return selector;
	  },
	  addLinkFromMagnet: function (magnet, x, y) {
	    var paper = this.paper;
	    var graph = paper.model;
	    var link = paper.getDefaultLink(this, magnet);
	    link.set({
	      source: this.getLinkEnd(magnet, x, y, link, 'source'),
	      target: {
	        x: x,
	        y: y
	      }
	    }).addTo(graph, {
	      async: false,
	      ui: true
	    });
	    return link.findView(paper);
	  },
	  getLinkEnd: function (magnet, ...args) {
	    const model = this.model;
	    const id = model.id;
	    // Find a node with the `port` attribute set on it.
	    const portNode = this.findAttributeNode('port', magnet);
	    // Find a unique `selector` of the element under pointer that is a magnet.
	    const selector = magnet.getAttribute('joint-selector');
	    const end = {
	      id: id
	    };
	    if (selector != null) end.magnet = selector;
	    if (portNode != null) {
	      let port = portNode.getAttribute('port');
	      if (portNode.getAttribute('port-id-type') === 'number') {
	        port = parseInt(port, 10);
	      }
	      end.port = port;
	      if (!model.hasPort(port) && !selector) {
	        // port created via the `port` attribute (not API)
	        end.selector = this.getSelector(magnet);
	      }
	    } else if (selector == null && this.el !== magnet) {
	      end.selector = this.getSelector(magnet);
	    }
	    return this.customizeLinkEnd(end, magnet, ...args);
	  },
	  customizeLinkEnd: function (end, magnet, x, y, link, endType) {
	    const {
	      paper
	    } = this;
	    const {
	      connectionStrategy
	    } = paper.options;
	    if (typeof connectionStrategy === 'function') {
	      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);
	      if (strategy) return strategy;
	    }
	    return end;
	  },
	  getMagnetFromLinkEnd: function (end) {
	    var port = end.port;
	    var selector = end.magnet;
	    var model = this.model;
	    var magnet;
	    if (port != null && model.isElement() && model.hasPort(port)) {
	      magnet = this.findPortNode(port, selector) || this.el;
	    } else {
	      if (!selector) selector = end.selector;
	      if (!selector && port != null) {
	        // link end has only `id` and `port` property referencing
	        // a port created via the `port` attribute (not API).
	        selector = '[port="' + port + '"]';
	      }
	      magnet = this.findNode(selector);
	    }
	    return this.findProxyNode(magnet, 'magnet');
	  },
	  dragLinkStart: function (evt, magnet, x, y) {
	    this.model.startBatch('add-link');
	    const linkView = this.addLinkFromMagnet(magnet, x, y);
	    // backwards compatibility events
	    linkView.notifyPointerdown(evt, x, y);
	    linkView.eventData(evt, linkView.startArrowheadMove('target', {
	      whenNotAllowed: 'remove'
	    }));
	    this.eventData(evt, {
	      linkView
	    });
	  },
	  dragLink: function (evt, x, y) {
	    var data = this.eventData(evt);
	    var linkView = data.linkView;
	    if (linkView) {
	      linkView.pointermove(evt, x, y);
	    } else {
	      var paper = this.paper;
	      var magnetThreshold = paper.options.magnetThreshold;
	      var currentTarget = this.getEventTarget(evt);
	      var targetMagnet = data.targetMagnet;
	      if (magnetThreshold === 'onleave') {
	        // magnetThreshold when the pointer leaves the magnet
	        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;
	      } else {
	        // magnetThreshold defined as a number of movements
	        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;
	      }
	      this.dragLinkStart(evt, targetMagnet, x, y);
	    }
	  },
	  dragLinkEnd: function (evt, x, y) {
	    var data = this.eventData(evt);
	    var linkView = data.linkView;
	    if (!linkView) return;
	    linkView.pointerup(evt, x, y);
	    this.model.stopBatch('add-link');
	  },
	  getAttributeDefinition: function (attrName) {
	    return this.model.constructor.getAttributeDefinition(attrName);
	  },
	  setNodeAttributes: function (node, attrs) {
	    if (!isEmpty(attrs)) {
	      if (node instanceof SVGElement) {
	        V(node).attr(attrs);
	      } else {
	        $(node).attr(attrs);
	      }
	    }
	  },
	  processNodeAttributes: function (node, attrs) {
	    var attrName, attrVal, def, i, n;
	    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;
	    var relatives = [];
	    const rawAttrs = {};
	    for (attrName in attrs) {
	      if (!attrs.hasOwnProperty(attrName)) continue;
	      rawAttrs[V.attributeNames[attrName]] = attrs[attrName];
	    }
	    // divide the attributes between normal and special
	    for (attrName in rawAttrs) {
	      if (!rawAttrs.hasOwnProperty(attrName)) continue;
	      attrVal = rawAttrs[attrName];
	      def = this.getAttributeDefinition(attrName);
	      if (def) {
	        if (attrVal === null) {
	          // Assign the unset attribute name.
	          let unsetAttrName;
	          if (isFunction(def.unset)) {
	            unsetAttrName = def.unset.call(this, node, rawAttrs, this);
	          } else {
	            unsetAttrName = def.unset;
	          }
	          if (!unsetAttrName && isString(def.set)) {
	            // We unset an alias attribute.
	            unsetAttrName = def.set;
	          }
	          if (!unsetAttrName) {
	            // There is no alias for the attribute. We unset the attribute itself.
	            unsetAttrName = attrName;
	          }
	          // Unset the attribute.
	          if (isString(unsetAttrName) && unsetAttrName) {
	            // Unset a single attribute.
	            normalAttrs || (normalAttrs = {});
	            // values takes precedence over unset values
	            if (unsetAttrName in normalAttrs) continue;
	            normalAttrs[unsetAttrName] = attrVal;
	          } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {
	            // Unset multiple attributes.
	            normalAttrs || (normalAttrs = {});
	            for (i = 0, n = unsetAttrName.length; i < n; i++) {
	              const attrName = unsetAttrName[i];
	              // values takes precedence over unset values
	              if (attrName in normalAttrs) continue;
	              normalAttrs[attrName] = attrVal;
	            }
	          }
	          // The unset value is neither a string nor an array.
	          // The attribute is not unset.
	        } else {
	          if (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {
	            if (isString(def.set)) {
	              // An alias e.g 'xlink:href' -> 'href'
	              normalAttrs || (normalAttrs = {});
	              normalAttrs[def.set] = attrVal;
	            }
	            relatives.push(attrName, def);
	          } else {
	            normalAttrs || (normalAttrs = {});
	            normalAttrs[attrName] = attrVal;
	          }
	        }
	      } else {
	        normalAttrs || (normalAttrs = {});
	        normalAttrs[attrName] = attrVal;
	      }
	    }

	    // handle the rest of attributes via related method
	    // from the special attributes namespace.
	    for (i = 0, n = relatives.length; i < n; i += 2) {
	      attrName = relatives[i];
	      def = relatives[i + 1];
	      attrVal = attrs[attrName];
	      if (isFunction(def.set)) {
	        setAttrs || (setAttrs = {});
	        setAttrs[attrName] = attrVal;
	      }
	      if (isFunction(def.position)) {
	        positionAttrs || (positionAttrs = {});
	        positionAttrs[attrName] = attrVal;
	      }
	      if (isFunction(def.offset)) {
	        offsetAttrs || (offsetAttrs = {});
	        offsetAttrs[attrName] = attrVal;
	      }
	    }
	    return {
	      raw: rawAttrs,
	      normal: normalAttrs,
	      set: setAttrs,
	      position: positionAttrs,
	      offset: offsetAttrs
	    };
	  },
	  updateRelativeAttributes: function (node, attrs, refBBox, opt) {
	    opt || (opt = {});
	    var attrName, attrVal, def;
	    var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);
	    var nodeAttrs = attrs.normal || {};
	    for (const nodeAttrName in nodeAttrs) {
	      nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];
	    }
	    var setAttrs = attrs.set;
	    var positionAttrs = attrs.position;
	    var offsetAttrs = attrs.offset;
	    for (attrName in setAttrs) {
	      attrVal = evalAttrs[attrName];
	      def = this.getAttributeDefinition(attrName);
	      // SET - set function should return attributes to be set on the node,
	      // which will affect the node dimensions based on the reference bounding
	      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points
	      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
	      if (isObject(setResult)) {
	        assign(nodeAttrs, setResult);
	      } else if (setResult !== undefined) {
	        nodeAttrs[attrName] = setResult;
	      }
	    }
	    if (node instanceof HTMLElement) {
	      // TODO: setting the `transform` attribute on HTMLElements
	      // via `node.style.transform = 'matrix(...)';` would introduce
	      // a breaking change (e.g. basic.TextBlock).
	      this.setNodeAttributes(node, nodeAttrs);
	      return;
	    }

	    // The final translation of the subelement.
	    var nodeTransform = nodeAttrs.transform;
	    var nodeMatrix = V.transformStringToMatrix(nodeTransform);
	    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);
	    if (nodeTransform) {
	      nodeAttrs = omit(nodeAttrs, 'transform');
	      nodeMatrix.e = nodeMatrix.f = 0;
	    }

	    // Calculate node scale determined by the scalable group
	    // only if later needed.
	    var sx, sy, translation;
	    if (positionAttrs || offsetAttrs) {
	      var nodeScale = this.getNodeScale(node, opt.scalableNode);
	      sx = nodeScale.sx;
	      sy = nodeScale.sy;
	    }
	    var positioned = false;
	    for (attrName in positionAttrs) {
	      attrVal = evalAttrs[attrName];
	      def = this.getAttributeDefinition(attrName);
	      // POSITION - position function should return a point from the
	      // reference bounding box. The default position of the node is x:0, y:0 of
	      // the reference bounding box or could be further specify by some
	      // SVG attributes e.g. `x`, `y`
	      translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
	      if (translation) {
	        nodePosition.offset(Point(translation).scale(sx, sy));
	        positioned || (positioned = true);
	      }
	    }

	    // The node bounding box could depend on the `size` set from the previous loop.
	    // Here we know, that all the size attributes have been already set.
	    this.setNodeAttributes(node, nodeAttrs);
	    var offseted = false;
	    if (offsetAttrs) {
	      // Check if the node is visible
	      var nodeBoundingRect = this.getNodeBoundingRect(node);
	      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
	        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
	        for (attrName in offsetAttrs) {
	          attrVal = evalAttrs[attrName];
	          def = this.getAttributeDefinition(attrName);
	          // OFFSET - offset function should return a point from the element
	          // bounding box. The default offset point is x:0, y:0 (origin) or could be further
	          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`
	          translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);
	          if (translation) {
	            nodePosition.offset(Point(translation).scale(sx, sy));
	            offseted || (offseted = true);
	          }
	        }
	      }
	    }

	    // Do not touch node's transform attribute if there is no transformation applied.
	    if (nodeTransform !== undefined || positioned || offseted) {
	      // Round the coordinates to 1 decimal point.
	      nodePosition.round(1);
	      nodeMatrix.e = nodePosition.x;
	      nodeMatrix.f = nodePosition.y;
	      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));
	      // TODO: store nodeMatrix metrics?
	    }
	  },
	  getNodeScale: function (node, scalableNode) {
	    // Check if the node is a descendant of the scalable group.
	    var sx, sy;
	    if (scalableNode && scalableNode.contains(node)) {
	      var scale = scalableNode.scale();
	      sx = 1 / scale.sx;
	      sy = 1 / scale.sy;
	    } else {
	      sx = 1;
	      sy = 1;
	    }
	    return {
	      sx: sx,
	      sy: sy
	    };
	  },
	  cleanNodesCache: function () {
	    this.metrics = {};
	  },
	  cleanNodeCache: function (node) {
	    const id = node.id;
	    if (!id) return;
	    delete this.metrics[id];
	  },
	  nodeCache: function (magnet) {
	    var metrics = this.metrics;
	    // Don't use cache? It most likely a custom view with overridden update.
	    if (!metrics) return {};
	    var id = V.ensureId(magnet);
	    var value = metrics[id];
	    if (!value) value = metrics[id] = {};
	    return value;
	  },
	  getNodeData: function (magnet) {
	    var metrics = this.nodeCache(magnet);
	    if (!metrics.data) metrics.data = {};
	    return metrics.data;
	  },
	  getNodeBoundingRect: function (magnet) {
	    var metrics = this.nodeCache(magnet);
	    if (metrics.boundingRect === undefined) {
	      const {
	        measureNode
	      } = this.paper.options;
	      if (typeof measureNode === 'function') {
	        // Measure the node bounding box using the paper's measureNode method.
	        metrics.boundingRect = measureNode(magnet, this);
	      } else {
	        metrics.boundingRect = V(magnet).getBBox();
	      }
	    }
	    return new Rect(metrics.boundingRect);
	  },
	  getNodeMatrix: function (magnet) {
	    const metrics = this.nodeCache(magnet);
	    if (metrics.magnetMatrix === undefined) {
	      const {
	        rotatableNode,
	        el
	      } = this;
	      let target;
	      if (rotatableNode && rotatableNode.contains(magnet)) {
	        target = rotatableNode;
	      } else {
	        target = el;
	      }
	      metrics.magnetMatrix = V(magnet).getTransformToElement(target, {
	        // We use `safe` mode if the magnet is not visible (not in the DOM render tree).
	        // The browser would not be able to calculate the transformation matrix
	        // using `getScreenCTM()` method.
	        safe: !magnet.checkVisibility()
	      });
	    }
	    return V.createSVGMatrix(metrics.magnetMatrix);
	  },
	  getNodeShape: function (magnet) {
	    var metrics = this.nodeCache(magnet);
	    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();
	    return metrics.geometryShape.clone();
	  },
	  isNodeConnection: function (node) {
	    return this.model.isLink() && (!node || node === this.el);
	  },
	  findNodesAttributes: function (attrs, root, selectorCache, selectors) {
	    var i, n, nodeAttrs, nodeId;
	    var nodesAttrs = {};
	    var mergeIds = [];
	    for (var selector in attrs) {
	      if (!attrs.hasOwnProperty(selector)) continue;
	      nodeAttrs = attrs[selector];
	      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair
	      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);
	      for (i = 0, n = selected.length; i < n; i++) {
	        var node = selected[i];
	        nodeId = V.ensureId(node);
	        // "unique" selectors are selectors that referencing a single node (defined by `selector`)
	        // groupSelector referencing a single node is not "unique"
	        var unique = selectors && selectors[selector] === node;
	        var prevNodeAttrs = nodesAttrs[nodeId];
	        if (prevNodeAttrs) {
	          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.
	          // e.g. css:`.circle` and selector:`circle` can be applied in a random order
	          if (!prevNodeAttrs.array) {
	            mergeIds.push(nodeId);
	            prevNodeAttrs.array = true;
	            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];
	            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];
	          }
	          var attributes = prevNodeAttrs.attributes;
	          var selectedLength = prevNodeAttrs.selectedLength;
	          if (unique) {
	            // node referenced by `selector`
	            attributes.unshift(nodeAttrs);
	            selectedLength.unshift(-1);
	          } else {
	            // node referenced by `groupSelector`
	            var sortIndex = sortedIndex(selectedLength, n);
	            attributes.splice(sortIndex, 0, nodeAttrs);
	            selectedLength.splice(sortIndex, 0, n);
	          }
	        } else {
	          nodesAttrs[nodeId] = {
	            attributes: nodeAttrs,
	            selectedLength: unique ? -1 : n,
	            node: node,
	            array: false
	          };
	        }
	      }
	    }
	    for (i = 0, n = mergeIds.length; i < n; i++) {
	      nodeId = mergeIds[i];
	      nodeAttrs = nodesAttrs[nodeId];
	      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());
	    }
	    return nodesAttrs;
	  },
	  getEventTarget: function (evt, opt = {}) {
	    const {
	      target,
	      type,
	      clientX = 0,
	      clientY = 0
	    } = evt;
	    if (
	    // Explicitly defined `fromPoint` option
	    opt.fromPoint ||
	    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.
	    // It holds the element when a touchstart triggered.
	    type === 'touchmove' || type === 'touchend' ||
	    // Pointermove/Pointerup event with the pointer captured
	    'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {
	      return document.elementFromPoint(clientX, clientY);
	    }
	    return target;
	  },
	  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,
	  // unless `attrs` parameter was passed.
	  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {
	    opt || (opt = {});
	    opt.rootBBox || (opt.rootBBox = Rect());
	    opt.selectors || (opt.selectors = this.selectors); // selector collection to use

	    // Cache table for query results and bounding box calculation.
	    // Note that `selectorCache` needs to be invalidated for all
	    // `updateAttributes` calls, as the selectors might pointing
	    // to nodes designated by an attribute or elements dynamically
	    // created.
	    var selectorCache = {};
	    var bboxCache = {};
	    var relativeItems = [];
	    var relativeRefItems = [];
	    var item, node, nodeAttrs, nodeData, processedAttrs;
	    var roAttrs = opt.roAttributes;
	    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);
	    // `nodesAttrs` are different from all attributes, when
	    // rendering only  attributes sent to this method.
	    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;
	    for (var nodeId in nodesAttrs) {
	      nodeData = nodesAttrs[nodeId];
	      nodeAttrs = nodeData.attributes;
	      node = nodeData.node;
	      processedAttrs = this.processNodeAttributes(node, nodeAttrs);
	      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {
	        // Set all the normal attributes right on the SVG/HTML element.
	        this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));
	      } else {
	        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;
	        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;
	        var refNode;
	        if (refSelector) {
	          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];
	          if (!refNode) {
	            throw new Error('dia.CellView: "' + refSelector + '" reference does not exist.');
	          }
	        } else {
	          refNode = null;
	        }
	        item = {
	          node: node,
	          refNode: refNode,
	          processedAttributes: processedAttrs,
	          allAttributes: nodeAllAttrs
	        };
	        if (refNode) {
	          // If an element in the list is positioned relative to this one, then
	          // we want to insert this one before it in the list.
	          var itemIndex = relativeRefItems.findIndex(function (item) {
	            return item.refNode === node;
	          });
	          if (itemIndex > -1) {
	            relativeRefItems.splice(itemIndex, 0, item);
	          } else {
	            relativeRefItems.push(item);
	          }
	        } else {
	          // A node with no ref attribute. To be updated before the nodes referencing other nodes.
	          // The order of no-ref-items is not specified/important.
	          relativeItems.push(item);
	        }
	      }
	    }
	    relativeItems.push(...relativeRefItems);
	    for (let i = 0, n = relativeItems.length; i < n; i++) {
	      item = relativeItems[i];
	      node = item.node;
	      refNode = item.refNode;

	      // Find the reference element bounding box. If no reference was provided, we
	      // use the optional bounding box.
	      const refNodeId = refNode ? V.ensureId(refNode) : '';
	      let refBBox = bboxCache[refNodeId];
	      if (!refBBox) {
	        if (refNode) {
	          // Get the bounding box of the reference element using to the common ancestor
	          // transformation space.
	          //
	          // @example 1
	          // <g transform="translate(11, 13)">
	          //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
	          //     <rect @selector="a"/>
	          // </g>
	          //
	          // In this case, the reference bounding box can not be affected
	          // by the `transform` attribute of the `<g>` element,
	          // because the exact transformation will be applied to the `a` element
	          // as well as to the `b` element.
	          //
	          // @example 2
	          // <g transform="translate(11, 13)">
	          //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
	          // </g>
	          // <rect @selector="a"/>
	          //
	          // In this case, the reference bounding box have to be affected by the
	          // `transform` attribute of the `<g>` element, because the `a` element
	          // is not descendant of the `<g>` element and will not be affected
	          // by the transformation.
	          const refRect = this.getNodeBoundingRect(refNode);
	          const refTMatrix = V(refNode).getTransformToElement(V.getCommonAncestor(node, refNode));
	          refBBox = V.transformRect(refRect, refTMatrix);
	        } else {
	          refBBox = opt.rootBBox;
	        }
	        bboxCache[refNodeId] = refBBox;
	      }
	      if (roAttrs) {
	        // if there was a special attribute affecting the position amongst passed-in attributes
	        // we have to merge it with the rest of the element's attributes as they are necessary
	        // to update the position relatively (i.e `ref-x` && 'ref-dx')
	        processedAttrs = this.processNodeAttributes(node, item.allAttributes);
	        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);
	      } else {
	        processedAttrs = item.processedAttributes;
	      }
	      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);
	    }
	  },
	  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {
	    processedAttrs.set || (processedAttrs.set = {});
	    processedAttrs.position || (processedAttrs.position = {});
	    processedAttrs.offset || (processedAttrs.offset = {});
	    assign(processedAttrs.set, roProcessedAttrs.set);
	    assign(processedAttrs.position, roProcessedAttrs.position);
	    assign(processedAttrs.offset, roProcessedAttrs.offset);

	    // Handle also the special transform property.
	    var transform = processedAttrs.normal && processedAttrs.normal.transform;
	    if (transform !== undefined && roProcessedAttrs.normal) {
	      roProcessedAttrs.normal.transform = transform;
	    }
	    processedAttrs.normal = roProcessedAttrs.normal;
	  },
	  // Lifecycle methods

	  // Called when the view is attached to the DOM,
	  // as result of `cell.addTo(graph)` being called (isInitialMount === true)
	  // or `paper.options.viewport` returning `true` (isInitialMount === false).
	  onMount(isInitialMount) {
	    if (isInitialMount) return;
	    this.mountTools();
	    HighlighterView.mount(this);
	  },
	  // Called when the view is detached from the DOM,
	  // as result of `paper.options.viewport` returning `false`.
	  onDetach() {
	    this.unmountTools();
	    HighlighterView.unmount(this);
	  },
	  // Called when the view is removed from the DOM
	  // as result of `cell.remove()`.
	  onRemove: function () {
	    this.removeTools();
	    this.removeHighlighters();
	  },
	  _toolsView: null,
	  hasTools: function (name) {
	    var toolsView = this._toolsView;
	    if (!toolsView) return false;
	    if (!name) return true;
	    return toolsView.getName() === name;
	  },
	  addTools: function (toolsView) {
	    this.removeTools();
	    if (toolsView) {
	      this._toolsView = toolsView;
	      toolsView.configure({
	        relatedView: this
	      });
	      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));
	    }
	    return this;
	  },
	  unmountTools() {
	    const toolsView = this._toolsView;
	    if (toolsView) toolsView.unmount();
	    return this;
	  },
	  mountTools() {
	    const toolsView = this._toolsView;
	    // Prevent unnecessary re-appending of the tools.
	    if (toolsView && !toolsView.isMounted()) toolsView.mount();
	    return this;
	  },
	  updateTools: function (opt) {
	    var toolsView = this._toolsView;
	    if (toolsView) toolsView.update(opt);
	    return this;
	  },
	  removeTools: function () {
	    var toolsView = this._toolsView;
	    if (toolsView) {
	      toolsView.remove();
	      this._toolsView = null;
	    }
	    return this;
	  },
	  hideTools: function () {
	    var toolsView = this._toolsView;
	    if (toolsView) toolsView.hide();
	    return this;
	  },
	  showTools: function () {
	    var toolsView = this._toolsView;
	    if (toolsView) toolsView.show();
	    return this;
	  },
	  onToolEvent: function (event) {
	    switch (event) {
	      case 'remove':
	        this.removeTools();
	        break;
	      case 'hide':
	        this.hideTools();
	        break;
	      case 'show':
	        this.showTools();
	        break;
	    }
	  },
	  removeHighlighters: function () {
	    HighlighterView.remove(this);
	  },
	  updateHighlighters: function (dirty = false) {
	    HighlighterView.update(this, null, dirty);
	  },
	  transformHighlighters: function () {
	    HighlighterView.transform(this);
	  },
	  // Interaction. The controller part.
	  // ---------------------------------

	  preventDefaultInteraction(evt) {
	    this.eventData(evt, {
	      defaultInteractionPrevented: true
	    });
	  },
	  isDefaultInteractionPrevented(evt) {
	    const {
	      defaultInteractionPrevented = false
	    } = this.eventData(evt);
	    return defaultInteractionPrevented;
	  },
	  // Interaction is handled by the paper and delegated to the view in interest.
	  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.
	  // If necessary, real coordinates can be obtained from the `evt` event object.

	  // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,
	  // i.e. `joint.dia.Element` and `joint.dia.Link`.

	  pointerdblclick: function (evt, x, y) {
	    this.notify('cell:pointerdblclick', evt, x, y);
	  },
	  pointerclick: function (evt, x, y) {
	    this.notify('cell:pointerclick', evt, x, y);
	  },
	  contextmenu: function (evt, x, y) {
	    this.notify('cell:contextmenu', evt, x, y);
	  },
	  pointerdown: function (evt, x, y) {
	    const {
	      model
	    } = this;
	    const {
	      graph
	    } = model;
	    if (graph) {
	      model.startBatch('pointer');
	      this.eventData(evt, {
	        graph
	      });
	    }
	    this.notify('cell:pointerdown', evt, x, y);
	  },
	  pointermove: function (evt, x, y) {
	    this.notify('cell:pointermove', evt, x, y);
	  },
	  pointerup: function (evt, x, y) {
	    const {
	      graph
	    } = this.eventData(evt);
	    this.notify('cell:pointerup', evt, x, y);
	    if (graph) {
	      // we don't want to trigger event on model as model doesn't
	      // need to be member of collection anymore (remove)
	      graph.stopBatch('pointer', {
	        cell: this.model
	      });
	    }
	  },
	  mouseover: function (evt) {
	    this.notify('cell:mouseover', evt);
	  },
	  mouseout: function (evt) {
	    this.notify('cell:mouseout', evt);
	  },
	  mouseenter: function (evt) {
	    this.notify('cell:mouseenter', evt);
	  },
	  mouseleave: function (evt) {
	    this.notify('cell:mouseleave', evt);
	  },
	  mousewheel: function (evt, x, y, delta) {
	    this.notify('cell:mousewheel', evt, x, y, delta);
	  },
	  onevent: function (evt, eventName, x, y) {
	    this.notify(eventName, evt, x, y);
	  },
	  onmagnet: function () {

	    // noop
	  },
	  magnetpointerdblclick: function () {

	    // noop
	  },
	  magnetcontextmenu: function () {

	    // noop
	  },
	  checkMouseleave(evt) {
	    const {
	      paper,
	      model
	    } = this;
	    if (paper.isAsync()) {
	      // Make sure the source/target views are updated before this view.
	      // It's not 100% bulletproof (see below) but it's a good enough solution for now.
	      // The connected cells could be links as well. In that case, we would
	      // need to recursively go through all the connected links and update
	      // their source/target views as well.
	      if (model.isLink()) {
	        // The `this.sourceView` and `this.targetView` might not be updated yet.
	        // We need to find the view by the model.
	        const sourceElement = model.getSourceElement();
	        if (sourceElement) {
	          const sourceView = paper.findViewByModel(sourceElement);
	          if (sourceView) {
	            paper.dumpView(sourceView);
	            paper.checkViewVisibility(sourceView);
	          }
	        }
	        const targetElement = model.getTargetElement();
	        if (targetElement) {
	          const targetView = paper.findViewByModel(targetElement);
	          if (targetView) {
	            paper.dumpView(targetView);
	            paper.checkViewVisibility(targetView);
	          }
	        }
	      }
	      // Do the updates of the current view synchronously now
	      paper.dumpView(this);
	      paper.checkViewVisibility(this);
	    }
	    const target = this.getEventTarget(evt, {
	      fromPoint: true
	    });
	    const view = paper.findView(target);
	    if (view === this) return;
	    // Leaving the current view
	    this.mouseleave(evt);
	    if (!view) return;
	    // Entering another view
	    view.mouseenter(evt);
	  },
	  setInteractivity: function (value) {
	    this.options.interactive = value;
	  },
	  isIntersecting: function (geometryShape, geometryData) {
	    return intersection$1.exists(geometryShape, this.getNodeBBox(this.el), geometryData);
	  },
	  isEnclosedIn: function (geometryRect) {
	    return geometryRect.containsRect(this.getNodeBBox(this.el));
	  },
	  isInArea: function (geometryRect, options = {}) {
	    if (options.strict) {
	      return this.isEnclosedIn(geometryRect);
	    }
	    return this.isIntersecting(geometryRect);
	  },
	  isAtPoint: function (point, options) {
	    return this.getNodeBBox(this.el).containsPoint(point, options);
	  }
	}, {
	  Flags: Flags$2,
	  Highlighting: HighlightingTypes$1,
	  addPresentationAttributes: function (presentationAttributes) {
	    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {
	      if (!a || !b) return;
	      if (typeof a === 'string') a = [a];
	      if (typeof b === 'string') b = [b];
	      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));
	    });
	  },
	  evalAttribute
	});
	Object.defineProperty(CellView.prototype, 'useCSSSelectors', {
	  get() {
	    const localUse = this.model.useCSSSelectors;
	    if (localUse !== undefined) return localUse;
	    return config$3.useCSSSelectors;
	  }
	});

	// Internal tag to identify this object as a cell view instance.
	// Used instead of `instanceof` for performance and cross-frame safety.

	Object.defineProperty(CellView.prototype, CELL_VIEW_MARKER, {
	  value: true
	});

	const Flags$1 = {
	  TOOLS: CellView.Flags.TOOLS,
	  UPDATE: 'UPDATE',
	  TRANSLATE: 'TRANSLATE',
	  RESIZE: 'RESIZE',
	  PORTS: 'PORTS',
	  ROTATE: 'ROTATE',
	  RENDER: 'RENDER'
	};
	const DragActions = {
	  MOVE: 'move',
	  MAGNET: 'magnet'
	};
	// Element base view and controller.
	// -------------------------------------------

	const ElementView = CellView.extend({
	  /**
	   * @abstract
	   */
	  _removePorts: function () {
	    // implemented in ports.js
	  },
	  /**
	   *
	   * @abstract
	   */
	  _renderPorts: function () {
	    // implemented in ports.js
	  },
	  className: function () {
	    var classNames = CellView.prototype.className.apply(this).split(' ');
	    classNames.push('element');
	    return classNames.join(' ');
	  },
	  initialize: function () {
	    CellView.prototype.initialize.apply(this, arguments);
	    this._initializePorts();
	  },
	  presentationAttributes: {
	    'attrs': [Flags$1.UPDATE],
	    'position': [Flags$1.TRANSLATE, Flags$1.TOOLS],
	    'size': [Flags$1.RESIZE, Flags$1.PORTS, Flags$1.TOOLS],
	    'angle': [Flags$1.ROTATE, Flags$1.TOOLS],
	    'markup': [Flags$1.RENDER],
	    'ports': [Flags$1.PORTS]
	  },
	  initFlag: [Flags$1.RENDER],
	  UPDATE_PRIORITY: 0,
	  confirmUpdate: function (flag, opt) {
	    const {
	      useCSSSelectors
	    } = this;
	    if (this.hasFlag(flag, Flags$1.PORTS)) {
	      this._removePorts();
	      this._cleanPortsCache();
	    }
	    let transformHighlighters = false;
	    if (this.hasFlag(flag, Flags$1.RENDER)) {
	      this.render();
	      this.updateTools(opt);
	      this.updateHighlighters(true);
	      transformHighlighters = true;
	      flag = this.removeFlag(flag, [Flags$1.RENDER, Flags$1.UPDATE, Flags$1.RESIZE, Flags$1.TRANSLATE, Flags$1.ROTATE, Flags$1.PORTS, Flags$1.TOOLS]);
	    } else {
	      let updateHighlighters = false;

	      // Skip this branch if render is required
	      if (this.hasFlag(flag, Flags$1.RESIZE)) {
	        this.resize(opt);
	        updateHighlighters = true;
	        // Resize method is calling `update()` internally
	        flag = this.removeFlag(flag, [Flags$1.RESIZE, Flags$1.UPDATE]);
	        if (useCSSSelectors) {
	          // `resize()` rendered the ports when useCSSSelectors are enabled
	          flag = this.removeFlag(flag, Flags$1.PORTS);
	        }
	      }
	      if (this.hasFlag(flag, Flags$1.UPDATE)) {
	        this.update(this.model, null, opt);
	        flag = this.removeFlag(flag, Flags$1.UPDATE);
	        updateHighlighters = true;
	        if (useCSSSelectors) {
	          // `update()` will render ports when useCSSSelectors are enabled
	          flag = this.removeFlag(flag, Flags$1.PORTS);
	        }
	      }
	      if (this.hasFlag(flag, Flags$1.TRANSLATE)) {
	        this.translate();
	        flag = this.removeFlag(flag, Flags$1.TRANSLATE);
	        transformHighlighters = true;
	      }
	      if (this.hasFlag(flag, Flags$1.ROTATE)) {
	        this.rotate();
	        flag = this.removeFlag(flag, Flags$1.ROTATE);
	        transformHighlighters = true;
	      }
	      if (this.hasFlag(flag, Flags$1.PORTS)) {
	        this._renderPorts();
	        updateHighlighters = true;
	        flag = this.removeFlag(flag, Flags$1.PORTS);
	      }
	      if (updateHighlighters) {
	        this.updateHighlighters(false);
	      }
	    }
	    if (transformHighlighters) {
	      this.transformHighlighters();
	    }
	    if (this.hasFlag(flag, Flags$1.TOOLS)) {
	      this.updateTools(opt);
	      flag = this.removeFlag(flag, Flags$1.TOOLS);
	    }
	    return flag;
	  },
	  /**
	   * @abstract
	   */
	  _initializePorts: function () {
	    // implemented in ports.js
	  },
	  update: function (_, renderingOnlyAttrs) {
	    this.cleanNodesCache();

	    // When CSS selector strings are used, make sure no rule matches port nodes.
	    const {
	      useCSSSelectors
	    } = this;
	    if (useCSSSelectors) this._removePorts();
	    var model = this.model;
	    var modelAttrs = model.attr();
	    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {
	      rootBBox: new Rect(model.size()),
	      selectors: this.selectors,
	      scalableNode: this.scalableNode,
	      rotatableNode: this.rotatableNode,
	      // Use rendering only attributes if they differs from the model attributes
	      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs
	    });
	    if (useCSSSelectors) {
	      this._renderPorts();
	    }
	  },
	  rotatableSelector: 'rotatable',
	  scalableSelector: 'scalable',
	  scalableNode: null,
	  rotatableNode: null,
	  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the
	  // default markup is not desirable.
	  renderMarkup: function () {
	    var element = this.model;
	    var markup = element.get('markup') || element.markup;
	    if (!markup) throw new Error('dia.ElementView: markup required');
	    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
	    if (typeof markup === 'string') return this.renderStringMarkup(markup);
	    throw new Error('dia.ElementView: invalid markup');
	  },
	  renderJSONMarkup: function (markup) {
	    var doc = this.parseDOMJSON(markup, this.el);
	    var selectors = this.selectors = doc.selectors;
	    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;
	    this.scalableNode = V(selectors[this.scalableSelector]) || null;
	    // Fragment
	    this.vel.append(doc.fragment);
	  },
	  renderStringMarkup: function (markup) {
	    var vel = this.vel;
	    vel.append(V(markup));
	    // Cache transformation groups
	    this.rotatableNode = vel.findOne('.rotatable');
	    this.scalableNode = vel.findOne('.scalable');
	    var selectors = this.selectors = {};
	    selectors[this.selector] = this.el;
	  },
	  render: function () {
	    this.vel.empty();
	    this.renderMarkup();
	    if (this.scalableNode) {
	      // Double update is necessary for elements with the scalable group only
	      // Note the resize() triggers the other `update`.
	      this.update();
	    }
	    this.resize();
	    if (this.rotatableNode) {
	      // Translate transformation is applied on `this.el` while the rotation transformation
	      // on `this.rotatableNode`
	      this.rotate();
	      this.translate();
	    } else {
	      this.updateTransformation();
	    }
	    if (!this.useCSSSelectors) this._renderPorts();
	    return this;
	  },
	  resize: function (opt) {
	    if (this.scalableNode) return this.sgResize(opt);
	    if (this.model.attributes.angle) this.rotate();
	    this.update();
	  },
	  translate: function () {
	    if (this.rotatableNode) return this.rgTranslate();
	    this.updateTransformation();
	  },
	  rotate: function () {
	    if (this.rotatableNode) {
	      this.rgRotate();
	      // It's necessary to call the update for the nodes outside
	      // the rotatable group referencing nodes inside the group
	      this.update();
	      return;
	    }
	    this.updateTransformation();
	  },
	  updateTransformation: function () {
	    var transformation = this.getTranslateString();
	    var rotateString = this.getRotateString();
	    if (rotateString) transformation += ' ' + rotateString;
	    this.vel.attr('transform', transformation);
	  },
	  getTranslateString: function () {
	    const {
	      x,
	      y
	    } = this.model.position();
	    return `translate(${x},${y})`;
	  },
	  getRotateString: function () {
	    const angle = this.model.angle();
	    if (!angle) return null;
	    const {
	      width,
	      height
	    } = this.model.size();
	    return `rotate(${angle},${width / 2},${height / 2})`;
	  },
	  // Rotatable & Scalable Group
	  // always slower, kept mainly for backwards compatibility

	  rgRotate: function () {
	    this.rotatableNode.attr('transform', this.getRotateString());
	  },
	  rgTranslate: function () {
	    this.vel.attr('transform', this.getTranslateString());
	  },
	  sgResize: function (opt) {
	    var model = this.model;
	    var angle = model.angle();
	    var size = model.size();
	    var scalable = this.scalableNode;

	    // Getting scalable group's bbox.
	    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.
	    // To work around the issue, we need to check whether there are any path elements inside the scalable group.
	    var recursive = false;
	    if (scalable.node.getElementsByTagName('path').length > 0) {
	      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.
	      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.
	      recursive = true;
	    }
	    var scalableBBox = scalable.getBBox({
	      recursive: recursive
	    });

	    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making
	    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.
	    var sx = size.width / (scalableBBox.width || 1);
	    var sy = size.height / (scalableBBox.height || 1);
	    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');

	    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
	    // Order of transformations is significant but we want to reconstruct the object always in the order:
	    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
	    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
	    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
	    // around the center of the resized object (which is a different origin then the origin of the previous rotation)
	    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.

	    // Cancel the rotation but now around a different origin, which is the center of the scaled object.
	    var rotatable = this.rotatableNode;
	    var rotation = rotatable && rotatable.attr('transform');
	    if (rotation) {
	      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');
	      var rotatableBBox = scalable.getBBox({
	        target: this.paper.cells
	      });

	      // Store new x, y and perform rotate() again against the new rotation origin.
	      model.set('position', {
	        x: rotatableBBox.x,
	        y: rotatableBBox.y
	      }, assign({
	        updateHandled: true
	      }, opt));
	      this.translate();
	      this.rotate();
	    }

	    // Update must always be called on non-rotated element. Otherwise, relative positioning
	    // would work with wrong (rotated) bounding boxes.
	    this.update();
	  },
	  // Embedding mode methods.
	  // -----------------------

	  prepareEmbedding: function (data = {}) {
	    const element = data.model || this.model;
	    const paper = data.paper || this.paper;
	    const graph = paper.model;
	    const initialZIndices = data.initialZIndices = {};
	    const embeddedCells = element.getEmbeddedCells({
	      deep: true
	    });
	    const connectedLinks = graph.getConnectedLinks(element, {
	      deep: true,
	      includeEnclosed: true
	    });

	    // Note: an embedded cell can be a connect link, but it's fine
	    // to iterate over the cell twice.
	    [element, ...embeddedCells, ...connectedLinks].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);
	    element.startBatch('to-front');

	    // Bring the model to the front with all his embeds.
	    element.toFront({
	      deep: true,
	      ui: true
	    });

	    // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see
	    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.
	    const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);

	    // Move to front also all the inbound and outbound links that are connected
	    // to any of the element descendant. If we bring to front only embedded elements,
	    // links connected to them would stay in the background.
	    connectedLinks.forEach(link => {
	      if (link.attributes.z <= maxZ) {
	        link.set('z', maxZ + 1, {
	          ui: true
	        });
	      }
	    });
	    element.stopBatch('to-front');

	    // Before we start looking for suitable parent we remove the current one.
	    const parentId = element.parent();
	    if (parentId) {
	      const parent = graph.getCell(parentId);
	      parent.unembed(element, {
	        ui: true
	      });
	      data.initialParentId = parentId;
	    } else {
	      // `data.initialParentId` can be explicitly set to a dummy value to enable validation of unembedding.
	      data.initialParentId = data.initialParentId || null;
	    }
	  },
	  processEmbedding: function (data = {}, evt, x, y) {
	    const model = data.model || this.model;
	    const paper = data.paper || this.paper;
	    const graph = paper.model;
	    const {
	      findParentBy,
	      frontParentOnly,
	      validateEmbedding
	    } = paper.options;
	    let candidates;
	    if (isFunction(findParentBy)) {
	      candidates = toArray$1(findParentBy.call(graph, this, evt, x, y));
	    } else if (findParentBy === 'pointer') {
	      candidates = graph.findElementsAtPoint({
	        x,
	        y
	      });
	    } else {
	      candidates = graph.findElementsUnderElement(model, {
	        searchBy: findParentBy
	      });
	    }
	    candidates = candidates.filter(el => {
	      return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);
	    });
	    if (frontParentOnly) {
	      // pick the element with the highest `z` index
	      candidates = candidates.slice(-1);
	    }
	    let newCandidateView = null;
	    const prevCandidateView = data.candidateEmbedView;

	    // iterate over all candidates starting from the last one (has the highest z-index).
	    for (let i = candidates.length - 1; i >= 0; i--) {
	      const candidate = candidates[i];
	      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {
	        // candidate remains the same
	        newCandidateView = prevCandidateView;
	        break;
	      } else {
	        const view = candidate.findView(paper);
	        if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {
	          // flip to the new candidate
	          newCandidateView = view;
	          break;
	        }
	      }
	    }
	    if (newCandidateView && newCandidateView != prevCandidateView) {
	      // A new candidate view found. Highlight the new one.
	      this.clearEmbedding(data);
	      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {
	        embedding: true
	      });
	    }
	    if (!newCandidateView && prevCandidateView) {
	      // No candidate view found. Unhighlight the previous candidate.
	      this.clearEmbedding(data);
	    }
	  },
	  clearEmbedding: function (data) {
	    data || (data = {});
	    var candidateView = data.candidateEmbedView;
	    if (candidateView) {
	      // No candidate view found. Unhighlight the previous candidate.
	      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {
	        embedding: true
	      });
	      data.candidateEmbedView = null;
	    }
	  },
	  finalizeEmbedding: function (data = {}) {
	    const candidateView = data.candidateEmbedView;
	    const element = data.model || this.model;
	    const paper = data.paper || this.paper;
	    if (candidateView) {
	      // We finished embedding. Candidate view is chosen to become the parent of the model.
	      candidateView.model.embed(element, {
	        ui: true
	      });
	      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {
	        embedding: true
	      });
	      data.candidateEmbedView = null;
	    } else {
	      const {
	        validateUnembedding
	      } = paper.options;
	      const {
	        initialParentId
	      } = data;
	      // The element was originally embedded into another element.
	      // The interaction would unembed the element. Let's validate
	      // if the element can be unembedded.
	      if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {
	        this._disallowUnembed(data);
	        return;
	      }
	    }
	    paper.model.getConnectedLinks(element, {
	      deep: true
	    }).forEach(link => {
	      link.reparent({
	        ui: true
	      });
	    });
	  },
	  _disallowUnembed: function (data) {
	    const {
	      model,
	      whenNotAllowed = 'revert'
	    } = data;
	    const element = model || this.model;
	    const paper = data.paper || this.paper;
	    const graph = paper.model;
	    switch (whenNotAllowed) {
	      case 'remove':
	        {
	          element.remove({
	            ui: true
	          });
	          break;
	        }
	      case 'revert':
	        {
	          const {
	            initialParentId,
	            initialPosition,
	            initialZIndices
	          } = data;
	          // Revert the element's position (and the position of its embedded cells if any)
	          if (initialPosition) {
	            const {
	              x,
	              y
	            } = initialPosition;
	            element.position(x, y, {
	              deep: true,
	              ui: true
	            });
	          }
	          // Revert all the z-indices changed during the embedding
	          if (initialZIndices) {
	            Object.keys(initialZIndices).forEach(id => {
	              const cell = graph.getCell(id);
	              if (cell) {
	                cell.set('z', initialZIndices[id], {
	                  ui: true
	                });
	              }
	            });
	          }
	          // Revert the original parent
	          const parent = graph.getCell(initialParentId);
	          if (parent) {
	            parent.embed(element, {
	              ui: true
	            });
	          }
	          break;
	        }
	    }
	  },
	  getTargetParentView: function (evt) {
	    const {
	      candidateEmbedView = null
	    } = this.eventData(evt);
	    return candidateEmbedView;
	  },
	  getDelegatedView: function () {
	    var view = this;
	    var model = view.model;
	    var paper = view.paper;
	    while (view) {
	      if (model.isLink()) break;
	      if (!model.isEmbedded() || view.can('stopDelegation')) return view;
	      model = model.getParentCell();
	      view = paper.findViewByModel(model);
	    }
	    return null;
	  },
	  findProxyNode: function (el, type) {
	    el || (el = this.el);
	    const nodeSelector = el.getAttribute(`${type}-selector`);
	    if (nodeSelector) {
	      const port = this.findAttribute('port', el);
	      if (port) {
	        const proxyPortNode = this.findPortNode(port, nodeSelector);
	        if (proxyPortNode) return proxyPortNode;
	      } else {
	        const proxyNode = this.findNode(nodeSelector);
	        if (proxyNode) return proxyNode;
	      }
	    }
	    return el;
	  },
	  // Interaction. The controller part.
	  // ---------------------------------

	  notifyPointerdown(evt, x, y) {
	    CellView.prototype.pointerdown.call(this, evt, x, y);
	    this.notify('element:pointerdown', evt, x, y);
	  },
	  notifyPointermove(evt, x, y) {
	    CellView.prototype.pointermove.call(this, evt, x, y);
	    this.notify('element:pointermove', evt, x, y);
	  },
	  notifyPointerup(evt, x, y) {
	    this.notify('element:pointerup', evt, x, y);
	    CellView.prototype.pointerup.call(this, evt, x, y);
	  },
	  pointerdblclick: function (evt, x, y) {
	    CellView.prototype.pointerdblclick.apply(this, arguments);
	    this.notify('element:pointerdblclick', evt, x, y);
	  },
	  pointerclick: function (evt, x, y) {
	    CellView.prototype.pointerclick.apply(this, arguments);
	    this.notify('element:pointerclick', evt, x, y);
	  },
	  contextmenu: function (evt, x, y) {
	    CellView.prototype.contextmenu.apply(this, arguments);
	    this.notify('element:contextmenu', evt, x, y);
	  },
	  pointerdown: function (evt, x, y) {
	    this.notifyPointerdown(evt, x, y);
	    this.dragStart(evt, x, y);
	  },
	  pointermove: function (evt, x, y) {
	    const data = this.eventData(evt);
	    const {
	      targetMagnet,
	      action,
	      delegatedView
	    } = data;
	    if (targetMagnet) {
	      this.magnetpointermove(evt, targetMagnet, x, y);
	    }
	    switch (action) {
	      case DragActions.MAGNET:
	        this.dragMagnet(evt, x, y);
	        break;
	      case DragActions.MOVE:
	        (delegatedView || this).drag(evt, x, y);
	      // eslint: no-fallthrough=false
	      default:
	        if (data.preventPointerEvents) break;
	        this.notifyPointermove(evt, x, y);
	        break;
	    }

	    // Make sure the element view data is passed along.
	    // It could have been wiped out in the handlers above.
	    this.eventData(evt, data);
	  },
	  pointerup: function (evt, x, y) {
	    const data = this.eventData(evt);
	    const {
	      targetMagnet,
	      action,
	      delegatedView
	    } = data;
	    if (targetMagnet) {
	      this.magnetpointerup(evt, targetMagnet, x, y);
	    }
	    switch (action) {
	      case DragActions.MAGNET:
	        this.dragMagnetEnd(evt, x, y);
	        break;
	      case DragActions.MOVE:
	        (delegatedView || this).dragEnd(evt, x, y);
	      // eslint: no-fallthrough=false
	      default:
	        if (data.preventPointerEvents) break;
	        this.notifyPointerup(evt, x, y);
	    }
	    if (targetMagnet) {
	      this.magnetpointerclick(evt, targetMagnet, x, y);
	    }
	    this.checkMouseleave(evt);
	  },
	  mouseover: function (evt) {
	    CellView.prototype.mouseover.apply(this, arguments);
	    this.notify('element:mouseover', evt);
	  },
	  mouseout: function (evt) {
	    CellView.prototype.mouseout.apply(this, arguments);
	    this.notify('element:mouseout', evt);
	  },
	  mouseenter: function (evt) {
	    CellView.prototype.mouseenter.apply(this, arguments);
	    this.notify('element:mouseenter', evt);
	  },
	  mouseleave: function (evt) {
	    CellView.prototype.mouseleave.apply(this, arguments);
	    this.notify('element:mouseleave', evt);
	  },
	  mousewheel: function (evt, x, y, delta) {
	    CellView.prototype.mousewheel.apply(this, arguments);
	    this.notify('element:mousewheel', evt, x, y, delta);
	  },
	  onmagnet: function (evt, x, y) {
	    const {
	      currentTarget: targetMagnet
	    } = evt;
	    this.magnetpointerdown(evt, targetMagnet, x, y);
	    this.eventData(evt, {
	      targetMagnet
	    });
	    this.dragMagnetStart(evt, x, y);
	  },
	  magnetpointerdown: function (evt, magnet, x, y) {
	    this.notify('element:magnet:pointerdown', evt, magnet, x, y);
	  },
	  magnetpointermove: function (evt, magnet, x, y) {
	    this.notify('element:magnet:pointermove', evt, magnet, x, y);
	  },
	  magnetpointerup: function (evt, magnet, x, y) {
	    this.notify('element:magnet:pointerup', evt, magnet, x, y);
	  },
	  magnetpointerdblclick: function (evt, magnet, x, y) {
	    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);
	  },
	  magnetcontextmenu: function (evt, magnet, x, y) {
	    this.notify('element:magnet:contextmenu', evt, magnet, x, y);
	  },
	  // Drag Start Handlers

	  dragStart: function (evt, x, y) {
	    if (this.isDefaultInteractionPrevented(evt)) return;
	    var view = this.getDelegatedView();
	    if (!view || !view.can('elementMove')) return;
	    this.eventData(evt, {
	      action: DragActions.MOVE,
	      delegatedView: view
	    });
	    const position = view.model.position();
	    view.eventData(evt, {
	      initialPosition: position,
	      pointerOffset: position.difference(x, y),
	      restrictedArea: this.paper.getRestrictedArea(view, x, y)
	    });
	  },
	  dragMagnetStart: function (evt, x, y) {
	    const {
	      paper
	    } = this;
	    const isPropagationAlreadyStopped = evt.isPropagationStopped();
	    if (isPropagationAlreadyStopped) {
	      // Special case when the propagation was already stopped
	      // on the `element:magnet:pointerdown` event.
	      // Do not trigger any `element:pointer*` events
	      // but still start the magnet dragging.
	      this.eventData(evt, {
	        preventPointerEvents: true
	      });
	    }
	    if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {
	      // Stop the default action, which is to start dragging a link.
	      return;
	    }
	    const {
	      targetMagnet = evt.currentTarget
	    } = this.eventData(evt);
	    evt.stopPropagation();

	    // Invalid (Passive) magnet. Start dragging the element.
	    if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {
	      if (isPropagationAlreadyStopped) {
	        // Do not trigger `element:pointerdown` and start element dragging
	        // if the propagation was stopped.
	        this.dragStart(evt, x, y);
	        // The `element:pointerdown` event is not triggered because
	        // of `preventPointerEvents` flag.
	      } else {
	        // We need to reset the action
	        // to `MOVE` so that the element is dragged.
	        this.pointerdown(evt, x, y);
	      }
	      return;
	    }

	    // Valid magnet. Start dragging a link.
	    if (paper.options.magnetThreshold <= 0) {
	      this.dragLinkStart(evt, targetMagnet, x, y);
	    }
	    this.eventData(evt, {
	      action: DragActions.MAGNET
	    });
	  },
	  // Drag Handlers

	  snapToGrid: function (evt, x, y) {
	    const grid = this.paper.options.gridSize;
	    return {
	      x: snapToGrid$1(x, grid),
	      y: snapToGrid$1(y, grid)
	    };
	  },
	  drag: function (evt, x, y) {
	    var paper = this.paper;
	    var element = this.model;
	    var data = this.eventData(evt);
	    var {
	      pointerOffset,
	      restrictedArea,
	      embedding
	    } = data;

	    // Make sure the new element's position always snaps to the current grid
	    const {
	      x: elX,
	      y: elY
	    } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);
	    element.position(elX, elY, {
	      restrictedArea,
	      deep: true,
	      ui: true
	    });
	    if (paper.options.embeddingMode) {
	      if (!embedding) {
	        // Prepare the element for embedding only if the pointer moves.
	        // We don't want to do unnecessary action with the element
	        // if an user only clicks/dblclicks on it.
	        this.prepareEmbedding(data);
	        embedding = true;
	      }
	      this.processEmbedding(data, evt, x, y);
	    }
	    this.eventData(evt, {
	      embedding
	    });
	  },
	  dragMagnet: function (evt, x, y) {
	    this.dragLink(evt, x, y);
	  },
	  // Drag End Handlers

	  dragEnd: function (evt, x, y) {
	    var data = this.eventData(evt);
	    if (data.embedding) this.finalizeEmbedding(data);
	  },
	  dragMagnetEnd: function (evt, x, y) {
	    this.dragLinkEnd(evt, x, y);
	  },
	  magnetpointerclick: function (evt, magnet, x, y) {
	    var paper = this.paper;
	    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;
	    this.notify('element:magnet:pointerclick', evt, magnet, x, y);
	  }
	}, {
	  Flags: Flags$1
	});
	assign(ElementView.prototype, elementViewPortPrototype);

	const Flags = {
	  TOOLS: CellView.Flags.TOOLS,
	  RENDER: 'RENDER',
	  UPDATE: 'UPDATE',
	  LABELS: 'LABELS',
	  SOURCE: 'SOURCE',
	  TARGET: 'TARGET',
	  CONNECTOR: 'CONNECTOR'
	};

	// Link base view and controller.
	// ----------------------------------------

	const LinkView = CellView.extend({
	  className: function () {
	    var classNames = CellView.prototype.className.apply(this).split(' ');
	    classNames.push('link');
	    return classNames.join(' ');
	  },
	  _labelCache: null,
	  _labelSelectors: null,
	  _V: null,
	  _sourceMagnet: null,
	  _targetMagnet: null,
	  _dragData: null,
	  // deprecated

	  metrics: null,
	  decimalsRounding: 2,
	  initialize: function () {
	    CellView.prototype.initialize.apply(this, arguments);

	    // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to
	    // `<g class="label">` nodes wrapped by Vectorizer. This allows for quick access to the
	    // nodes in `updateLabelPosition()` in order to update the label positions.
	    this._labelCache = {};

	    // a cache of label selectors
	    this._labelSelectors = {};

	    // cache of default markup nodes
	    this._V = {};

	    // connection path metrics
	    this.cleanNodesCache();
	  },
	  presentationAttributes: {
	    markup: [Flags.RENDER],
	    attrs: [Flags.UPDATE],
	    router: [Flags.UPDATE],
	    connector: [Flags.CONNECTOR],
	    labels: [Flags.LABELS, Flags.TOOLS],
	    labelMarkup: [Flags.LABELS],
	    vertices: [Flags.UPDATE],
	    source: [Flags.SOURCE, Flags.UPDATE],
	    target: [Flags.TARGET, Flags.UPDATE]
	  },
	  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],
	  UPDATE_PRIORITY: 1,
	  EPSILON: 1e-6,
	  confirmUpdate: function (flags, opt = {}) {
	    const {
	      paper,
	      model
	    } = this;
	    const {
	      attributes
	    } = model;
	    const {
	      source: {
	        id: sourceId
	      },
	      target: {
	        id: targetId
	      }
	    } = attributes;
	    if (this.hasFlag(flags, Flags.SOURCE)) {
	      this._sourceMagnet = null; // reset cached source magnet
	      this.checkEndModel('source', sourceId);
	      flags = this.removeFlag(flags, Flags.SOURCE);
	    }
	    if (this.hasFlag(flags, Flags.TARGET)) {
	      this._targetMagnet = null; // reset cached target magnet
	      this.checkEndModel('target', targetId);
	      flags = this.removeFlag(flags, Flags.TARGET);
	    }
	    if (paper && (sourceId && !paper.isCellVisible(sourceId) || targetId && !paper.isCellVisible(targetId))) {
	      // Wait for the source and target views to be rendered
	      return flags;
	    }
	    if (this.hasFlag(flags, Flags.RENDER)) {
	      this.render();
	      this.updateHighlighters(true);
	      this.updateTools(opt);
	      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);
	      if (env.test('isAppleWebKit')) {
	        this.__fixWebKitBug268376();
	      }
	      return flags;
	    }
	    let updateHighlighters = false;
	    let updateLabels = this.hasFlag(flags, Flags.LABELS);
	    if (updateLabels) {
	      this.onLabelsChange(model, attributes.labels, opt);
	      flags = this.removeFlag(flags, Flags.LABELS);
	      updateHighlighters = true;
	    }
	    const updateAll = this.hasFlag(flags, Flags.UPDATE);
	    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);
	    if (updateAll || updateConnector) {
	      if (!updateAll) {
	        // Keep the current route and update the geometry
	        this.updatePath();
	        this.updateDOM();
	      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {
	        // The link is being translated by an ancestor that will
	        // shift source point, target point and all vertices
	        // by an equal distance.
	        this.translate(opt.tx, opt.ty);
	      } else {
	        this.update();
	      }
	      this.updateTools(opt);
	      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);
	      updateLabels = false;
	      updateHighlighters = true;
	    }
	    if (updateLabels) {
	      this.updateLabelPositions();
	    }
	    if (updateHighlighters) {
	      this.updateHighlighters();
	    }
	    if (this.hasFlag(flags, Flags.TOOLS)) {
	      this.updateTools(opt);
	      flags = this.removeFlag(flags, Flags.TOOLS);
	    }
	    return flags;
	  },
	  __fixWebKitBug268376: function () {
	    // WebKit has a bug where any change after the first render is not reflected in the DOM.
	    // https://bugs.webkit.org/show_bug.cgi?id=268376
	    const {
	      el
	    } = this;
	    const childNodes = Array.from(el.childNodes);
	    const fragment = document.createDocumentFragment();
	    for (let i = 0, n = childNodes.length; i < n; i++) {
	      el.removeChild(childNodes[i]);
	      fragment.appendChild(childNodes[i]);
	    }
	    el.appendChild(fragment);
	  },
	  requestConnectionUpdate: function (opt) {
	    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);
	  },
	  isLabelsRenderRequired: function (opt = {}) {
	    const previousLabels = this.model.previous('labels');
	    if (!previousLabels) return true;

	    // Here is an optimization for cases when we know, that change does
	    // not require re-rendering of all labels.
	    if ('propertyPathArray' in opt && 'propertyValue' in opt) {
	      // The label is setting by `prop()` method
	      var pathArray = opt.propertyPathArray || [];
	      var pathLength = pathArray.length;
	      if (pathLength > 1) {
	        // We are changing a single label here e.g. 'labels/0/position'
	        var labelExists = !!previousLabels[pathArray[1]];
	        if (labelExists) {
	          if (pathLength === 2) {
	            // We are changing the entire label. Need to check if the
	            // markup is also being changed.
	            return 'markup' in Object(opt.propertyValue);
	          } else if (pathArray[2] !== 'markup') {
	            // We are changing a label property but not the markup
	            return false;
	          }
	        }
	      }
	    }
	    return true;
	  },
	  onLabelsChange: function (_link, _labels, opt) {
	    // Note: this optimization works in async=false mode only
	    if (this.isLabelsRenderRequired(opt)) {
	      this.renderLabels();
	    } else {
	      this.updateLabels();
	    }
	  },
	  // Rendering.
	  // ----------

	  render: function () {
	    this.vel.empty();
	    this.unmountLabels();
	    this._V = {};
	    this.renderMarkup();
	    // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox
	    // returns zero values)
	    this.renderLabels();
	    this.update();
	    return this;
	  },
	  renderMarkup: function () {
	    var link = this.model;
	    var markup = link.get('markup') || link.markup;
	    if (!markup) throw new Error('dia.LinkView: markup required');
	    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
	    if (typeof markup === 'string') return this.renderStringMarkup(markup);
	    throw new Error('dia.LinkView: invalid markup');
	  },
	  renderJSONMarkup: function (markup) {
	    var doc = this.parseDOMJSON(markup, this.el);
	    // Selectors
	    this.selectors = doc.selectors;
	    // Fragment
	    this.vel.append(doc.fragment);
	  },
	  renderStringMarkup: function (markup) {
	    // A special markup can be given in the `properties.markup` property. This might be handy
	    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.
	    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors
	    // of elements with special meaning though. Therefore, those classes should be preserved in any
	    // special markup passed in `properties.markup`.
	    var children = V(markup);
	    // custom markup may contain only one children
	    if (!Array.isArray(children)) children = [children];
	    this.vel.append(children);
	  },
	  _getLabelMarkup: function (labelMarkup) {
	    if (!labelMarkup) return undefined;
	    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);
	    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);
	    throw new Error('dia.linkView: invalid label markup');
	  },
	  _getLabelStringMarkup: function (labelMarkup) {
	    var children = V(labelMarkup);
	    var fragment = document.createDocumentFragment();
	    if (!Array.isArray(children)) {
	      fragment.appendChild(children.node);
	    } else {
	      for (var i = 0, n = children.length; i < n; i++) {
	        var currentChild = children[i].node;
	        fragment.appendChild(currentChild);
	      }
	    }
	    return {
	      fragment: fragment,
	      selectors: {}
	    }; // no selectors
	  },
	  // Label markup fragment may come wrapped in <g class="label" />, or not.
	  // If it doesn't, add the <g /> container here.
	  _normalizeLabelMarkup: function (markup) {
	    if (!markup) return undefined;
	    var fragment = markup.fragment;
	    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');
	    var vNode;
	    var childNodes = fragment.childNodes;
	    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
	      // default markup fragment is not wrapped in <g />
	      // add a <g /> container
	      vNode = V('g').append(fragment);
	    } else {
	      vNode = V(childNodes[0]);
	    }
	    vNode.addClass('label');
	    return {
	      node: vNode.node,
	      selectors: markup.selectors
	    };
	  },
	  renderLabels: function () {
	    var cache = this._V;
	    var vLabels = cache.labels;
	    var labelCache = this._labelCache = {};
	    var labelSelectors = this._labelSelectors = {};
	    var model = this.model;
	    var labels = model.attributes.labels || [];
	    var labelsCount = labels.length;
	    if (labelsCount === 0) {
	      if (vLabels) vLabels.remove();
	      return this;
	    }
	    if (vLabels) {
	      vLabels.empty();
	    } else {
	      // there is no label container in the markup but some labels are defined
	      // add a <g class="labels" /> container
	      vLabels = cache.labels = V('g').addClass('labels');
	      if (this.options.labelsLayer) {
	        vLabels.addClass(addClassNamePrefix(result(this, 'className')));
	        vLabels.attr('model-id', model.id);
	      }
	    }
	    for (var i = 0; i < labelsCount; i++) {
	      var label = labels[i];
	      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));
	      var labelNode;
	      var selectors;
	      if (labelMarkup) {
	        labelNode = labelMarkup.node;
	        selectors = labelMarkup.selectors;
	      } else {
	        var builtinDefaultLabel = model._builtins.defaultLabel;
	        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));
	        var defaultLabel = model._getDefaultLabel();
	        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));
	        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;
	        labelNode = defaultMarkup.node;
	        selectors = defaultMarkup.selectors;
	      }
	      labelNode.setAttribute('label-idx', i); // assign label-idx
	      vLabels.append(labelNode);
	      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions

	      var rootSelector = this.selector;
	      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');
	      selectors[rootSelector] = labelNode;
	      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`
	    }
	    if (!vLabels.parent()) {
	      this.mountLabels();
	    }
	    this.updateLabels();
	    return this;
	  },
	  mountLabels: function () {
	    const {
	      el,
	      paper,
	      model,
	      _V,
	      options
	    } = this;
	    const {
	      labels: vLabels
	    } = _V;
	    if (!vLabels || !model.hasLabels()) return;
	    const {
	      node
	    } = vLabels;
	    if (options.labelsLayer) {
	      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));
	    } else {
	      if (node.parentNode !== el) {
	        el.appendChild(node);
	      }
	    }
	  },
	  unmountLabels: function () {
	    const {
	      options,
	      _V
	    } = this;
	    if (!_V) return;
	    const {
	      labels: vLabels
	    } = _V;
	    if (vLabels && options.labelsLayer) {
	      vLabels.remove();
	    }
	  },
	  findLabelNodes: function (labelIndex, selector) {
	    const labelRoot = this._labelCache[labelIndex];
	    if (!labelRoot) return [];
	    const labelSelectors = this._labelSelectors[labelIndex];
	    return this.findBySelector(selector, labelRoot, labelSelectors);
	  },
	  findLabelNode: function (labelIndex, selector) {
	    const [node = null] = this.findLabelNodes(labelIndex, selector);
	    return node;
	  },
	  // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)
	  // keep `undefined` or `null` because `{}` means something else
	  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {
	    if (labelAttrs === null) return null;
	    if (labelAttrs === undefined) {
	      if (defaultLabelAttrs === null) return null;
	      if (defaultLabelAttrs === undefined) {
	        if (hasCustomMarkup) return undefined;
	        return builtinDefaultLabelAttrs;
	      }
	      if (hasCustomMarkup) return defaultLabelAttrs;
	      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);
	    }
	    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);
	    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);
	  },
	  // merge default label size into label size (no built-in default)
	  // keep `undefined` or `null` because `{}` means something else
	  _mergeLabelSize: function (labelSize, defaultLabelSize) {
	    if (labelSize === null) return null;
	    if (labelSize === undefined) {
	      if (defaultLabelSize === null) return null;
	      if (defaultLabelSize === undefined) return undefined;
	      return defaultLabelSize;
	    }
	    return merge({}, defaultLabelSize, labelSize);
	  },
	  updateLabels: function () {
	    if (!this._V.labels) return this;
	    if (!this.paper.options.labelLayer) {
	      // If there is no label layer, the cache needs to be cleared
	      // of the root node because the labels are attached
	      // to it and could affect the bounding box.
	      this.cleanNodeCache(this.el);
	    }
	    var model = this.model;
	    var labels = model.get('labels') || [];
	    var canLabelMove = this.can('labelMove');
	    var builtinDefaultLabel = model._builtins.defaultLabel;
	    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;
	    var defaultLabel = model._getDefaultLabel();
	    var defaultLabelMarkup = defaultLabel.markup;
	    var defaultLabelAttrs = defaultLabel.attrs;
	    var defaultLabelSize = defaultLabel.size;
	    for (var i = 0, n = labels.length; i < n; i++) {
	      var labelNode = this._labelCache[i];
	      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');
	      var selectors = this._labelSelectors[i];
	      var label = labels[i];
	      var labelMarkup = label.markup;
	      var labelAttrs = label.attrs;
	      var labelSize = label.size;
	      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);
	      var size = this._mergeLabelSize(labelSize, defaultLabelSize);
	      this.updateDOMSubtreeAttributes(labelNode, attrs, {
	        rootBBox: new Rect(size),
	        selectors: selectors
	      });
	    }
	    return this;
	  },
	  // remove vertices that lie on (or nearly on) straight lines within the link
	  // return the number of removed points
	  removeRedundantLinearVertices: function (opt) {
	    const SIMPLIFY_THRESHOLD = 0.001;
	    const link = this.model;
	    const vertices = link.vertices();
	    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
	    const numRoutePoints = routePoints.length;

	    // put routePoints into a polyline and try to simplify
	    const polyline = new Polyline$1(routePoints);
	    polyline.simplify({
	      threshold: SIMPLIFY_THRESHOLD
	    });
	    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification
	    const numPolylinePoints = polylinePoints.length; // number of points after simplification

	    // shortcut if simplification did not remove any redundant vertices:
	    if (numRoutePoints === numPolylinePoints) return 0;

	    // else: set simplified polyline points as link vertices
	    // remove first and last polyline points again (= source/target anchors)
	    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);
	    return numRoutePoints - numPolylinePoints;
	  },
	  getEndView: function (type) {
	    switch (type) {
	      case 'source':
	        return this.sourceView || null;
	      case 'target':
	        return this.targetView || null;
	      default:
	        throw new Error('dia.LinkView: type parameter required.');
	    }
	  },
	  getEndAnchor: function (type) {
	    switch (type) {
	      case 'source':
	        return new Point(this.sourceAnchor);
	      case 'target':
	        return new Point(this.targetAnchor);
	      default:
	        throw new Error('dia.LinkView: type parameter required.');
	    }
	  },
	  getEndConnectionPoint: function (type) {
	    switch (type) {
	      case 'source':
	        return new Point(this.sourcePoint);
	      case 'target':
	        return new Point(this.targetPoint);
	      default:
	        throw new Error('dia.LinkView: type parameter required.');
	    }
	  },
	  getEndMagnet: function (type) {
	    switch (type) {
	      case 'source':
	        var sourceView = this.sourceView;
	        if (!sourceView) break;
	        return this.sourceMagnet || sourceView.el;
	      case 'target':
	        var targetView = this.targetView;
	        if (!targetView) break;
	        return this.targetMagnet || targetView.el;
	      default:
	        throw new Error('dia.LinkView: type parameter required.');
	    }
	    return null;
	  },
	  // Updating.
	  // ---------

	  update: function () {
	    this.updateRoute();
	    this.updatePath();
	    this.updateDOM();
	    return this;
	  },
	  translate: function (tx = 0, ty = 0) {
	    const {
	      route,
	      path
	    } = this;
	    if (!route || !path) return;
	    // translate the route
	    const polyline = new Polyline$1(route);
	    polyline.translate(tx, ty);
	    this.route = polyline.points;
	    // translate source and target connection and anchor points.
	    this.sourcePoint.offset(tx, ty);
	    this.targetPoint.offset(tx, ty);
	    this.sourceAnchor.offset(tx, ty);
	    this.targetAnchor.offset(tx, ty);
	    // translate the geometry path
	    path.translate(tx, ty);
	    this.updateDOM();
	  },
	  updateDOM() {
	    const {
	      el,
	      model,
	      selectors
	    } = this;
	    this.cleanNodesCache();
	    // update SVG attributes defined by 'attrs/'.
	    this.updateDOMSubtreeAttributes(el, model.attr(), {
	      selectors
	    });
	    // update the label position etc.
	    this.updateLabelPositions();
	    // *Deprecated*
	    // Local perpendicular flag (as opposed to one defined on paper).
	    // Could be enabled inside a connector/router. It's valid only
	    // during the update execution.
	    this.options.perpendicular = null;
	  },
	  updateRoute: function () {
	    const {
	      model
	    } = this;
	    const vertices = model.vertices();
	    // 1. Find Anchors
	    const anchors = this.findAnchors(vertices);
	    const sourceAnchor = this.sourceAnchor = anchors.source;
	    const targetAnchor = this.targetAnchor = anchors.target;
	    // 2. Find Route
	    const route = this.findRoute(vertices);
	    this.route = route;
	    // 3. Find Connection Points
	    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);
	    this.sourcePoint = connectionPoints.source;
	    this.targetPoint = connectionPoints.target;
	  },
	  updatePath: function () {
	    const {
	      route,
	      sourcePoint,
	      targetPoint
	    } = this;
	    // 4. Find Connection
	    const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());
	    this.path = path;
	  },
	  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {
	    var firstAnchor, secondAnchor;
	    var firstAnchorRef, secondAnchorRef;
	    var model = this.model;
	    var firstDef = model.get(firstEndType);
	    var secondDef = model.get(secondEndType);
	    var firstView = this.getEndView(firstEndType);
	    var secondView = this.getEndView(secondEndType);
	    var firstMagnet = this.getEndMagnet(firstEndType);
	    var secondMagnet = this.getEndMagnet(secondEndType);

	    // Anchor first
	    if (firstView) {
	      if (firstRef) {
	        firstAnchorRef = new Point(firstRef);
	      } else if (secondView) {
	        firstAnchorRef = secondMagnet;
	      } else {
	        firstAnchorRef = new Point(secondDef);
	      }
	      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);
	    } else {
	      firstAnchor = new Point(firstDef);
	    }

	    // Anchor second
	    if (secondView) {
	      secondAnchorRef = new Point(secondRef || firstAnchor);
	      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);
	    } else {
	      secondAnchor = new Point(secondDef);
	    }
	    var res = {};
	    res[firstEndType] = firstAnchor;
	    res[secondEndType] = secondAnchor;
	    return res;
	  },
	  findAnchors: function (vertices) {
	    var model = this.model;
	    var firstVertex = vertices[0];
	    var lastVertex = vertices[vertices.length - 1];
	    if (model.target().priority && !model.source().priority) {
	      // Reversed order
	      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
	    }

	    // Usual order
	    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
	  },
	  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {
	    var firstWaypoint = route[0];
	    var lastWaypoint = route[route.length - 1];
	    var model = this.model;
	    var sourceDef = model.get('source');
	    var targetDef = model.get('target');
	    var sourceView = this.sourceView;
	    var targetView = this.targetView;
	    var paperOptions = this.paper.options;
	    var sourceMagnet, targetMagnet;

	    // Connection Point Source
	    var sourcePoint;
	    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {
	      sourceMagnet = this.sourceMagnet || sourceView.el;
	      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;
	      var sourcePointRef = firstWaypoint || targetAnchor;
	      var sourceLine = new Line(sourcePointRef, sourceAnchor);
	      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
	    } else {
	      sourcePoint = sourceAnchor;
	    }
	    // Connection Point Target
	    var targetPoint;
	    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {
	      targetMagnet = this.targetMagnet || targetView.el;
	      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;
	      var targetPointRef = lastWaypoint || sourceAnchor;
	      var targetLine = new Line(targetPointRef, targetAnchor);
	      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
	    } else {
	      targetPoint = targetAnchor;
	    }
	    return {
	      source: sourcePoint,
	      target: targetPoint
	    };
	  },
	  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {
	    var isConnection = cellView.isNodeConnection(magnet);
	    var paperOptions = this.paper.options;
	    if (!anchorDef) {
	      if (isConnection) {
	        anchorDef = paperOptions.defaultLinkAnchor;
	      } else {
	        if (this.options.perpendicular) {
	          // Backwards compatibility
	          // See `manhattan` router for more details
	          anchorDef = {
	            name: 'perpendicular'
	          };
	        } else {
	          anchorDef = paperOptions.defaultAnchor;
	        }
	      }
	    }
	    if (!anchorDef) throw new Error('Anchor required.');
	    var anchorFn;
	    if (typeof anchorDef === 'function') {
	      anchorFn = anchorDef;
	    } else {
	      var anchorName = anchorDef.name;
	      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';
	      anchorFn = paperOptions[anchorNamespace][anchorName];
	      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);
	    }
	    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);
	    if (!anchor) return new Point();
	    return anchor.round(this.decimalsRounding);
	  },
	  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {
	    var connectionPoint;
	    var anchor = line.end;
	    var paperOptions = this.paper.options;
	    if (!connectionPointDef) return anchor;
	    var connectionPointFn;
	    if (typeof connectionPointDef === 'function') {
	      connectionPointFn = connectionPointDef;
	    } else {
	      var connectionPointName = connectionPointDef.name;
	      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];
	      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);
	    }
	    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);
	    if (!connectionPoint) return anchor;
	    return connectionPoint.round(this.decimalsRounding);
	  },
	  isIntersecting: function (geometryShape, geometryData) {
	    const connection = this.getConnection();
	    if (!connection) return false;
	    return intersection$1.exists(geometryShape, connection, geometryData, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  isEnclosedIn: function (geometryRect) {
	    const connection = this.getConnection();
	    if (!connection) return false;
	    const bbox = connection.bbox();
	    if (!bbox) return false;
	    return geometryRect.containsRect(bbox);
	  },
	  isAtPoint: function (point /*, options */) {
	    // Note: `strict` option is not applicable for links.
	    // There is currently no method to determine if a path contains a point.
	    const area = new Rect(point);
	    // Intersection with a zero-size area is not possible.
	    area.inflate(this.EPSILON);
	    return this.isIntersecting(area);
	  },
	  // combine default label position with built-in default label position
	  _getDefaultLabelPositionProperty: function () {
	    var model = this.model;
	    var builtinDefaultLabel = model._builtins.defaultLabel;
	    var builtinDefaultLabelPosition = builtinDefaultLabel.position;
	    var defaultLabel = model._getDefaultLabel();
	    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);
	    return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);
	  },
	  // if label position is a number, normalize it to a position object
	  // this makes sure that label positions can be merged properly
	  _normalizeLabelPosition: function (labelPosition) {
	    if (typeof labelPosition === 'number') return {
	      distance: labelPosition,
	      offset: null,
	      angle: 0,
	      args: null
	    };
	    return labelPosition;
	  },
	  // expects normalized position properties
	  // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`
	  _mergeLabelPositionProperty: function (normalizedLabelPosition, normalizedDefaultLabelPosition) {
	    if (normalizedLabelPosition === null) return null;
	    if (normalizedLabelPosition === undefined) {
	      if (normalizedDefaultLabelPosition === null) return null;
	      return normalizedDefaultLabelPosition;
	    }
	    return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);
	  },
	  updateLabelPositions: function () {
	    if (!this._V.labels) return this;
	    var path = this.path;
	    if (!path) return this;

	    // This method assumes all the label nodes are stored in the `this._labelCache` hash table
	    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.

	    var model = this.model;
	    var labels = model.get('labels') || [];
	    if (!labels.length) return this;
	    var defaultLabelPosition = this._getDefaultLabelPositionProperty();
	    for (var idx = 0, n = labels.length; idx < n; idx++) {
	      var labelNode = this._labelCache[idx];
	      if (!labelNode) continue;
	      var label = labels[idx];
	      var labelPosition = this._normalizeLabelPosition(label.position);
	      var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);
	      var transformationMatrix = this._getLabelTransformationMatrix(position);
	      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));
	      this._cleanLabelMatrices(idx);
	    }
	    return this;
	  },
	  _cleanLabelMatrices: function (index) {
	    // Clean magnetMatrix for all nodes of the label.
	    // Cached BoundingRect does not need to updated when the position changes
	    // TODO: this doesn't work for labels with XML String markups.
	    const {
	      metrics,
	      _labelSelectors
	    } = this;
	    const selectors = _labelSelectors[index];
	    if (!selectors) return;
	    for (let selector in selectors) {
	      const {
	        id
	      } = selectors[selector];
	      if (id && id in metrics) delete metrics[id].magnetMatrix;
	    }
	  },
	  checkEndModel: function (endType, endId) {
	    if (!endId) return;
	    const endModel = this.paper.getModelById(endId);
	    if (!endModel) {
	      throw new Error(`LinkView: invalid ${endType} cell.`);
	    }
	  },
	  _getLabelPositionProperty: function (idx) {
	    return this.model.label(idx).position || {};
	  },
	  _getLabelPositionAngle: function (idx) {
	    var labelPosition = this._getLabelPositionProperty(idx);
	    return labelPosition.angle || 0;
	  },
	  _getLabelPositionArgs: function (idx) {
	    var labelPosition = this._getLabelPositionProperty(idx);
	    return labelPosition.args;
	  },
	  _getDefaultLabelPositionArgs: function () {
	    var defaultLabel = this.model._getDefaultLabel();
	    var defaultLabelPosition = defaultLabel.position || {};
	    return defaultLabelPosition.args;
	  },
	  // merge default label position args into label position args
	  // keep `undefined` or `null` because `{}` means something else
	  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {
	    if (labelPositionArgs === null) return null;
	    if (labelPositionArgs === undefined) {
	      if (defaultLabelPositionArgs === null) return null;
	      return defaultLabelPositionArgs;
	    }
	    return merge({}, defaultLabelPositionArgs, labelPositionArgs);
	  },
	  // Add default label at given position at end of `labels` array.
	  // Four signatures:
	  // - obj, obj = point, opt
	  // - obj, num, obj = point, angle, opt
	  // - num, num, obj = x, y, opt
	  // - num, num, num, obj = x, y, angle, opt
	  // Assigns relative coordinates by default:
	  // `opt.absoluteDistance` forces absolute coordinates.
	  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).
	  // `opt.absoluteOffset` forces absolute coordinates for offset.
	  // Additional args:
	  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.
	  // `opt.ensureLegibility` rotates labels so they are never upside-down.
	  addLabel: function (p1, p2, p3, p4) {
	    // normalize data from the four possible signatures
	    var localX;
	    var localY;
	    var localAngle = 0;
	    var localOpt;
	    if (typeof p1 !== 'number') {
	      // {x, y} object provided as first parameter
	      localX = p1.x;
	      localY = p1.y;
	      if (typeof p2 === 'number') {
	        // angle and opt provided as second and third parameters
	        localAngle = p2;
	        localOpt = p3;
	      } else {
	        // opt provided as second parameter
	        localOpt = p2;
	      }
	    } else {
	      // x and y provided as first and second parameters
	      localX = p1;
	      localY = p2;
	      if (typeof p3 === 'number') {
	        // angle and opt provided as third and fourth parameters
	        localAngle = p3;
	        localOpt = p4;
	      } else {
	        // opt provided as third parameter
	        localOpt = p3;
	      }
	    }

	    // merge label position arguments
	    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
	    var labelPositionArgs = localOpt;
	    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);

	    // append label to labels array
	    var label = {
	      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
	    };
	    var idx = -1;
	    this.model.insertLabel(idx, label, localOpt);
	    return idx;
	  },
	  // Add a new vertex at calculated index to the `vertices` array.
	  addVertex: function (x, y, opt) {
	    // accept input in form `{ x, y }, opt` or `x, y, opt`
	    var isPointProvided = typeof x !== 'number';
	    var localX = isPointProvided ? x.x : x;
	    var localY = isPointProvided ? x.y : y;
	    var localOpt = isPointProvided ? y : opt;
	    var vertex = {
	      x: localX,
	      y: localY
	    };
	    var idx = this.getVertexIndex(localX, localY);
	    this.model.insertVertex(idx, vertex, localOpt);
	    return idx;
	  },
	  // Send a token (an SVG element, usually a circle) along the connection path.
	  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`
	  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.
	  // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)
	  // `opt.connection` is an optional selector to the connection path.
	  // `callback` is optional and is a function to be called once the token reaches the target.
	  sendToken: function (token, opt, callback) {
	    function onAnimationEnd(vToken, callback) {
	      return function () {
	        vToken.remove();
	        if (typeof callback === 'function') {
	          callback();
	        }
	      };
	    }
	    var duration, isReversed, selector;
	    if (isObject(opt)) {
	      duration = opt.duration;
	      isReversed = opt.direction === 'reverse';
	      selector = opt.connection;
	    } else {
	      // Backwards compatibility
	      duration = opt;
	      isReversed = false;
	      selector = null;
	    }
	    duration = duration || 1000;
	    var animationAttributes = {
	      dur: duration + 'ms',
	      repeatCount: 1,
	      calcMode: 'linear',
	      fill: 'freeze'
	    };
	    if (isReversed) {
	      animationAttributes.keyPoints = '1;0';
	      animationAttributes.keyTimes = '0;1';
	    }
	    var vToken = V(token);
	    var connection;
	    if (typeof selector === 'string') {
	      // Use custom connection path.
	      connection = this.findNode(selector);
	    } else {
	      // Select connection path automatically.
	      var cache = this._V;
	      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');
	    }
	    if (!(connection instanceof SVGPathElement)) {
	      throw new Error('dia.LinkView: token animation requires a valid connection path.');
	    }
	    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);
	    setTimeout(onAnimationEnd(vToken, callback), duration);
	  },
	  findRoute: function (vertices) {
	    vertices || (vertices = []);
	    var namespace = this.paper.options.routerNamespace || routers;
	    var router = this.model.router();
	    var defaultRouter = this.paper.options.defaultRouter;
	    if (!router) {
	      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified
	    }
	    var routerFn = isFunction(router) ? router : namespace[router.name];
	    if (!isFunction(routerFn)) {
	      throw new Error('dia.LinkView: unknown router: "' + router.name + '".');
	    }
	    var args = router.args || {};
	    var route = routerFn.call(this,
	    // context
	    vertices,
	    // vertices
	    args,
	    // options
	    this // linkView
	    );
	    if (!route) return vertices.map(Point);
	    return route;
	  },
	  // Return the `d` attribute value of the `<path>` element representing the link
	  // between `source` and `target`.
	  findPath: function (route, sourcePoint, targetPoint) {
	    var namespace = this.paper.options.connectorNamespace || connectors;
	    var connector = this.model.connector();
	    var defaultConnector = this.paper.options.defaultConnector;
	    if (!connector) {
	      connector = defaultConnector || {};
	    }
	    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];
	    if (!isFunction(connectorFn)) {
	      throw new Error('dia.LinkView: unknown connector: "' + connector.name + '".');
	    }
	    var args = clone$1(connector.args || {});
	    args.raw = true; // Request raw g.Path as the result.

	    var path = connectorFn.call(this,
	    // context
	    sourcePoint,
	    // start point
	    targetPoint,
	    // end point
	    route,
	    // vertices
	    args,
	    // options
	    this // linkView
	    );
	    if (typeof path === 'string') {
	      // Backwards compatibility for connectors not supporting `raw` option.
	      path = new Path$1(V.normalizePathData(path));
	    }
	    return path;
	  },
	  // Public API.
	  // -----------

	  getConnection: function () {
	    var path = this.path;
	    if (!path) return null;
	    return path.clone();
	  },
	  getSerializedConnection: function () {
	    var path = this.path;
	    if (!path) return null;
	    var metrics = this.metrics;
	    if (metrics.hasOwnProperty('data')) return metrics.data;
	    var data = path.serialize();
	    metrics.data = data;
	    return data;
	  },
	  getConnectionSubdivisions: function () {
	    var path = this.path;
	    if (!path) return null;
	    var metrics = this.metrics;
	    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;
	    var subdivisions = path.getSegmentSubdivisions();
	    metrics.segmentSubdivisions = subdivisions;
	    return subdivisions;
	  },
	  getConnectionLength: function () {
	    var path = this.path;
	    if (!path) return 0;
	    var metrics = this.metrics;
	    if (metrics.hasOwnProperty('length')) return metrics.length;
	    var length = path.length({
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	    metrics.length = length;
	    return length;
	  },
	  getPointAtLength: function (length) {
	    var path = this.path;
	    if (!path) return null;
	    return path.pointAtLength(length, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getPointAtRatio: function (ratio) {
	    var path = this.path;
	    if (!path) return null;
	    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;
	    return path.pointAt(ratio, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getTangentAtLength: function (length) {
	    var path = this.path;
	    if (!path) return null;
	    return path.tangentAtLength(length, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getTangentAtRatio: function (ratio) {
	    var path = this.path;
	    if (!path) return null;
	    return path.tangentAt(ratio, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getClosestPoint: function (point) {
	    var path = this.path;
	    if (!path) return null;
	    return path.closestPoint(point, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getClosestPointLength: function (point) {
	    var path = this.path;
	    if (!path) return null;
	    return path.closestPointLength(point, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  getClosestPointRatio: function (point) {
	    var path = this.path;
	    if (!path) return null;
	    return path.closestPointNormalizedLength(point, {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    });
	  },
	  // Get label position object based on two provided coordinates, x and y.
	  // (Used behind the scenes when user moves labels around.)
	  // Two signatures:
	  // - num, num, obj = x, y, options
	  // - num, num, num, obj = x, y, angle, options
	  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`
	  // - `absoluteOffset` is necessary in order to move beyond connection endpoints
	  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`
	  getLabelPosition: function (x, y, p3, p4) {
	    var position = {};

	    // normalize data from the two possible signatures
	    var localAngle = 0;
	    var localOpt;
	    if (typeof p3 === 'number') {
	      // angle and opt provided as third and fourth argument
	      localAngle = p3;
	      localOpt = p4;
	    } else {
	      // opt provided as third argument
	      localOpt = p3;
	    }

	    // save localOpt as `args` of the position object that is passed along
	    if (localOpt) position.args = localOpt;

	    // identify distance/offset settings
	    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default
	    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default
	    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default

	    // find closest point t
	    var path = this.path;
	    var pathOpt = {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    };
	    var labelPoint = new Point(x, y);
	    var t = path.closestPointT(labelPoint, pathOpt);

	    // DISTANCE:
	    var labelDistance = path.lengthAtT(t, pathOpt);
	    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length
	    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)
	    position.distance = labelDistance;

	    // OFFSET:
	    // use absolute offset if:
	    // - opt.absoluteOffset is true,
	    // - opt.absoluteOffset is not true but there is no tangent
	    var tangent;
	    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);
	    var labelOffset;
	    if (tangent) {
	      labelOffset = tangent.pointOffset(labelPoint);
	    } else {
	      var closestPoint = path.pointAtT(t);
	      var labelOffsetDiff = labelPoint.difference(closestPoint);
	      labelOffset = {
	        x: labelOffsetDiff.x,
	        y: labelOffsetDiff.y
	      };
	    }
	    position.offset = labelOffset;

	    // ANGLE:
	    position.angle = localAngle;
	    return position;
	  },
	  _getLabelTransformationMatrix: function (labelPosition) {
	    var labelDistance;
	    var labelAngle = 0;
	    var args = {};
	    if (typeof labelPosition === 'number') {
	      labelDistance = labelPosition;
	    } else if (typeof labelPosition.distance === 'number') {
	      args = labelPosition.args || {};
	      labelDistance = labelPosition.distance;
	      labelAngle = labelPosition.angle || 0;
	    } else {
	      throw new Error('dia.LinkView: invalid label position distance.');
	    }
	    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
	    var labelOffset = 0;
	    var labelOffsetCoordinates = {
	      x: 0,
	      y: 0
	    };
	    if (labelPosition.offset) {
	      var positionOffset = labelPosition.offset;
	      if (typeof positionOffset === 'number') labelOffset = positionOffset;
	      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;
	      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;
	    }
	    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;
	    var isKeepGradient = args.keepGradient;
	    var isEnsureLegibility = args.ensureLegibility;
	    var path = this.path;
	    var pathOpt = {
	      segmentSubdivisions: this.getConnectionSubdivisions()
	    };
	    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
	    var tangent = path.tangentAtLength(distance, pathOpt);
	    var translation;
	    var angle = labelAngle;
	    if (tangent) {
	      if (isOffsetAbsolute) {
	        translation = tangent.start.clone();
	        translation.offset(labelOffsetCoordinates);
	      } else {
	        var normal = tangent.clone();
	        normal.rotate(tangent.start, -90);
	        normal.setLength(labelOffset);
	        translation = normal.end;
	      }
	      if (isKeepGradient) {
	        angle = tangent.angle() + labelAngle;
	        if (isEnsureLegibility) {
	          angle = normalizeAngle((angle + 90) % 180 - 90);
	        }
	      }
	    } else {
	      // fallback - the connection has zero length
	      translation = path.start.clone();
	      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);
	    }
	    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
	  },
	  getLabelCoordinates: function (labelPosition) {
	    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);
	    return new Point(transformationMatrix.e, transformationMatrix.f);
	  },
	  getVertexIndex: function (x, y) {
	    var model = this.model;
	    var vertices = model.vertices();
	    var vertexLength = this.getClosestPointLength(new Point(x, y));
	    var idx = 0;
	    for (var n = vertices.length; idx < n; idx++) {
	      var currentVertex = vertices[idx];
	      var currentVertexLength = this.getClosestPointLength(currentVertex);
	      if (vertexLength < currentVertexLength) break;
	    }
	    return idx;
	  },
	  // Interaction. The controller part.
	  // ---------------------------------

	  notifyPointerdown(evt, x, y) {
	    CellView.prototype.pointerdown.call(this, evt, x, y);
	    this.notify('link:pointerdown', evt, x, y);
	  },
	  notifyPointermove(evt, x, y) {
	    CellView.prototype.pointermove.call(this, evt, x, y);
	    this.notify('link:pointermove', evt, x, y);
	  },
	  notifyPointerup(evt, x, y) {
	    this.notify('link:pointerup', evt, x, y);
	    CellView.prototype.pointerup.call(this, evt, x, y);
	  },
	  pointerdblclick: function (evt, x, y) {
	    CellView.prototype.pointerdblclick.apply(this, arguments);
	    this.notify('link:pointerdblclick', evt, x, y);
	  },
	  pointerclick: function (evt, x, y) {
	    CellView.prototype.pointerclick.apply(this, arguments);
	    this.notify('link:pointerclick', evt, x, y);
	  },
	  contextmenu: function (evt, x, y) {
	    CellView.prototype.contextmenu.apply(this, arguments);
	    this.notify('link:contextmenu', evt, x, y);
	  },
	  pointerdown: function (evt, x, y) {
	    this.notifyPointerdown(evt, x, y);
	    this.dragStart(evt, x, y);
	  },
	  pointermove: function (evt, x, y) {
	    // Backwards compatibility
	    var dragData = this._dragData;
	    if (dragData) this.eventData(evt, dragData);
	    var data = this.eventData(evt);
	    switch (data.action) {
	      case 'label-move':
	        this.dragLabel(evt, x, y);
	        break;
	      case 'arrowhead-move':
	        this.dragArrowhead(evt, x, y);
	        break;
	      case 'move':
	        this.drag(evt, x, y);
	        break;
	    }

	    // Backwards compatibility
	    if (dragData) assign(dragData, this.eventData(evt));
	    this.notifyPointermove(evt, x, y);
	  },
	  pointerup: function (evt, x, y) {
	    // Backwards compatibility
	    var dragData = this._dragData;
	    if (dragData) {
	      this.eventData(evt, dragData);
	      this._dragData = null;
	    }
	    var data = this.eventData(evt);
	    switch (data.action) {
	      case 'label-move':
	        this.dragLabelEnd(evt, x, y);
	        break;
	      case 'arrowhead-move':
	        this.dragArrowheadEnd(evt, x, y);
	        break;
	      case 'move':
	        this.dragEnd(evt, x, y);
	    }
	    this.notifyPointerup(evt, x, y);
	    this.checkMouseleave(evt);
	  },
	  mouseover: function (evt) {
	    CellView.prototype.mouseover.apply(this, arguments);
	    this.notify('link:mouseover', evt);
	  },
	  mouseout: function (evt) {
	    CellView.prototype.mouseout.apply(this, arguments);
	    this.notify('link:mouseout', evt);
	  },
	  mouseenter: function (evt) {
	    CellView.prototype.mouseenter.apply(this, arguments);
	    this.notify('link:mouseenter', evt);
	  },
	  mouseleave: function (evt) {
	    CellView.prototype.mouseleave.apply(this, arguments);
	    this.notify('link:mouseleave', evt);
	  },
	  mousewheel: function (evt, x, y, delta) {
	    CellView.prototype.mousewheel.apply(this, arguments);
	    this.notify('link:mousewheel', evt, x, y, delta);
	  },
	  onlabel: function (evt, x, y) {
	    this.notifyPointerdown(evt, x, y);
	    this.dragLabelStart(evt, x, y);
	    var stopPropagation = this.eventData(evt).stopPropagation;
	    if (stopPropagation) evt.stopPropagation();
	  },
	  // Drag Start Handlers

	  dragLabelStart: function (evt, x, y) {
	    if (this.can('labelMove')) {
	      if (this.isDefaultInteractionPrevented(evt)) return;
	      var labelNode = evt.currentTarget;
	      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);
	      var defaultLabelPosition = this._getDefaultLabelPositionProperty();
	      var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));
	      var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);
	      var coords = this.getLabelCoordinates(position);
	      var dx = coords.x - x; // how much needs to be added to cursor x to get to label x
	      var dy = coords.y - y; // how much needs to be added to cursor y to get to label y

	      var positionAngle = this._getLabelPositionAngle(labelIdx);
	      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);
	      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
	      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
	      this.eventData(evt, {
	        action: 'label-move',
	        labelIdx: labelIdx,
	        dx: dx,
	        dy: dy,
	        positionAngle: positionAngle,
	        positionArgs: positionArgs,
	        stopPropagation: true
	      });
	    } else {
	      // Backwards compatibility:
	      // If labels can't be dragged no default action is triggered.
	      this.eventData(evt, {
	        stopPropagation: true
	      });
	    }
	    this.paper.delegateDragEvents(this, evt.data);
	  },
	  dragArrowheadStart: function (evt, x, y) {
	    if (!this.can('arrowheadMove')) return;
	    var arrowheadNode = evt.target;
	    var arrowheadType = arrowheadNode.getAttribute('end');
	    var data = this.startArrowheadMove(arrowheadType, {
	      ignoreBackwardsCompatibility: true
	    });
	    this.eventData(evt, data);
	  },
	  dragStart: function (evt, x, y) {
	    if (this.isDefaultInteractionPrevented(evt)) return;
	    if (!this.can('linkMove')) return;
	    this.eventData(evt, {
	      action: 'move',
	      dx: x,
	      dy: y
	    });
	  },
	  // Drag Handlers
	  dragLabel: function (evt, x, y) {
	    var data = this.eventData(evt);
	    var label = {
	      position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)
	    };
	    if (this.paper.options.snapLabels) delete label.position.offset;
	    // The `touchmove' events are not fired
	    // when the original event target is removed from the DOM.
	    // The labels are currently re-rendered completely when only
	    // the position changes. This is why we need to make sure that
	    // the label is updated synchronously.
	    // TODO: replace `touchmove` with `pointermove` (breaking change).
	    const setOptions = {
	      ui: true
	    };
	    if (this.paper.isAsync() && evt.type === 'touchmove') {
	      setOptions.async = false;
	    }
	    this.model.label(data.labelIdx, label, setOptions);
	  },
	  dragArrowhead: function (evt, x, y) {
	    if (this.paper.options.snapLinks) {
	      const isSnapped = this._snapArrowhead(evt, x, y);
	      if (!isSnapped && this.paper.options.snapLinksSelf) {
	        this._snapArrowheadSelf(evt, x, y);
	      }
	    } else {
	      if (this.paper.options.snapLinksSelf) {
	        this._snapArrowheadSelf(evt, x, y);
	      } else {
	        this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));
	      }
	    }
	  },
	  drag: function (evt, x, y) {
	    var data = this.eventData(evt);
	    this.model.translate(x - data.dx, y - data.dy, {
	      ui: true
	    });
	    this.eventData(evt, {
	      dx: x,
	      dy: y
	    });
	  },
	  // Drag End Handlers

	  dragLabelEnd: function () {
	    // noop
	  },
	  dragArrowheadEnd: function (evt, x, y) {
	    var data = this.eventData(evt);
	    var paper = this.paper;
	    if (paper.options.snapLinks) {
	      this._snapArrowheadEnd(data);
	    } else {
	      this._connectArrowheadEnd(data, x, y);
	    }
	    if (!paper.linkAllowed(this)) {
	      // If the changed link is not allowed, revert to its previous state.
	      this._disallow(data);
	    } else {
	      this._finishEmbedding(data);
	      this._notifyConnectEvent(data, evt);
	    }
	    this._afterArrowheadMove(data);
	  },
	  dragEnd: function () {
	    // noop
	  },
	  _disallow: function (data) {
	    switch (data.whenNotAllowed) {
	      case 'remove':
	        this.model.remove({
	          ui: true
	        });
	        break;
	      case 'revert':
	      default:
	        this.model.set(data.arrowhead, data.initialEnd, {
	          ui: true
	        });
	        break;
	    }
	  },
	  _finishEmbedding: function (data) {
	    // Reparent the link if embedding is enabled
	    if (this.paper.options.embeddingMode && this.model.reparent()) {
	      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).
	      data.z = null;
	    }
	  },
	  _notifyConnectEvent: function (data, evt) {
	    var arrowhead = data.arrowhead;
	    var initialEnd = data.initialEnd;
	    var currentEnd = this.model.prop(arrowhead);
	    var endChanged = currentEnd && !Link$1.endsEqual(initialEnd, currentEnd);
	    if (endChanged) {
	      var paper = this.paper;
	      if (initialEnd.id) {
	        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);
	      }
	      if (currentEnd.id) {
	        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);
	      }
	    }
	  },
	  _snapToPoints: function (snapPoint, points, radius) {
	    let closestPointX = null;
	    let closestDistanceX = Infinity;
	    let closestPointY = null;
	    let closestDistanceY = Infinity;
	    let x = snapPoint.x;
	    let y = snapPoint.y;
	    for (let i = 0; i < points.length; i++) {
	      const distX = Math.abs(points[i].x - snapPoint.x);
	      if (distX < closestDistanceX) {
	        closestDistanceX = distX;
	        closestPointX = points[i];
	      }
	      const distY = Math.abs(points[i].y - snapPoint.y);
	      if (distY < closestDistanceY) {
	        closestDistanceY = distY;
	        closestPointY = points[i];
	      }
	    }
	    if (closestDistanceX < radius) {
	      x = closestPointX.x;
	    }
	    if (closestDistanceY < radius) {
	      y = closestPointY.y;
	    }
	    return {
	      x,
	      y
	    };
	  },
	  _snapArrowheadSelf: function (evt, x, y) {
	    const {
	      paper,
	      model
	    } = this;
	    const {
	      snapLinksSelf
	    } = paper.options;
	    const data = this.eventData(evt);
	    const radius = snapLinksSelf.radius || 20;
	    const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');
	    const vertices = model.vertices();
	    const points = [anchor, ...vertices];
	    const snapPoint = this._snapToPoints({
	      x: x,
	      y: y
	    }, points, radius);
	    const point = paper.localToClientPoint(snapPoint);
	    this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));
	  },
	  _snapArrowhead: function (evt, x, y) {
	    const {
	      paper
	    } = this;
	    const {
	      snapLinks,
	      connectionStrategy
	    } = paper.options;
	    const data = this.eventData(evt);
	    let isSnapped = false;
	    // checking view in close area of the pointer

	    const radius = snapLinks.radius || 50;
	    const findInAreaOptions = snapLinks.findInAreaOptions;
	    const prevClosestView = data.closestView || null;
	    const prevClosestMagnet = data.closestMagnet || null;
	    const prevMagnetProxy = data.magnetProxy || null;
	    data.closestView = data.closestMagnet = data.magnetProxy = null;
	    const isValidCandidate = (view, magnet) => {
	      // Do not snap to the current view
	      if (view === this) {
	        return false;
	      }
	      const isAlreadyValidated = prevClosestMagnet === magnet;
	      return isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet));
	    };
	    const closest = paper.findClosestMagnetToPoint({
	      x,
	      y
	    }, {
	      radius,
	      findInAreaOptions,
	      filter: isValidCandidate
	    });
	    data.closestView = closest ? closest.view : null;
	    data.closestMagnet = closest ? closest.magnet : null;
	    var end;
	    var magnetProxy = null;
	    var closestView = data.closestView;
	    var closestMagnet = data.closestMagnet;
	    if (closestMagnet) {
	      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');
	    }
	    var endType = data.arrowhead;
	    var newClosestMagnet = prevClosestMagnet !== closestMagnet;
	    if (prevClosestView && newClosestMagnet) {
	      prevClosestView.unhighlight(prevMagnetProxy, {
	        connecting: true,
	        snapping: true
	      });
	    }
	    if (closestView) {
	      const {
	        prevEnd,
	        prevX,
	        prevY
	      } = data;
	      data.prevX = x;
	      data.prevY = y;
	      isSnapped = true;
	      if (!newClosestMagnet) {
	        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {
	          // the magnet has not changed and the link's end does not depend on the x and y
	          return isSnapped;
	        }
	      }
	      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);
	      if (!newClosestMagnet && isEqual(prevEnd, end)) {
	        // the source/target json has not changed
	        return isSnapped;
	      }
	      data.prevEnd = end;
	      if (newClosestMagnet) {
	        closestView.highlight(magnetProxy, {
	          connecting: true,
	          snapping: true
	        });
	      }
	    } else {
	      end = {
	        x: x,
	        y: y
	      };
	    }
	    this.model.set(endType, end || {
	      x: x,
	      y: y
	    }, {
	      ui: true
	    });
	    if (prevClosestView) {
	      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);
	    }
	    if (closestView) {
	      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);
	    }
	    return isSnapped;
	  },
	  _snapArrowheadEnd: function (data) {
	    // Finish off link snapping.
	    // Everything except view unhighlighting was already done on pointermove.
	    var closestView = data.closestView;
	    var closestMagnet = data.closestMagnet;
	    if (closestView && closestMagnet) {
	      closestView.unhighlight(data.magnetProxy, {
	        connecting: true,
	        snapping: true
	      });
	      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);
	    }
	    data.closestView = data.closestMagnet = null;
	  },
	  _connectArrowhead: function (target, x, y, data) {
	    // checking views right under the pointer
	    const {
	      paper,
	      model
	    } = this;
	    if (data.eventTarget !== target) {
	      // Unhighlight the previous view under pointer if there was one.
	      if (data.magnetProxy) {
	        data.viewUnderPointer.unhighlight(data.magnetProxy, {
	          connecting: true
	        });
	      }
	      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);
	      if (viewUnderPointer) {
	        // If we found a view that is under the pointer, we need to find the closest
	        // magnet based on the real target element of the event.
	        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);
	        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');
	        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {
	          // If there was no magnet found, do not highlight anything and assume there
	          // is no view under pointer we're interested in reconnecting to.
	          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.
	          if (magnetProxy) {
	            viewUnderPointer.highlight(magnetProxy, {
	              connecting: true
	            });
	          }
	        } else {
	          // This type of connection is not valid. Disregard this magnet.
	          data.magnetUnderPointer = null;
	          data.magnetProxy = null;
	        }
	      } else {
	        // Make sure we'll unset previous magnet.
	        data.magnetUnderPointer = null;
	        data.magnetProxy = null;
	      }
	    }
	    data.eventTarget = target;
	    model.set(data.arrowhead, {
	      x: x,
	      y: y
	    }, {
	      ui: true
	    });
	  },
	  _connectArrowheadEnd: function (data = {}, x, y) {
	    const {
	      model
	    } = this;
	    const {
	      viewUnderPointer,
	      magnetUnderPointer,
	      magnetProxy,
	      arrowhead
	    } = data;
	    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;
	    viewUnderPointer.unhighlight(magnetProxy, {
	      connecting: true
	    });

	    // The link end is taken from the magnet under the pointer, not the proxy.
	    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);
	    model.set(arrowhead, end, {
	      ui: true
	    });
	  },
	  _beforeArrowheadMove: function (data) {
	    data.z = this.model.get('z');
	    this.model.toFront();

	    // Let the pointer propagate through the link view elements so that
	    // the `evt.target` is another element under the pointer, not the link itself.
	    var style = this.el.style;
	    data.pointerEvents = style.pointerEvents;
	    style.pointerEvents = 'none';
	    if (this.paper.options.markAvailable) {
	      this._markAvailableMagnets(data);
	    }
	  },
	  _afterArrowheadMove: function (data) {
	    if (data.z !== null) {
	      this.model.set('z', data.z, {
	        ui: true
	      });
	      data.z = null;
	    }

	    // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.
	    this.el.style.pointerEvents = data.pointerEvents;
	    if (this.paper.options.markAvailable) {
	      this._unmarkAvailableMagnets(data);
	    }
	  },
	  _createValidateConnectionArgs: function (arrowhead) {
	    // It makes sure the arguments for validateConnection have the following form:
	    // (source view, source magnet, target view, target magnet and link view)
	    var args = [];
	    args[4] = arrowhead;
	    args[5] = this;
	    var oppositeArrowhead;
	    var i = 0;
	    var j = 0;
	    if (arrowhead === 'source') {
	      i = 2;
	      oppositeArrowhead = 'target';
	    } else {
	      j = 2;
	      oppositeArrowhead = 'source';
	    }
	    var end = this.model.get(oppositeArrowhead);
	    if (end.id) {
	      var view = args[i] = this.paper.findViewByModel(end.id);
	      var magnet = view.getMagnetFromLinkEnd(end);
	      if (magnet === view.el) magnet = undefined;
	      args[i + 1] = magnet;
	    }
	    function validateConnectionArgs(cellView, magnet) {
	      args[j] = cellView;
	      args[j + 1] = cellView.el === magnet ? undefined : magnet;
	      return args;
	    }
	    return validateConnectionArgs;
	  },
	  _markAvailableMagnets: function (data) {
	    function isMagnetAvailable(view, magnet) {
	      var paper = view.paper;
	      var validate = paper.options.validateConnection;
	      return validate.apply(paper, this.validateConnectionArgs(view, magnet));
	    }
	    var paper = this.paper;
	    var elements = paper.model.getCells();
	    data.marked = {};
	    for (var i = 0, n = elements.length; i < n; i++) {
	      var view = elements[i].findView(paper);
	      if (!view) {
	        continue;
	      }
	      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));
	      if (view.el.getAttribute('magnet') !== 'false') {
	        // Element wrapping group is also a magnet
	        magnets.push(view.el);
	      }
	      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));
	      if (availableMagnets.length > 0) {
	        // highlight all available magnets
	        for (var j = 0, m = availableMagnets.length; j < m; j++) {
	          view.highlight(availableMagnets[j], {
	            magnetAvailability: true
	          });
	        }
	        // highlight the entire view
	        view.highlight(null, {
	          elementAvailability: true
	        });
	        data.marked[view.model.id] = availableMagnets;
	      }
	    }
	  },
	  _unmarkAvailableMagnets: function (data) {
	    var markedKeys = Object.keys(data.marked);
	    var id;
	    var markedMagnets;
	    for (var i = 0, n = markedKeys.length; i < n; i++) {
	      id = markedKeys[i];
	      markedMagnets = data.marked[id];
	      var view = this.paper.findViewByModel(id);
	      if (view) {
	        for (var j = 0, m = markedMagnets.length; j < m; j++) {
	          view.unhighlight(markedMagnets[j], {
	            magnetAvailability: true
	          });
	        }
	        view.unhighlight(null, {
	          elementAvailability: true
	        });
	      }
	    }
	    data.marked = null;
	  },
	  startArrowheadMove: function (end, opt) {
	    opt || (opt = {});

	    // Allow to delegate events from an another view to this linkView in order to trigger arrowhead
	    // move without need to click on the actual arrowhead dom element.
	    var data = {
	      action: 'arrowhead-move',
	      arrowhead: end,
	      whenNotAllowed: opt.whenNotAllowed || 'revert',
	      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),
	      initialEnd: clone$1(this.model.get(end)),
	      validateConnectionArgs: this._createValidateConnectionArgs(end)
	    };
	    this._beforeArrowheadMove(data);
	    if (opt.ignoreBackwardsCompatibility !== true) {
	      this._dragData = data;
	    }
	    return data;
	  },
	  // Lifecycle methods

	  onMount: function () {
	    CellView.prototype.onMount.apply(this, arguments);
	    this.mountLabels();
	  },
	  onDetach: function () {
	    CellView.prototype.onDetach.apply(this, arguments);
	    this.unmountLabels();
	  },
	  onRemove: function () {
	    CellView.prototype.onRemove.apply(this, arguments);
	    this.unmountLabels();
	  }
	}, {
	  Flags: Flags
	});
	Object.defineProperty(LinkView.prototype, 'sourceView', {
	  enumerable: true,
	  get: function () {
	    const source = this.model.attributes.source;
	    if (source.id && this.paper) {
	      return this.paper.findViewByModel(source.id);
	    }
	    return null;
	  }
	});
	Object.defineProperty(LinkView.prototype, 'targetView', {
	  enumerable: true,
	  get: function () {
	    const target = this.model.attributes.target;
	    if (target.id && this.paper) {
	      return this.paper.findViewByModel(target.id);
	    }
	    return null;
	  }
	});
	Object.defineProperty(LinkView.prototype, 'sourceMagnet', {
	  enumerable: true,
	  get: function () {
	    const sourceView = this.sourceView;
	    if (!sourceView) return null;
	    let sourceMagnet = null;
	    // Check if the magnet is already found and cached.
	    // We need to check if the cached magnet is still part of the source view.
	    // The source view might have been disposed and recreated, or the magnet might have been changed.
	    const cachedSourceMagnet = this._sourceMagnet;
	    if (cachedSourceMagnet && sourceView.el.contains(cachedSourceMagnet)) {
	      sourceMagnet = cachedSourceMagnet;
	    } else {
	      // If the cached magnet is not valid, we need to find the magnet.
	      sourceMagnet = sourceView.getMagnetFromLinkEnd(this.model.attributes.source);
	    }
	    this._sourceMagnet = sourceMagnet;
	    if (sourceMagnet === sourceView.el) {
	      // If the source magnet is the element itself, we treat it as no magnet.
	      return null;
	    }
	    return sourceMagnet;
	  }
	});
	Object.defineProperty(LinkView.prototype, 'targetMagnet', {
	  enumerable: true,
	  get: function () {
	    const targetView = this.targetView;
	    if (!targetView) return null;
	    let targetMagnet = null;
	    // Check if the magnet is already found and cached (See `sourceMagnet` for explanation).
	    const cachedTargetMagnet = this._targetMagnet;
	    if (cachedTargetMagnet && targetView.el.contains(cachedTargetMagnet)) {
	      targetMagnet = cachedTargetMagnet;
	    } else {
	      // If the cached magnet is not valid, we need to find the magnet.
	      targetMagnet = targetView.getMagnetFromLinkEnd(this.model.attributes.target);
	    }
	    this._targetMagnet = targetMagnet;
	    if (targetMagnet === targetView.el) {
	      // If the target magnet is the element itself, we treat it as no magnet.
	      return null;
	    }
	    return targetMagnet;
	  }
	});
	Object.defineProperty(LinkView.prototype, 'sourceBBox', {
	  enumerable: true,
	  get: function () {
	    var sourceView = this.sourceView;
	    if (!sourceView) {
	      var sourceDef = this.model.source();
	      return new Rect(sourceDef.x, sourceDef.y);
	    }
	    var sourceMagnet = this.sourceMagnet;
	    if (sourceView.isNodeConnection(sourceMagnet)) {
	      return new Rect(this.sourceAnchor);
	    }
	    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);
	  }
	});
	Object.defineProperty(LinkView.prototype, 'targetBBox', {
	  enumerable: true,
	  get: function () {
	    var targetView = this.targetView;
	    if (!targetView) {
	      var targetDef = this.model.target();
	      return new Rect(targetDef.x, targetDef.y);
	    }
	    var targetMagnet = this.targetMagnet;
	    if (targetView.isNodeConnection(targetMagnet)) {
	      return new Rect(this.targetAnchor);
	    }
	    return targetView.getNodeBBox(targetMagnet || targetView.el);
	  }
	});

	const LayerView = View.extend({
	  tagName: 'g',
	  svgElement: true,
	  pivotNodes: null,
	  defaultTheme: null,
	  UPDATE_PRIORITY: 4,
	  options: {
	    id: ''
	  },
	  paper: null,
	  init: function () {
	    this.pivotNodes = {};
	    this.id = this.options.id || this.cid;
	  },
	  setPaperReference: function (paper) {
	    this.paper = paper;
	    this.afterPaperReferenceSet(paper);
	  },
	  unsetPaperReference: function () {
	    if (!this.paper) return;
	    this.beforePaperReferenceUnset(this.paper);
	    this.paper = null;
	  },
	  assertPaperReference() {
	    if (!this.paper) {
	      throw new Error('LayerView: paper reference is not set.');
	    }
	  },
	  afterPaperReferenceSet: function () {
	    // Can be overridden in subclasses.
	  },
	  beforePaperReferenceUnset: function () {
	    // Can be overridden in subclasses.
	  },
	  // prevents id to be set on the DOM element
	  _setAttributes: function (attrs) {
	    const newAttrs = clone$1(attrs);
	    delete newAttrs.id;
	    View.prototype._setAttributes.call(this, newAttrs);
	  },
	  className: function () {
	    const {
	      id
	    } = this.options;
	    return addClassNamePrefix(`${id}-layer`);
	  },
	  insertSortedNode: function (node, z) {
	    this.el.insertBefore(node, this.insertPivot(z));
	  },
	  insertNode: function (node) {
	    const {
	      el
	    } = this;
	    if (node.parentNode !== el) {
	      el.appendChild(node);
	    }
	  },
	  insertPivot: function (z) {
	    const {
	      el,
	      pivotNodes
	    } = this;
	    z = +z;
	    z || (z = 0);
	    let pivotNode = pivotNodes[z];
	    if (pivotNode) return pivotNode;
	    pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));
	    let neighborZ = -Infinity;
	    for (let currentZ in pivotNodes) {
	      currentZ = +currentZ;
	      if (currentZ < z && currentZ > neighborZ) {
	        neighborZ = currentZ;
	        if (neighborZ === z - 1) continue;
	      }
	    }
	    if (neighborZ !== -Infinity) {
	      const neighborPivot = pivotNodes[neighborZ];
	      // Insert After
	      el.insertBefore(pivotNode, neighborPivot.nextSibling);
	    } else {
	      // First Child
	      el.insertBefore(pivotNode, el.firstChild);
	    }
	    return pivotNode;
	  },
	  removePivots: function () {
	    const {
	      el,
	      pivotNodes
	    } = this;
	    for (let z in pivotNodes) el.removeChild(pivotNodes[z]);
	    this.pivotNodes = {};
	  },
	  isEmpty: function () {
	    // Check if the layer has any child elements (pivot comments are not counted).
	    return this.el.children.length === 0;
	  },
	  reset: function () {
	    this.removePivots();
	  }
	});
	Object.defineProperty(LayerView.prototype, LAYER_VIEW_MARKER, {
	  value: true
	});

	/**
	 * @class GraphLayerView
	 * @description A GraphLayerView is responsible for managing the rendering of cell views inside a layer.
	 * It listens to the corresponding GraphLayer model and updates the DOM accordingly.
	 * It uses dia.Paper sorting options to sort cell views in the DOM based on their `z` attribute.
	 */
	const GraphLayerView = LayerView.extend({
	  SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],
	  style: {
	    webkitUserSelect: 'none',
	    userSelect: 'none'
	  },
	  graph: null,
	  init() {
	    LayerView.prototype.init.apply(this, arguments);
	    this.graph = this.model.graph;
	  },
	  className: function () {
	    const {
	      id
	    } = this.options;
	    return [addClassNamePrefix(`${id}-layer`), addClassNamePrefix('cells')].join(' ');
	  },
	  afterPaperReferenceSet(paper) {
	    this.listenTo(this.model, 'sort', this.onCellCollectionSort);
	    this.listenTo(this.model, 'change', this.onCellChange);
	    this.listenTo(this.model, 'move', this.onCellMove);
	    this.listenTo(this.graph, 'batch:stop', this.onGraphBatchStop);
	  },
	  beforePaperReferenceUnset() {
	    this.stopListening(this.model);
	    this.stopListening(this.graph);
	  },
	  onCellCollectionSort() {
	    if (this.graph.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;
	    this.sort();
	  },
	  onCellMove(cell, opt = {}) {
	    // When a cell is moved from one layer to another,
	    // request insertion of its view in the new layer.
	    this.paper.requestCellViewInsertion(cell, opt);
	  },
	  onCellChange(cell, opt) {
	    if (!cell.hasChanged('z')) return;
	    // Re-insert the cell view to maintain correct z-ordering
	    if (this.paper.options.sorting === sortingTypes.APPROX) {
	      this.paper.requestCellViewInsertion(cell, opt);
	    }
	  },
	  onGraphBatchStop(data) {
	    const name = data && data.batchName;
	    const sortDelayingBatches = this.SORT_DELAYING_BATCHES;
	    // After certain batches, sorting may be required
	    if (sortDelayingBatches.includes(name) && !this.graph.hasActiveBatch(sortDelayingBatches)) {
	      this.sort();
	    }
	  },
	  sort() {
	    this.assertPaperReference();
	    const {
	      paper
	    } = this;
	    if (!paper.isExactSorting()) {
	      // noop
	      return;
	    }
	    if (paper.isFrozen()) {
	      // sort views once unfrozen
	      paper._updates.sort = true;
	      return;
	    }
	    this.sortExact();
	  },
	  sortExact() {
	    // Run insertion sort algorithm in order to efficiently sort DOM elements according to their
	    // associated model `z` attribute.
	    const cellNodes = Array.from(this.el.children).filter(node => node.getAttribute('model-id'));
	    const cellCollection = this.model.cellCollection;
	    sortElements(cellNodes, function (a, b) {
	      const cellA = cellCollection.get(a.getAttribute('model-id'));
	      const cellB = cellCollection.get(b.getAttribute('model-id'));
	      const zA = cellA.attributes.z || 0;
	      const zB = cellB.attributes.z || 0;
	      return zA === zB ? 0 : zA < zB ? -1 : 1;
	    });
	  },
	  insertCellView(cellView) {
	    this.assertPaperReference();
	    const {
	      paper
	    } = this;
	    const {
	      el,
	      model
	    } = cellView;
	    switch (paper.options.sorting) {
	      case sortingTypes.APPROX:
	        this.insertSortedNode(el, model.get('z'));
	        break;
	      case sortingTypes.EXACT:
	      default:
	        this.insertNode(el);
	        break;
	    }
	  }
	});
	Object.defineProperty(GraphLayerView.prototype, GRAPH_LAYER_VIEW_MARKER, {
	  value: true
	});

	/**
	 * @class LegacyGraphLayerView
	 * @description A legacy GraphLayerView with an additional class name for backward compatibility.
	 */
	const LegacyGraphLayerView = GraphLayerView.extend({
	  className: function () {
	    const className = GraphLayerView.prototype.className.apply(this, arguments);
	    return className + ' ' + addClassNamePrefix('viewport');
	  }
	});

	/**
	 * Deque implementation for managing a double-ended queue.
	 * This implementation uses a doubly linked list for efficient operations.
	 * It supports operations like push, pop, move to head, and delete.
	 * The deque maintains a map for O(1) access to nodes by key.
	 */
	class Deque {
	  constructor() {
	    this.head = null;
	    this.tail = null;
	    this.map = new Map(); // key -> node
	  }

	  // Return an array of keys in the deque
	  keys() {
	    let current = this.head;
	    const keys = [];
	    while (current) {
	      keys.push(current.key);
	      current = current.next;
	    }
	    return keys;
	  }

	  // Return the first node and remove it from the deque
	  popHead() {
	    if (!this.head) return null;
	    const node = this.head;
	    this.map.delete(node.key);
	    this.head = node.next;
	    if (this.head) {
	      this.head.prev = null;
	    } else {
	      this.tail = null;
	    }
	    return node;
	  }

	  // Add a new node to the back of the deque
	  pushTail(key, value) {
	    if (this.map.has(key)) {
	      throw new Error(`Key "${key}" already exists in the deque.`);
	    }
	    const node = {
	      key,
	      value,
	      prev: null,
	      next: null
	    };
	    this.map.set(key, node);
	    if (!this.tail) {
	      this.head = this.tail = node;
	    } else {
	      this.tail.next = node;
	      node.prev = this.tail;
	      this.tail = node;
	    }
	  }

	  // Move a node from the deque to the head
	  moveToHead(key) {
	    const node = this.map.get(key);
	    if (!node) return;
	    if (node === this.head) return; // already at head
	    // Remove node from its current position
	    if (node.prev) node.prev.next = node.next;
	    if (node.next) node.next.prev = node.prev;
	    if (node === this.tail) this.tail = node.prev; // if it's the tail
	    if (node === this.head) this.head = node.next; // if it's the head
	    // Move node to head
	    node.prev = null;
	    node.next = this.head;
	    if (this.head) {
	      this.head.prev = node; // link old head back to new head
	    }
	    this.head = node; // update head to be the moved node
	    if (!this.tail) {
	      this.tail = node; // if it was the only node, set tail as well
	    }
	  }

	  // Return the first node without removing it
	  peekHead() {
	    return this.head || null;
	  }

	  // Move the head node to the back of the deque
	  rotate() {
	    if (!this.head || !this.head.next) return;
	    this.tail.next = this.head; // link tail to head
	    this.head.prev = this.tail; // link head back to tail
	    this.tail = this.head; // update tail to be the old head
	    this.head = this.head.next; // move head to the next node
	    this.tail.next = null; // set new tail's next to null
	    this.head.prev = null; // set new head's prev to null
	  }

	  // Remove a node from the deque
	  delete(key) {
	    const node = this.map.get(key);
	    if (!node) return;
	    if (node.prev) node.prev.next = node.next;else this.head = node.next;
	    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;
	    this.map.delete(key);
	  }

	  // Does the deque contain a node with the given key?
	  has(key) {
	    return this.map.has(key);
	  }

	  // Get the node with the given key
	  get(key) {
	    return this.map.get(key) || null;
	  }

	  // Number of nodes in the deque
	  get length() {
	    return this.map.size;
	  }
	}

	const GridLayerView = LayerView.extend({
	  style: {
	    'pointer-events': 'none'
	  },
	  _gridCache: null,
	  _gridSettings: null,
	  init() {
	    LayerView.prototype.init.apply(this, arguments);
	    this.paper = this.options.paper;
	    this._gridCache = null;
	    this._gridSettings = [];
	  },
	  afterPaperReferenceSet(paper) {
	    this.listenTo(paper, 'transform resize', this.updateGrid);
	  },
	  beforePaperReferenceUnset(paper) {
	    this.stopListening(paper);
	  },
	  setGrid(drawGrid) {
	    this._gridSettings = this.getGridSettings(drawGrid);
	    this.renderGrid();
	  },
	  getGridSettings(drawGrid) {
	    const gridSettings = [];
	    if (drawGrid) {
	      const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];
	      optionsList.forEach(item => {
	        gridSettings.push(...this._resolveDrawGridOption(item));
	      });
	    }
	    return gridSettings;
	  },
	  removeGrid() {
	    const {
	      _gridCache: grid
	    } = this;
	    if (!grid) return;
	    grid.root.remove();
	    this._gridCache = null;
	  },
	  renderGrid() {
	    const {
	      paper
	    } = this;
	    const {
	      _gridSettings: gridSettings
	    } = this;
	    this.removeGrid();
	    if (gridSettings.length === 0) return;
	    const gridSize = paper.options.drawGridSize || paper.options.gridSize;
	    if (gridSize <= 1) {
	      return;
	    }
	    const refs = this._getGridRefs();
	    gridSettings.forEach((gridLayerSetting, index) => {
	      const id = this._getPatternId(index);
	      const options = merge({}, gridLayerSetting);
	      const {
	        scaleFactor = 1
	      } = options;
	      options.width = gridSize * scaleFactor || 1;
	      options.height = gridSize * scaleFactor || 1;
	      let vPattern;
	      if (!refs.exist(id)) {
	        vPattern = V('pattern', {
	          id: id,
	          patternUnits: 'userSpaceOnUse'
	        }, V(options.markup));
	        refs.add(id, vPattern);
	      } else {
	        vPattern = refs.get(id);
	      }
	      if (isFunction(options.render)) {
	        options.render(vPattern.node.firstChild, options, paper);
	      }
	      vPattern.attr({
	        width: options.width,
	        height: options.height
	      });
	    });
	    refs.root.appendTo(this.el);
	    this.updateGrid();
	  },
	  updateGrid() {
	    const {
	      _gridCache: grid,
	      _gridSettings: gridSettings,
	      paper
	    } = this;
	    if (!grid) return;
	    const {
	      root: vSvg,
	      patterns
	    } = grid;
	    const {
	      x,
	      y,
	      width,
	      height
	    } = paper.getArea();
	    vSvg.attr({
	      x,
	      y,
	      width,
	      height
	    });
	    for (const patternId in patterns) {
	      const vPattern = patterns[patternId];
	      vPattern.attr({
	        x: -x,
	        y: -y
	      });
	    }
	    gridSettings.forEach((options, index) => {
	      if (isFunction(options.update)) {
	        const vPattern = patterns[this._getPatternId(index)];
	        options.update(vPattern.node.firstChild, options, paper);
	      }
	    });
	  },
	  _getPatternId(index) {
	    return `pattern_${this.paper.cid}_${index}`;
	  },
	  _getGridRefs() {
	    let {
	      _gridCache: grid
	    } = this;
	    if (grid) return grid;
	    const defsVEl = V('defs');
	    const svgVEl = V('svg', {
	      width: '100%',
	      height: '100%'
	    }, [defsVEl]);
	    grid = this._gridCache = {
	      root: svgVEl,
	      patterns: {},
	      add: function (id, patternVEl) {
	        const rectVEl = V('rect', {
	          width: '100%',
	          height: '100%',
	          fill: `url(#${id})`
	        });
	        defsVEl.append(patternVEl);
	        svgVEl.append(rectVEl);
	        this.patterns[id] = patternVEl;
	      },
	      get: function (id) {
	        return this.patterns[id];
	      },
	      exist: function (id) {
	        return this.patterns[id] !== undefined;
	      }
	    };
	    return grid;
	  },
	  _resolveDrawGridOption(opt) {
	    const namespace = this.options.patterns;
	    if (isString(opt) && Array.isArray(namespace[opt])) {
	      return namespace[opt].map(function (item) {
	        return assign({}, item);
	      });
	    }
	    const options = opt || {
	      args: [{}]
	    };
	    const isArray = Array.isArray(options);
	    let name = options.name;
	    if (!isArray && !name && !options.markup) {
	      name = 'dot';
	    }
	    if (name && Array.isArray(namespace[name])) {
	      const pattern = namespace[name].map(function (item) {
	        return assign({}, item);
	      });
	      const args = Array.isArray(options.args) ? options.args : [options.args || {}];
	      defaults(args[0], omit(opt, 'args'));
	      for (let i = 0; i < args.length; i++) {
	        if (pattern[i]) {
	          assign(pattern[i], args[i]);
	        }
	      }
	      return pattern;
	    }
	    return isArray ? options : [options];
	  },
	  isEmpty() {
	    const {
	      _gridCache: grid
	    } = this;
	    return this.el.children.length === (grid ? 1 : 0);
	  }
	});

	const paperLayers = {
	  GRID: 'grid',
	  BACK: 'back',
	  /** @deprecated */
	  CELLS: 'cells',
	  FRONT: 'front',
	  TOOLS: 'tools',
	  LABELS: 'labels'
	};
	const sortingTypes = {
	  NONE: 'sorting-none',
	  APPROX: 'sorting-approximate',
	  EXACT: 'sorting-exact'
	};
	const WHEEL_CAP = 50;
	const WHEEL_WAIT_MS = 20;
	const MOUNT_BATCH_SIZE = 1000;
	const UPDATE_BATCH_SIZE = Infinity;
	const MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER

	const HighlightingTypes = CellView.Highlighting;
	const defaultHighlighting = {
	  [HighlightingTypes.DEFAULT]: {
	    name: 'stroke',
	    options: {
	      padding: 3
	    }
	  },
	  [HighlightingTypes.MAGNET_AVAILABILITY]: {
	    name: 'addClass',
	    options: {
	      className: 'available-magnet'
	    }
	  },
	  [HighlightingTypes.ELEMENT_AVAILABILITY]: {
	    name: 'addClass',
	    options: {
	      className: 'available-cell'
	    }
	  }
	};
	const gridPatterns = {
	  dot: [{
	    color: '#AAAAAA',
	    thickness: 1,
	    markup: 'rect',
	    render: function (el, opt) {
	      V(el).attr({
	        width: opt.thickness,
	        height: opt.thickness,
	        fill: opt.color
	      });
	    }
	  }],
	  fixedDot: [{
	    color: '#AAAAAA',
	    thickness: 1,
	    markup: 'rect',
	    render: function (el, opt) {
	      V(el).attr({
	        fill: opt.color
	      });
	    },
	    update: function (el, opt, paper) {
	      const {
	        sx,
	        sy
	      } = paper.scale();
	      const width = sx <= 1 ? opt.thickness : opt.thickness / sx;
	      const height = sy <= 1 ? opt.thickness : opt.thickness / sy;
	      V(el).attr({
	        width,
	        height
	      });
	    }
	  }],
	  mesh: [{
	    color: '#AAAAAA',
	    thickness: 1,
	    markup: 'path',
	    render: function (el, opt) {
	      var d;
	      var width = opt.width;
	      var height = opt.height;
	      var thickness = opt.thickness;
	      if (width - thickness >= 0 && height - thickness >= 0) {
	        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
	      } else {
	        d = 'M 0 0 0 0';
	      }
	      V(el).attr({
	        'd': d,
	        stroke: opt.color,
	        'stroke-width': opt.thickness
	      });
	    }
	  }],
	  doubleMesh: [{
	    color: '#AAAAAA',
	    thickness: 1,
	    markup: 'path',
	    render: function (el, opt) {
	      var d;
	      var width = opt.width;
	      var height = opt.height;
	      var thickness = opt.thickness;
	      if (width - thickness >= 0 && height - thickness >= 0) {
	        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
	      } else {
	        d = 'M 0 0 0 0';
	      }
	      V(el).attr({
	        'd': d,
	        stroke: opt.color,
	        'stroke-width': opt.thickness
	      });
	    }
	  }, {
	    color: '#000000',
	    thickness: 3,
	    scaleFactor: 4,
	    markup: 'path',
	    render: function (el, opt) {
	      var d;
	      var width = opt.width;
	      var height = opt.height;
	      var thickness = opt.thickness;
	      if (width - thickness >= 0 && height - thickness >= 0) {
	        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
	      } else {
	        d = 'M 0 0 0 0';
	      }
	      V(el).attr({
	        'd': d,
	        stroke: opt.color,
	        'stroke-width': opt.thickness
	      });
	    }
	  }]
	};
	const backgroundPatterns = {
	  flipXy: function (img) {
	    // d b
	    // q p

	    var canvas = document.createElement('canvas');
	    var imgWidth = img.width;
	    var imgHeight = img.height;
	    canvas.width = 2 * imgWidth;
	    canvas.height = 2 * imgHeight;
	    var ctx = canvas.getContext('2d');
	    // top-left image
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    // xy-flipped bottom-right image
	    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    // x-flipped top-right image
	    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    // y-flipped bottom-left image
	    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    return canvas;
	  },
	  flipX: function (img) {
	    // d b
	    // d b

	    var canvas = document.createElement('canvas');
	    var imgWidth = img.width;
	    var imgHeight = img.height;
	    canvas.width = imgWidth * 2;
	    canvas.height = imgHeight;
	    var ctx = canvas.getContext('2d');
	    // left image
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    // flipped right image
	    ctx.translate(2 * imgWidth, 0);
	    ctx.scale(-1, 1);
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    return canvas;
	  },
	  flipY: function (img) {
	    // d d
	    // q q

	    var canvas = document.createElement('canvas');
	    var imgWidth = img.width;
	    var imgHeight = img.height;
	    canvas.width = imgWidth;
	    canvas.height = imgHeight * 2;
	    var ctx = canvas.getContext('2d');
	    // top image
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    // flipped bottom image
	    ctx.translate(0, 2 * imgHeight);
	    ctx.scale(1, -1);
	    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
	    return canvas;
	  },
	  watermark: function (img, opt) {
	    //   d
	    // d

	    opt = opt || {};
	    var imgWidth = img.width;
	    var imgHeight = img.height;
	    var canvas = document.createElement('canvas');
	    canvas.width = imgWidth * 3;
	    canvas.height = imgHeight * 3;
	    var ctx = canvas.getContext('2d');
	    var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;
	    var radians = toRad(angle);
	    var stepX = canvas.width / 4;
	    var stepY = canvas.height / 4;
	    for (var i = 0; i < 4; i++) {
	      for (var j = 0; j < 4; j++) {
	        if ((i + j) % 2 > 0) {
	          // reset the current transformations
	          ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
	          ctx.rotate(radians);
	          ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
	        }
	      }
	    }
	    return canvas;
	  }
	};
	const implicitLayers = [{
	  id: paperLayers.GRID,
	  type: 'GridLayerView',
	  patterns: gridPatterns
	}, {
	  id: paperLayers.BACK
	}, {
	  id: paperLayers.LABELS
	}, {
	  id: paperLayers.FRONT
	}, {
	  id: paperLayers.TOOLS
	}];
	const CELL_VIEW_PLACEHOLDER_MARKER = Symbol('joint.cellViewPlaceholderMarker');
	const Paper = View.extend({
	  className: 'paper',
	  options: {
	    width: 800,
	    height: 600,
	    gridSize: 1,
	    // Whether or not to draw the grid lines on the paper's DOM element.
	    // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }
	    drawGrid: false,
	    // If not set, the size of the visual grid is the same as the `gridSize`.
	    drawGridSize: null,
	    // Whether or not to draw the background on the paper's DOM element.
	    // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }
	    background: false,
	    elementView: ElementView,
	    linkView: LinkView,
	    snapLabels: false,
	    // false, true
	    snapLinks: false,
	    // false, true, { radius: value }
	    snapLinksSelf: false,
	    // false, true, { radius: value }

	    // Should the link labels be rendered into its own layer?
	    // `false` - the labels are part of the links
	    // `true` - the labels are appended to LayersName.LABELS
	    // [LayersName] - the labels are appended to the layer specified
	    labelsLayer: false,
	    // When set to FALSE, an element may not have more than 1 link with the same source and target element.
	    multiLinks: true,
	    // For adding custom guard logic.
	    guard: function (evt, view) {
	      // FALSE means the event isn't guarded.
	      return false;
	    },
	    highlighting: defaultHighlighting,
	    // Prevent the default context menu from being displayed.
	    preventContextMenu: true,
	    // Prevent the default action for blank:pointer<action>.
	    preventDefaultBlankAction: true,
	    // Prevent the default action for cell:pointer<action>.
	    preventDefaultViewAction: true,
	    // Restrict the translation of elements by given bounding box.
	    // Option accepts a boolean:
	    //  true - the translation is restricted to the paper area
	    //  false - no restrictions
	    // A method:
	    // restrictTranslate: function(elementView) {
	    //     var parentId = elementView.model.get('parent');
	    //     return parentId && this.model.getCell(parentId).getBBox();
	    // },
	    // Or a bounding box:
	    // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }
	    restrictTranslate: false,
	    // Marks all available magnets with 'available-magnet' class name and all available cells with
	    // 'available-cell' class name. Marks them when dragging a link is started and unmark
	    // when the dragging is stopped.
	    markAvailable: false,
	    // Defines what link model is added to the graph after an user clicks on an active magnet.
	    // Value could be the mvc.model or a function returning the mvc.model
	    // defaultLink: (elementView, magnet) => {
	    //   return condition ? new customLink1() : new customLink2()
	    // }
	    defaultLink: function () {
	      // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)
	      const {
	        cellNamespace
	      } = this.model.layerCollection;
	      const ctor = getByPath(cellNamespace, ['standard', 'Link']);
	      if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');
	      return new ctor();
	    },
	    // A connector that is used by links with no connector defined on the model.
	    // e.g. { name: 'rounded', args: { radius: 5 }} or a function
	    defaultConnector: {
	      name: 'normal'
	    },
	    // A router that is used by links with no router defined on the model.
	    // e.g. { name: 'oneSide', args: { padding: 10 }} or a function
	    defaultRouter: {
	      name: 'normal'
	    },
	    defaultAnchor: {
	      name: 'center'
	    },
	    defaultLinkAnchor: {
	      name: 'connectionRatio'
	    },
	    defaultConnectionPoint: {
	      name: 'boundary'
	    },
	    /* CONNECTING */

	    connectionStrategy: null,
	    // Check whether to add a new link to the graph when user clicks on an a magnet.
	    validateMagnet: function (_cellView, magnet, _evt) {
	      return magnet.getAttribute('magnet') !== 'passive';
	    },
	    // Check whether to allow or disallow the link connection while an arrowhead end (source/target)
	    // being changed.
	    validateConnection: function (cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {
	      return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;
	    },
	    /* EMBEDDING */

	    // Enables embedding. Re-parent the dragged element with elements under it and makes sure that
	    // all links and elements are visible taken the level of embedding into account.
	    embeddingMode: false,
	    // Check whether to allow or disallow the element embedding while an element being translated.
	    validateEmbedding: function (childView, parentView) {
	      // by default all elements can be in relation child-parent
	      return true;
	    },
	    // Check whether to allow or disallow an embedded element to be unembedded / to become a root.
	    validateUnembedding: function (childView) {
	      // by default all elements can become roots
	      return true;
	    },
	    // Determines the way how a cell finds a suitable parent when it's dragged over the paper.
	    // The cell with the highest z-index (visually on the top) will be chosen.
	    findParentBy: 'bbox',
	    // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'

	    // If enabled only the element on the very front is taken into account for the embedding.
	    // If disabled the elements under the dragged view are tested one by one
	    // (from front to back) until a valid parent found.
	    frontParentOnly: true,
	    // Interactive flags. See online docs for the complete list of interactive flags.
	    interactive: {
	      labelMove: false
	    },
	    // When set to true the links can be pinned to the paper.
	    // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };
	    linkPinning: true,
	    // Custom validation after an interaction with a link ends.
	    // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)
	    // (linkView, paper) => boolean
	    allowLink: null,
	    // Allowed number of mousemove events after which the pointerclick event will be still triggered.
	    clickThreshold: 0,
	    // Number of required mousemove events before the first pointermove event will be triggered.
	    moveThreshold: 0,
	    // Number of required mousemove events before a link is created out of the magnet.
	    // Or string `onleave` so the link is created when the pointer leaves the magnet
	    magnetThreshold: 0,
	    // Rendering Options

	    sorting: sortingTypes.APPROX,
	    frozen: false,
	    autoFreeze: false,
	    viewManagement: false,
	    // no docs yet
	    onViewUpdate: function (view, flag, priority, opt, paper) {
	      if (opt.mounting || opt.isolate) {
	        // Do not update connected links when:
	        // - the view was just mounted (added back to the paper by viewport function)
	        // - the change was marked as `isolate`.
	        return;
	      }
	      // Always update connected links when the view model was replaced with another model
	      // with the same id.
	      // Note: the removal is done in 2 steps: remove the old model, add the new model.
	      // We update connected links on the add step.
	      if (!(opt.replace && opt.add)) {
	        if (flag & (paper.FLAG_INSERT | paper.FLAG_REMOVE)) {
	          // Do not update connected links when:
	          // - the view was just inserted (added to the graph and rendered)
	          // - the view model was just removed from the graph
	          return;
	        }
	      }
	      paper.requestConnectedLinksUpdate(view, priority, opt);
	    },
	    // no docs yet
	    onViewPostponed: function (view, flag, paper) {
	      return paper.forcePostponedViewUpdate(view, flag);
	    },
	    beforeRender: null,
	    // function(opt, paper) { },

	    afterRender: null,
	    // function(stats, opt, paper) {

	    viewport: null,
	    // Default namespaces

	    cellViewNamespace: null,
	    layerViewNamespace: null,
	    routerNamespace: null,
	    connectorNamespace: null,
	    highlighterNamespace: highlighters,
	    anchorNamespace: anchors,
	    linkAnchorNamespace: linkAnchors,
	    connectionPointNamespace: connectionPoints,
	    overflow: false
	  },
	  events: {
	    'dblclick': 'pointerdblclick',
	    'dbltap': 'pointerdblclick',
	    'contextmenu': 'contextmenu',
	    'mousedown': 'pointerdown',
	    'touchstart': 'pointerdown',
	    'mouseover': 'mouseover',
	    'mouseout': 'mouseout',
	    'mouseenter': 'mouseenter',
	    'mouseleave': 'mouseleave',
	    'wheel': 'mousewheel',
	    'mouseenter .joint-cell': 'mouseenter',
	    'mouseleave .joint-cell': 'mouseleave',
	    'mouseenter .joint-tools': 'mouseenter',
	    'mouseleave .joint-tools': 'mouseleave',
	    'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',
	    'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',
	    'mousedown .joint-link .label': 'onlabel',
	    // interaction with link label
	    'touchstart .joint-link .label': 'onlabel',
	    'dragstart .joint-cell image': 'onImageDragStart' // firefox fix
	  },
	  documentEvents: {
	    'mousemove': 'pointermove',
	    'touchmove': 'pointermove',
	    'mouseup': 'pointerup',
	    'touchend': 'pointerup',
	    'touchcancel': 'pointerup'
	  },
	  /* CSS within the SVG document
	  * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for
	  *    elements that use the `scalable` group.
	  */
	  stylesheet: /*css*/`
        .joint-element .scalable * {
            vector-effect: non-scaling-stroke;
        }
    `,
	  svg: null,
	  defs: null,
	  tools: null,
	  layers: null,
	  // deprecated, use layers element instead
	  viewport: null,
	  // For storing the current transformation matrix (CTM) of the paper's viewport.
	  _viewportMatrix: null,
	  // For verifying whether the CTM is up-to-date. The viewport transform attribute
	  // could have been manipulated directly.
	  _viewportTransformString: null,
	  // Updates data (priorities, unmounted views etc.)
	  _updates: null,
	  // Paper Layers
	  _layers: null,
	  UPDATE_DELAYING_BATCHES: ['translate'],
	  // If you interact with these elements,
	  // the default interaction such as `element move` is prevented.
	  FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],
	  // If you interact with these elements, the events are not propagated to the paper
	  // i.e. paper events such as `element:pointerdown` are not triggered.
	  GUARDED_TAG_NAMES: [
	  // Guard <select> for consistency. When you click on it:
	  // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open
	  // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).
	  //          on close. However, if you open and then close by clicking elsewhere on the page,
	  //           no other event is triggered.
	  // Safari: when you open it, it triggers `pointerdown`. That's it.
	  'SELECT'],
	  MIN_SCALE: 1e-6,
	  // Default find buffer for the findViewsInArea and findViewsAtPoint methods.
	  // The find buffer is used to extend the area of the search
	  // to mitigate the differences between the model and view geometry.
	  DEFAULT_FIND_BUFFER: 200,
	  FLAG_INSERT: 1 << 30,
	  FLAG_REMOVE: 1 << 29,
	  FLAG_INIT: 1 << 28,
	  // Layers that are always present on the paper (e.g. grid, back, front, tools)
	  implicitLayers,
	  // Reference layer for inserting new graph layers.
	  graphLayerRefId: paperLayers.LABELS,
	  init: function () {
	    const {
	      options
	    } = this;
	    if (!options.cellViewNamespace) {
	      /* eslint-disable no-undef */
	      options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;
	      /* eslint-enable no-undef */
	    }
	    const defaultLayerViewNamespace = {
	      LayerView,
	      GraphLayerView,
	      GridLayerView
	    };
	    this.layerViewNamespace = defaultsDeep({}, options.layerViewNamespace || {}, defaultLayerViewNamespace);
	    const model = this.model = options.model || new Graph();

	    // This property tells us if we need to keep the compatibility
	    // with the v4 API and behavior.
	    this.legacyMode = !options.viewManagement;

	    // Layers (SVGGroups)
	    this._layers = {
	      viewsMap: {},
	      order: []
	    };

	    // Hash of all cell views.
	    this._views = {};
	    this._viewPlaceholders = {};
	    this._idToCid = {};
	    this.cloneOptions();
	    this.render();
	    this._setDimensions();
	    this.startListening();

	    // Mouse wheel events buffer
	    this._mw_evt_buffer = {
	      event: null,
	      deltas: []
	    };

	    // Render existing cells in the graph
	    this.resetViews(model.getCells());
	  },
	  _resetUpdates: function () {
	    if (this._updates && this._updates.id) cancelFrame(this._updates.id);
	    return this._updates = {
	      id: null,
	      priorities: [{}, {}, {}],
	      unmountedList: new Deque(),
	      mountedList: new Deque(),
	      count: 0,
	      keyFrozen: false,
	      freezeKey: null,
	      sort: false,
	      disabled: false,
	      idle: false,
	      freshAfterReset: true
	    };
	  },
	  startListening: function () {
	    var model = this.model;
	    this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'batch:stop', this.onGraphBatchStop);
	    this.listenTo(model, 'layer:add', this.onGraphLayerAdd).listenTo(model, 'layer:remove', this.onGraphLayerRemove).listenTo(model, 'layers:sort', this.onGraphLayerCollectionSort);
	    this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('transform', this.update);
	  },
	  onCellAdded: function (cell, _, opt) {
	    var position = opt.position;
	    if (this.isAsync() || !isNumber(position)) {
	      this.renderView(cell, opt);
	    } else {
	      if (opt.maxPosition === position) this.freeze({
	        key: 'addCells'
	      });
	      this.renderView(cell, opt);
	      if (position === 0) this.unfreeze({
	        key: 'addCells'
	      });
	    }
	  },
	  onCellRemoved: function (cell, _, opt) {
	    const viewLike = this._getCellViewLike(cell);
	    if (!viewLike) return;
	    if (viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {
	      // It's a cell placeholder, it must be in the unmounted list.
	      // Remove it from there and unregister.
	      this._updates.unmountedList.delete(viewLike.cid);
	      this._unregisterCellViewPlaceholder(viewLike);
	    } else {
	      this.requestViewUpdate(viewLike, this.FLAG_REMOVE, viewLike.UPDATE_PRIORITY, opt);
	    }
	  },
	  onGraphReset: function (_collection, opt) {
	    // Re-render all graph layer views
	    // but keep the implicit layer views.
	    this.renderGraphLayerViews();
	    this.resetLayerViews();
	    // Backward compatibility: reassign the `cells` property
	    // with the default layer view.
	    this.assertLayerViews();
	    this.resetViews(this.model.getCells(), opt);
	  },
	  onGraphBatchStop: function (data) {
	    if (this.isFrozen() || this.isIdle()) return;
	    var name = data && data.batchName;
	    var graph = this.model;
	    if (!this.isAsync()) {
	      var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;
	      if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {
	        this.updateViews(data);
	      }
	    }
	  },
	  /**
	  * @protected
	  * @description When a new layer is added to the graph, we create a new layer view
	  **/
	  onGraphLayerAdd: function (layer, _, opt) {
	    if (this.hasLayerView(layer.id)) return;
	    const layerView = this.createLayerView({
	      id: layer.id,
	      model: layer
	    });
	    const layers = this.model.getLayers();
	    let before;
	    // Note: There is always at least one graph layer.
	    if (layers[layers.length - 1] === layer) {
	      // This is the last layer, so insert before the labels layer
	      before = paperLayers.LABELS;
	    } else {
	      // There is a layer after the current one, so insert before that one
	      const index = layers.indexOf(layer);
	      before = layers[index + 1].id;
	    }
	    this.addLayerView(layerView, {
	      before
	    });
	  },
	  /**
	   * @protected
	   * @description When a layer is removed from the graph, we remove the corresponding layer view
	   **/
	  onGraphLayerRemove: function (layer, _, opt) {
	    if (!this.hasLayerView(layer)) return;

	    // Request layer removal. Since the UPDATE_PRIORITY is lower
	    // than cells update priority, the cell views will be removed first.
	    this.requestLayerViewRemoval(layer);
	  },
	  /**
	   * @protected
	   * @description When the graph layer collection is sorted,
	   * we reorder all graph layer views.
	   **/
	  onGraphLayerCollectionSort: function (layerCollection) {
	    layerCollection.each(layer => {
	      if (!this.hasLayerView(layer)) return;
	      this.moveLayerView(layer, {
	        before: this.graphLayerRefId
	      });
	    });
	  },
	  /**
	   * @protected
	   * @description Resets all graph layer views.
	   */
	  renderGraphLayerViews: function () {
	    // Remove all existing graph layer views
	    // Note: we don't use `getGraphLayerViews()` here because
	    // rendered graph layer views could be different from the ones
	    // in the graph layer collection (`onResetGraphLayerCollectionReset`).
	    this.getLayerViews().forEach(layerView => {
	      if (!layerView[GRAPH_LAYER_VIEW_MARKER]) return;
	      this._removeLayerView(layerView);
	    });
	    // Create and insert new graph layer views
	    this.model.getLayers().forEach(layer => {
	      const layerView = this.createLayerView({
	        id: layer.id,
	        model: layer
	      });
	      // Insert the layer view into the paper layers, just before the labels layer.
	      // All cell layers are positioned between the "back" and "labels" layers,
	      // with the default "cells" layer originally occupying this position.
	      this.addLayerView(layerView, {
	        before: this.graphLayerRefId
	      });
	    });
	  },
	  /**
	   * @protected
	   * @description Renders all implicit layer views.
	   */
	  renderImplicitLayerViews: function () {
	    this.implicitLayers.forEach(layerInit => {
	      const layerView = this.createLayerView(layerInit);
	      this.addLayerView(layerView);
	    });
	  },
	  cloneOptions: function () {
	    const {
	      options
	    } = this;
	    const {
	      defaultConnector,
	      defaultRouter,
	      defaultConnectionPoint,
	      defaultAnchor,
	      defaultLinkAnchor,
	      highlighting,
	      cellViewNamespace,
	      interactive
	    } = options;

	    // Default cellView namespace for ES5
	    /* eslint-disable no-undef */
	    if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {
	      options.cellViewNamespace = joint.shapes;
	    }
	    /* eslint-enable no-undef */

	    // Here if a function was provided, we can not clone it, as this would result in loosing the function.
	    // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.
	    if (!isFunction(defaultConnector)) {
	      options.defaultConnector = cloneDeep(defaultConnector);
	    }
	    if (!isFunction(defaultRouter)) {
	      options.defaultRouter = cloneDeep(defaultRouter);
	    }
	    if (!isFunction(defaultConnectionPoint)) {
	      options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);
	    }
	    if (!isFunction(defaultAnchor)) {
	      options.defaultAnchor = cloneDeep(defaultAnchor);
	    }
	    if (!isFunction(defaultLinkAnchor)) {
	      options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);
	    }
	    if (isPlainObject(interactive)) {
	      options.interactive = assign({}, interactive);
	    }
	    if (isPlainObject(highlighting)) {
	      // Return the default highlighting options into the user specified options.
	      options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);
	    }
	    // Copy and set defaults for the view management options.
	    options.viewManagement = defaults({}, options.viewManagement, {
	      // Whether to lazy initialize the cell views.
	      lazyInitialize: !!options.viewManagement,
	      // default `true` if options.viewManagement provided
	      // Whether to add initialized cell views into the unmounted queue.
	      initializeUnmounted: false,
	      // Whether to dispose the cell views that are not visible.
	      disposeHidden: false
	    });
	  },
	  children: function () {
	    var ns = V.namespace;
	    return [{
	      namespaceURI: ns.xhtml,
	      tagName: 'div',
	      className: addClassNamePrefix('paper-background'),
	      selector: 'background',
	      style: {
	        position: 'absolute',
	        inset: 0
	      }
	    }, {
	      namespaceURI: ns.svg,
	      tagName: 'svg',
	      attributes: {
	        'width': '100%',
	        'height': '100%',
	        'xmlns:xlink': ns.xlink
	      },
	      selector: 'svg',
	      style: {
	        position: 'absolute',
	        inset: 0
	      },
	      children: [{
	        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.
	        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).
	        tagName: 'defs',
	        selector: 'defs'
	      }, {
	        tagName: 'g',
	        className: addClassNamePrefix('layers'),
	        selector: 'layers'
	      }]
	    }];
	  },
	  /**
	   * @public
	   * @description Checks whether the layer view exists by the given layer id or layer model.
	   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
	   * @return {boolean} True if the layer view exists, false otherwise.
	   */
	  hasLayerView(layerRef) {
	    let layerId;
	    if (isString(layerRef)) {
	      layerId = layerRef;
	    } else if (layerRef) {
	      layerId = layerRef.id;
	    } else {
	      return false;
	    }
	    return layerId in this._layers.viewsMap;
	  },
	  /**
	   * @public
	   * @description Returns the layer view by the given layer id or layer model.
	   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
	   * @return {dia.LayerView} The layer view.
	   * @throws {Error} if the layer view is not found
	   */
	  getLayerView(layerRef) {
	    let layerId;
	    if (isString(layerRef)) {
	      layerId = layerRef;
	    } else if (layerRef) {
	      layerId = layerRef.id;
	    } else {
	      throw new Error('dia.Paper: No layer provided.');
	    }
	    const layerView = this._layers.viewsMap[layerId];
	    if (!layerView) {
	      throw new Error(`dia.Paper: Unknown layer view "${layerId}".`);
	    }
	    return layerView;
	  },
	  /**
	   * @deprecated use `getLayerView(layerId).el` instead
	   */
	  getLayerNode(layerId) {
	    return this.getLayerView(layerId).el;
	  },
	  /**
	   * @protected
	   * @description Removes the given layer view from the paper.
	   * It does not check whether the layer view is empty.
	   * @param {dia.LayerView} layerView - The layer view to remove.
	   */
	  _removeLayerView(layerView) {
	    this._unregisterLayerView(layerView);
	    layerView.remove();
	  },
	  /**
	   * @protected
	   * @description Removes all layer views from the paper.
	   * It does not check whether the layer views are empty.
	   */
	  _removeLayerViews: function () {
	    Object.values(this._layers.viewsMap).forEach(layerView => {
	      this._removeLayerView(layerView);
	    });
	  },
	  /**
	   * @protected
	   * @description Unregisters the given layer view from the paper.
	   * @param {dia.LayerView} layerView - The layer view to unregister.
	   */
	  _unregisterLayerView(layerView) {
	    const {
	      _layers: {
	        viewsMap,
	        order
	      }
	    } = this;
	    const layerId = layerView.id;
	    // Remove the layer id from the order list.
	    const layerIndex = order.indexOf(layerId);
	    if (layerIndex !== -1) {
	      order.splice(layerIndex, 1);
	    }
	    // Unlink the layer view from the paper.
	    layerView.unsetPaperReference();
	    // Remove the layer view from the paper's registry.
	    delete viewsMap[layerId];
	  },
	  /**
	   * @protected
	   * @description Registers the given layer view in the paper.
	   * @param {dia.LayerView} layerView - The layer view to register.
	   * @throws {Error} if the layer view is not an instance of dia.LayerView
	   * @throws {Error} if the layer view already exists in the paper
	   */
	  _registerLayerView(layerView) {
	    if (!layerView || !layerView[LAYER_VIEW_MARKER]) {
	      throw new Error('dia.Paper: The layer view must be an instance of dia.LayerView.');
	    }
	    if (this.hasLayerView(layerView.id)) {
	      throw new Error(`dia.Paper: The layer view "${layerView.id}" already exists.`);
	    }
	    // Link the layer view back to the paper.
	    layerView.setPaperReference(this);
	    // Store the layer view in the paper's registry.
	    this._layers.viewsMap[layerView.id] = layerView;
	  },
	  /**
	   * @public
	   * @description Removes the layer view by the given layer id or layer model.
	   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
	   * @throws {Error} if the layer view is not empty
	   */
	  removeLayerView(layerRef) {
	    const layerView = this.getLayerView(layerRef);
	    if (!layerView.isEmpty()) {
	      throw new Error('dia.Paper: The layer view is not empty.');
	    }
	    this._removeLayerView(layerView);
	  },
	  /**
	   * @protected
	   * @description Schedules the layer view removal by the given layer id or layer model.
	   * The actual removal will be performed during the paper update cycle.
	   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
	   * @param {Object} [opt] - Update options.
	   */
	  requestLayerViewRemoval(layerRef, opt) {
	    const layerView = this.getLayerView(layerRef);
	    const {
	      FLAG_REMOVE
	    } = this;
	    const {
	      UPDATE_PRIORITY
	    } = layerView;
	    this.requestViewUpdate(layerView, FLAG_REMOVE, UPDATE_PRIORITY, opt);
	  },
	  /**
	   * @public
	   * @internal not documented
	   * @description Schedules the cell view insertion into the appropriate layer view.
	   * The actual insertion will be performed during the paper update cycle.
	   * @param {dia.Cell} cell - The cell model whose view should be inserted.
	   * @param {Object} [opt] - Update options.
	   */
	  requestCellViewInsertion(cell, opt) {
	    const viewLike = this._getCellViewLike(cell);
	    if (!viewLike) return;
	    this.requestViewUpdate(viewLike, this.FLAG_INSERT, viewLike.UPDATE_PRIORITY, opt);
	  },
	  /**
	   * @private
	   * Helper method for addLayerView and moveLayerView methods
	   */
	  _getBeforeLayerViewFromOptions(layerView, options) {
	    let {
	      before = null,
	      index
	    } = options;
	    if (before && index !== undefined) {
	      throw new Error('dia.Paper: Options "before" and "index" are mutually exclusive.');
	    }
	    let computedBefore;
	    if (index !== undefined) {
	      const {
	        _layers: {
	          order
	        }
	      } = this;
	      if (index >= order.length) {
	        // If index is greater than the number of layers,
	        // return before as null (move to the end).
	        computedBefore = null;
	      } else if (index < 0) {
	        // If index is negative, move to the beginning.
	        computedBefore = order[0];
	      } else {
	        const originalIndex = order.indexOf(layerView.id);
	        if (originalIndex !== -1 && index > originalIndex) {
	          // If moving a layer upwards in the stack, we need to adjust the index
	          // to account for the layer being removed from its original position.
	          index += 1;
	        }
	        // Otherwise, get the layer ID at the specified index.
	        computedBefore = order[index] || null;
	      }
	    } else {
	      computedBefore = before;
	    }
	    return computedBefore ? this.getLayerView(computedBefore) : null;
	  },
	  /**
	   * @public
	   * @description Adds the layer view to the paper.
	   * @param {dia.LayerView} layerView - The layer view to add.
	   * @param {Object} [options] - Adding options.
	   * @param {string|dia.GraphLayer} [options.before] - Layer id or layer model before
	   */
	  addLayerView(layerView, options = {}) {
	    this._registerLayerView(layerView);
	    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);
	    this.insertLayerView(layerView, beforeLayerView);
	  },
	  /**
	   * @public
	   * @description Moves the layer view.
	   * @param {Paper.LayerRef} layerRef - The layer view reference to move.
	   * @param {Object} [options] - Moving options.
	   * @param {Paper.LayerRef} [options.before] - Layer id or layer model before
	   * @param {number} [options.index] - Zero-based index to which to move the layer view.
	   */
	  moveLayerView(layerRef, options = {}) {
	    const layerView = this.getLayerView(layerRef);
	    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);
	    this.insertLayerView(layerView, beforeLayerView);
	  },
	  /**
	   * @protected
	   * @description Inserts the layer view into the paper.
	   * If the layer view already exists in the paper, it is moved to the new position.
	   * @param {dia.LayerView} layerView - The layer view to insert.
	   * @param {dia.LayerView} [before] - Layer view before
	   * which the layer view should be inserted.
	   */
	  insertLayerView(layerView, beforeLayerView) {
	    const layerId = layerView.id;
	    const {
	      _layers: {
	        order
	      }
	    } = this;
	    const currentLayerIndex = order.indexOf(layerId);

	    // Should the layer view be inserted before another layer view?
	    if (beforeLayerView) {
	      const beforeLayerViewId = beforeLayerView.id;
	      if (layerId === beforeLayerViewId) {
	        // The layer view is already in the right place.
	        return;
	      }
	      let beforeLayerPosition = order.indexOf(beforeLayerViewId);
	      // Remove from the `order` list if the layer view is already in the order.
	      if (currentLayerIndex !== -1) {
	        if (currentLayerIndex < beforeLayerPosition) {
	          beforeLayerPosition -= 1;
	        }
	        order.splice(currentLayerIndex, 1);
	      }
	      order.splice(beforeLayerPosition, 0, layerId);
	      this.layers.insertBefore(layerView.el, beforeLayerView.el);
	      return;
	    }

	    // Remove from the `order` list if the layer view is already in the order.
	    // This is needed for the case when the layer view is inserted in the new position.
	    if (currentLayerIndex !== -1) {
	      order.splice(currentLayerIndex, 1);
	    }
	    order.push(layerId);
	    this.layers.appendChild(layerView.el);
	  },
	  /**
	   * @protected
	   * @description Returns an array of layer view ids in the order they are rendered.
	   * @returns {string[]} An array of layer view ids.
	   */
	  getLayerViewOrder() {
	    return this._layers.order.slice();
	  },
	  /**
	   * @public
	   * @description Returns an array of layer views in the order they are rendered.
	   * @returns {dia.LayerView[]} An array of layer views.
	   */
	  getLayerViews() {
	    return this.getLayerViewOrder().map(id => this.getLayerView(id));
	  },
	  /**
	   * @public
	   * @description Returns an array of graph layer views in the order they are rendered.
	   * @returns {dia.GraphLayerView[]} An array of graph layer views.
	   */
	  getGraphLayerViews() {
	    const {
	      _layers: {
	        viewsMap
	      }
	    } = this;
	    return this.model.getLayers().map(layer => viewsMap[layer.id]);
	  },
	  render: function () {
	    this.renderChildren();
	    const {
	      el,
	      childNodes,
	      options,
	      stylesheet
	    } = this;
	    const {
	      svg,
	      defs,
	      layers
	    } = childNodes;
	    el.style.position = 'relative';
	    svg.style.overflow = options.overflow ? 'visible' : 'hidden';
	    this.svg = svg;
	    this.defs = defs;
	    this.layers = layers;
	    this.renderLayerViews();
	    V.ensureId(svg);
	    this.addStylesheet(stylesheet);
	    if (options.background) {
	      this.drawBackground(options.background);
	    }
	    if (options.drawGrid) {
	      this.setGrid(options.drawGrid);
	    }
	    return this;
	  },
	  addStylesheet: function (css) {
	    if (!css) return;
	    V(this.svg).prepend(V.createSVGStyle(css));
	  },
	  /**
	   * @protected
	   * @description Creates a layer view instance based on the provided options.
	   * It finds the appropriate layer view constructor from the paper's
	   * `layerViewNamespace` and instantiates it.
	   * @param {*} options See `dia.LayerView` options.
	   * @returns {dia.LayerView}
	   */
	  createLayerView(options) {
	    if (options == null) {
	      throw new Error('dia.Paper: Layer view options are required.');
	    }
	    if (options.id == null) {
	      throw new Error('dia.Paper: Layer view id is required.');
	    }
	    const viewOptions = clone$1(options);
	    let viewConstructor;
	    if (viewOptions.model) {
	      const modelType = viewOptions.model.get('type') || viewOptions.model.constructor.name;
	      const type = modelType + 'View';

	      // For backward compatibility we use the LegacyGraphLayerView for the default `cells` layer.
	      if (this.model.legacyMode) {
	        viewConstructor = LegacyGraphLayerView;
	      } else {
	        viewConstructor = this.layerViewNamespace[type] || LayerView;
	      }
	    } else {
	      // Paper layers
	      const type = viewOptions.type;
	      viewConstructor = this.layerViewNamespace[type] || LayerView;
	    }
	    return new viewConstructor(viewOptions);
	  },
	  /**
	   * @protected
	   * @description Renders all paper layer views and graph layer views.
	   */
	  renderLayerViews: function () {
	    this._removeLayerViews();
	    // Render the paper layers.
	    this.renderImplicitLayerViews();
	    // Render the layers.
	    this.renderGraphLayerViews();
	    // Ensure that essential layer views are present.
	    this.assertLayerViews();
	  },
	  /**
	   * @protected
	   * @description Ensures that essential layer views are present on the paper.
	   * @throws {Error} if any of the essential layer views is missing
	   */
	  assertLayerViews: function () {
	    // Throws an exception if essential layer views are missing.
	    const cellsLayerView = this.getLayerView(this.model.getDefaultLayer().id);
	    const toolsLayerView = this.getLayerView(paperLayers.TOOLS);
	    const labelsLayerView = this.getLayerView(paperLayers.LABELS);

	    // backwards compatibility
	    this.tools = toolsLayerView.el;
	    this.cells = this.viewport = cellsLayerView.el;
	    // Backwards compatibility: same as `LegacyGraphLayerView` we keep
	    // the `viewport` class on the labels layer.
	    labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));
	    labelsLayerView.el.style.webkitUserSelect = 'none';
	    labelsLayerView.el.style.userSelect = 'none';
	  },
	  /**
	   * @protected
	   * @description Resets all layer views.
	   */
	  resetLayerViews: function () {
	    this.getLayerViews().forEach(layerView => layerView.reset());
	  },
	  update: function () {
	    if (this._background) {
	      this.updateBackgroundImage(this._background);
	    }
	    return this;
	  },
	  scale: function (sx, sy, data) {
	    const ctm = this.matrix();
	    // getter
	    if (sx === undefined) {
	      return V.matrixToScale(ctm);
	    }
	    // setter
	    if (sy === undefined) {
	      sy = sx;
	    }
	    sx = Math.max(sx || 0, this.MIN_SCALE);
	    sy = Math.max(sy || 0, this.MIN_SCALE);
	    ctm.a = sx;
	    ctm.d = sy;
	    this.matrix(ctm, data);
	    return this;
	  },
	  scaleUniformAtPoint: function (scale, point, data) {
	    const {
	      a: sx,
	      d: sy,
	      e: tx,
	      f: ty
	    } = this.matrix();
	    scale = Math.max(scale || 0, this.MIN_SCALE);
	    if (scale === sx && scale === sy) {
	      // The scale is the same as the current one.
	      return this;
	    }
	    const matrix = V.createSVGMatrix().translate(tx - point.x * (scale - sx), ty - point.y * (scale - sy)).scale(scale, scale);
	    this.matrix(matrix, data);
	    return this;
	  },
	  translate: function (tx, ty, data) {
	    const ctm = this.matrix();
	    // getter
	    if (tx === undefined) {
	      return V.matrixToTranslate(ctm);
	    }
	    // setter
	    tx || (tx = 0);
	    ty || (ty = 0);
	    if (ctm.e === tx && ctm.f === ty) return this;
	    ctm.e = tx;
	    ctm.f = ty;
	    this.matrix(ctm, data);
	    return this;
	  },
	  matrix: function (ctm, data = {}) {
	    var viewport = this.layers;

	    // Getter:
	    if (ctm === undefined) {
	      var transformString = viewport.getAttribute('transform');
	      if ((this._viewportTransformString || null) === transformString) {
	        // It's ok to return the cached matrix. The transform attribute has not changed since
	        // the matrix was stored.
	        ctm = this._viewportMatrix;
	      } else {
	        // The viewport transform attribute has changed. Measure the matrix and cache again.
	        ctm = viewport.getCTM();
	        this._viewportMatrix = ctm;
	        this._viewportTransformString = transformString;
	      }

	      // Clone the cached current transformation matrix.
	      // If no matrix previously stored the identity matrix is returned.
	      return V.createSVGMatrix(ctm);
	    }

	    // Setter:
	    const prev = this.matrix();
	    const current = V.createSVGMatrix(ctm);
	    const currentTransformString = this._viewportTransformString;
	    const ctmString = V.matrixToTransformString(current);
	    if (ctmString === currentTransformString) {
	      // The new transform string is the same as the current one.
	      // No need to update the transform attribute.
	      return this;
	    }
	    if (!currentTransformString && V.matrixToTransformString() === ctmString) {
	      // The current transform string is empty and the new one is an identity matrix.
	      // No need to update the transform attribute.
	      return this;
	    }
	    const {
	      a,
	      d,
	      e,
	      f
	    } = current;
	    viewport.setAttribute('transform', ctmString);
	    this._viewportMatrix = current;
	    this._viewportTransformString = viewport.getAttribute('transform');

	    // scale event
	    if (a !== prev.a || d !== prev.d) {
	      this.trigger('scale', a, d, data);
	    }

	    // translate event
	    if (e !== prev.e || f !== prev.f) {
	      this.trigger('translate', e, f, data);
	    }
	    this.trigger('transform', current, data);
	    return this;
	  },
	  clientMatrix: function () {
	    return V.createSVGMatrix(this.layers.getScreenCTM());
	  },
	  requestConnectedLinksUpdate: function (view, priority, opt) {
	    if (!view || !view[CELL_VIEW_MARKER]) return;
	    const model = view.model;
	    const links = this.model.getConnectedLinks(model);
	    for (let j = 0, n = links.length; j < n; j++) {
	      const link = links[j];
	      const linkView = this._getCellViewLike(link);
	      if (!linkView) continue;
	      // We do not have to update placeholder views.
	      // They will be updated on initial render.
	      if (linkView[CELL_VIEW_PLACEHOLDER_MARKER]) continue;
	      const flagLabels = [LinkView.Flags.UPDATE];
	      // We need to tell the link view which end requested this update.
	      if (link.getTargetCell() === model) flagLabels.push(LinkView.Flags.TARGET);
	      if (link.getSourceCell() === model) flagLabels.push(LinkView.Flags.SOURCE);
	      const nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);
	      this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);
	    }
	  },
	  forcePostponedViewUpdate: function (view, flag) {
	    if (!view || !view[CELL_VIEW_MARKER]) return false;
	    const model = view.model;
	    if (model.isElement()) return false;
	    const dumpOptions = {
	      silent: true
	    };
	    // LinkView is waiting for the target or the source cellView to be rendered
	    // This can happen when the cells are not in the viewport.
	    let sourceFlag = 0;
	    const sourceCell = model.getSourceCell();
	    if (sourceCell && !this.isCellVisible(sourceCell)) {
	      const sourceView = this.findViewByModel(sourceCell);
	      sourceFlag = this.dumpView(sourceView, dumpOptions);
	    }
	    let targetFlag = 0;
	    const targetCell = model.getTargetCell();
	    if (targetCell && !this.isCellVisible(targetCell)) {
	      const targetView = this.findViewByModel(targetCell);
	      targetFlag = this.dumpView(targetView, dumpOptions);
	    }
	    if (sourceFlag === 0 && targetFlag === 0) {
	      // If leftover flag is 0, all view updates were done.
	      return !this.dumpView(view, dumpOptions);
	    }
	    return false;
	  },
	  requestViewUpdate: function (view, flag, priority, opt) {
	    opt || (opt = {});
	    // Note: `scheduleViewUpdate` wakes up the paper if it is idle.
	    this.scheduleViewUpdate(view, flag, priority, opt);
	    var isAsync = this.isAsync();
	    if (this.isFrozen() || isAsync && opt.async !== false) return;
	    if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;
	    var stats = this.updateViews(opt);
	    if (isAsync) this.notifyAfterRender(stats, opt);
	  },
	  scheduleViewUpdate: function (view, type, priority, opt) {
	    const {
	      _updates: updates,
	      options
	    } = this;
	    if (updates.idle && options.autoFreeze) {
	      this.legacyMode ? this.unfreeze() // Restart rendering loop without original options
	      : this.wakeUp();
	    }
	    const {
	      FLAG_REMOVE,
	      FLAG_INSERT
	    } = this;
	    const {
	      UPDATE_PRIORITY,
	      cid
	    } = view;
	    let priorityUpdates = updates.priorities[priority];
	    if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};
	    // Move higher priority updates to this priority
	    if (priority > UPDATE_PRIORITY) {
	      // Not the default priority for this view. It's most likely a link view
	      // connected to another link view, which triggered the update.
	      // TODO: If there is an update scheduled with a lower priority already, we should
	      // change the requested priority to the lowest one. Does not seem to be critical
	      // right now, as it "only" results in multiple updates on the same view.
	      for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {
	        const prevPriorityUpdates = updates.priorities[i];
	        if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;
	        priorityUpdates[cid] |= prevPriorityUpdates[cid];
	        delete prevPriorityUpdates[cid];
	      }
	    }
	    let currentType = priorityUpdates[cid] || 0;
	    // Prevent cycling
	    if ((currentType & type) === type) return;
	    if (!currentType) updates.count++;
	    if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {
	      // When a view is removed we need to remove the insert flag as this is a reinsert
	      priorityUpdates[cid] ^= FLAG_INSERT;
	    } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {
	      // When a view is added we need to remove the remove flag as this is view was previously removed
	      priorityUpdates[cid] ^= FLAG_REMOVE;
	    }
	    priorityUpdates[cid] |= type;
	    const viewUpdateFn = options.onViewUpdate;
	    if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);
	  },
	  dumpViewUpdate: function (view) {
	    if (!view) return 0;
	    var updates = this._updates;
	    var cid = view.cid;
	    var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];
	    var flag = this.registerMountedView(view) | priorityUpdates[cid];
	    delete priorityUpdates[cid];
	    return flag;
	  },
	  dumpView: function (view, opt = {}) {
	    const flag = this.dumpViewUpdate(view);
	    if (!flag) return 0;
	    this.notifyBeforeRender(opt);
	    const leftover = this.updateView(view, flag, opt);
	    const stats = {
	      updated: 1,
	      priority: view.UPDATE_PRIORITY
	    };
	    this.notifyAfterRender(stats, opt);
	    return leftover;
	  },
	  updateView: function (view, flag, opt) {
	    if (!view) return 0;
	    const {
	      FLAG_REMOVE,
	      FLAG_INSERT,
	      FLAG_INIT
	    } = this;
	    const {
	      model
	    } = view;
	    if (view[GRAPH_LAYER_VIEW_MARKER]) {
	      if (flag & FLAG_REMOVE) {
	        this.removeLayerView(view);
	        return 0;
	      }
	    }
	    if (view[CELL_VIEW_MARKER]) {
	      if (flag & FLAG_REMOVE) {
	        this.removeView(model);
	        return 0;
	      }
	      if (flag & FLAG_INSERT) {
	        const isInitialInsert = !!(flag & FLAG_INIT);
	        if (isInitialInsert) {
	          flag ^= FLAG_INIT;
	        }
	        this.insertView(view, isInitialInsert);
	        flag ^= FLAG_INSERT;
	      }
	    }
	    if (!flag) return 0;
	    return view.confirmUpdate(flag, opt || {});
	  },
	  requireView: function (model, opt) {
	    var view = this.findViewByModel(model);
	    if (!view) return null;
	    this.dumpView(view, opt);
	    return view;
	  },
	  registerUnmountedView: function (view) {
	    var cid = view.cid;
	    var updates = this._updates;
	    if (updates.unmountedList.has(cid)) return 0;
	    const flag = this.FLAG_INSERT;
	    updates.unmountedList.pushTail(cid, flag);
	    updates.mountedList.delete(cid);
	    return flag;
	  },
	  registerMountedView: function (view) {
	    var cid = view.cid;
	    var updates = this._updates;
	    if (updates.mountedList.has(cid)) return 0;
	    const unmountedItem = updates.unmountedList.get(cid);
	    const flag = unmountedItem ? unmountedItem.value : 0;
	    updates.unmountedList.delete(cid);
	    updates.mountedList.pushTail(cid);
	    return flag;
	  },
	  isCellVisible: function (cellOrId) {
	    const cid = cellOrId && this._idToCid[cellOrId.id || cellOrId];
	    if (!cid) return false; // The view is not registered.
	    return this.isViewMounted(cid);
	  },
	  isViewMounted: function (viewOrCid) {
	    if (!viewOrCid) return false;
	    let cid;
	    if (viewOrCid[CELL_VIEW_MARKER] || viewOrCid[CELL_VIEW_PLACEHOLDER_MARKER]) {
	      cid = viewOrCid.cid;
	    } else {
	      cid = viewOrCid;
	    }
	    return this._updates.mountedList.has(cid);
	  },
	  /**
	   * @deprecated use `updateCellsVisibility` instead.
	   * `paper.updateCellsVisibility({ cellVisibility: () => true });`
	   */
	  dumpViews: function (opt) {
	    // Update cell visibility without `cellVisibility` callback i.e. make the cells visible
	    const passingOpt = defaults({}, opt, {
	      cellVisibility: null,
	      viewport: null
	    });
	    this.updateCellsVisibility(passingOpt);
	  },
	  /**
	   * Process all scheduled updates synchronously.
	   */
	  updateViews: function (opt = {}) {
	    this.notifyBeforeRender(opt);
	    const batchStats = this.updateViewsBatch({
	      ...opt,
	      batchSize: Infinity
	    });
	    const stats = {
	      updated: batchStats.updated,
	      priority: batchStats.priority,
	      // For backward compatibility. Will be removed in the future.
	      batches: Number.isFinite(opt.batchSize) ? Math.ceil(batchStats.updated / opt.batchSize) : 1
	    };
	    this.notifyAfterRender(stats, opt);
	    return stats;
	  },
	  hasScheduledUpdates: function () {
	    const updates = this._updates;
	    const priorities = updates.priorities;
	    const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
	    let i = priorityIndexes.length;
	    while (i > 0 && i--) {
	      // a faster way how to check if an object is empty
	      for (let _key in priorities[priorityIndexes[i]]) return true;
	    }
	    return false;
	  },
	  updateViewsAsync: function (opt, data) {
	    opt || (opt = {});
	    data || (data = {
	      processed: 0,
	      priority: MIN_PRIORITY,
	      checkedUnmounted: 0,
	      checkedMounted: 0
	    });
	    const {
	      _updates: updates,
	      options
	    } = this;
	    const {
	      id,
	      mountedList,
	      unmountedList,
	      freshAfterReset
	    } = updates;

	    // Should we run the next batch update this frame?
	    let runBatchUpdate = true;
	    if (!id) {
	      // If there's no scheduled frame, no batch update is needed.
	      runBatchUpdate = false;
	    } else {
	      // Cancel any scheduled frame.
	      cancelFrame(id);
	      if (freshAfterReset) {
	        // First update after a reset.
	        updates.freshAfterReset = false;
	        // When `initializeUnmounted` is enabled, there are no scheduled updates.
	        // We check whether the `mountedList` and `unmountedList` are empty.
	        if (!this.legacyMode && mountedList.length === 0 && unmountedList.length === 0) {
	          // No updates to process; We trigger before/after render events via `updateViews`.
	          // Note: If `autoFreeze` is enabled, 'idle' event triggers next frame.
	          this.updateViews();
	          runBatchUpdate = false;
	        }
	      }
	    }
	    if (runBatchUpdate) {
	      if (data.processed === 0 && this.hasScheduledUpdates()) {
	        this.notifyBeforeRender(opt);
	      }
	      const stats = this.updateViewsBatch(opt);
	      const passingOpt = defaults({}, opt, {
	        mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,
	        unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted
	      });
	      const checkStats = this.scheduleCellsVisibilityUpdate(passingOpt);
	      const unmountCount = checkStats.unmounted;
	      const mountCount = checkStats.mounted;
	      let processed = data.processed;
	      const total = updates.count;
	      if (stats.updated > 0) {
	        // Some updates have been just processed
	        processed += stats.updated + stats.unmounted;
	        stats.processed = processed;
	        data.priority = Math.min(stats.priority, data.priority);
	        if (stats.empty && mountCount === 0) {
	          stats.unmounted += unmountCount;
	          stats.mounted += mountCount;
	          stats.priority = data.priority;
	          this.notifyAfterRender(stats, opt);
	          data.processed = 0;
	          data.priority = MIN_PRIORITY;
	          updates.count = 0;
	        } else {
	          data.processed = processed;
	        }
	        data.checkedUnmounted = 0;
	        data.checkedMounted = 0;
	      } else {
	        data.checkedUnmounted += Math.max(passingOpt.mountBatchSize, 0);
	        data.checkedMounted += Math.max(passingOpt.unmountBatchSize, 0);
	        // The `scheduleCellsVisibilityUpdate` could have scheduled some insertions
	        // (note that removals are currently done synchronously).
	        if (options.autoFreeze && !this.hasScheduledUpdates()) {
	          // If there are no updates scheduled and we checked all unmounted views,
	          if (data.checkedUnmounted >= unmountedList.length && data.checkedMounted >= mountedList.length) {
	            // We freeze the paper and notify the idle state.
	            this.freeze();
	            updates.idle = {
	              wakeUpOptions: opt
	            };
	            this.trigger('render:idle', opt);
	          }
	        }
	      }
	      // Progress callback
	      const progressFn = opt.progress;
	      if (total && typeof progressFn === 'function') {
	        progressFn.call(this, stats.empty, processed, total, stats, this);
	      }
	      // The current frame could have been canceled in a callback
	      if (updates.id !== id) return;
	    }
	    if (updates.disabled) {
	      throw new Error('dia.Paper: can not unfreeze the paper after it was removed');
	    }
	    updates.id = nextFrame(this.updateViewsAsync, this, opt, data);
	  },
	  notifyBeforeRender: function (opt = {}) {
	    if (opt.silent) return;
	    let beforeFn = opt.beforeRender;
	    if (typeof beforeFn !== 'function') {
	      beforeFn = this.options.beforeRender;
	      if (typeof beforeFn !== 'function') return;
	    }
	    beforeFn.call(this, opt, this);
	  },
	  notifyAfterRender: function (stats, opt = {}) {
	    if (opt.silent) return;
	    let afterFn = opt.afterRender;
	    if (typeof afterFn !== 'function') {
	      afterFn = this.options.afterRender;
	    }
	    if (typeof afterFn === 'function') {
	      afterFn.call(this, stats, opt, this);
	    }
	    this.trigger('render:done', stats, opt);
	  },
	  prioritizeCellViewMount: function (cellOrId) {
	    if (!cellOrId) return false;
	    const cid = this._idToCid[cellOrId.id || cellOrId];
	    if (!cid) return false;
	    const {
	      unmountedList
	    } = this._updates;
	    if (!unmountedList.has(cid)) return false;
	    // Move the view to the head of the mounted list
	    unmountedList.moveToHead(cid);
	    return true;
	  },
	  prioritizeCellViewUnmount: function (cellOrId) {
	    if (!cellOrId) return false;
	    const cid = this._idToCid[cellOrId.id || cellOrId];
	    if (!cid) return false;
	    const {
	      mountedList
	    } = this._updates;
	    if (!mountedList.has(cid)) return false;
	    // Move the view to the head of the unmounted list
	    mountedList.moveToHead(cid);
	    return true;
	  },
	  _evalCellVisibility: function (viewLike, isMounted, visibilityCallback) {
	    if (!visibilityCallback || !viewLike.DETACHABLE) return true;
	    if (this.legacyMode) {
	      return visibilityCallback.call(this, viewLike, isMounted, this);
	    }
	    // The visibility check runs for CellView only.
	    if (!viewLike[CELL_VIEW_MARKER] && !viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) return true;
	    // The cellView model must be a member of this graph.
	    if (viewLike.model.graph !== this.model) {
	      // It could have been removed from the graph.
	      // If the view was mounted, we keep it mounted.
	      return isMounted;
	    }
	    return visibilityCallback.call(this, viewLike.model, isMounted, this);
	  },
	  _getCellVisibilityCallback: function (opt) {
	    const {
	      options
	    } = this;
	    if (this.legacyMode) {
	      const viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;
	      if (typeof viewportFn === 'function') return viewportFn;
	    } else {
	      const isVisibleFn = 'cellVisibility' in opt ? opt.cellVisibility : options.cellVisibility;
	      if (typeof isVisibleFn === 'function') return isVisibleFn;
	    }
	    return null;
	  },
	  updateViewsBatch: function (opt) {
	    opt || (opt = {});
	    var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;
	    var updates = this._updates;
	    var updateCount = 0;
	    var postponeCount = 0;
	    var unmountCount = 0;
	    var mountCount = 0;
	    var maxPriority = MIN_PRIORITY;
	    var empty = true;
	    var options = this.options;
	    var priorities = updates.priorities;
	    const visibilityCb = this._getCellVisibilityCallback(opt);
	    var postponeViewFn = options.onViewPostponed;
	    if (typeof postponeViewFn !== 'function') postponeViewFn = null;
	    var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
	    main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {
	      var priority = +priorityIndexes[i];
	      var priorityUpdates = priorities[priority];
	      for (var cid in priorityUpdates) {
	        if (updateCount >= batchSize) {
	          empty = false;
	          break main;
	        }
	        var view = views[cid];
	        if (!view) {
	          view = this._viewPlaceholders[cid];
	          if (!view) {
	            /**
	             * This can occur when:
	             * - the model is removed and a new model with the same id is added
	             * - the view `initialize` method was overridden and the view was not registered
	             * - an mvc.View scheduled an update, was removed and paper was not notified
	             */
	            delete priorityUpdates[cid];
	            continue;
	          }
	        }
	        var currentFlag = priorityUpdates[cid];
	        if ((currentFlag & this.FLAG_REMOVE) === 0) {
	          // We should never check a view for viewport if we are about to remove the view
	          const isMounted = !updates.unmountedList.has(cid);
	          if (!this._evalCellVisibility(view, isMounted, visibilityCb)) {
	            // Unmount View
	            if (isMounted) {
	              // The view is currently mounted. Hide the view (detach or remove it).
	              this.registerUnmountedView(view);
	              this._hideView(view);
	            } else {
	              // The view is not mounted. We can just update the unmounted list.
	              // We ADD the current flag to the flag that was already scheduled.
	              this._mergeUnmountedViewScheduledUpdates(cid, currentFlag);
	            }
	            // Delete the current update as it has been processed.
	            delete priorityUpdates[cid];
	            unmountCount++;
	            continue;
	          }
	          // Mount View
	          if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {
	            view = this._resolveCellViewPlaceholder(view);
	            // Newly initialized view needs to be initialized
	            currentFlag |= this.getCellViewInitFlag(view);
	          }
	          if (!isMounted) {
	            currentFlag |= this.FLAG_INSERT;
	            mountCount++;
	          }
	          currentFlag |= this.registerMountedView(view);
	        } else if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {
	          // We are trying to remove a placeholder view.
	          // This should not occur as the placeholder should have been unregistered
	          continue;
	        }
	        var leftoverFlag = this.updateView(view, currentFlag, opt);
	        if (leftoverFlag > 0) {
	          // View update has not finished completely
	          priorityUpdates[cid] = leftoverFlag;
	          if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {
	            postponeCount++;
	            empty = false;
	            continue;
	          }
	        }
	        if (maxPriority > priority) maxPriority = priority;
	        updateCount++;
	        delete priorityUpdates[cid];
	      }
	    }
	    return {
	      priority: maxPriority,
	      updated: updateCount,
	      postponed: postponeCount,
	      unmounted: unmountCount,
	      mounted: mountCount,
	      empty: empty
	    };
	  },
	  getCellViewInitFlag: function (cellView) {
	    return this.FLAG_INIT | cellView.getFlag(result(cellView, 'initFlag'));
	  },
	  /**
	   * @ignore This method returns an array of cellViewLike objects and therefore
	   * is meant for internal/test use only.
	   * The view placeholders are not exposed via public API.
	  */
	  getUnmountedViews: function () {
	    const updates = this._updates;
	    const unmountedViews = new Array(updates.unmountedList.length);
	    const unmountedCids = updates.unmountedList.keys();
	    let i = 0;
	    for (const cid of unmountedCids) {
	      // If the view is a placeholder, it won't be in the global views map
	      // If the view is not a cell view, it won't be in the viewPlaceholders map
	      unmountedViews[i++] = views[cid] || this._viewPlaceholders[cid];
	    }
	    return unmountedViews;
	  },
	  /**
	   * @ignore This method returns an array of cellViewLike objects and therefore
	   * is meant for internal/test use only.
	   * The view placeholders are not exposed via public API.
	   */
	  getMountedViews: function () {
	    const updates = this._updates;
	    const mountedViews = new Array(updates.mountedList.length);
	    const mountedCids = updates.mountedList.keys();
	    let i = 0;
	    for (const cid of mountedCids) {
	      mountedViews[i++] = views[cid] || this._viewPlaceholders[cid];
	    }
	    return mountedViews;
	  },
	  checkUnmountedViews: function (visibilityCb, opt) {
	    opt || (opt = {});
	    var mountCount = 0;
	    if (typeof visibilityCb !== 'function') visibilityCb = null;
	    var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;
	    var updates = this._updates;
	    var unmountedList = updates.unmountedList;
	    for (var i = 0, n = Math.min(unmountedList.length, batchSize); i < n; i++) {
	      const {
	        key: cid
	      } = unmountedList.peekHead();
	      let view = views[cid] || this._viewPlaceholders[cid];
	      if (!view) {
	        // This should not occur
	        // Prevent looping over this invalid cid
	        unmountedList.popHead();
	        continue;
	      }
	      if (!this._evalCellVisibility(view, false, visibilityCb)) {
	        // Push at the end of all unmounted ids, so this can be check later again
	        unmountedList.rotate();
	        continue;
	      }
	      // Remove the view from the unmounted list
	      const {
	        value: prevFlag
	      } = unmountedList.popHead();
	      mountCount++;
	      const flag = this.registerMountedView(view) | prevFlag;
	      if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {
	        mounting: true
	      });
	    }
	    return mountCount;
	  },
	  checkMountedViews: function (visibilityCb, opt) {
	    opt || (opt = {});
	    var unmountCount = 0;
	    if (typeof visibilityCb !== 'function') return unmountCount;
	    var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;
	    var updates = this._updates;
	    const mountedList = updates.mountedList;
	    for (var i = 0, n = Math.min(mountedList.length, batchSize); i < n; i++) {
	      const {
	        key: cid
	      } = mountedList.peekHead();
	      const view = views[cid];
	      if (!view) {
	        // A view (not a cell view) has been removed from the paper.
	        // Remove it from the mounted list and continue.
	        mountedList.popHead();
	        continue;
	      }
	      if (this._evalCellVisibility(view, true, visibilityCb)) {
	        // Push at the end of all mounted ids, so this can be check later again
	        mountedList.rotate();
	        continue;
	      }
	      // Remove the view from the mounted list
	      mountedList.popHead();
	      unmountCount++;
	      var flag = this.registerUnmountedView(view);
	      if (flag) {
	        this._hideView(view);
	      }
	    }
	    return unmountCount;
	  },
	  checkViewVisibility: function (cellView, opt = {}) {
	    const visibilityCb = this._getCellVisibilityCallback(opt);
	    const updates = this._updates;
	    const {
	      mountedList,
	      unmountedList
	    } = updates;
	    const visible = this._evalCellVisibility(cellView, false, visibilityCb);
	    let isUnmounted = false;
	    let isMounted = false;
	    if (mountedList.has(cellView.cid) && !visible) {
	      const flag = this.registerUnmountedView(cellView);
	      if (flag) this._hideView(cellView);
	      mountedList.delete(cellView.cid);
	      isUnmounted = true;
	    }
	    if (!isUnmounted && unmountedList.has(cellView.cid) && visible) {
	      const unmountedItem = unmountedList.get(cellView.cid);
	      unmountedList.delete(cellView.cid);
	      const flag = unmountedItem.value | this.registerMountedView(cellView);
	      if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
	        mounting: true
	      });
	      isMounted = true;
	    }
	    return {
	      mounted: isMounted ? 1 : 0,
	      unmounted: isUnmounted ? 1 : 0
	    };
	  },
	  /**
	   * @public
	   * Update the visibility of a single cell.
	   */
	  updateCellVisibility: function (cell, opt = {}) {
	    const cellViewLike = this._getCellViewLike(cell);
	    if (!cellViewLike) return;
	    const stats = this.checkViewVisibility(cellViewLike, opt);
	    // Note: `unmounted` views are removed immediately
	    if (stats.mounted > 0) {
	      // Mounting is scheduled. Run the update.
	      // Note: the view might be a placeholder.
	      this.requireView(cell, opt);
	    }
	  },
	  /**
	   * @public
	   * Update the visibility of all cells.
	   */
	  updateCellsVisibility: function (opt = {}) {
	    // Check the visibility of all cells and schedule their updates.
	    this.scheduleCellsVisibilityUpdate(opt);
	    // Perform the scheduled updates while avoiding re-evaluating the visibility.
	    const keepCurrentVisibility = (_, isVisible) => isVisible;
	    this.updateViews({
	      ...opt,
	      cellVisibility: keepCurrentVisibility
	    });
	  },
	  /**
	   * @protected
	   * Run visibility checks for all cells and schedule their updates.
	   */
	  scheduleCellsVisibilityUpdate(opt) {
	    const passingOpt = defaults({}, opt, {
	      mountBatchSize: Infinity,
	      unmountBatchSize: Infinity
	    });
	    const visibilityCb = this._getCellVisibilityCallback(passingOpt);
	    const unmountedCount = this.checkMountedViews(visibilityCb, passingOpt);
	    if (unmountedCount > 0) {
	      // Do not check views, that have been just unmounted and pushed at the end of the cids array
	      var unmountedList = this._updates.unmountedList;
	      passingOpt.mountBatchSize = Math.min(unmountedList.length - unmountedCount, passingOpt.mountBatchSize);
	    }
	    const mountedCount = this.checkUnmountedViews(visibilityCb, passingOpt);
	    return {
	      mounted: mountedCount,
	      unmounted: unmountedCount
	    };
	  },
	  /**
	   * @deprecated use `updateCellsVisibility` instead
	   * This method will be renamed and made private in the future.
	   */
	  checkViewport: function (opt) {
	    return this.scheduleCellsVisibilityUpdate(opt);
	  },
	  freeze: function (opt) {
	    opt || (opt = {});
	    var updates = this._updates;
	    var key = opt.key;
	    var isFrozen = this.options.frozen;
	    var freezeKey = updates.freezeKey;
	    if (key && key !== freezeKey) {
	      // key passed, but the paper is already freezed with another key
	      if (isFrozen && freezeKey) return;
	      updates.freezeKey = key;
	      updates.keyFrozen = isFrozen;
	    }
	    this.options.frozen = true;
	    var id = updates.id;
	    updates.id = null;
	    if (!this.legacyMode) {
	      // Make sure the `freeze()` method ends the idle state.
	      updates.idle = false;
	    }
	    if (this.isAsync() && id) cancelFrame(id);
	  },
	  unfreeze: function (opt) {
	    opt || (opt = {});
	    var updates = this._updates;
	    var key = opt.key;
	    var freezeKey = updates.freezeKey;
	    // key passed, but the paper is already freezed with another key
	    if (key && freezeKey && key !== freezeKey) return;
	    updates.freezeKey = null;
	    // key passed, but the paper is already freezed
	    if (key && key === freezeKey && updates.keyFrozen) return;
	    updates.idle = false;
	    if (this.isAsync()) {
	      this.freeze();
	      this.updateViewsAsync(opt);
	    } else {
	      this.updateViews(opt);
	    }
	    this.options.frozen = updates.keyFrozen = false;
	    if (updates.sort) {
	      this.sortLayerViews();
	      updates.sort = false;
	    }
	  },
	  wakeUp: function () {
	    if (!this.isIdle()) return;
	    this.unfreeze(this._updates.idle.wakeUpOptions);
	  },
	  isAsync: function () {
	    return !!this.options.async;
	  },
	  isFrozen: function () {
	    return !!this.options.frozen && !this.isIdle();
	  },
	  isIdle: function () {
	    if (this.legacyMode) {
	      // Not implemented in the legacy mode.
	      return false;
	    }
	    return !!(this._updates && this._updates.idle);
	  },
	  isExactSorting: function () {
	    return this.options.sorting === sortingTypes.EXACT;
	  },
	  onRemove: function () {
	    this.freeze();
	    this._updates.disabled = true;
	    //clean up all DOM elements/views to prevent memory leaks
	    this.removeViews();
	    this._removeLayerViews();
	  },
	  getComputedSize: function () {
	    var options = this.options;
	    var w = options.width;
	    var h = options.height;
	    if (!isNumber(w)) w = this.el.clientWidth;
	    if (!isNumber(h)) h = this.el.clientHeight;
	    return {
	      width: w,
	      height: h
	    };
	  },
	  setDimensions: function (width, height, data = {}) {
	    const {
	      options
	    } = this;
	    const {
	      width: currentWidth,
	      height: currentHeight
	    } = options;
	    let w = width === undefined ? currentWidth : width;
	    let h = height === undefined ? currentHeight : height;
	    if (currentWidth === w && currentHeight === h) return;
	    options.width = w;
	    options.height = h;
	    this._setDimensions();
	    const computedSize = this.getComputedSize();
	    this.trigger('resize', computedSize.width, computedSize.height, data);
	  },
	  _setDimensions: function () {
	    const {
	      options
	    } = this;
	    let w = options.width;
	    let h = options.height;
	    if (isNumber(w)) w = `${Math.round(w)}px`;
	    if (isNumber(h)) h = `${Math.round(h)}px`;
	    this.$el.css({
	      width: w === null ? '' : w,
	      height: h === null ? '' : h
	    });
	  },
	  // Expand/shrink the paper to fit the content.
	  // Alternatively signature function(opt)
	  fitToContent: function (gridWidth, gridHeight, padding, opt) {
	    if (isObject(gridWidth)) {
	      // first parameter is an option object
	      opt = gridWidth;
	    } else {
	      // Support for a deprecated signature
	      opt = assign({
	        gridWidth,
	        gridHeight,
	        padding
	      }, opt);
	    }
	    const {
	      x,
	      y,
	      width,
	      height
	    } = this.getFitToContentArea(opt);
	    const {
	      sx,
	      sy
	    } = this.scale();
	    this.translate(-x * sx, -y * sy, opt);
	    this.setDimensions(width * sx, height * sy, opt);
	    return new Rect(x, y, width, height);
	  },
	  getFitToContentArea: function (opt = {}) {
	    // Calculate the paper size to accommodate all the graph's elements.

	    const gridWidth = opt.gridWidth || 1;
	    const gridHeight = opt.gridHeight || 1;
	    const padding = normalizeSides(opt.padding || 0);
	    const minWidth = Math.max(opt.minWidth || 0, gridWidth);
	    const minHeight = Math.max(opt.minHeight || 0, gridHeight);
	    const maxWidth = opt.maxWidth || Number.MAX_VALUE;
	    const maxHeight = opt.maxHeight || Number.MAX_VALUE;
	    const newOrigin = opt.allowNewOrigin;
	    const area = 'contentArea' in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);
	    const {
	      sx,
	      sy
	    } = this.scale();
	    area.x *= sx;
	    area.y *= sy;
	    area.width *= sx;
	    area.height *= sy;
	    let calcWidth = Math.ceil((area.width + area.x) / gridWidth);
	    let calcHeight = Math.ceil((area.height + area.y) / gridHeight);
	    if (!opt.allowNegativeBottomRight) {
	      calcWidth = Math.max(calcWidth, 1);
	      calcHeight = Math.max(calcHeight, 1);
	    }
	    calcWidth *= gridWidth;
	    calcHeight *= gridHeight;
	    let tx = 0;
	    if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {
	      tx = Math.ceil(-area.x / gridWidth) * gridWidth;
	      tx += padding.left;
	      calcWidth += tx;
	    }
	    let ty = 0;
	    if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {
	      ty = Math.ceil(-area.y / gridHeight) * gridHeight;
	      ty += padding.top;
	      calcHeight += ty;
	    }
	    calcWidth += padding.right;
	    calcHeight += padding.bottom;

	    // Make sure the resulting width and height are greater than minimum.
	    calcWidth = Math.max(calcWidth, minWidth);
	    calcHeight = Math.max(calcHeight, minHeight);

	    // Make sure the resulting width and height are lesser than maximum.
	    calcWidth = Math.min(calcWidth, maxWidth);
	    calcHeight = Math.min(calcHeight, maxHeight);
	    return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);
	  },
	  transformToFitContent: function (opt) {
	    opt || (opt = {});
	    let contentBBox, contentLocalOrigin;
	    if ('contentArea' in opt) {
	      const contentArea = opt.contentArea;
	      contentBBox = this.localToPaperRect(contentArea);
	      contentLocalOrigin = new Point(contentArea);
	    } else {
	      contentBBox = this.getContentBBox(opt);
	      contentLocalOrigin = this.paperToLocalPoint(contentBBox);
	    }
	    if (!contentBBox.width || !contentBBox.height) return;
	    defaults(opt, {
	      padding: 0,
	      preserveAspectRatio: true,
	      scaleGrid: null,
	      minScale: 0,
	      maxScale: Number.MAX_VALUE,
	      verticalAlign: 'top',
	      horizontalAlign: 'left'
	      //minScaleX
	      //minScaleY
	      //maxScaleX
	      //maxScaleY
	      //fittingBBox
	    });
	    const padding = normalizeSides(opt.padding);
	    const minScaleX = opt.minScaleX || opt.minScale;
	    const maxScaleX = opt.maxScaleX || opt.maxScale;
	    const minScaleY = opt.minScaleY || opt.minScale;
	    const maxScaleY = opt.maxScaleY || opt.maxScale;
	    let fittingBBox;
	    if (opt.fittingBBox) {
	      fittingBBox = opt.fittingBBox;
	    } else {
	      const currentTranslate = this.translate();
	      const computedSize = this.getComputedSize();
	      fittingBBox = {
	        x: currentTranslate.tx,
	        y: currentTranslate.ty,
	        width: computedSize.width,
	        height: computedSize.height
	      };
	    }
	    fittingBBox = new Rect(fittingBBox).moveAndExpand({
	      x: padding.left,
	      y: padding.top,
	      width: -padding.left - padding.right,
	      height: -padding.top - padding.bottom
	    });
	    const ctm = this.matrix();
	    const {
	      a: sx,
	      d: sy,
	      e: tx,
	      f: ty
	    } = ctm;
	    let newSx = fittingBBox.width / contentBBox.width * sx;
	    let newSy = fittingBBox.height / contentBBox.height * sy;
	    if (opt.preserveAspectRatio) {
	      newSx = newSy = Math.min(newSx, newSy);
	    }

	    // snap scale to a grid
	    if (opt.scaleGrid) {
	      const gridSize = opt.scaleGrid;
	      newSx = gridSize * Math.floor(newSx / gridSize);
	      newSy = gridSize * Math.floor(newSy / gridSize);
	    }

	    // scale min/max boundaries
	    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
	    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
	    const scaleDiff = {
	      x: newSx / sx,
	      y: newSy / sy
	    };
	    let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;
	    let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;
	    switch (opt.verticalAlign) {
	      case 'middle':
	        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;
	        break;
	      case 'bottom':
	        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);
	        break;
	      case 'top':
	      default:
	        break;
	    }
	    switch (opt.horizontalAlign) {
	      case 'middle':
	        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;
	        break;
	      case 'right':
	        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);
	        break;
	      case 'left':
	      default:
	        break;
	    }
	    ctm.a = newSx;
	    ctm.d = newSy;
	    ctm.e = newOx;
	    ctm.f = newOy;
	    this.matrix(ctm, opt);
	  },
	  scaleContentToFit: function (opt) {
	    this.transformToFitContent(opt);
	  },
	  // Return the dimensions of the content area in local units (without transformations).
	  getContentArea: function (opt) {
	    if (opt && opt.useModelGeometry) {
	      return this.model.getBBox() || new Rect();
	    }
	    const graphLayerViews = this.getGraphLayerViews();
	    // Return an empty rectangle if there are no layers
	    // should not happen in practice
	    if (graphLayerViews.length === 0) {
	      return new Rect();
	    }

	    // Combine content area rectangles from all layers,
	    // considering only graph layer views to exclude non-cell elements (e.g., grid, tools)
	    const bbox = Rect.fromRectUnion(...graphLayerViews.map(view => view.vel.getBBox()));
	    return bbox;
	  },
	  // Return the dimensions of the content bbox in the paper units (as it appears on screen).
	  getContentBBox: function (opt) {
	    return this.localToPaperRect(this.getContentArea(opt));
	  },
	  // Returns a geometry rectangle representing the entire
	  // paper area (coordinates from the left paper border to the right one
	  // and the top border to the bottom one).
	  getArea: function () {
	    return this.paperToLocalRect(this.getComputedSize());
	  },
	  getRestrictedArea: function (...args) {
	    const {
	      restrictTranslate
	    } = this.options;
	    let restrictedArea;
	    if (isFunction(restrictTranslate)) {
	      // A method returning a bounding box
	      restrictedArea = restrictTranslate.apply(this, args);
	    } else if (restrictTranslate === true) {
	      // The paper area
	      restrictedArea = this.getArea();
	    } else if (!restrictTranslate) {
	      // falsy value
	      restrictedArea = null;
	    } else {
	      // any other value
	      restrictedArea = new Rect(restrictTranslate);
	    }
	    return restrictedArea;
	  },
	  _resolveCellViewPlaceholder: function (placeholder) {
	    const {
	      model,
	      viewClass,
	      cid
	    } = placeholder;
	    const view = this._initializeCellView(viewClass, model, cid);
	    this._registerCellView(view);
	    this._unregisterCellViewPlaceholder(placeholder);
	    return view;
	  },
	  _registerCellViewPlaceholder: function (cell, cid = uniqueId('view')) {
	    const ViewClass = this._resolveCellViewClass(cell);
	    const placeholder = {
	      // A tag to identify the placeholder from a CellView.
	      [CELL_VIEW_PLACEHOLDER_MARKER]: true,
	      cid,
	      model: cell,
	      DETACHABLE: true,
	      viewClass: ViewClass,
	      UPDATE_PRIORITY: ViewClass.prototype.UPDATE_PRIORITY
	    };
	    this._viewPlaceholders[cid] = placeholder;
	    return placeholder;
	  },
	  _registerCellView: function (cellView) {
	    cellView.paper = this;
	    this._views[cellView.model.id] = cellView;
	  },
	  _unregisterCellViewPlaceholder: function (placeholder) {
	    delete this._viewPlaceholders[placeholder.cid];
	  },
	  _initializeCellView: function (ViewClass, cell, cid) {
	    const {
	      options
	    } = this;
	    const {
	      interactive,
	      labelsLayer
	    } = options;
	    return new ViewClass({
	      cid,
	      model: cell,
	      interactive,
	      labelsLayer: labelsLayer === true ? paperLayers.LABELS : labelsLayer
	    });
	  },
	  _resolveCellViewClass: function (cell) {
	    const {
	      options
	    } = this;
	    const {
	      cellViewNamespace
	    } = options;
	    const type = cell.get('type') + 'View';
	    const namespaceViewClass = getByPath(cellViewNamespace, type, '.');
	    // A class taken from the paper options.
	    let optionalViewClass;
	    let defaultViewClass;
	    if (cell.isLink()) {
	      optionalViewClass = options.linkView;
	      defaultViewClass = LinkView;
	    } else {
	      optionalViewClass = options.elementView;
	      defaultViewClass = ElementView;
	    }
	    // a) the paper options view is a class (deprecated)
	    //  1. search the namespace for a view
	    //  2. if no view was found, use view from the paper options
	    // b) the paper options view is a function
	    //  1. call the function from the paper options
	    //  2. if no view was return, search the namespace for a view
	    //  3. if no view was found, use the default
	    return optionalViewClass.prototype instanceof ViewBase ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;
	  },
	  // Returns a CellView instance or its placeholder for the given cell.
	  _getCellViewLike: function (cell) {
	    let id;
	    if (isString(cell) || isNumber(cell)) {
	      // If the cell is a string or number, it is an id of the view.
	      id = cell;
	    } else if (cell) {
	      // If the cell is an object, it should have an id property.
	      id = cell.id;
	    } else {
	      // If the cell is falsy, return null.
	      return null;
	    }
	    const view = this._views[id];
	    if (view) return view;

	    // If the view is not found, it may be a placeholder
	    const cid = this._idToCid[id];
	    if (cid) {
	      return this._viewPlaceholders[cid];
	    }
	    return null;
	  },
	  createViewForModel: function (cell, cid) {
	    return this._initializeCellView(this._resolveCellViewClass(cell), cell, cid);
	  },
	  removeView: function (cell) {
	    const {
	      id
	    } = cell;
	    const {
	      _views,
	      _updates
	    } = this;
	    const view = _views[id];
	    if (view) {
	      var {
	        cid
	      } = view;
	      const {
	        mountedList,
	        unmountedList
	      } = _updates;
	      view.remove();
	      delete _views[id];
	      delete this._idToCid[id];
	      mountedList.delete(cid);
	      unmountedList.delete(cid);
	    }
	    return view;
	  },
	  renderView: function (cell, opt) {
	    const {
	      id
	    } = cell;
	    const views = this._views;
	    let view, flag;
	    let create = true;
	    if (id in views) {
	      view = views[id];
	      if (view.model === cell) {
	        flag = this.FLAG_INSERT;
	        create = false;
	      } else {
	        // The view for this `id` already exist.
	        // The cell is a new instance of the model with identical id
	        // We simply remove the existing view and create a new one
	        this.removeView(cell);
	      }
	    }
	    if (create) {
	      const {
	        viewManagement
	      } = this.options;
	      const cid = uniqueId('view');
	      this._idToCid[cell.id] = cid;
	      if (viewManagement.lazyInitialize) {
	        // Register only a placeholder for the view
	        view = this._registerCellViewPlaceholder(cell, cid);
	        flag = this.registerUnmountedView(view);
	      } else {
	        // Create a new view instance
	        view = this.createViewForModel(cell, cid);
	        this._registerCellView(view);
	        flag = this.registerUnmountedView(view);
	        // The newly created view needs to be initialized
	        flag |= this.getCellViewInitFlag(view);
	      }
	      if (viewManagement.initializeUnmounted) {
	        // Save the initialization flags for later and exit early
	        this._mergeUnmountedViewScheduledUpdates(cid, flag);
	        return view;
	      }
	    }
	    this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);
	    return view;
	  },
	  // Update the view flags in the `unmountedList` using the bitwise OR operation
	  _mergeUnmountedViewScheduledUpdates: function (cid, flag) {
	    const {
	      unmountedList
	    } = this._updates;
	    const unmountedItem = unmountedList.get(cid);
	    if (unmountedItem) {
	      unmountedItem.value |= flag;
	    }
	  },
	  onImageDragStart: function () {
	    // This is the only way to prevent image dragging in Firefox that works.
	    // Setting -moz-user-select: none, draggable="false" attribute or user-drag: none didn't help.

	    return false;
	  },
	  resetViews: function (cells, opt) {
	    opt || (opt = {});
	    cells || (cells = []);
	    // Allows to unfreeze normally while in the idle state using autoFreeze option
	    const key = (this.legacyMode ? this.options.autoFreeze : this.isIdle()) ? null : 'reset';
	    this._resetUpdates();
	    // clearing views removes any event listeners
	    this.removeViews();
	    this.freeze({
	      key
	    });
	    for (var i = 0, n = cells.length; i < n; i++) {
	      this.renderView(cells[i], opt);
	    }
	    this.unfreeze({
	      key
	    });
	    this.sortLayerViews();
	  },
	  removeViews: function () {
	    // Remove all views and their references from the paper.
	    for (const id in this._views) {
	      const view = this._views[id];
	      if (view) {
	        view.remove();
	      }
	    }
	    this._views = {};
	    this._viewPlaceholders = {};
	    this._idToCid = {};
	  },
	  sortLayerViews: function () {
	    if (!this.isExactSorting()) {
	      // noop
	      return;
	    }
	    if (this.isFrozen() || this.isIdle()) {
	      // sort views once unfrozen
	      this._updates.sort = true;
	      return;
	    }
	    this.sortLayerViewsExact();
	  },
	  sortLayerViewsExact: function () {
	    this.getGraphLayerViews().forEach(view => view.sortExact());
	  },
	  insertView: function (view, isInitialInsert) {
	    // layer can be null if it is added to the graph with 'dry' option
	    const layerId = this.model.getCellLayerId(view.model);
	    const layerView = this.getLayerView(layerId);
	    layerView.insertCellView(view);
	    view.onMount(isInitialInsert);
	  },
	  _hideView: function (viewLike) {
	    if (!viewLike || viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {
	      // A placeholder view was never mounted
	      return;
	    }
	    if (viewLike[CELL_VIEW_MARKER]) {
	      this._hideCellView(viewLike);
	    } else {
	      // A generic view that is not a cell view.
	      viewLike.unmount();
	    }
	  },
	  // If `cellVisibility` returns `false`, the view will be hidden using this method.
	  _hideCellView: function (cellView) {
	    if (this.options.viewManagement.disposeHidden) {
	      if (this._disposeCellView(cellView)) return;
	    }
	    // Detach the view from the paper, but keep it in memory
	    this._detachCellView(cellView);
	  },
	  _disposeCellView: function (cellView) {
	    if (HighlighterView.has(cellView) || cellView.hasTools()) {
	      // We currently do not dispose views which has a highlighter or tools attached
	      // Note: Possible improvement would be to serialize highlighters/tools and
	      // restore them on view re-mount.
	      return false;
	    }
	    const cell = cellView.model;
	    // Remove the view from the paper and dispose it
	    cellView.remove();
	    delete this._views[cell.id];
	    this._registerCellViewPlaceholder(cell, cellView.cid);
	    return true;
	  },
	  // Dispose (release resources) all hidden views.
	  disposeHiddenCellViews: function () {
	    // Only cell views can be in the unmounted list (not in the legacy mode).
	    if (this.legacyMode) return;
	    const unmountedCids = this._updates.unmountedList.keys();
	    for (const cid of unmountedCids) {
	      const cellView = views[cid];
	      cellView && this._disposeCellView(cellView);
	    }
	  },
	  // Detach a view from the paper, but keep it in memory.
	  _detachCellView(cellView) {
	    cellView.unmount();
	    cellView.onDetach();
	  },
	  // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also
	  // be a selector or a jQuery object.
	  findView: function ($el) {
	    var el = isString($el) ? this.layers.querySelector($el) : $el instanceof $ ? $el[0] : $el;
	    var id = this.findAttribute('model-id', el);
	    if (id) return this._views[id];
	    return undefined;
	  },
	  // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.
	  findViewByModel: function (cellOrId) {
	    const cellViewLike = this._getCellViewLike(cellOrId);
	    if (!cellViewLike) return undefined;
	    if (cellViewLike[CELL_VIEW_MARKER]) {
	      // If the view is not a placeholder, return it directly
	      return cellViewLike;
	    }
	    // We do not expose placeholder views directly. We resolve them before returning.
	    const cellView = this._resolveCellViewPlaceholder(cellViewLike);
	    const flag = this.getCellViewInitFlag(cellView);
	    if (this.isViewMounted(cellView)) {
	      // The view was acting as a placeholder and is already present in the `mounted` list,
	      // indicating that its visibility has been checked, but the update hasn't occurred yet.
	      // Placeholders are resolved during the update routine. Since we're handling it
	      // manually here, we must ensure the view is properly initialized on the next update.
	      this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
	        // It's important to run in isolation to avoid triggering the update of
	        // connected links
	        isolate: true
	      });
	    } else {
	      // Update the flags in the `unmounted` list
	      this._mergeUnmountedViewScheduledUpdates(cellView.cid, flag);
	    }
	    return cellView;
	  },
	  // Find all views at given point
	  findViewsFromPoint: function (p) {
	    p = new Point(p);
	    var views = this.model.getElements().map(this.findViewByModel, this);
	    return views.filter(function (view) {
	      return view && view.vel.getBBox({
	        target: this.layers
	      }).containsPoint(p);
	    }, this);
	  },
	  // Find all views in given area
	  findViewsInArea: function (rect, opt) {
	    opt = defaults(opt || {}, {
	      strict: false
	    });
	    rect = new Rect(rect);
	    var views = this.model.getElements().map(this.findViewByModel, this);
	    var method = opt.strict ? 'containsRect' : 'intersect';
	    return views.filter(function (view) {
	      return view && rect[method](view.vel.getBBox({
	        target: this.layers
	      }));
	    }, this);
	  },
	  findElementViewsInArea(plainArea, opt) {
	    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt), opt);
	  },
	  findLinkViewsInArea: function (plainArea, opt) {
	    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt), opt);
	  },
	  findCellViewsInArea: function (plainArea, opt) {
	    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt), opt);
	  },
	  findElementViewsAtPoint: function (plainPoint, opt) {
	    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findElementsInArea(extArea), opt);
	  },
	  findLinkViewsAtPoint: function (plainPoint, opt) {
	    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findLinksInArea(extArea), opt);
	  },
	  findCellViewsAtPoint: function (plainPoint, opt) {
	    return this._filterViewsAtPoint(plainPoint,
	    // Note: we do not want to pass `opt` to `findCellsInArea`
	    // because the `strict` option works differently for querying at a point
	    extArea => this.model.findCellsInArea(extArea), opt);
	  },
	  findClosestMagnetToPoint: function (point, options = {}) {
	    let minDistance = Number.MAX_SAFE_INTEGER;
	    let bestPriority = -Infinity;
	    const pointer = new Point(point);
	    const radius = options.radius || Number.MAX_SAFE_INTEGER;
	    const viewsInArea = this.findCellViewsInArea({
	      x: pointer.x - radius,
	      y: pointer.y - radius,
	      width: 2 * radius,
	      height: 2 * radius
	    }, options.findInAreaOptions);
	    // Enable all connections by default
	    const filterFn = typeof options.filter === 'function' ? options.filter : null;
	    let closestView = null;
	    let closestMagnet = null;

	    // Note: If snapRadius is smaller than magnet size, views will not be found.
	    viewsInArea.forEach(view => {
	      const candidates = [];
	      const {
	        model
	      } = view;
	      // skip connecting to the element in case '.': { magnet: false } attribute present
	      if (view.el.getAttribute('magnet') !== 'false') {
	        if (model.isLink()) {
	          const connection = view.getConnection();
	          candidates.push({
	            // find distance from the closest point of a link to pointer coordinates
	            priority: 0,
	            distance: connection.closestPoint(pointer).squaredDistance(pointer),
	            magnet: view.el
	          });
	        } else {
	          candidates.push({
	            // Set the priority to the level of nested elements of the model
	            // To ensure that the embedded cells get priority over the parent cells
	            priority: model.getAncestors().length,
	            // find distance from the center of the model to pointer coordinates
	            distance: model.getBBox().center().squaredDistance(pointer),
	            magnet: view.el
	          });
	        }
	      }
	      view.$('[magnet]').toArray().forEach(magnet => {
	        const magnetBBox = view.getNodeBBox(magnet);
	        let magnetDistance = magnetBBox.pointNearestToPoint(pointer).squaredDistance(pointer);
	        if (magnetBBox.containsPoint(pointer)) {
	          // Pointer sits inside this magnet.
	          // Push its distance far into the negative range so any
	          // "under-pointer" magnet outranks magnets that are only nearby
	          // (positive distance) and every non-magnet candidate.
	          // We add the original distance back to keep ordering among
	          // overlapping magnets: the one whose border is closest to the
	          // pointer (smaller original distance) still wins.
	          magnetDistance = -Number.MAX_SAFE_INTEGER + magnetDistance;
	        }

	        // Check if magnet is inside the snap radius.
	        if (magnetDistance <= radius * radius) {
	          candidates.push({
	            // Give magnets priority over other candidates.
	            priority: Number.MAX_SAFE_INTEGER,
	            distance: magnetDistance,
	            magnet
	          });
	        }
	      });
	      candidates.forEach(candidate => {
	        const {
	          magnet,
	          distance,
	          priority
	        } = candidate;
	        const isBetterCandidate = priority > bestPriority || priority === bestPriority && distance < minDistance;
	        if (isBetterCandidate && (!filterFn || filterFn(view, magnet))) {
	          bestPriority = priority;
	          minDistance = distance;
	          closestView = view;
	          closestMagnet = magnet;
	        }
	      });
	    });
	    return closestView ? {
	      view: closestView,
	      magnet: closestMagnet
	    } : null;
	  },
	  _findInExtendedArea: function (area, findCellsFn, opt = {}) {
	    const {
	      buffer = this.DEFAULT_FIND_BUFFER
	    } = opt;
	    const extendedArea = new Rect(area).inflate(buffer);
	    const cellsInExtendedArea = findCellsFn(extendedArea, opt);
	    return cellsInExtendedArea.map(element => this.findViewByModel(element));
	  },
	  _filterViewsInArea: function (plainArea, findCells, opt = {}) {
	    const area = new Rect(plainArea);
	    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
	    const viewsInArea = viewsInExtendedArea.filter(view => {
	      if (!view) return false;
	      return view.isInArea(area, opt);
	    });
	    return viewsInArea;
	  },
	  _filterViewsAtPoint: function (plainPoint, findCells, opt = {}) {
	    const area = new Rect(plainPoint); // zero-size area
	    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
	    const viewsAtPoint = viewsInExtendedArea.filter(view => {
	      if (!view) return false;
	      return view.isAtPoint(plainPoint, opt);
	    });
	    return viewsAtPoint;
	  },
	  removeTools: function () {
	    this.dispatchToolsEvent('remove');
	    return this;
	  },
	  hideTools: function () {
	    this.dispatchToolsEvent('hide');
	    return this;
	  },
	  showTools: function () {
	    this.dispatchToolsEvent('show');
	    return this;
	  },
	  dispatchToolsEvent: function (event, ...args) {
	    if (typeof event !== 'string') return;
	    this.trigger('tools:event', event, ...args);
	  },
	  getModelById: function (id) {
	    return this.model.getCell(id);
	  },
	  snapToGrid: function (x, y) {
	    // Convert global coordinates to the local ones of the `viewport`. Otherwise,
	    // improper transformation would be applied when the viewport gets transformed (scaled/rotated).
	    return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);
	  },
	  localToPaperPoint: function (x, y) {
	    // allow `x` to be a point and `y` undefined
	    var localPoint = new Point(x, y);
	    var paperPoint = V.transformPoint(localPoint, this.matrix());
	    return paperPoint;
	  },
	  localToPaperRect: function (x, y, width, height) {
	    // allow `x` to be a rectangle and rest arguments undefined
	    var localRect = new Rect(x, y, width, height);
	    var paperRect = V.transformRect(localRect, this.matrix());
	    return paperRect;
	  },
	  paperToLocalPoint: function (x, y) {
	    // allow `x` to be a point and `y` undefined
	    var paperPoint = new Point(x, y);
	    var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());
	    return localPoint;
	  },
	  paperToLocalRect: function (x, y, width, height) {
	    // allow `x` to be a rectangle and rest arguments undefined
	    var paperRect = new Rect(x, y, width, height);
	    var localRect = V.transformRect(paperRect, this.matrix().inverse());
	    return localRect;
	  },
	  localToClientPoint: function (x, y) {
	    // allow `x` to be a point and `y` undefined
	    var localPoint = new Point(x, y);
	    var clientPoint = V.transformPoint(localPoint, this.clientMatrix());
	    return clientPoint;
	  },
	  localToClientRect: function (x, y, width, height) {
	    // allow `x` to be a point and `y` undefined
	    var localRect = new Rect(x, y, width, height);
	    var clientRect = V.transformRect(localRect, this.clientMatrix());
	    return clientRect;
	  },
	  // Transform client coordinates to the paper local coordinates.
	  // Useful when you have a mouse event object and you'd like to get coordinates
	  // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.
	  // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });
	  clientToLocalPoint: function (x, y) {
	    // allow `x` to be a point and `y` undefined
	    var clientPoint = new Point(x, y);
	    var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());
	    return localPoint;
	  },
	  clientToLocalRect: function (x, y, width, height) {
	    // allow `x` to be a point and `y` undefined
	    var clientRect = new Rect(x, y, width, height);
	    var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());
	    return localRect;
	  },
	  localToPagePoint: function (x, y) {
	    return this.localToPaperPoint(x, y).offset(this.pageOffset());
	  },
	  localToPageRect: function (x, y, width, height) {
	    return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());
	  },
	  pageToLocalPoint: function (x, y) {
	    var pagePoint = new Point(x, y);
	    var paperPoint = pagePoint.difference(this.pageOffset());
	    return this.paperToLocalPoint(paperPoint);
	  },
	  pageToLocalRect: function (x, y, width, height) {
	    var pageOffset = this.pageOffset();
	    var paperRect = new Rect(x, y, width, height);
	    paperRect.x -= pageOffset.x;
	    paperRect.y -= pageOffset.y;
	    return this.paperToLocalRect(paperRect);
	  },
	  clientOffset: function () {
	    var clientRect = this.svg.getBoundingClientRect();
	    return new Point(clientRect.left, clientRect.top);
	  },
	  pageOffset: function () {
	    return this.clientOffset().offset(window.scrollX, window.scrollY);
	  },
	  linkAllowed: function (linkView) {
	    if (!(linkView instanceof LinkView)) {
	      throw new Error('Must provide a linkView.');
	    }
	    var link = linkView.model;
	    var paperOptions = this.options;
	    var graph = this.model;
	    var ns = graph.constructor.validations;
	    if (!paperOptions.multiLinks) {
	      if (!ns.multiLinks.call(this, graph, link)) return false;
	    }
	    if (!paperOptions.linkPinning) {
	      // Link pinning is not allowed and the link is not connected to the target.
	      if (!ns.linkPinning.call(this, graph, link)) return false;
	    }
	    if (typeof paperOptions.allowLink === 'function') {
	      if (!paperOptions.allowLink.call(this, linkView, this)) return false;
	    }
	    return true;
	  },
	  getDefaultLink: function (cellView, magnet) {
	    return isFunction(this.options.defaultLink)
	    // default link is a function producing link model
	    ? this.options.defaultLink.call(this, cellView, magnet)
	    // default link is the mvc model
	    : this.options.defaultLink.clone();
	  },
	  // Cell highlighting.
	  // ------------------

	  resolveHighlighter: function (opt = {}) {
	    let {
	      highlighter: highlighterDef,
	      type
	    } = opt;
	    const {
	      highlighting,
	      highlighterNamespace
	    } = this.options;

	    /*
	        Expecting opt.highlighter to have the following structure:
	        {
	            name: 'highlighter-name',
	            options: {
	                some: 'value'
	            }
	        }
	    */
	    if (highlighterDef === undefined) {
	      // Is highlighting disabled?
	      if (!highlighting) return false;
	      // check for built-in types
	      if (type) {
	        highlighterDef = highlighting[type];
	        // Is a specific type highlight disabled?
	        if (highlighterDef === false) return false;
	      }
	      if (!highlighterDef) {
	        // Type not defined use default highlight
	        highlighterDef = highlighting['default'];
	      }
	    }

	    // Do nothing if opt.highlighter is falsy.
	    // This allows the case to not highlight cell(s) in certain cases.
	    // For example, if you want to NOT highlight when embedding elements
	    // or use a custom highlighter.
	    if (!highlighterDef) return false;

	    // Allow specifying a highlighter by name.
	    if (isString(highlighterDef)) {
	      highlighterDef = {
	        name: highlighterDef
	      };
	    }
	    const name = highlighterDef.name;
	    const highlighter = highlighterNamespace[name];

	    // Highlighter validation
	    if (!highlighter) {
	      throw new Error('Unknown highlighter ("' + name + '")');
	    }
	    if (typeof highlighter.highlight !== 'function') {
	      throw new Error('Highlighter ("' + name + '") is missing required highlight() method');
	    }
	    if (typeof highlighter.unhighlight !== 'function') {
	      throw new Error('Highlighter ("' + name + '") is missing required unhighlight() method');
	    }
	    return {
	      highlighter,
	      options: highlighterDef.options || {},
	      name
	    };
	  },
	  onCellHighlight: function (cellView, magnetEl, opt) {
	    const highlighterDescriptor = this.resolveHighlighter(opt);
	    if (!highlighterDescriptor) return;
	    const {
	      highlighter,
	      options
	    } = highlighterDescriptor;
	    highlighter.highlight(cellView, magnetEl, options);
	  },
	  onCellUnhighlight: function (cellView, magnetEl, opt) {
	    const highlighterDescriptor = this.resolveHighlighter(opt);
	    if (!highlighterDescriptor) return;
	    const {
	      highlighter,
	      options
	    } = highlighterDescriptor;
	    highlighter.unhighlight(cellView, magnetEl, options);
	  },
	  // Interaction.
	  // ------------

	  pointerdblclick: function (evt) {
	    evt.preventDefault();

	    // magnetpointerdblclick can stop propagation

	    evt = normalizeEvent(evt);
	    var view = this.findView(evt.target);
	    if (this.guard(evt, view)) return;
	    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	    if (view) {
	      view.pointerdblclick(evt, localPoint.x, localPoint.y);
	    } else {
	      this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);
	    }
	  },
	  pointerclick: function (evt) {
	    // magnetpointerclick can stop propagation

	    var data = this.eventData(evt);
	    // Trigger event only if mouse has not moved.
	    if (data.mousemoved <= this.options.clickThreshold) {
	      evt = normalizeEvent(evt);
	      var view = this.findView(evt.target);
	      if (this.guard(evt, view)) return;
	      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	      if (view) {
	        view.pointerclick(evt, localPoint.x, localPoint.y);
	      } else {
	        this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);
	      }
	    }
	  },
	  contextmenu: function (evt) {
	    if (this.options.preventContextMenu) evt.preventDefault();
	    if (this.contextMenuFired) {
	      this.contextMenuFired = false;
	      return;
	    }
	    evt = normalizeEvent(evt);
	    this.contextMenuTrigger(evt);
	  },
	  contextMenuTrigger: function (evt) {
	    var view = this.findView(evt.target);
	    if (this.guard(evt, view)) return;
	    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	    if (view) {
	      view.contextmenu(evt, localPoint.x, localPoint.y);
	    } else {
	      this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);
	    }
	  },
	  pointerdown: function (evt) {
	    evt = normalizeEvent(evt);
	    const {
	      target,
	      button
	    } = evt;
	    const view = this.findView(target);
	    const isContextMenu = button === 2;
	    if (view) {
	      if (!isContextMenu && this.guard(evt, view)) return;
	      const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);
	      if (this.options.preventDefaultViewAction && !isTargetFormNode) {
	        // If the target is a form element, we do not want to prevent the default action.
	        // For example, we want to be able to select text in a text input or
	        // to be able to click on a checkbox.
	        evt.preventDefault();
	      }
	      if (isTargetFormNode) {
	        // If the target is a form element, we do not want to start dragging the element.
	        // For example, we want to be able to select text by dragging the mouse.
	        view.preventDefaultInteraction(evt);
	      }

	      // Custom event
	      const eventEvt = this.customEventTrigger(evt, view);
	      if (eventEvt) {
	        // `onevent` could have stopped propagation
	        if (eventEvt.isPropagationStopped()) return;
	        evt.data = eventEvt.data;
	      }

	      // Element magnet
	      const magnetNode = target.closest('[magnet]');
	      if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {
	        const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {
	          data: evt.data,
	          // Originally the event listener was attached to the magnet element.
	          currentTarget: magnetNode
	        }));
	        this.onmagnet(magnetEvt);
	        if (magnetEvt.isDefaultPrevented()) {
	          evt.preventDefault();
	        }
	        // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed
	        if (magnetEvt.isPropagationStopped()) {
	          // `magnet:pointermove` and `magnet:pointerup` events must be fired
	          if (isContextMenu) return;
	          this.delegateDragEvents(view, magnetEvt.data);
	          return;
	        }
	        evt.data = magnetEvt.data;
	      }
	    }
	    if (isContextMenu) {
	      this.contextMenuFired = true;
	      const contextmenuEvt = new $.Event(evt.originalEvent, {
	        type: 'contextmenu',
	        data: evt.data
	      });
	      this.contextMenuTrigger(contextmenuEvt);
	    } else {
	      const localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	      if (view) {
	        view.pointerdown(evt, localPoint.x, localPoint.y);
	      } else {
	        if (this.options.preventDefaultBlankAction) {
	          evt.preventDefault();
	        }
	        this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);
	      }
	      this.delegateDragEvents(view, evt.data);
	    }
	  },
	  pointermove: function (evt) {
	    // mouse moved counter
	    var data = this.eventData(evt);
	    if (!data.mousemoved) {
	      data.mousemoved = 0;
	      // Make sure that events like `mouseenter` and `mouseleave` are
	      // not triggered while the user is dragging a cellView.
	      this.undelegateEvents();
	      // Note: the events are undelegated after the first `pointermove` event.
	      // Not on `pointerdown` to make sure that `dbltap` is recognized.
	    }
	    var mousemoved = ++data.mousemoved;
	    if (mousemoved <= this.options.moveThreshold) return;
	    evt = normalizeEvent(evt);
	    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	    let view = data.sourceView;
	    if (view) {
	      // The view could have been disposed during dragging
	      // e.g. dragged outside of the viewport and hidden
	      view = this.findViewByModel(view.model);
	      view.pointermove(evt, localPoint.x, localPoint.y);
	    } else {
	      this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);
	    }
	    this.eventData(evt, data);
	  },
	  pointerup: function (evt) {
	    this.undelegateDocumentEvents();
	    var normalizedEvt = normalizeEvent(evt);
	    var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
	    let view = this.eventData(evt).sourceView;
	    if (view) {
	      // The view could have been disposed during dragging
	      // e.g. dragged outside of the viewport and hidden
	      view = this.findViewByModel(view.model);
	      view.pointerup(normalizedEvt, localPoint.x, localPoint.y);
	    } else {
	      this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);
	    }
	    if (!normalizedEvt.isPropagationStopped()) {
	      this.pointerclick(new $.Event(evt.originalEvent, {
	        type: 'click',
	        data: evt.data
	      }));
	    }
	    this.delegateEvents();
	  },
	  mouseover: function (evt) {
	    evt = normalizeEvent(evt);
	    var view = this.findView(evt.target);
	    if (this.guard(evt, view)) return;
	    if (view) {
	      view.mouseover(evt);
	    } else {
	      if (this.el === evt.target) return; // prevent border of paper from triggering this
	      this.trigger('blank:mouseover', evt);
	    }
	  },
	  mouseout: function (evt) {
	    evt = normalizeEvent(evt);
	    var view = this.findView(evt.target);
	    if (this.guard(evt, view)) return;
	    if (view) {
	      view.mouseout(evt);
	    } else {
	      if (this.el === evt.target) return; // prevent border of paper from triggering this
	      this.trigger('blank:mouseout', evt);
	    }
	  },
	  mouseenter: function (evt) {
	    evt = normalizeEvent(evt);
	    const {
	      target,
	      // The EventTarget the pointing device entered to
	      relatedTarget,
	      // The EventTarget the pointing device exited from
	      currentTarget // The EventTarget on which the event listener was registered
	    } = evt;
	    const view = this.findView(target);
	    if (this.guard(evt, view)) return;
	    const relatedView = this.findView(relatedTarget);
	    if (view) {
	      if (relatedView === view) {
	        // Mouse left a cell tool
	        return;
	      }
	      view.mouseenter(evt);
	      if (this.el.contains(relatedTarget)) {
	        // The pointer remains inside the paper.
	        return;
	      }
	    }
	    if (relatedView) {
	      return;
	    }
	    // prevent double `mouseenter` event if the `relatedTarget` is outside the paper
	    // (mouseenter method would be fired twice)
	    if (currentTarget === this.el) {
	      // `paper` (more descriptive), not `blank`
	      this.trigger('paper:mouseenter', evt);
	    }
	  },
	  mouseleave: function (evt) {
	    evt = normalizeEvent(evt);
	    const {
	      target,
	      // The EventTarget the pointing device exited from
	      relatedTarget,
	      // The EventTarget the pointing device entered to
	      currentTarget // The EventTarget on which the event listener was registered
	    } = evt;
	    const view = this.findView(target);
	    if (this.guard(evt, view)) return;
	    const relatedView = this.findView(relatedTarget);
	    if (view) {
	      if (relatedView === view) {
	        // Mouse entered a cell tool
	        return;
	      }
	      view.mouseleave(evt);
	      if (this.el.contains(relatedTarget)) {
	        // The pointer has exited a cellView. The pointer is still inside of the paper.
	        return;
	      }
	    }
	    if (relatedView) {
	      // The pointer has entered a new cellView
	      return;
	    }
	    // prevent double `mouseleave` event if the `relatedTarget` is outside the paper
	    // (mouseleave method would be fired twice)
	    if (currentTarget === this.el) {
	      // There is no cellView under the pointer, nor the blank area of the paper
	      this.trigger('paper:mouseleave', evt);
	    }
	  },
	  _processMouseWheelEvtBuf: debounce(function () {
	    const {
	      event,
	      deltas
	    } = this._mw_evt_buffer;
	    const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);
	    const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom
	    const {
	      x,
	      y
	    } = this.clientToLocalPoint(event.clientX, event.clientY);
	    this.trigger('paper:pinch', event, x, y, scale);
	    this._mw_evt_buffer = {
	      event: null,
	      deltas: []
	    };
	  }, WHEEL_WAIT_MS, {
	    maxWait: WHEEL_WAIT_MS
	  }),
	  mousewheel: function (evt) {
	    evt = normalizeEvent(evt);
	    const view = this.findView(evt.target);
	    if (this.guard(evt, view)) return;
	    const originalEvent = evt.originalEvent;
	    const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);
	    const {
	      deltaX,
	      deltaY
	    } = normalizeWheel(originalEvent);
	    const pinchHandlers = this._events['paper:pinch'];

	    // Touchpad devices will send a fake CTRL press when a pinch is performed
	    //
	    // We also check if there are any subscribers to paper:pinch event. If there are none,
	    // just skip the entire block of code (we don't want to blindly call
	    // .preventDefault() if we really don't have to).
	    if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {
	      // This is a pinch gesture, it's safe to assume that we must call .preventDefault()
	      originalEvent.preventDefault();
	      this._mw_evt_buffer.event = evt;
	      this._mw_evt_buffer.deltas.push(deltaY);
	      this._processMouseWheelEvtBuf();
	    } else {
	      const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));
	      if (view) {
	        view.mousewheel(evt, localPoint.x, localPoint.y, delta);
	      } else {
	        this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);
	      }
	      this.trigger('paper:pan', evt, deltaX, deltaY);
	    }
	  },
	  onevent: function (evt) {
	    var eventNode = evt.currentTarget;
	    var eventName = eventNode.getAttribute('event');
	    if (eventName) {
	      var view = this.findView(eventNode);
	      if (view) {
	        evt = normalizeEvent(evt);
	        if (this.guard(evt, view)) return;
	        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	        view.onevent(evt, eventName, localPoint.x, localPoint.y);
	      }
	    }
	  },
	  magnetEvent: function (evt, handler) {
	    var magnetNode = evt.currentTarget;
	    var magnetValue = magnetNode.getAttribute('magnet');
	    if (magnetValue) {
	      var view = this.findView(magnetNode);
	      if (view) {
	        evt = normalizeEvent(evt);
	        if (this.guard(evt, view)) return;
	        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	        handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);
	      }
	    }
	  },
	  onmagnet: function (evt) {
	    if (evt.button === 2) {
	      this.contextMenuFired = true;
	      this.magnetContextMenuFired = true;
	      const contextmenuEvt = new $.Event(evt.originalEvent, {
	        type: 'contextmenu',
	        data: evt.data,
	        currentTarget: evt.currentTarget
	      });
	      this.magnetContextMenuTrigger(contextmenuEvt);
	      if (contextmenuEvt.isPropagationStopped()) {
	        evt.stopPropagation();
	      }
	    } else {
	      this.magnetEvent(evt, function (view, evt, _, x, y) {
	        view.onmagnet(evt, x, y);
	      });
	    }
	  },
	  magnetpointerdblclick: function (evt) {
	    this.magnetEvent(evt, function (view, evt, magnet, x, y) {
	      view.magnetpointerdblclick(evt, magnet, x, y);
	    });
	  },
	  magnetcontextmenu: function (evt) {
	    if (this.options.preventContextMenu) evt.preventDefault();
	    if (this.magnetContextMenuFired) {
	      this.magnetContextMenuFired = false;
	      return;
	    }
	    this.magnetContextMenuTrigger(evt);
	  },
	  magnetContextMenuTrigger: function (evt) {
	    this.magnetEvent(evt, function (view, evt, magnet, x, y) {
	      view.magnetcontextmenu(evt, magnet, x, y);
	    });
	  },
	  onlabel: function (evt) {
	    var labelNode = evt.currentTarget;
	    var view = this.findView(labelNode);
	    if (!view) return;
	    evt = normalizeEvent(evt);
	    if (this.guard(evt, view)) return;

	    // Custom event
	    const eventEvt = this.customEventTrigger(evt, view, labelNode);
	    if (eventEvt) {
	      // `onevent` could have stopped propagation
	      if (eventEvt.isPropagationStopped()) return;
	      evt.data = eventEvt.data;
	    }
	    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
	    view.onlabel(evt, localPoint.x, localPoint.y);
	  },
	  getPointerArgs(evt) {
	    const normalizedEvt = normalizeEvent(evt);
	    const {
	      x,
	      y
	    } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
	    return [normalizedEvt, x, y];
	  },
	  delegateDragEvents: function (view, data) {
	    data || (data = {});
	    this.eventData({
	      data: data
	    }, {
	      sourceView: view || null,
	      mousemoved: 0
	    });
	    this.delegateDocumentEvents(null, data);
	  },
	  // Guard the specified event. If the event should be ignored, guard returns `true`.
	  // Otherwise, it returns `false`.
	  guard: function (evt, view) {
	    if (evt.type === 'mousedown' && evt.button === 2) {
	      // handled as `contextmenu` type
	      return true;
	    }
	    if (this.options.guard && this.options.guard(evt, view)) {
	      return true;
	    }
	    if (evt.data && evt.data.guarded !== undefined) {
	      return evt.data.guarded;
	    }
	    const {
	      target
	    } = evt;
	    if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {
	      return true;
	    }
	    if (view && view.model && view.model[CELL_MARKER]) {
	      return false;
	    }
	    if (this.el === target || this.svg.contains(target)) {
	      return false;
	    }
	    return true; // Event guarded. Paper should not react on it in any way.
	  },
	  setGridSize: function (gridSize) {
	    const {
	      options
	    } = this;
	    options.gridSize = gridSize;
	    if (options.drawGrid && !options.drawGridSize) {
	      // Do not redraw the grid if the `drawGridSize` is set.
	      this.getLayerView(paperLayers.GRID).renderGrid();
	    }
	    return this;
	  },
	  setGrid: function (drawGrid) {
	    this.getLayerView(paperLayers.GRID).setGrid(drawGrid);
	    return this;
	  },
	  updateBackgroundImage: function (opt) {
	    opt = opt || {};
	    var backgroundPosition = opt.position || 'center';
	    var backgroundSize = opt.size || 'auto auto';
	    var currentScale = this.scale();
	    var currentTranslate = this.translate();

	    // backgroundPosition
	    if (isObject(backgroundPosition)) {
	      var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);
	      var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);
	      backgroundPosition = x + 'px ' + y + 'px';
	    }

	    // backgroundSize
	    if (isObject(backgroundSize)) {
	      backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);
	      backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';
	    }
	    const {
	      background
	    } = this.childNodes;
	    background.style.backgroundSize = backgroundSize;
	    background.style.backgroundPosition = backgroundPosition;
	  },
	  drawBackgroundImage: function (img, opt) {
	    // Clear the background image if no image provided
	    if (!(img instanceof HTMLImageElement)) {
	      this.childNodes.background.style.backgroundImage = '';
	      return;
	    }
	    if (!this._background || this._background.id !== opt.id) {
	      // Draw only the last image requested (see drawBackground())
	      return;
	    }
	    opt = opt || {};
	    var backgroundImage;
	    var backgroundSize = opt.size;
	    var backgroundRepeat = opt.repeat || 'no-repeat';
	    var backgroundOpacity = opt.opacity || 1;
	    var backgroundQuality = Math.abs(opt.quality) || 1;
	    var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];
	    if (isFunction(backgroundPattern)) {
	      // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom
	      img.width *= backgroundQuality;
	      img.height *= backgroundQuality;
	      var canvas = backgroundPattern(img, opt);
	      if (!(canvas instanceof HTMLCanvasElement)) {
	        throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');
	      }
	      backgroundImage = canvas.toDataURL('image/png');
	      backgroundRepeat = 'repeat';
	      if (isObject(backgroundSize)) {
	        // recalculate the tile size if an object passed in
	        backgroundSize.width *= canvas.width / img.width;
	        backgroundSize.height *= canvas.height / img.height;
	      } else if (backgroundSize === undefined) {
	        // calculate the tile size if no provided
	        opt.size = {
	          width: canvas.width / backgroundQuality,
	          height: canvas.height / backgroundQuality
	        };
	      }
	    } else {
	      // backgroundRepeat:
	      // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'
	      backgroundImage = img.src;
	      if (backgroundSize === undefined) {
	        // pass the image size for  the backgroundSize if no size provided
	        opt.size = {
	          width: img.width,
	          height: img.height
	        };
	      }
	    }
	    this.childNodes.background.style.opacity = backgroundOpacity;
	    this.childNodes.background.style.backgroundRepeat = backgroundRepeat;
	    this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;
	    this.updateBackgroundImage(opt);
	  },
	  updateBackgroundColor: function (color) {
	    this.$el.css('backgroundColor', color || '');
	  },
	  drawBackground: function (opt) {
	    opt = opt || {};
	    this.updateBackgroundColor(opt.color);
	    if (opt.image) {
	      opt = this._background = cloneDeep(opt);
	      guid(opt);
	      var img = document.createElement('img');
	      img.onload = this.drawBackgroundImage.bind(this, img, opt);
	      img.src = opt.image;
	    } else {
	      this.drawBackgroundImage(null);
	      this._background = null;
	    }
	    return this;
	  },
	  setInteractivity: function (value) {
	    this.options.interactive = value;
	    invoke(this._views, 'setInteractivity', value);
	  },
	  // Paper definitions.
	  // ------------------

	  isDefined: function (defId) {
	    return !!this.svg.getElementById(defId);
	  },
	  defineFilter: function (filter$1) {
	    if (!isObject(filter$1)) {
	      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');
	    }
	    var filterId = filter$1.id;
	    var name = filter$1.name;
	    // Generate a hash code from the stringified filter definition. This gives us
	    // a unique filter ID for different definitions.
	    if (!filterId) {
	      filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));
	    }
	    // If the filter already exists in the document,
	    // we're done and we can just use it (reference it using `url()`).
	    // If not, create one.
	    if (!this.isDefined(filterId)) {
	      var namespace = filter;
	      var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});
	      if (!filterSVGString) {
	        throw new Error('Non-existing filter ' + name);
	      }

	      // SVG <filter/> attributes
	      var filterAttrs = assign({
	        filterUnits: 'userSpaceOnUse'
	      }, filter$1.attrs, {
	        id: filterId
	      });
	      V(filterSVGString, filterAttrs).appendTo(this.defs);
	    }
	    return filterId;
	  },
	  defineGradient: function (gradient) {
	    if (!isObject(gradient)) {
	      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');
	    }
	    const {
	      svg,
	      defs
	    } = this;
	    const {
	      type,
	      // Generate a hash code from the stringified filter definition. This gives us
	      // a unique filter ID for different definitions.
	      id = type + svg.id + hashCode(JSON.stringify(gradient)),
	      stops,
	      attrs = {}
	    } = gradient;
	    // If the gradient already exists in the document,
	    // we're done and we can just use it (reference it using `url()`).
	    if (this.isDefined(id)) return id;
	    // If not, create one.
	    const stopVEls = toArray$1(stops).map(({
	      offset,
	      color,
	      opacity
	    }) => {
	      return V('stop').attr({
	        'offset': offset,
	        'stop-color': color,
	        'stop-opacity': Number.isFinite(opacity) ? opacity : 1
	      });
	    });
	    const gradientVEl = V(type, attrs, stopVEls);
	    gradientVEl.id = id;
	    gradientVEl.appendTo(defs);
	    return id;
	  },
	  definePattern: function (pattern) {
	    if (!isObject(pattern)) {
	      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');
	    }
	    const {
	      svg,
	      defs
	    } = this;
	    const {
	      // Generate a hash code from the stringified filter definition. This gives us
	      // a unique filter ID for different definitions.
	      id = svg.id + hashCode(JSON.stringify(pattern)),
	      markup,
	      attrs = {}
	    } = pattern;
	    if (!markup) {
	      throw new TypeError('dia.Paper: definePattern() requires markup.');
	    }
	    // If the gradient already exists in the document,
	    // we're done and we can just use it (reference it using `url()`).
	    if (this.isDefined(id)) return id;
	    // If not, create one.
	    const patternVEl = V('pattern', {
	      patternUnits: 'userSpaceOnUse'
	    });
	    patternVEl.id = id;
	    patternVEl.attr(attrs);
	    if (typeof markup === 'string') {
	      patternVEl.append(V(markup));
	    } else {
	      const {
	        fragment
	      } = parseDOMJSON(markup);
	      patternVEl.append(fragment);
	    }
	    patternVEl.appendTo(defs);
	    return id;
	  },
	  defineMarker: function (marker) {
	    if (!isObject(marker)) {
	      throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');
	    }
	    const {
	      svg,
	      defs
	    } = this;
	    const {
	      // Generate a hash code from the stringified filter definition. This gives us
	      // a unique filter ID for different definitions.
	      id = svg.id + hashCode(JSON.stringify(marker)),
	      // user-provided markup
	      // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)
	      markup,
	      // user-provided attributes
	      // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)
	      // note: `transform` attrs are ignored by browsers
	      attrs = {},
	      // deprecated - use `attrs/markerUnits` instead (which has higher priority)
	      markerUnits = 'userSpaceOnUse'
	    } = marker;
	    // If the marker already exists in the document,
	    // we're done and we can just use it (reference it using `url()`).
	    if (this.isDefined(id)) return id;
	    // If not, create one.
	    const markerVEl = V('marker', {
	      orient: 'auto',
	      overflow: 'visible',
	      markerUnits: markerUnits
	    });
	    markerVEl.id = id;
	    markerVEl.attr(attrs);
	    let markerContentVEl;
	    if (markup) {
	      let markupVEl;
	      if (typeof markup === 'string') {
	        // Marker object has a `markup` property of type string.
	        // - Construct V from the provided string.
	        markupVEl = V(markup);
	        // `markupVEl` is now either a single VEl, or an array of VEls.
	        // - Coerce it to an array.
	        markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];
	      } else {
	        // Marker object has a `markup` property of type object.
	        // - Construct V from the object by parsing it as DOM JSON.
	        const {
	          fragment
	        } = parseDOMJSON(markup);
	        markupVEl = V(fragment).children();
	      }
	      // `markupVEl` is an array with one or more VEls inside.
	      // - If there are multiple VEls, wrap them in a newly-constructed <g> element
	      if (markupVEl.length > 1) {
	        markerContentVEl = V('g').append(markupVEl);
	      } else {
	        markerContentVEl = markupVEl[0];
	      }
	    } else {
	      // Marker object is a flat structure.
	      // - Construct a new V of type `marker.type`.
	      const {
	        type = 'path'
	      } = marker;
	      markerContentVEl = V(type);
	    }
	    // `markerContentVEl` is a single VEl.
	    // Assign additional attributes to it (= context attributes + marker attributes):
	    // - Attribute values are taken from non-special properties of `marker`.
	    const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');
	    const markerAttrsKeys = Object.keys(markerAttrs);
	    markerAttrsKeys.forEach(key => {
	      const value = markerAttrs[key];
	      const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority
	      if (markupValue == null) {
	        // Default logic:
	        markerContentVEl.attr(key, value);
	      } else {
	        // Properties with special logic should be added as cases to this switch block:
	        switch (key) {
	          case 'transform':
	            // - Prepend `transform` to existing value.
	            markerContentVEl.attr(key, value + ' ' + markupValue);
	            break;
	        }
	      }
	    });
	    markerContentVEl.appendTo(markerVEl);
	    markerVEl.appendTo(defs);
	    return id;
	  },
	  customEventTrigger: function (evt, view, rootNode = view.el) {
	    const eventNode = evt.target.closest('[event]');
	    if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {
	      const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {
	        data: evt.data,
	        // Originally the event listener was attached to the event element.
	        currentTarget: eventNode
	      }));
	      this.onevent(eventEvt);
	      if (eventEvt.isDefaultPrevented()) {
	        evt.preventDefault();
	      }
	      return eventEvt;
	    }
	    return null;
	  }
	}, {
	  sorting: sortingTypes,
	  Layers: paperLayers,
	  backgroundPatterns,
	  gridPatterns
	});

	const ToolView = View.extend({
	  name: null,
	  tagName: 'g',
	  className: 'tool',
	  svgElement: true,
	  _visible: true,
	  _visibleExplicit: true,
	  init: function () {
	    var name = this.name;
	    if (name) this.vel.attr('data-tool-name', name);
	  },
	  configure: function (view, toolsView) {
	    this.relatedView = view;
	    this.paper = view.paper;
	    this.parentView = toolsView;
	    this.simulateRelatedView(this.el);
	    // Delegate events in case the ToolView was removed from the DOM and reused.
	    this.delegateEvents();
	    return this;
	  },
	  simulateRelatedView: function (el) {
	    if (el) el.setAttribute('model-id', this.relatedView.model.id);
	  },
	  getName: function () {
	    return this.name;
	  },
	  // Evaluate the visibility of the tool and update the `display` CSS property
	  updateVisibility: function () {
	    const isVisible = this.computeVisibility();
	    this.el.style.display = isVisible ? '' : 'none';
	    this._visible = isVisible;
	  },
	  // Evaluate the visibility of the tool. The method returns `true` if the tool
	  // should be visible in the DOM.
	  computeVisibility() {
	    if (!this.isExplicitlyVisible()) return false;
	    const {
	      visibility
	    } = this.options;
	    if (typeof visibility !== 'function') return true;
	    return !!visibility.call(this, this.relatedView, this);
	  },
	  show: function () {
	    this._visibleExplicit = true;
	    this.updateVisibility();
	  },
	  hide: function () {
	    this._visibleExplicit = false;
	    this.updateVisibility();
	  },
	  // The method returns `false` if the `hide()` method was called on the tool.
	  isExplicitlyVisible: function () {
	    return !!this._visibleExplicit;
	  },
	  // The method returns `false` if the tool is not visible (it has `display: none`).
	  // This can happen if the `hide()` method was called or the tool is not visible
	  // because of the `visibility` option was evaluated to `false`.
	  isVisible: function () {
	    return !!this._visible;
	  },
	  isOverlay: function () {
	    return !!this.parentView && this.parentView.hasLayer();
	  },
	  focus: function () {
	    var opacity = this.options.focusOpacity;
	    if (isFinite(opacity)) this.el.style.opacity = opacity;
	    this.parentView.focusTool(this);
	  },
	  blur: function () {
	    this.el.style.opacity = '';
	    this.parentView.blurTool(this);
	  },
	  update: function () {
	    // to be overridden
	  },
	  guard: function (evt) {
	    // Let the context-menu event bubble up to the relatedView
	    const {
	      paper,
	      relatedView
	    } = this;
	    if (!paper || !relatedView) return true;
	    return paper.guard(evt, relatedView);
	  }
	});

	const ToolsView = View.extend({
	  tagName: 'g',
	  className: 'tools',
	  svgElement: true,
	  tools: null,
	  isRendered: false,
	  options: {
	    tools: null,
	    relatedView: null,
	    name: null
	    // layer?: Paper.Layers.TOOLS
	    // z?: number
	  },
	  configure: function (options) {
	    options = assign(this.options, options);
	    var tools = options.tools;
	    if (!Array.isArray(tools)) return this;
	    var relatedView = options.relatedView;
	    if (!(relatedView instanceof CellView)) return this;
	    var views = this.tools = [];
	    for (var i = 0, n = tools.length; i < n; i++) {
	      var tool = tools[i];
	      if (!(tool instanceof ToolView)) continue;
	      tool.configure(relatedView, this);
	      this.vel.append(tool.el);
	      views.push(tool);
	    }
	    this.isRendered = false;
	    relatedView.requestUpdate(relatedView.getFlag('TOOLS'));
	    return this;
	  },
	  getName: function () {
	    return this.options.name;
	  },
	  update: function (opt) {
	    opt || (opt = {});
	    const tools = this.tools;
	    if (!tools) return this;
	    const n = tools.length;
	    const wasRendered = this.isRendered;
	    for (let i = 0; i < n; i++) {
	      const tool = tools[i];
	      tool.updateVisibility();
	      if (!tool.isVisible()) continue;
	      if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {
	        tool.update();
	      }
	    }
	    if (!this.isRendered && n > 0) {
	      // None of the tools is visible
	      // Note: ToolsView with no tools are always mounted
	      return this;
	    }
	    if (!this.isMounted()) {
	      this.mount();
	    }
	    if (!wasRendered) {
	      // Make sure tools are visible (if they were hidden and the tool removed)
	      this.blurTool();
	    }
	    return this;
	  },
	  ensureToolRendered(tools, i) {
	    if (!this.isRendered) {
	      // There is at least one visible tool
	      this.isRendered = Array(tools.length).fill(false);
	    }
	    if (!this.isRendered[i]) {
	      // First update executes render()
	      tools[i].render();
	      this.isRendered[i] = true;
	      return false;
	    }
	    return true;
	  },
	  focusTool: function (focusedTool) {
	    var tools = this.tools;
	    if (!tools) return this;
	    for (var i = 0, n = tools.length; i < n; i++) {
	      var tool = tools[i];
	      if (focusedTool === tool) {
	        tool.show();
	      } else {
	        tool.hide();
	      }
	    }
	    return this;
	  },
	  blurTool: function (blurredTool) {
	    var tools = this.tools;
	    if (!tools) return this;
	    for (var i = 0, n = tools.length; i < n; i++) {
	      var tool = tools[i];
	      if (tool !== blurredTool && !tool.isExplicitlyVisible()) {
	        tool.show();
	        // Check if the tool is conditionally visible too
	        if (tool.isVisible()) {
	          this.ensureToolRendered(tools, i) && tool.update();
	        }
	      }
	    }
	    return this;
	  },
	  hide: function () {
	    return this.focusTool(null);
	  },
	  show: function () {
	    this.blurTool(null);
	    // If this the first time the tools are shown, make sure they are mounted
	    if (!this.isMounted()) {
	      this.mount();
	    }
	    return this;
	  },
	  onRemove: function () {
	    var tools = this.tools;
	    if (!tools) return this;
	    for (var i = 0, n = tools.length; i < n; i++) {
	      tools[i].remove();
	    }
	    this.tools = null;
	  },
	  getLayer() {
	    const {
	      layer = Paper.Layers.TOOLS
	    } = this.options;
	    return layer;
	  },
	  hasLayer() {
	    return !!this.getLayer();
	  },
	  mount: function () {
	    const {
	      options,
	      el
	    } = this;
	    const {
	      relatedView,
	      z
	    } = options;
	    if (relatedView) {
	      if (this.hasLayer()) {
	        relatedView.paper.getLayerView(this.getLayer()).insertSortedNode(el, z);
	      } else {
	        relatedView.el.appendChild(el);
	      }
	    }
	    return this;
	  }
	});

	var index$2 = {
		__proto__: null,
		Cell: Cell,
		CellCollection: CellCollection,
		CellView: CellView,
		DEFAULT_GRAPH_LAYER_TYPE: DEFAULT_GRAPH_LAYER_TYPE,
		Element: Element$1,
		ElementView: ElementView,
		Graph: Graph,
		GraphLayer: GraphLayer,
		GraphLayerCollection: GraphLayerCollection,
		GraphLayerView: GraphLayerView,
		GridLayerView: GridLayerView,
		HighlighterView: HighlighterView,
		LayerView: LayerView,
		Link: Link$1,
		LinkView: LinkView,
		Paper: Paper,
		ToolView: ToolView,
		ToolsView: ToolsView,
		attributes: attributes,
		sortingTypes: sortingTypes
	};

	// Vertex Handles
	var VertexHandle = View.extend({
	  tagName: 'circle',
	  svgElement: true,
	  className: 'marker-vertex',
	  events: {
	    mousedown: 'onPointerDown',
	    touchstart: 'onPointerDown',
	    dblclick: 'onDoubleClick',
	    dbltap: 'onDoubleClick'
	  },
	  documentEvents: {
	    mousemove: 'onPointerMove',
	    touchmove: 'onPointerMove',
	    mouseup: 'onPointerUp',
	    touchend: 'onPointerUp',
	    touchcancel: 'onPointerUp'
	  },
	  attributes: {
	    'r': 6,
	    'fill': '#33334F',
	    'stroke': '#FFFFFF',
	    'stroke-width': 2,
	    'cursor': 'move'
	  },
	  position: function (x, y) {
	    const {
	      vel,
	      options
	    } = this;
	    const {
	      scale
	    } = options;
	    let matrix = V.createSVGMatrix().translate(x, y);
	    if (scale) matrix = matrix.scale(scale);
	    vel.transform(matrix, {
	      absolute: true
	    });
	  },
	  onPointerDown: function (evt) {
	    if (this.options.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    this.options.paper.undelegateEvents();
	    this.delegateDocumentEvents(null, evt.data);
	    this.trigger('will-change', this, evt);
	  },
	  onPointerMove: function (evt) {
	    this.trigger('changing', this, evt);
	  },
	  onDoubleClick: function (evt) {
	    this.trigger('remove', this, evt);
	  },
	  onPointerUp: function (evt) {
	    this.trigger('changed', this, evt);
	    this.undelegateDocumentEvents();
	    this.options.paper.delegateEvents();
	  }
	});
	const Vertices = ToolView.extend({
	  name: 'vertices',
	  options: {
	    handleClass: VertexHandle,
	    snapRadius: 20,
	    redundancyRemoval: true,
	    vertexAdding: true,
	    // vertexRemoving: true,
	    // vertexMoving: true,
	    stopPropagation: true,
	    scale: null
	  },
	  children: [{
	    tagName: 'path',
	    selector: 'connection',
	    className: 'joint-vertices-path',
	    attributes: {
	      'fill': 'none',
	      'stroke': 'transparent',
	      'stroke-width': 10,
	      'cursor': 'cell'
	    }
	  }],
	  handles: null,
	  interactiveLinkNode: null,
	  events: {
	    'mousedown .joint-vertices-path': 'onPathPointerDown',
	    'touchstart .joint-vertices-path': 'onPathPointerDown'
	  },
	  linkEvents: {
	    mousedown: 'onLinkPointerDown',
	    touchstart: 'onLinkPointerDown'
	  },
	  onRender: function () {
	    const {
	      vertexAdding
	    } = this.options;
	    if (vertexAdding) {
	      const {
	        interactiveLinkNode = null
	      } = vertexAdding;
	      if (interactiveLinkNode) {
	        this.delegateLinkEvents(interactiveLinkNode);
	      } else {
	        this.renderChildren();
	        this.updatePath();
	      }
	    }
	    this.resetHandles();
	    this.renderHandles();
	    return this;
	  },
	  delegateLinkEvents: function (selector) {
	    this.undelegateLinkEvents();
	    const el = this.relatedView.findNode(selector);
	    if (!el) {
	      console.warn(`Interactive link node "${selector}" not found.`);
	      return;
	    }
	    el.classList.add('joint-vertices-path');
	    this.interactiveLinkNode = el;
	    this.delegateElementEvents(el, this.linkEvents);
	  },
	  undelegateLinkEvents: function () {
	    const el = this.interactiveLinkNode;
	    if (!el) return;
	    this.undelegateElementEvents(el);
	    el.classList.remove('joint-vertices-path');
	    this.interactiveLinkNode = null;
	  },
	  update: function () {
	    var relatedView = this.relatedView;
	    var vertices = relatedView.model.vertices();
	    if (vertices.length === this.handles.length) {
	      this.updateHandles();
	    } else {
	      this.resetHandles();
	      this.renderHandles();
	    }
	    if (this.options.vertexAdding) {
	      this.updatePath();
	    }
	    return this;
	  },
	  resetHandles: function () {
	    var handles = this.handles;
	    this.handles = [];
	    this.stopListening();
	    if (!Array.isArray(handles)) return;
	    for (var i = 0, n = handles.length; i < n; i++) {
	      handles[i].remove();
	    }
	  },
	  renderHandles: function () {
	    var relatedView = this.relatedView;
	    var vertices = relatedView.model.vertices();
	    for (var i = 0, n = vertices.length; i < n; i++) {
	      var vertex = vertices[i];
	      var handle = new this.options.handleClass({
	        index: i,
	        paper: this.paper,
	        scale: this.options.scale,
	        guard: evt => this.guard(evt)
	      });
	      handle.render();
	      handle.position(vertex.x, vertex.y);
	      this.simulateRelatedView(handle.el);
	      handle.vel.appendTo(this.el);
	      this.handles.push(handle);
	      this.startHandleListening(handle);
	    }
	  },
	  updateHandles: function () {
	    var relatedView = this.relatedView;
	    var vertices = relatedView.model.vertices();
	    for (var i = 0, n = vertices.length; i < n; i++) {
	      var vertex = vertices[i];
	      var handle = this.handles[i];
	      if (!handle) return;
	      handle.position(vertex.x, vertex.y);
	    }
	  },
	  updatePath: function () {
	    if (this.interactiveLinkNode) return;
	    const connection = this.childNodes.connection;
	    if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());
	  },
	  startHandleListening: function (handle) {
	    const {
	      vertexRemoving = true,
	      vertexMoving = true
	    } = this.options;
	    if (vertexMoving) {
	      this.listenTo(handle, 'will-change', this.onHandleWillChange);
	      this.listenTo(handle, 'changing', this.onHandleChanging);
	      this.listenTo(handle, 'changed', this.onHandleChanged);
	    }
	    if (vertexRemoving) {
	      this.listenTo(handle, 'remove', this.onHandleRemove);
	    }
	  },
	  getNeighborPoints: function (index) {
	    var linkView = this.relatedView;
	    var vertices = linkView.model.vertices();
	    var prev = index > 0 ? vertices[index - 1] : linkView.sourceAnchor;
	    var next = index < vertices.length - 1 ? vertices[index + 1] : linkView.targetAnchor;
	    return {
	      prev: new Point(prev),
	      next: new Point(next)
	    };
	  },
	  onHandleWillChange: function (_handle, evt) {
	    this.focus();
	    const {
	      relatedView,
	      options
	    } = this;
	    relatedView.model.startBatch('vertex-move', {
	      ui: true,
	      tool: this.cid
	    });
	    if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));
	  },
	  onHandleChanging: function (handle, evt) {
	    const {
	      options,
	      relatedView: linkView
	    } = this;
	    var index = handle.options.index;
	    var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);
	    var vertex = {
	      x,
	      y
	    };
	    this.snapVertex(vertex, index);
	    linkView.model.vertex(index, vertex, {
	      ui: true,
	      tool: this.cid
	    });
	    handle.position(vertex.x, vertex.y);
	    if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);
	  },
	  onHandleChanged: function (_handle, evt) {
	    const {
	      options,
	      relatedView: linkView
	    } = this;
	    if (options.vertexAdding) this.updatePath();
	    if (options.redundancyRemoval) {
	      const verticesRemoved = linkView.removeRedundantLinearVertices({
	        ui: true,
	        tool: this.cid
	      });
	      if (verticesRemoved) this.render();
	    }
	    this.blur();
	    linkView.model.stopBatch('vertex-move', {
	      ui: true,
	      tool: this.cid
	    });
	    if (this.eventData(evt).vertexAdded) {
	      linkView.model.stopBatch('vertex-add', {
	        ui: true,
	        tool: this.cid
	      });
	    }
	    const [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);
	    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);
	    linkView.checkMouseleave(normalizedEvt);
	  },
	  snapVertex: function (vertex, index) {
	    var snapRadius = this.options.snapRadius;
	    if (snapRadius > 0) {
	      var neighbors = this.getNeighborPoints(index);
	      var prev = neighbors.prev;
	      var next = neighbors.next;
	      if (Math.abs(vertex.x - prev.x) < snapRadius) {
	        vertex.x = prev.x;
	      } else if (Math.abs(vertex.x - next.x) < snapRadius) {
	        vertex.x = next.x;
	      }
	      if (Math.abs(vertex.y - prev.y) < snapRadius) {
	        vertex.y = neighbors.prev.y;
	      } else if (Math.abs(vertex.y - next.y) < snapRadius) {
	        vertex.y = next.y;
	      }
	    }
	  },
	  onHandleRemove: function (handle, evt) {
	    var index = handle.options.index;
	    var linkView = this.relatedView;
	    linkView.model.removeVertex(index, {
	      ui: true
	    });
	    if (this.options.vertexAdding) this.updatePath();
	    linkView.checkMouseleave(normalizeEvent(evt));
	  },
	  onPathPointerDown: function (evt) {
	    if (this.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    var normalizedEvent = normalizeEvent(evt);
	    var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();
	    var relatedView = this.relatedView;
	    relatedView.model.startBatch('vertex-add', {
	      ui: true,
	      tool: this.cid
	    });
	    var index = relatedView.getVertexIndex(vertex.x, vertex.y);
	    this.snapVertex(vertex, index);
	    relatedView.model.insertVertex(index, vertex, {
	      ui: true,
	      tool: this.cid
	    });
	    this.update();
	    var handle = this.handles[index];
	    this.eventData(normalizedEvent, {
	      vertexAdded: true
	    });
	    handle.onPointerDown(normalizedEvent);
	  },
	  onLinkPointerDown: function (evt) {
	    this.relatedView.preventDefaultInteraction(evt);
	    this.onPathPointerDown(evt);
	  },
	  onRemove: function () {
	    this.resetHandles();
	    this.undelegateLinkEvents();
	  }
	}, {
	  VertexHandle: VertexHandle // keep as class property
	});

	/**
	 * Common helper for getting a cell viewâs bounding box,
	 * configurable with `useModelGeometry`, `relative`, and `el`.
	 */
	function getViewBBox(view, {
	  useModelGeometry = false,
	  relative = false,
	  el = view.el
	} = {}) {
	  const {
	    model
	  } = view;
	  let bbox;
	  if (useModelGeometry) {
	    // cell model bbox
	    bbox = model.getBBox();
	  } else if (model.isLink()) {
	    // link view bbox
	    bbox = view.getConnection().bbox();
	  } else {
	    // element view bbox
	    bbox = view.getNodeUnrotatedBBox(el);
	  }
	  if (relative) {
	    // Relative to the element position.
	    const position = model.position();
	    bbox.x -= position.x;
	    bbox.y -= position.y;
	  }
	  return bbox;
	}

	/**
	 * Retrieves the tool options.
	 * Automatically overrides `useModelGeometry` and `rotate`
	 * if the tool is positioned relative to the element.
	 */
	function getToolOptions(toolView) {
	  // Positioning is relative if the tool is drawn within the element view.
	  const relative = !toolView.isOverlay();
	  const {
	    useModelGeometry,
	    rotate,
	    ...otherOptions
	  } = toolView.options;
	  return {
	    ...otherOptions,
	    useModelGeometry: useModelGeometry || relative,
	    rotate: rotate || relative,
	    relative
	  };
	}
	function getAnchor(coords, view, magnet) {
	  // take advantage of an existing logic inside of the
	  // pin relative connection strategy
	  var end = pinRelative.call(this.paper, {}, view, magnet, coords, this.model);
	  return end.anchor;
	}
	function snapAnchor(coords, view, magnet, type, relatedView, toolView) {
	  var snapRadius = toolView.options.snapRadius;
	  var isSource = type === 'source';
	  var refIndex = isSource ? 0 : -1;
	  var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');
	  if (ref) {
	    if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;
	    if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;
	  }
	  return coords;
	}

	var SegmentHandle = View.extend({
	  tagName: 'g',
	  svgElement: true,
	  className: 'marker-segment',
	  events: {
	    mousedown: 'onPointerDown',
	    touchstart: 'onPointerDown'
	  },
	  documentEvents: {
	    mousemove: 'onPointerMove',
	    touchmove: 'onPointerMove',
	    mouseup: 'onPointerUp',
	    touchend: 'onPointerUp',
	    touchcancel: 'onPointerUp'
	  },
	  children: [{
	    tagName: 'line',
	    selector: 'line',
	    attributes: {
	      'stroke': '#33334F',
	      'stroke-width': 2,
	      'fill': 'none',
	      'pointer-events': 'none'
	    }
	  }, {
	    tagName: 'rect',
	    selector: 'handle',
	    attributes: {
	      'width': 20,
	      'height': 8,
	      'x': -10,
	      'y': -4,
	      'rx': 4,
	      'ry': 4,
	      'fill': '#33334F',
	      'stroke': '#FFFFFF',
	      'stroke-width': 2
	    }
	  }],
	  onRender: function () {
	    this.renderChildren();
	  },
	  position: function (x, y, angle, view) {
	    const {
	      scale
	    } = this.options;
	    let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);
	    if (scale) matrix = matrix.scale(scale);
	    var handle = this.childNodes.handle;
	    handle.setAttribute('transform', V.matrixToTransformString(matrix));
	    handle.setAttribute('cursor', angle % 180 === 0 ? 'row-resize' : 'col-resize');
	    var viewPoint = view.getClosestPoint(new Point(x, y));
	    var line = this.childNodes.line;
	    line.setAttribute('x1', x);
	    line.setAttribute('y1', y);
	    line.setAttribute('x2', viewPoint.x);
	    line.setAttribute('y2', viewPoint.y);
	  },
	  onPointerDown: function (evt) {
	    if (this.options.guard(evt)) return;
	    this.trigger('change:start', this, evt);
	    evt.stopPropagation();
	    evt.preventDefault();
	    this.options.paper.undelegateEvents();
	    this.delegateDocumentEvents(null, evt.data);
	  },
	  onPointerMove: function (evt) {
	    this.trigger('changing', this, evt);
	  },
	  onPointerUp: function (evt) {
	    this.undelegateDocumentEvents();
	    this.options.paper.delegateEvents();
	    this.trigger('change:end', this, evt);
	  },
	  show: function () {
	    this.el.style.display = '';
	  },
	  hide: function () {
	    this.el.style.display = 'none';
	  }
	});
	const Segments = ToolView.extend({
	  name: 'segments',
	  precision: .5,
	  options: {
	    handleClass: SegmentHandle,
	    segmentLengthThreshold: 40,
	    redundancyRemoval: true,
	    anchor: getAnchor,
	    snapRadius: 10,
	    snapHandle: true,
	    stopPropagation: true
	  },
	  handles: null,
	  onRender: function () {
	    this.resetHandles();
	    var relatedView = this.relatedView;
	    var vertices = relatedView.model.vertices();
	    vertices.unshift(relatedView.sourcePoint);
	    vertices.push(relatedView.targetPoint);
	    for (var i = 0, n = vertices.length; i < n - 1; i++) {
	      var vertex = vertices[i];
	      var nextVertex = vertices[i + 1];
	      var handle = this.renderHandle(vertex, nextVertex);
	      this.simulateRelatedView(handle.el);
	      this.handles.push(handle);
	      handle.options.index = i;
	    }
	    return this;
	  },
	  renderHandle: function (vertex, nextVertex) {
	    var handle = new this.options.handleClass({
	      paper: this.paper,
	      scale: this.options.scale,
	      guard: evt => this.guard(evt)
	    });
	    handle.render();
	    this.updateHandle(handle, vertex, nextVertex);
	    handle.vel.appendTo(this.el);
	    this.startHandleListening(handle);
	    return handle;
	  },
	  update: function () {
	    this.render();
	    return this;
	  },
	  startHandleListening: function (handle) {
	    this.listenTo(handle, 'change:start', this.onHandleChangeStart);
	    this.listenTo(handle, 'changing', this.onHandleChanging);
	    this.listenTo(handle, 'change:end', this.onHandleChangeEnd);
	  },
	  resetHandles: function () {
	    var handles = this.handles;
	    this.handles = [];
	    this.stopListening();
	    if (!Array.isArray(handles)) return;
	    for (var i = 0, n = handles.length; i < n; i++) {
	      handles[i].remove();
	    }
	  },
	  shiftHandleIndexes: function (value) {
	    var handles = this.handles;
	    for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;
	  },
	  resetAnchor: function (type, anchor) {
	    var relatedModel = this.relatedView.model;
	    if (anchor) {
	      relatedModel.prop([type, 'anchor'], anchor, {
	        rewrite: true,
	        ui: true,
	        tool: this.cid
	      });
	    } else {
	      relatedModel.removeProp([type, 'anchor'], {
	        ui: true,
	        tool: this.cid
	      });
	    }
	  },
	  snapHandle: function (handle, position, data) {
	    var index = handle.options.index;
	    var linkView = this.relatedView;
	    var link = linkView.model;
	    var vertices = link.vertices();
	    var axis = handle.options.axis;
	    var prev = vertices[index - 2] || data.sourceAnchor;
	    var next = vertices[index + 1] || data.targetAnchor;
	    var snapRadius = this.options.snapRadius;
	    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
	      position[axis] = prev[axis];
	    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
	      position[axis] = next[axis];
	    }
	    return position;
	  },
	  onHandleChanging: function (handle, evt) {
	    const {
	      options
	    } = this;
	    var data = this.eventData(evt);
	    var relatedView = this.relatedView;
	    var paper = relatedView.paper;
	    var index = handle.options.index - 1;
	    var normalizedEvent = normalizeEvent(evt);
	    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    var position = this.snapHandle(handle, coords.clone(), data);
	    var axis = handle.options.axis;
	    var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];
	    var link = relatedView.model;
	    var vertices = cloneDeep(link.vertices());
	    var anchorFn = this.options.anchor;
	    if (typeof anchorFn !== 'function') anchorFn = null;
	    const handleIndex = handle.options.index;
	    const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];
	    let indexOffset = 0;

	    // check if vertex before handle vertex exists
	    if (handleIndex - 1 >= 0) {
	      const v1 = vertexPoints[handleIndex - 1];
	      const v2 = vertexPoints[handleIndex];
	      const theta = new Line(v1, v2).vector().theta();

	      // check only non-orthogonal segments
	      if (theta % 90 !== 0) {
	        vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);
	        indexOffset++;
	        this.shiftHandleIndexes(1);
	      }
	    }
	    var vertex = vertices[index + indexOffset];
	    var nextVertex = vertices[index + 1 + indexOffset];

	    // check if vertex after handle vertex exists
	    if (handleIndex + 2 < vertexPoints.length) {
	      const v1 = vertexPoints[handleIndex + 1];
	      const v2 = vertexPoints[handleIndex + 2];
	      const theta = new Line(v1, v2).vector().theta();

	      // check only non-orthogonal segments
	      if (theta % 90 !== 0) {
	        const isSingleVertex = data.originalVertices.length === 1;
	        const origVIndex = isSingleVertex ? 0 : handleIndex;
	        const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;
	        let nextVIndex = 1 + indexOffset;
	        vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);
	      }
	    }

	    // First Segment
	    var sourceView = relatedView.sourceView;
	    var sourceBBox = relatedView.sourceBBox;
	    var changeSourceAnchor = false;
	    var deleteSourceAnchor = false;
	    if (!vertex) {
	      vertex = relatedView.sourceAnchor.toJSON();
	      vertex[axis] = position[axis];
	      if (sourceBBox.containsPoint(vertex)) {
	        vertex[axis] = position[axis];
	        changeSourceAnchor = true;
	      } else {
	        // we left the area of the source magnet for the first time
	        vertices.unshift(vertex);
	        this.shiftHandleIndexes(1);
	        data.firstHandleShifted = true;
	        deleteSourceAnchor = true;
	      }
	    } else if (index === 0) {
	      if (sourceBBox.containsPoint(vertex)) {
	        vertices.shift();
	        this.shiftHandleIndexes(-1);
	        changeSourceAnchor = true;
	      } else {
	        vertex[axis] = position[axis];
	        deleteSourceAnchor = true;
	      }
	    } else {
	      vertex[axis] = position[axis];
	    }
	    if (anchorFn && sourceView) {
	      if (changeSourceAnchor) {
	        var sourceAnchorPosition = data.sourceAnchor.clone();
	        sourceAnchorPosition[axis] = position[axis];
	        var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);
	        this.resetAnchor('source', sourceAnchor);
	      }
	      if (deleteSourceAnchor) {
	        this.resetAnchor('source', data.sourceAnchorDef);
	      }
	    }

	    // Last segment
	    var targetView = relatedView.targetView;
	    var targetBBox = relatedView.targetBBox;
	    var changeTargetAnchor = false;
	    var deleteTargetAnchor = false;
	    if (!nextVertex) {
	      nextVertex = relatedView.targetAnchor.toJSON();
	      nextVertex[axis] = position[axis];
	      if (targetBBox.containsPoint(nextVertex)) {
	        changeTargetAnchor = true;
	      } else {
	        // we left the area of the target magnet for the first time
	        vertices.push(nextVertex);
	        deleteTargetAnchor = true;
	      }
	    } else if (index === vertices.length - 2) {
	      if (targetBBox.containsPoint(nextVertex)) {
	        vertices.pop();
	        changeTargetAnchor = true;
	      } else {
	        nextVertex[axis] = position[axis];
	        deleteTargetAnchor = true;
	      }
	    } else {
	      nextVertex[axis] = position[axis];
	    }
	    if (anchorFn && targetView) {
	      if (changeTargetAnchor) {
	        var targetAnchorPosition = data.targetAnchor.clone();
	        targetAnchorPosition[axis] = position[axis];
	        var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);
	        this.resetAnchor('target', targetAnchor);
	      }
	      if (deleteTargetAnchor) {
	        this.resetAnchor('target', data.targetAnchorDef);
	      }
	    }
	    if (vertices.some(v => !v)) {
	      // This can happen when the link is using a smart routing and the number of
	      // vertices is not the same as the number of route points.
	      throw new Error('Segments: incompatible router in use');
	    }
	    link.vertices(vertices, {
	      ui: true,
	      tool: this.cid
	    });
	    this.updateHandle(handle, vertex, nextVertex, offset);
	    if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);
	  },
	  onHandleChangeStart: function (handle, evt) {
	    const {
	      options,
	      handles,
	      relatedView: linkView
	    } = this;
	    const {
	      model,
	      paper
	    } = linkView;
	    var index = handle.options.index;
	    if (!Array.isArray(handles)) return;
	    for (var i = 0, n = handles.length; i < n; i++) {
	      if (i !== index) handles[i].hide();
	    }
	    this.focus();
	    this.eventData(evt, {
	      sourceAnchor: linkView.sourceAnchor.clone(),
	      targetAnchor: linkView.targetAnchor.clone(),
	      sourceAnchorDef: clone$1(model.prop(['source', 'anchor'])),
	      targetAnchorDef: clone$1(model.prop(['target', 'anchor'])),
	      originalVertices: cloneDeep(model.vertices()),
	      firstHandleShifted: false
	    });
	    model.startBatch('segment-move', {
	      ui: true,
	      tool: this.cid
	    });
	    if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));
	  },
	  onHandleChangeEnd: function (_handle, evt) {
	    const {
	      options,
	      relatedView: linkView
	    } = this;
	    const {
	      paper,
	      model
	    } = linkView;
	    if (options.redundancyRemoval) {
	      linkView.removeRedundantLinearVertices({
	        ui: true,
	        tool: this.cid
	      });
	    }
	    const normalizedEvent = normalizeEvent(evt);
	    const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    this.render();
	    this.blur();
	    model.stopBatch('segment-move', {
	      ui: true,
	      tool: this.cid
	    });
	    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);
	    linkView.checkMouseleave(normalizedEvent);
	  },
	  updateHandle: function (handle, vertex, nextVertex, offset) {
	    var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;
	    var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;
	    if (vertical || horizontal) {
	      var segmentLine = new Line(vertex, nextVertex);
	      var length = segmentLine.length();
	      if (length < this.options.segmentLengthThreshold) {
	        handle.hide();
	      } else {
	        var position = segmentLine.midpoint();
	        var axis = vertical ? 'x' : 'y';
	        position[axis] += offset || 0;
	        var angle = segmentLine.vector().vectorAngle(new Point(1, 0));
	        handle.position(position.x, position.y, angle, this.relatedView);
	        handle.show();
	        handle.options.axis = axis;
	      }
	    } else {
	      handle.hide();
	    }
	  },
	  onRemove: function () {
	    this.resetHandles();
	  }
	}, {
	  SegmentHandle: SegmentHandle // keep as class property
	});

	// End Markers
	const Arrowhead = ToolView.extend({
	  tagName: 'path',
	  xAxisVector: new Point(1, 0),
	  events: {
	    mousedown: 'onPointerDown',
	    touchstart: 'onPointerDown'
	  },
	  documentEvents: {
	    mousemove: 'onPointerMove',
	    touchmove: 'onPointerMove',
	    mouseup: 'onPointerUp',
	    touchend: 'onPointerUp',
	    touchcancel: 'onPointerUp'
	  },
	  options: {
	    scale: null
	  },
	  onRender: function () {
	    this.update();
	  },
	  update: function () {
	    var ratio = this.ratio;
	    var view = this.relatedView;
	    var tangent = view.getTangentAtRatio(ratio);
	    var position, angle;
	    if (tangent) {
	      position = tangent.start;
	      angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;
	    } else {
	      position = view.getPointAtRatio(ratio);
	      angle = 0;
	    }
	    if (!position) return this;
	    var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);
	    const {
	      scale
	    } = this.options;
	    if (scale) matrix = matrix.scale(scale);
	    this.vel.transform(matrix, {
	      absolute: true
	    });
	    return this;
	  },
	  onPointerDown: function (evt) {
	    if (this.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    var relatedView = this.relatedView;
	    var paper = relatedView.paper;
	    relatedView.model.startBatch('arrowhead-move', {
	      ui: true,
	      tool: this.cid
	    });
	    relatedView.startArrowheadMove(this.arrowheadType);
	    const data = evt.data || (evt.data = {});
	    this.delegateDocumentEvents(null, data);
	    paper.undelegateEvents();
	    this.focus();
	    this.el.style.pointerEvents = 'none';
	    relatedView.notifyPointerdown(...paper.getPointerArgs(evt));
	  },
	  onPointerMove: function (evt) {
	    var normalizedEvent = normalizeEvent(evt);
	    var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);
	  },
	  onPointerUp: function (evt) {
	    this.undelegateDocumentEvents();
	    var relatedView = this.relatedView;
	    var paper = relatedView.paper;
	    var normalizedEvent = normalizeEvent(evt);
	    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    relatedView.pointerup(normalizedEvent, coords.x, coords.y);
	    paper.delegateEvents();
	    this.blur();
	    this.el.style.pointerEvents = '';
	    relatedView.model.stopBatch('arrowhead-move', {
	      ui: true,
	      tool: this.cid
	    });
	  }
	});
	const TargetArrowhead = Arrowhead.extend({
	  name: 'target-arrowhead',
	  ratio: 1,
	  arrowheadType: 'target',
	  attributes: {
	    'd': 'M -10 -8 10 0 -10 8 Z',
	    'fill': '#33334F',
	    'stroke': '#FFFFFF',
	    'stroke-width': 2,
	    'cursor': 'move',
	    'class': 'target-arrowhead'
	  }
	});
	const SourceArrowhead = Arrowhead.extend({
	  name: 'source-arrowhead',
	  ratio: 0,
	  arrowheadType: 'source',
	  attributes: {
	    'd': 'M 10 -8 -10 0 10 8 Z',
	    'fill': '#33334F',
	    'stroke': '#FFFFFF',
	    'stroke-width': 2,
	    'cursor': 'move',
	    'class': 'source-arrowhead'
	  }
	});

	const Anchor = ToolView.extend({
	  tagName: 'g',
	  type: null,
	  children: [{
	    tagName: 'circle',
	    selector: 'anchor',
	    attributes: {
	      'cursor': 'pointer'
	    }
	  }, {
	    tagName: 'rect',
	    selector: 'area',
	    attributes: {
	      'pointer-events': 'none',
	      'fill': 'none',
	      'stroke': '#33334F',
	      'stroke-dasharray': '2,4',
	      'rx': 5,
	      'ry': 5
	    }
	  }],
	  events: {
	    mousedown: 'onPointerDown',
	    touchstart: 'onPointerDown',
	    dblclick: 'onPointerDblClick',
	    dbltap: 'onPointerDblClick'
	  },
	  documentEvents: {
	    mousemove: 'onPointerMove',
	    touchmove: 'onPointerMove',
	    mouseup: 'onPointerUp',
	    touchend: 'onPointerUp',
	    touchcancel: 'onPointerUp'
	  },
	  options: {
	    snap: snapAnchor,
	    anchor: getAnchor,
	    scale: null,
	    resetAnchor: true,
	    customAnchorAttributes: {
	      'stroke-width': 4,
	      'stroke': '#33334F',
	      'fill': '#FFFFFF',
	      'r': 5
	    },
	    defaultAnchorAttributes: {
	      'stroke-width': 2,
	      'stroke': '#FFFFFF',
	      'fill': '#33334F',
	      'r': 6
	    },
	    areaPadding: 6,
	    snapRadius: 10,
	    restrictArea: true,
	    redundancyRemoval: true
	  },
	  onRender: function () {
	    this.renderChildren();
	    this.toggleArea(false);
	    this.update();
	  },
	  update: function () {
	    var type = this.type;
	    var relatedView = this.relatedView;
	    var view = relatedView.getEndView(type);
	    if (view) {
	      this.updateAnchor();
	      this.updateArea();
	      this.el.style.display = '';
	    } else {
	      this.el.style.display = 'none';
	    }
	    return this;
	  },
	  updateAnchor: function () {
	    var childNodes = this.childNodes;
	    if (!childNodes) return;
	    var anchorNode = childNodes.anchor;
	    if (!anchorNode) return;
	    var relatedView = this.relatedView;
	    var type = this.type;
	    var position = relatedView.getEndAnchor(type);
	    var options = this.options;
	    var customAnchor = relatedView.model.prop([type, 'anchor']);
	    let transformString = `translate(${position.x},${position.y})`;
	    if (options.scale) {
	      transformString += ` scale(${options.scale})`;
	    }
	    anchorNode.setAttribute('transform', transformString);
	    var anchorAttributes = customAnchor ? options.customAnchorAttributes : options.defaultAnchorAttributes;
	    for (var attrName in anchorAttributes) {
	      anchorNode.setAttribute(attrName, anchorAttributes[attrName]);
	    }
	  },
	  updateArea: function () {
	    var childNodes = this.childNodes;
	    if (!childNodes) return;
	    var areaNode = childNodes.area;
	    if (!areaNode) return;
	    var relatedView = this.relatedView;
	    var type = this.type;
	    var view = relatedView.getEndView(type);
	    var model = view.model;
	    var magnet = relatedView.getEndMagnet(type);
	    var padding = this.options.areaPadding;
	    if (!isFinite(padding)) padding = 0;
	    var bbox, angle, center;
	    if (view.isNodeConnection(magnet)) {
	      bbox = view.getNodeBBox(magnet);
	      angle = 0;
	      center = bbox.center();
	    } else {
	      bbox = view.getNodeUnrotatedBBox(magnet);
	      angle = model.angle();
	      center = bbox.center();
	      if (angle) center.rotate(model.getCenter(), -angle);
	      // TODO: get the link's magnet rotation into account
	    }
	    bbox.inflate(padding);
	    areaNode.setAttribute('x', -bbox.width / 2);
	    areaNode.setAttribute('y', -bbox.height / 2);
	    areaNode.setAttribute('width', bbox.width);
	    areaNode.setAttribute('height', bbox.height);
	    areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');
	  },
	  toggleArea: function (visible) {
	    var childNodes = this.childNodes;
	    if (!childNodes) return;
	    var areaNode = childNodes.area;
	    if (!areaNode) return;
	    areaNode.style.display = visible ? '' : 'none';
	  },
	  onPointerDown: function (evt) {
	    if (this.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    this.paper.undelegateEvents();
	    this.delegateDocumentEvents();
	    this.focus();
	    this.toggleArea(this.options.restrictArea);
	    this.relatedView.model.startBatch('anchor-move', {
	      ui: true,
	      tool: this.cid
	    });
	  },
	  resetAnchor: function (anchor) {
	    var type = this.type;
	    var relatedModel = this.relatedView.model;
	    if (anchor) {
	      relatedModel.prop([type, 'anchor'], anchor, {
	        rewrite: true,
	        ui: true,
	        tool: this.cid
	      });
	    } else {
	      relatedModel.removeProp([type, 'anchor'], {
	        ui: true,
	        tool: this.cid
	      });
	    }
	  },
	  onPointerMove: function (evt) {
	    var relatedView = this.relatedView;
	    var type = this.type;
	    var view = relatedView.getEndView(type);
	    var model = view.model;
	    var magnet = relatedView.getEndMagnet(type);
	    var normalizedEvent = normalizeEvent(evt);
	    var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);
	    var snapFn = this.options.snap;
	    if (typeof snapFn === 'function') {
	      coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);
	      coords = new Point(coords);
	    }
	    if (this.options.restrictArea) {
	      if (view.isNodeConnection(magnet)) {
	        // snap coords to the link's connection
	        var pointAtConnection = view.getClosestPoint(coords);
	        if (pointAtConnection) coords = pointAtConnection;
	      } else {
	        // snap coords within node bbox
	        var bbox = view.getNodeUnrotatedBBox(magnet);
	        var angle = model.angle();
	        var origin = model.getCenter();
	        var rotatedCoords = coords.clone().rotate(origin, angle);
	        if (!bbox.containsPoint(rotatedCoords)) {
	          coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);
	        }
	      }
	    }
	    var anchor;
	    var anchorFn = this.options.anchor;
	    if (typeof anchorFn === 'function') {
	      anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);
	    }
	    this.resetAnchor(anchor);
	    this.update();
	  },
	  onPointerUp: function (evt) {
	    const normalizedEvent = normalizeEvent(evt);
	    this.paper.delegateEvents();
	    this.undelegateDocumentEvents();
	    this.blur();
	    this.toggleArea(false);
	    var linkView = this.relatedView;
	    if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({
	      ui: true,
	      tool: this.cid
	    });
	    linkView.checkMouseleave(normalizedEvent);
	    linkView.model.stopBatch('anchor-move', {
	      ui: true,
	      tool: this.cid
	    });
	  },
	  onPointerDblClick: function () {
	    var anchor = this.options.resetAnchor;
	    if (anchor === false) return; // reset anchor disabled
	    if (anchor === true) anchor = null; // remove the current anchor
	    this.resetAnchor(cloneDeep(anchor));
	    this.update();
	  }
	});
	const SourceAnchor = Anchor.extend({
	  name: 'source-anchor',
	  type: 'source'
	});
	const TargetAnchor = Anchor.extend({
	  name: 'target-anchor',
	  type: 'target'
	});

	const Control = ToolView.extend({
	  tagName: 'g',
	  children: [{
	    tagName: 'circle',
	    selector: 'handle',
	    attributes: {
	      'cursor': 'pointer',
	      'stroke-width': 2,
	      'stroke': '#FFFFFF',
	      'fill': '#33334F',
	      'r': 6
	    }
	  }, {
	    tagName: 'rect',
	    selector: 'extras',
	    attributes: {
	      'pointer-events': 'none',
	      'fill': 'none',
	      'stroke': '#33334F',
	      'stroke-dasharray': '2,4',
	      'rx': 5,
	      'ry': 5
	    }
	  }],
	  events: {
	    mousedown: 'onPointerDown',
	    touchstart: 'onPointerDown',
	    dblclick: 'onPointerDblClick',
	    dbltap: 'onPointerDblClick'
	  },
	  documentEvents: {
	    mousemove: 'onPointerMove',
	    touchmove: 'onPointerMove',
	    mouseup: 'onPointerUp',
	    touchend: 'onPointerUp',
	    touchcancel: 'onPointerUp'
	  },
	  options: {
	    handleAttributes: null,
	    selector: 'root',
	    padding: 6,
	    scale: null
	  },
	  getPosition: function () {
	    // To be overridden
	  },
	  setPosition: function () {
	    // To be overridden
	  },
	  resetPosition: function () {
	    // To be overridden
	  },
	  onRender: function () {
	    this.renderChildren();
	    this.toggleExtras(false);
	    this.update();
	  },
	  update: function () {
	    const {
	      handle,
	      extras
	    } = this.childNodes;
	    if (handle) {
	      this.updateHandle(handle);
	    } else {
	      throw new Error('Control: markup selector `handle` is required');
	    }
	    if (extras) {
	      this.updateExtras(extras);
	    }
	    return this;
	  },
	  updateHandle: function (handleNode) {
	    const {
	      options: {
	        handleAttributes
	      }
	    } = this;
	    handleNode.setAttribute('transform', this.getHandleTransformString());
	    if (handleAttributes) {
	      for (let attrName in handleAttributes) {
	        handleNode.setAttribute(attrName, handleAttributes[attrName]);
	      }
	    }
	  },
	  getHandleTransformString() {
	    const {
	      relatedView,
	      options
	    } = this;
	    const {
	      scale
	    } = options;
	    const {
	      model
	    } = relatedView;
	    const relativePos = this.getPosition(relatedView, this);
	    const translate = this.isOverlay()
	    // The tool is rendered in the coordinate system of the paper
	    ? model.getAbsolutePointFromRelative(relativePos)
	    // The tool is rendered in the coordinate system of the relatedView
	    : relativePos;
	    let transformString = `translate(${translate.x},${translate.y})`;
	    if (scale) {
	      transformString += ` scale(${scale})`;
	    }
	    return transformString;
	  },
	  updateExtras: function (extrasNode) {
	    const {
	      relatedView,
	      options
	    } = this;
	    const {
	      selector,
	      relative,
	      useModelGeometry
	    } = getToolOptions(this);
	    if (!selector) {
	      // Hide the extras if no selector is given.
	      this.toggleExtras(false);
	      return;
	    }
	    // Get the size for the extras rectangle and update it.
	    let bbox;
	    if (useModelGeometry) {
	      if (selector !== 'root') {
	        // A selector other than null or `root` was provided.
	        console.warn('Control: selector will be ignored when `useModelGeometry` is used.');
	      }
	      bbox = getViewBBox(relatedView, {
	        useModelGeometry,
	        relative
	      });
	    } else {
	      // The reference node for calculating the bounding box of the extras.
	      const el = relatedView.findNode(selector);
	      if (!el) throw new Error('Control: invalid selector.');
	      bbox = getViewBBox(relatedView, {
	        el
	      });
	    }
	    let padding = options.padding;
	    if (!isFinite(padding)) padding = 0;
	    const model = relatedView.model;
	    // With relative positioning, rotation is implicit
	    // (the tool rotates along with the element).
	    const angle = relative ? 0 : model.angle();
	    const center = bbox.center();
	    if (angle) center.rotate(model.getCenter(), -angle);
	    bbox.inflate(padding);
	    extrasNode.setAttribute('x', -bbox.width / 2);
	    extrasNode.setAttribute('y', -bbox.height / 2);
	    extrasNode.setAttribute('width', bbox.width);
	    extrasNode.setAttribute('height', bbox.height);
	    extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);
	  },
	  toggleExtras: function (visible) {
	    const {
	      extras
	    } = this.childNodes;
	    if (!extras) return;
	    extras.style.display = visible ? '' : 'none';
	  },
	  onPointerDown: function (evt) {
	    const {
	      relatedView,
	      paper
	    } = this;
	    if (this.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    paper.undelegateEvents();
	    this.delegateDocumentEvents();
	    this.focus();
	    this.toggleExtras(true);
	    relatedView.model.startBatch('control-move', {
	      ui: true,
	      tool: this.cid
	    });
	  },
	  onPointerMove: function (evt) {
	    const {
	      relatedView,
	      paper
	    } = this;
	    const {
	      model
	    } = relatedView;
	    const {
	      clientX,
	      clientY
	    } = normalizeEvent(evt);
	    const coords = paper.clientToLocalPoint(clientX, clientY);
	    const relativeCoords = model.getRelativePointFromAbsolute(coords);
	    this.setPosition(relatedView, relativeCoords, evt);
	    this.update();
	  },
	  onPointerUp: function (_evt) {
	    const {
	      relatedView,
	      paper
	    } = this;
	    paper.delegateEvents();
	    this.undelegateDocumentEvents();
	    this.blur();
	    this.toggleExtras(false);
	    relatedView.model.stopBatch('control-move', {
	      ui: true,
	      tool: this.cid
	    });
	  },
	  onPointerDblClick: function (evt) {
	    const {
	      relatedView
	    } = this;
	    this.resetPosition(relatedView, evt);
	    this.update();
	  }
	});

	const RotateLabel = Control.extend({
	  xAxisVector: new Point(1, 0),
	  children() {
	    const {
	      buttonColor = '#333',
	      iconColor = '#fff',
	      outlineColor = '#fff'
	    } = this.options;
	    return [{
	      selector: 'handle',
	      tagName: 'g',
	      attributes: {
	        cursor: 'grab'
	      },
	      children: [{
	        tagName: 'circle',
	        attributes: {
	          r: 10,
	          fill: buttonColor,
	          stroke: outlineColor
	        }
	      }, {
	        tagName: 'path',
	        attributes: {
	          d: 'M -5 0 A 5 5 0 1 1 0 5',
	          fill: 'transparent',
	          stroke: iconColor,
	          strokeWidth: 2,
	          strokeLinecap: 'round'
	        }
	      }, {
	        tagName: 'path',
	        attributes: {
	          d: 'M -3 5 L 0 2.5 0 7.5 Z',
	          fill: iconColor,
	          stroke: iconColor,
	          strokeWidth: 1,
	          transform: 'rotate(-5, -3, 5)'
	        }
	      }]
	    }];
	  },
	  getPosition(view) {
	    const {
	      offset = 0
	    } = this.options;
	    const {
	      x = 0,
	      y = 0
	    } = typeof offset === 'number' ? {
	      x: 0,
	      y: offset
	    } : offset;
	    const label = this.getLabel();
	    const labelPosition = this.getLabelPosition(label);
	    const coords = view.getLabelCoordinates(labelPosition);
	    let {
	      angle = 0,
	      args = {}
	    } = labelPosition;
	    const keepGradient = args.keepGradient;
	    if (keepGradient) {
	      const tangent = view.getTangentAtRatio(view.getClosestPointRatio(coords));
	      if (tangent) {
	        // link slope angle
	        angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;
	      }
	    }
	    const matrix = new DOMMatrix().translate(coords.x, coords.y).rotate(angle).translate(x, y);
	    return new Point(matrix.e, matrix.f);
	  },
	  // Override the default `computeVisibility` method to hide the tool if the label is not present.
	  computeVisibility() {
	    const visibility = Control.prototype.computeVisibility.apply(this, arguments);
	    return visibility && !!this.getLabel();
	  },
	  setPosition(view, coordinates) {
	    const model = view.model;
	    const label = this.getLabel();
	    if (!label) return;
	    const labelPosition = this.getLabelPosition(label);
	    const position = view.getLabelCoordinates(labelPosition);
	    const angle = 90 - position.theta(coordinates);
	    const index = this.getLabelIndex();
	    model.prop(['labels', index, 'position', 'angle'], angle);
	  },
	  resetPosition(view) {
	    const model = view.model;
	    const index = this.getLabelIndex();
	    model.prop(['labels', index, 'position', 'angle'], 0);
	  },
	  getLabelIndex() {
	    return this.options.labelIndex || 0;
	  },
	  getLabel() {
	    return this.relatedView.model.label(this.getLabelIndex()) || null;
	  },
	  getLabelPosition(label) {
	    const view = this.relatedView;
	    const labelPosition = view._normalizeLabelPosition(label.position);
	    return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());
	  }
	});

	const Button = ToolView.extend({
	  name: 'button',
	  events: {
	    'mousedown': 'onPointerDown',
	    'touchstart': 'onPointerDown'
	  },
	  options: {
	    distance: 0,
	    offset: 0,
	    scale: null,
	    rotate: false
	  },
	  onRender: function () {
	    this.renderChildren(this.options.markup);
	    this.update();
	  },
	  update: function () {
	    this.position();
	    return this;
	  },
	  position: function () {
	    const {
	      vel
	    } = this;
	    vel.transform(this.getCellMatrix(), {
	      absolute: true
	    });
	  },
	  getCellMatrix() {
	    return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();
	  },
	  getElementMatrix() {
	    const {
	      relatedView: view
	    } = this;
	    let {
	      x = 0,
	      y = 0,
	      offset = {},
	      useModelGeometry,
	      rotate,
	      scale,
	      relative
	    } = getToolOptions(this);
	    let bbox = getViewBBox(view, {
	      useModelGeometry,
	      relative
	    });
	    const angle = view.model.angle();
	    if (!rotate) bbox = bbox.bbox(angle);
	    const {
	      x: offsetX = 0,
	      y: offsetY = 0
	    } = offset;
	    if (isPercentage(x)) {
	      x = parseFloat(x) / 100 * bbox.width;
	    } else if (isCalcExpression(x)) {
	      x = Number(evalCalcExpression(x, bbox));
	    }
	    if (isPercentage(y)) {
	      y = parseFloat(y) / 100 * bbox.height;
	    } else if (isCalcExpression(y)) {
	      y = Number(evalCalcExpression(y, bbox));
	    }
	    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
	    // With relative positioning, rotation is implicit
	    // (the tool rotates along with the element).
	    if (rotate && !relative) matrix = matrix.rotate(angle);
	    matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
	    if (scale) matrix = matrix.scale(scale);
	    return matrix;
	  },
	  getLinkMatrix() {
	    const {
	      relatedView: view,
	      options
	    } = this;
	    const {
	      offset = 0,
	      distance: distanceOpt = 0,
	      rotate,
	      scale
	    } = options;
	    const distance = typeof distanceOpt === 'function' ? distanceOpt.call(this, view, this) : distanceOpt;
	    let tangent, position, angle;
	    if (isPercentage(distance)) {
	      tangent = view.getTangentAtRatio(parseFloat(distance) / 100);
	    } else {
	      tangent = view.getTangentAtLength(distance);
	    }
	    if (tangent) {
	      position = tangent.start;
	      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
	    } else {
	      position = view.getConnection().start;
	      angle = 0;
	    }
	    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);
	    if (!rotate) matrix = matrix.rotate(-angle);
	    if (scale) matrix = matrix.scale(scale);
	    return matrix;
	  },
	  onPointerDown: function (evt) {
	    if (this.guard(evt)) return;
	    evt.stopPropagation();
	    evt.preventDefault();
	    var actionFn = this.options.action;
	    if (typeof actionFn === 'function') {
	      actionFn.call(this.relatedView, evt, this.relatedView, this);
	    }
	  }
	});
	const Remove = Button.extend({
	  name: 'remove',
	  children: [{
	    tagName: 'circle',
	    selector: 'button',
	    attributes: {
	      'r': 7,
	      'fill': '#FF1D00',
	      'cursor': 'pointer'
	    }
	  }, {
	    tagName: 'path',
	    selector: 'icon',
	    attributes: {
	      'd': 'M -3 -3 3 3 M -3 3 3 -3',
	      'fill': 'none',
	      'stroke': '#FFFFFF',
	      'stroke-width': 2,
	      'pointer-events': 'none'
	    }
	  }],
	  options: {
	    distance: 60,
	    offset: 0,
	    action: function (evt, view, tool) {
	      view.model.remove({
	        ui: true,
	        tool: tool.cid
	      });
	    }
	  }
	});

	const Boundary = ToolView.extend({
	  name: 'boundary',
	  tagName: 'rect',
	  options: {
	    padding: 10,
	    useModelGeometry: false
	  },
	  attributes: {
	    'fill': 'none',
	    'stroke': '#33334F',
	    'stroke-width': .5,
	    'stroke-dasharray': '5, 5',
	    'pointer-events': 'none'
	  },
	  onRender: function () {
	    this.update();
	  },
	  update: function () {
	    const {
	      relatedView: view,
	      vel
	    } = this;
	    const {
	      useModelGeometry,
	      rotate,
	      relative,
	      padding
	    } = getToolOptions(this);
	    const normalizedPadding = normalizeSides(padding);
	    let bbox = getViewBBox(view, {
	      useModelGeometry,
	      relative
	    }).moveAndExpand({
	      x: -normalizedPadding.left,
	      y: -normalizedPadding.top,
	      width: normalizedPadding.left + normalizedPadding.right,
	      height: normalizedPadding.top + normalizedPadding.bottom
	    });
	    const model = view.model;
	    // With relative positioning, rotation is implicit
	    // (the tool rotates along with the element).
	    if (model.isElement() && !relative) {
	      const angle = model.angle();
	      if (angle) {
	        if (rotate) {
	          const origin = model.getCenter();
	          vel.rotate(angle, origin.x, origin.y, {
	            absolute: true
	          });
	        } else {
	          bbox = bbox.bbox(angle);
	        }
	      }
	    }
	    vel.attr(bbox.toJSON());
	    return this;
	  }
	});

	const Connect = Button.extend({
	  name: 'connect',
	  documentEvents: {
	    mousemove: 'drag',
	    touchmove: 'drag',
	    mouseup: 'dragend',
	    touchend: 'dragend',
	    touchcancel: 'dragend'
	  },
	  children: [{
	    tagName: 'circle',
	    selector: 'button',
	    attributes: {
	      'r': 7,
	      'fill': '#333333',
	      'cursor': 'pointer'
	    }
	  }, {
	    tagName: 'path',
	    selector: 'icon',
	    attributes: {
	      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',
	      'fill': '#FFFFFF',
	      'stroke': 'none',
	      'stroke-width': 2,
	      'pointer-events': 'none'
	    }
	  }],
	  options: {
	    distance: 80,
	    offset: 0,
	    magnet: view => view.el,
	    action: (evt, _view, tool) => tool.dragstart(evt)
	  },
	  getMagnetNode: function () {
	    const {
	      options,
	      relatedView
	    } = this;
	    const {
	      magnet
	    } = options;
	    let magnetNode;
	    switch (typeof magnet) {
	      case 'function':
	        {
	          magnetNode = magnet.call(this, relatedView, this);
	          break;
	        }
	      case 'string':
	        {
	          magnetNode = relatedView.findNode(magnet);
	          break;
	        }
	      default:
	        {
	          magnetNode = magnet;
	          break;
	        }
	    }
	    if (!magnetNode) magnetNode = relatedView.el;
	    if (magnetNode instanceof SVGElement) return magnetNode;
	    throw new Error('Connect: magnet must be an SVGElement');
	  },
	  dragstart: function (evt) {
	    const {
	      paper,
	      relatedView
	    } = this;
	    const normalizedEvent = normalizeEvent(evt);
	    const {
	      x,
	      y
	    } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);
	    relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);
	    paper.undelegateEvents();
	    this.delegateDocumentEvents(null, normalizedEvent.data);
	    this.focus();
	  },
	  drag: function (evt) {
	    const {
	      paper,
	      relatedView
	    } = this;
	    const normalizedEvent = normalizeEvent(evt);
	    const {
	      x,
	      y
	    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    relatedView.dragLink(normalizedEvent, x, y);
	  },
	  dragend: function (evt) {
	    const {
	      paper,
	      relatedView
	    } = this;
	    const normalizedEvent = normalizeEvent(evt);
	    const {
	      x,
	      y
	    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
	    relatedView.dragLinkEnd(normalizedEvent, x, y);
	    this.undelegateDocumentEvents();
	    paper.delegateEvents();
	    this.blur();
	    relatedView.checkMouseleave(normalizedEvent);
	  }
	});

	const HoverConnect$1 = Connect.extend({
	  name: 'hover-connect',
	  defaultMarkup: [{
	    tagName: 'circle',
	    attributes: {
	      'r': 7,
	      'fill': '#333333',
	      'cursor': 'pointer'
	    }
	  }, {
	    tagName: 'path',
	    attributes: {
	      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',
	      'fill': '#FFFFFF',
	      'stroke': 'none',
	      'stroke-width': 2
	    }
	  }],
	  children() {
	    const {
	      options,
	      defaultMarkup
	    } = this;
	    return [{
	      tagName: 'path',
	      selector: 'track',
	      attributes: {
	        'fill': 'none',
	        'stroke': 'transparent',
	        'stroke-width': options.trackWidth || 15,
	        'cursor': 'pointer'
	      }
	    }, {
	      tagName: 'g',
	      selector: 'button',
	      attributes: {
	        'pointer-events': 'none',
	        'display': 'none'
	      },
	      children: options.markup || defaultMarkup
	    }];
	  },
	  events: Object.assign({
	    mousemove: 'onMousemove',
	    mouseenter: 'onMouseenter',
	    mouseleave: 'onMouseleave'
	  }, Connect.prototype.events),
	  onRender: function () {
	    this.renderChildren();
	    this.update();
	  },
	  trackPath: null,
	  update() {
	    const {
	      childNodes
	    } = this;
	    this.trackPath = this.getTrackPath();
	    Connect.prototype.update.apply(this, arguments);
	    childNodes.track.setAttribute('d', this.trackPath.serialize());
	  },
	  position() {
	    const {
	      el,
	      childNodes
	    } = this;
	    childNodes.button.setAttribute('transform', V.matrixToTransformString(this.getButtonMatrix()));
	    el.setAttribute('transform', V.matrixToTransformString(this.getTrackMatrix()));
	  },
	  getButtonMatrix() {
	    const {
	      options,
	      trackPath
	    } = this;
	    const {
	      offset = 0,
	      distance = 0,
	      rotate,
	      scale
	    } = options;
	    let tangent, position, angle;
	    if (isPercentage(distance)) {
	      tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);
	    } else {
	      tangent = trackPath.tangentAtLength(distance);
	    }
	    if (tangent) {
	      position = tangent.start;
	      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
	    } else {
	      position = trackPath.start;
	      angle = 0;
	    }
	    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);
	    if (!rotate) matrix = matrix.rotate(-angle);
	    if (scale) matrix = matrix.scale(scale);
	    return matrix;
	  },
	  getTrackPath() {
	    return this.relatedView.getConnection();
	  },
	  getTrackMatrix() {
	    return V.createSVGMatrix();
	  },
	  getTrackMatrixAbsolute() {
	    return this.getTrackMatrix();
	  },
	  getTrackRatioFromEvent(evt) {
	    const {
	      relatedView,
	      trackPath
	    } = this;
	    const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);
	    const trackPoint = V.transformPoint(localPoint, this.getTrackMatrixAbsolute().inverse());
	    return trackPath.closestPointLength(trackPoint);
	  },
	  canShowButton() {
	    // Has been the paper events undelegated? If so, we can't show the button.
	    // TODO: add a method to the paper to check if the events are delegated.
	    return $.event.has(this.paper.el);
	  },
	  showButton() {
	    this.childNodes.button.style.display = 'block';
	  },
	  hideButton() {
	    this.childNodes.button.style.display = '';
	  },
	  onMousemove(evt) {
	    const {
	      trackPath
	    } = this;
	    if (!trackPath) return;
	    const {
	      options
	    } = this;
	    options.distance = this.getTrackRatioFromEvent(evt);
	    this.position();
	  },
	  onMouseenter() {
	    if (!this.canShowButton()) return;
	    this.showButton();
	  },
	  onMouseleave() {
	    this.hideButton();
	  }
	});

	var index$1 = {
		__proto__: null,
		Boundary: Boundary,
		Button: Button,
		Connect: Connect,
		Control: Control,
		HoverConnect: HoverConnect$1,
		Remove: Remove,
		RotateLabel: RotateLabel,
		Segments: Segments,
		SourceAnchor: SourceAnchor,
		SourceArrowhead: SourceArrowhead,
		TargetAnchor: TargetAnchor,
		TargetArrowhead: TargetArrowhead,
		Vertices: Vertices
	};

	const HoverConnect = HoverConnect$1.extend({
	  getTrackPath() {
	    const {
	      relatedView: view
	    } = this;
	    let {
	      useModelGeometry,
	      relative,
	      trackPath = 'M 0 0 H calc(w) V calc(h) H 0 Z'
	    } = getToolOptions(this);
	    if (typeof trackPath === 'function') {
	      trackPath = trackPath.call(this, view);
	    }
	    if (isCalcExpression(trackPath)) {
	      const bbox = getViewBBox(view, {
	        useModelGeometry,
	        relative
	      });
	      trackPath = evalCalcExpression(trackPath, bbox);
	    }
	    return new Path$1(V.normalizePathData(trackPath));
	  },
	  getTrackMatrix() {
	    if (this.isOverlay()) return this.getTrackMatrixAbsolute();
	    return V.createSVGMatrix();
	  },
	  getTrackMatrixAbsolute() {
	    const {
	      relatedView: view
	    } = this;
	    let {
	      useModelGeometry,
	      rotate
	    } = getToolOptions(this);
	    let bbox = getViewBBox(view, {
	      useModelGeometry
	    });
	    const angle = view.model.angle();
	    if (!rotate) bbox = bbox.bbox(angle);
	    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
	    if (rotate) matrix = matrix.rotate(angle);
	    matrix = matrix.translate(-bbox.width / 2, -bbox.height / 2);
	    return matrix;
	  }
	});

	var index = {
		__proto__: null,
		Boundary: Boundary,
		Button: Button,
		Connect: Connect,
		Control: Control,
		HoverConnect: HoverConnect,
		Remove: Remove
	};

	var version = "4.2.1";

	const Vectorizer = V;
	const layout$1 = {
	  PortLabel,
	  Port
	};
	const setTheme = function (theme, opt) {
	  opt = opt || {};
	  invoke(views, 'setTheme', theme, opt);

	  // Update the default theme on the view prototype.
	  View.prototype.defaultTheme = theme;
	};

	const layout = {
	  PortLabel,
	  Port
	};

	// export empty namespaces - backward compatibility
	const format = {};
	const ui = {};

	exports.V = V;
	exports.Vectorizer = Vectorizer;
	exports.anchors = anchors;
	exports.config = config$3;
	exports.connectionPoints = connectionPoints;
	exports.connectionStrategies = index$3;
	exports.connectors = connectors;
	exports.dia = index$2;
	exports.elementTools = index;
	exports.env = env;
	exports.format = format;
	exports.g = g;
	exports.highlighters = highlighters;
	exports.layout = layout;
	exports.linkAnchors = linkAnchors;
	exports.linkTools = index$1;
	exports.mvc = index$4;
	exports.routers = routers;
	exports.setTheme = setTheme;
	exports.shapes = index$5;
	exports.ui = ui;
	exports.util = index$6;
	exports.version = version;

}));
if (typeof joint !== 'undefined') { var g = joint.g, V = joint.V, Vectorizer = joint.V; }


/***/ }),

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   popperGenerator: () => (/* binding */ popperGenerator)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_6__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update â it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");








function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__["default"])());

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLayoutViewport)
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: () => (/* binding */ afterMain),
/* harmony export */   afterRead: () => (/* binding */ afterRead),
/* harmony export */   afterWrite: () => (/* binding */ afterWrite),
/* harmony export */   auto: () => (/* binding */ auto),
/* harmony export */   basePlacements: () => (/* binding */ basePlacements),
/* harmony export */   beforeMain: () => (/* binding */ beforeMain),
/* harmony export */   beforeRead: () => (/* binding */ beforeRead),
/* harmony export */   beforeWrite: () => (/* binding */ beforeWrite),
/* harmony export */   bottom: () => (/* binding */ bottom),
/* harmony export */   clippingParents: () => (/* binding */ clippingParents),
/* harmony export */   end: () => (/* binding */ end),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   main: () => (/* binding */ main),
/* harmony export */   modifierPhases: () => (/* binding */ modifierPhases),
/* harmony export */   placements: () => (/* binding */ placements),
/* harmony export */   popper: () => (/* binding */ popper),
/* harmony export */   read: () => (/* binding */ read),
/* harmony export */   reference: () => (/* binding */ reference),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   top: () => (/* binding */ top),
/* harmony export */   variationPlacements: () => (/* binding */ variationPlacements),
/* harmony export */   viewport: () => (/* binding */ viewport),
/* harmony export */   write: () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain),
/* harmony export */   afterRead: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead),
/* harmony export */   afterWrite: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite),
/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.applyStyles),
/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.arrow),
/* harmony export */   auto: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto),
/* harmony export */   basePlacements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements),
/* harmony export */   beforeMain: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain),
/* harmony export */   beforeRead: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead),
/* harmony export */   beforeWrite: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite),
/* harmony export */   bottom: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   clippingParents: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents),
/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.computeStyles),
/* harmony export */   createPopper: () => (/* reexport safe */ _popper_js__WEBPACK_IMPORTED_MODULE_4__.createPopper),
/* harmony export */   createPopperBase: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.createPopper),
/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__.createPopper),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   end: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end),
/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.eventListeners),
/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.flip),
/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.hide),
/* harmony export */   left: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   main: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main),
/* harmony export */   modifierPhases: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases),
/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.offset),
/* harmony export */   placements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements),
/* harmony export */   popper: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper),
/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.popperGenerator),
/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.popperOffsets),
/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.preventOverflow),
/* harmony export */   read: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read),
/* harmony export */   reference: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference),
/* harmony export */   right: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   start: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start),
/* harmony export */   top: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   variationPlacements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements),
/* harmony export */   viewport: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport),
/* harmony export */   write: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_8__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_8__.left, _enums_js__WEBPACK_IMPORTED_MODULE_8__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__.top : _enums_js__WEBPACK_IMPORTED_MODULE_8__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_8__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_5__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mapToStyles: () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.right : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases â research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   arrow: () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   computeStyles: () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   eventListeners: () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   flip: () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   hide: () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   offset: () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   popperOffsets: () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   preventOverflow: () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   distanceAndSkiddingToXY: () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.top : _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.top : _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),
/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),
/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),
/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),
/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),
/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),
/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),
/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator),
/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),
/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_9__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_10__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_1__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_1__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_3__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_3__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_5__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.right, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   round: () => (/* binding */ round)
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUAString)
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   within: () => (/* binding */ within),
/* harmony export */   withinMaxClamp: () => (/* binding */ withinMaxClamp)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: () => (/* binding */ Alert),
/* harmony export */   Button: () => (/* binding */ Button),
/* harmony export */   Carousel: () => (/* binding */ Carousel),
/* harmony export */   Collapse: () => (/* binding */ Collapse),
/* harmony export */   Dropdown: () => (/* binding */ Dropdown),
/* harmony export */   Modal: () => (/* binding */ Modal),
/* harmony export */   Offcanvas: () => (/* binding */ Offcanvas),
/* harmony export */   Popover: () => (/* binding */ Popover),
/* harmony export */   ScrollSpy: () => (/* binding */ ScrollSpy),
/* harmony export */   Tab: () => (/* binding */ Tab),
/* harmony export */   Toast: () => (/* binding */ Toast),
/* harmony export */   Tooltip: () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/index.js");
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/*!
  * Bootstrap v5.3.8 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */


/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const elementMap = new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }
    const instanceMap = elementMap.get(element);

    // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);

    // free up element references if there are no instances left for an element
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend';

/**
 * Properly escape IDs selectors to handle weird IDs
 * @param {string} selector
 * @returns {string}
 */
const parseSelector = selector => {
  if (selector && window.CSS && window.CSS.escape) {
    // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};

// Shout-out Angus Croll (https://goo.gl/pxwQGp)
const toType = object => {
  if (object === null || object === undefined) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};

/**
 * Public Util API
 */

const getUID = prefix => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
const getTransitionDurationFromElement = element => {
  if (!element) {
    return 0;
  }

  // Get transition-duration of the element
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);

  // Return 0 if element or transition duration is not found
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }

  // If multiple durations are defined, take the first
  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = element => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = object => {
  if (!object || typeof object !== 'object') {
    return false;
  }
  if (typeof object.jquery !== 'undefined') {
    object = object[0];
  }
  return typeof object.nodeType !== 'undefined';
};
const getElement = object => {
  // it's a jQuery object or a node element
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === 'string' && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
const isVisible = element => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  // Handle `details` element as its content may falsie appear visible when it is closed
  const closedDetails = element.closest('details:not([open])');
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest('summary');
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
const isDisabled = element => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains('disabled')) {
    return true;
  }
  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }
  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};
const findShadowRoot = element => {
  if (!document.documentElement.attachShadow) {
    return null;
  }

  // Can find the shadow root otherwise it'll return the document
  if (typeof element.getRootNode === 'function') {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }

  // when we don't find a shadow root
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
const noop = () => {};

/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */
const reflow = element => {
  element.offsetHeight; // eslint-disable-line no-unused-expressions
};
const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return window.jQuery;
  }
  return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = callback => {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', () => {
        for (const callback of DOMContentLoadedCallbacks) {
          callback();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
const isRTL = () => document.documentElement.dir === 'rtl';
const defineJQueryPlugin = plugin => {
  onDOMContentLoaded(() => {
    const $ = getjQuery();
    /* istanbul ignore if */
    if ($) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;
      $.fn[name].noConflict = () => {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};

/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */
const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement);

  // if the element does not exist in the list return an element
  // depending on the direction and if cycle is allowed
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage
let uidEvent = 1;
const customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

/**
 * Private methods
 */

function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }
    return fn.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn);
        }
        return fn.apply(target, [event]);
      }
    }
  };
}
function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === 'string';
  // TODO: tooltip passes `false` instead of selector, so we need to check
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);

  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does
  if (originalTypeEvent in customEvents) {
    const wrapFunction = fn => {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
  const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn.delegationSelector = isDelegated ? handler : null;
  fn.callable = callable;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn) {
    return;
  }
  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}
const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith('.');
    if (typeof callable !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, '');
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }
    const $ = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

function normalizeData(value) {
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === '' || value === 'null') {
    return null;
  }
  if (typeof value !== 'string') {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
}
const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, '');
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Class definition
 */

class Config {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    return config;
  }
  _mergeConfigObj(config, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

    return {
      ...this.constructor.Default,
      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
      ...(typeof config === 'object' ? config : {})
    };
  }
  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config[property];
      const valueType = isElement(value) ? 'element' : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const VERSION = '5.3.8';

/**
 * Class definition
 */

class BaseComponent extends Config {
  constructor(element, config) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }

  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }

  // Private
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config, this._element);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }

  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name) {
    return `${name}${this.EVENT_KEY}`;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const getSelector = element => {
  let selector = element.getAttribute('data-bs-target');
  if (!selector || selector === '#') {
    let hrefAttribute = element.getAttribute('href');

    // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273
    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
      return null;
    }

    // Just in case some CMS puts out a full URL with the anchor appended
    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
      hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;
};
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter(child => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const enableDismissTrigger = (component, method = 'hide') => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target);

    // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
    instance[method]();
  });
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$f = 'alert';
const DATA_KEY$a = 'bs.alert';
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';

/**
 * Class definition
 */

class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }

  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }

  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Alert.getOrCreateInstance(this);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}

/**
 * Data API implementation
 */

enableDismissTrigger(Alert, 'close');

/**
 * jQuery
 */

defineJQueryPlugin(Alert);

/**
 * --------------------------------------------------------------------------
 * Bootstrap button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$e = 'button';
const DATA_KEY$9 = 'bs.button';
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

/**
 * Class definition
 */

class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }

  // Public
  toggle() {
    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Button.getOrCreateInstance(this);
      if (config === 'toggle') {
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Button);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$d = 'swipe';
const EVENT_KEY$9 = '.bs.swipe';
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: '(function|null)',
  leftCallback: '(function|null)',
  rightCallback: '(function|null)'
};

/**
 * Class definition
 */

class Swipe extends Config {
  constructor(element, config) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }

  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }

  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }

  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }

  // Static
  static isSupported() {
    return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$c = 'carousel';
const DATA_KEY$8 = 'bs.carousel';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = '.data-api';
const ARROW_LEFT_KEY$1 = 'ArrowLeft';
const ARROW_RIGHT_KEY$1 = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5000,
  keyboard: true,
  pause: 'hover',
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: '(number|boolean)',
  // TODO:v6 remove boolean support
  keyboard: 'boolean',
  pause: '(string|boolean)',
  ride: '(boolean|string)',
  touch: 'boolean',
  wrap: 'boolean'
};

/**
 * Class definition
 */

class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }

  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }

  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    // FIXME TODO use `document.visibilityState`
    // Don't call next when the page isn't visible
    // or the carousel or its parent isn't visible
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }

  // Private
  _configAfterMerge(config) {
    config.defaultInterval = config.interval;
    return config;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
    }
    if (this._config.pause === 'hover') {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== 'hover') {
        return;
      }

      // If it's a touch-enabled device, mouseenter/leave are fired as
      // part of the mouse compatibility events on first tap - the carousel
      // would stop cycling until user tapped out of it;
      // here, we listen for touchend, explicitly pause the carousel
      // (as if it's the second time we tap on it, mouseenter compat event
      // is NOT fired) and after a timeout (to allow for mouse compatibility
      // events to fire) we explicitly restart cycling

      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute('aria-current');
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute('aria-current', 'true');
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = eventName => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      // Some weirdness is happening, so we bail
      // TODO: change tests that use empty divs to avoid this check
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order) {
    if (isRTL()) {
      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Carousel.getOrCreateInstance(this, config);
      if (typeof config === 'number') {
        data.to(config);
        return;
      }
      if (typeof config === 'string') {
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute('data-bs-slide-to');
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Carousel);

/**
 * --------------------------------------------------------------------------
 * Bootstrap collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$b = 'collapse';
const DATA_KEY$7 = 'bs.collapse';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = '.data-api';
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: '(null|element)',
  toggle: 'boolean'
};

/**
 * Class definition
 */

class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }

  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }

  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];

    // find active children
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = '';
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = '';
    this._queueCallback(complete, this._element, true);
  }

  // Private
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  _configAfterMerge(config) {
    config.toggle = Boolean(config.toggle); // Coerce string values
    config.parent = getElement(config.parent);
    return config;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    // remove children if greater depth
    return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute('aria-expanded', isOpen);
    }
  }

  // Static
  static jQueryInterface(config) {
    const _config = {};
    if (typeof config === 'string' && /show|hide/.test(config)) {
      _config.toggle = false;
    }
    return this.each(function () {
      const data = Collapse.getOrCreateInstance(this, _config);
      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Collapse);

/**
 * --------------------------------------------------------------------------
 * Bootstrap dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$a = 'dropdown';
const DATA_KEY$6 = 'bs.dropdown';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY$1 = 'ArrowUp';
const ARROW_DOWN_KEY$1 = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR = '.navbar';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const PLACEMENT_TOPCENTER = 'top';
const PLACEMENT_BOTTOMCENTER = 'bottom';
const Default$9 = {
  autoClose: true,
  boundary: 'clippingParents',
  display: 'dynamic',
  offset: [0, 2],
  popperConfig: null,
  reference: 'toggle'
};
const DefaultType$9 = {
  autoClose: '(boolean|string)',
  boundary: '(string|element)',
  display: 'string',
  offset: '(array|string|function)',
  popperConfig: '(null|object|function)',
  reference: '(string|element|object)'
};

/**
 * Class definition
 */

class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._popper = null;
    this._parent = this._element.parentNode; // dropdown wrapper
    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }

  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }

  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();

    // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }
    this._element.focus();
    this._element.setAttribute('aria-expanded', true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }

  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }

    // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute('aria-expanded', 'false');
    Manipulator.removeDataAttribute(this._menu, 'popper');
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config) {
    config = super._getConfig(config);
    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
      // Popper virtual elements require a getBoundingClientRect method
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config;
  }
  _createPopper() {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');
    }
    let referenceElement = this._element;
    if (this._config.reference === 'parent') {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === 'object') {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }

    // We need to trim the value because custom properties can also include spaces
    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset
    } = this._config;
    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }
    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }
    return offset;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }]
    };

    // Disable Popper if we have a static display or Dropdown is in Navbar
    if (this._inNavbar || this._config.display === 'static') {
      Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
      defaultBsPopperConfig.modifiers = [{
        name: 'applyStyles',
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
    if (!items.length) {
      return;
    }

    // if target isn't included in items (e.g. when expanding the dropdown)
    // allow cycling to get the last item in case key equals ARROW_UP_KEY
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Dropdown.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
        continue;
      }

      // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
      if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === 'click') {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    // If not an UP | DOWN | ESCAPE key => not a dropdown command
    // If input/textarea && if key is other than ESCAPE => not a dropdown command

    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();

    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      // else is escape and we check if it is shown
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Dropdown);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$9 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: 'modal-backdrop',
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: 'body' // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
  className: 'string',
  clickCallback: '(function|null)',
  isAnimated: 'boolean',
  isVisible: 'boolean',
  rootElement: '(element|string)'
};

/**
 * Class definition
 */

class Backdrop extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }

  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }

  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }

  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement('div');
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config) {
    // use getElement() with the default "body" to get a fresh Element on each instantiation
    config.rootElement = getElement(config.rootElement);
    return config;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$8 = 'focustrap';
const DATA_KEY$5 = 'bs.focustrap';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';
const Default$7 = {
  autofocus: true,
  trapElement: null // The element to trap focus inside of
};
const DefaultType$7 = {
  autofocus: 'boolean',
  trapElement: 'element'
};

/**
 * Class definition
 */

class FocusTrap extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }

  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }

  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
    EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }

  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';
const PROPERTY_PADDING = 'padding-right';
const PROPERTY_MARGIN = 'margin-right';

/**
 * Class definition
 */

class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }

  // Public
  getWidth() {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    // give padding to element to balance the hidden scrollbar width
    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, 'overflow');
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }

  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, 'overflow');
    this._element.style.overflow = 'hidden';
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = element => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = element => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      // We only want to remove the property if the value is `null`; the value can also be zero
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$7 = 'modal';
const DATA_KEY$4 = 'bs.modal';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: '(boolean|string)',
  focus: 'boolean',
  keyboard: 'boolean'
};

/**
 * Class definition
 */

class Modal extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }

  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }

  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }

  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    // try to append dynamic modal
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = 'block';
    this._element.removeAttribute('aria-hidden');
    this._element.setAttribute('aria-modal', true);
    this._element.setAttribute('role', 'dialog');
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
      // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === 'static') {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = 'none';
    this._element.setAttribute('aria-hidden', true);
    this._element.removeAttribute('aria-modal');
    this._element.removeAttribute('role');
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    // return if the following background transition hasn't yet completed
    if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = 'hidden';
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }

  /**
   * The following methods are used to handle overflowing modals
   */

  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? 'paddingLeft' : 'paddingRight';
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? 'paddingRight' : 'paddingLeft';
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = '';
    this._element.style.paddingRight = '';
  }

  // Static
  static jQueryInterface(config, relatedTarget) {
    return this.each(function () {
      const data = Modal.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](relatedTarget);
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, showEvent => {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });

  // avoid conflict when clicking modal toggler while another one is open
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);

/**
 * jQuery
 */

defineJQueryPlugin(Modal);

/**
 * --------------------------------------------------------------------------
 * Bootstrap offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$6 = 'offcanvas';
const DATA_KEY$3 = 'bs.offcanvas';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = '.data-api';
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = 'Escape';
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_SHOWING$1 = 'showing';
const CLASS_NAME_HIDING = 'hiding';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  scroll: 'boolean'
};

/**
 * Class definition
 */

class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }

  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }

  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute('aria-modal', true);
    this._element.setAttribute('role', 'dialog');
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }

  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === 'static') {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };

    // 'static' option will be translated to true, and booleans will keep their value
    const isVisible = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Offcanvas.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    // focus on trigger when it is closed
    if (isVisible(this)) {
      this.focus();
    }
  });

  // avoid conflict when clicking a toggler of an offcanvas, while another is open
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
    if (getComputedStyle(element).position !== 'fixed') {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);

/**
 * jQuery
 */

defineJQueryPlugin(Offcanvas);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

// js-docs-start allow-list
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
// js-docs-end allow-list

const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);

/**
 * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
 * contexts.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
 */
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }

  // Check if a regular expression validates the attribute.
  return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === 'function') {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$5 = 'TemplateFactory';
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: '',
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: '<div></div>'
};
const DefaultType$4 = {
  allowList: 'object',
  content: 'object',
  extraClass: '(string|function)',
  html: 'boolean',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  template: 'string'
};
const DefaultContentType = {
  entry: '(string|element|function|null)',
  selector: '(string|element)'
};

/**
 * Class definition
 */

class TemplateFactory extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
  }

  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }

  // Public
  getContent() {
    return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement('div');
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(' '));
    }
    return template;
  }

  // Private
  _typeCheckConfig(config) {
    super._typeCheckConfig(config);
    this._checkContent(config.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [undefined, this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = '';
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$4 = 'tooltip';
const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
const EVENT_HIDE$2 = 'hide';
const EVENT_HIDDEN$2 = 'hidden';
const EVENT_SHOW$2 = 'show';
const EVENT_SHOWN$2 = 'shown';
const EVENT_INSERTED = 'inserted';
const EVENT_CLICK$1 = 'click';
const EVENT_FOCUSIN$1 = 'focusin';
const EVENT_FOCUSOUT$1 = 'focusout';
const EVENT_MOUSEENTER = 'mouseenter';
const EVENT_MOUSELEAVE = 'mouseleave';
const AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: isRTL() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: 'clippingParents',
  container: false,
  customClass: '',
  delay: 0,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  html: false,
  offset: [0, 6],
  placement: 'top',
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  title: '',
  trigger: 'hover focus'
};
const DefaultType$3 = {
  allowList: 'object',
  animation: 'boolean',
  boundary: '(string|element)',
  container: '(string|element|boolean)',
  customClass: '(string|function)',
  delay: '(number|object)',
  fallbackPlacements: 'array',
  html: 'boolean',
  offset: '(array|string|function)',
  placement: '(string|function)',
  popperConfig: '(null|object|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  selector: '(string|boolean)',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string'
};

/**
 * Class definition
 */

class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org/docs/v2/)');
    }
    super(element, config);

    // Private
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;

    // Protected
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }

  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }

  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute('data-bs-original-title')) {
      this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === 'none') {
      throw new Error('Please use show on visible elements');
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }

    // TODO: v6 remove this or make it optional
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);

    // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);

    // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null; // it is a trick to support manual triggering

    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute('aria-describedby');
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }

  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();

    // TODO: remove this check in v6
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    // TODO: v6 the following can be achieved with CSS only
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute('id', tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
  }

  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset
    } = this._config;
    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }
    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }
    return offset;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element, this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: 'flip',
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }, {
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'arrow',
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: 'preSetPlacement',
        enabled: true,
        phase: 'beforeMain',
        fn: data => {
          // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
          // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
          this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(' ');
    for (const trigger of triggers) {
      if (trigger === 'click') {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute('title');
    if (!title) {
      return;
    }
    if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
      this._element.setAttribute('aria-label', title);
    }
    this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
    this._element.removeAttribute('title');
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config = {
      ...dataAttributes,
      ...(typeof config === 'object' && config ? config : {})
    };
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    config.container = config.container === false ? document.body : getElement(config.container);
    if (typeof config.delay === 'number') {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }
    if (typeof config.title === 'number') {
      config.title = config.title.toString();
    }
    if (typeof config.content === 'number') {
      config.content = config.content.toString();
    }
    return config;
  }
  _getDelegateConfig() {
    const config = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config[key] = value;
      }
    }
    config.selector = false;
    config.trigger = 'manual';

    // In the future can be replaced with:
    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
    // `Object.fromEntries(keysWithDifferentValues)`
    return config;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tooltip.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * jQuery
 */

defineJQueryPlugin(Tooltip);

/**
 * --------------------------------------------------------------------------
 * Bootstrap popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$3 = 'popover';
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
const Default$2 = {
  ...Tooltip.Default,
  content: '',
  offset: [0, 8],
  placement: 'right',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
  trigger: 'click'
};
const DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: '(null|string|element|function)'
};

/**
 * Class definition
 */

class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }

  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }

  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Popover.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * jQuery
 */

defineJQueryPlugin(Popover);

/**
 * --------------------------------------------------------------------------
 * Bootstrap scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = '.data-api';
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = '[href]';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: '0px 0px -25%',
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
const DefaultType$1 = {
  offset: '(number|null)',
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: 'string',
  smoothScroll: 'boolean',
  target: 'element',
  threshold: 'array'
};

/**
 * Class definition
 */

class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element, config);

    // this._element is the observablesContainer and config.target the menu links wrapper
    this._targetLinks = new Map();
    this._observableSections = new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh(); // initialize
  }

  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }

  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }

  // Private
  _configAfterMerge(config) {
    // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
    config.target = getElement(config.target) || document.body;

    // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
    if (typeof config.threshold === 'string') {
      config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));
    }
    return config;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }

    // unregister any previous listeners
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: 'smooth'
          });
          return;
        }

        // Chrome 60 doesn't support `scrollTo`
        root.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver(entries => this._observerCallback(entries), options);
  }

  // The logic of selection
  _observerCallback(entries) {
    const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
    const activate = entry => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      // if we are scrolling down, pick the bigger offsetTop
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
        if (!parentScrollTop) {
          return;
        }
        continue;
      }

      // if we are scrolling up, pick the smallest offsetTop
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = new Map();
    this._observableSections = new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      // ensure that the anchor has an id and is not disabled
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);

      // ensure that the observableSection exists & is visible
      if (isVisible(observableSection)) {
        this._targetLinks.set(decodeURI(anchor.hash), anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    // Activate dropdown parents
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      // Set triggered links parents as active
      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = ScrollSpy.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(ScrollSpy);

/**
 * --------------------------------------------------------------------------
 * Bootstrap tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const HOME_KEY = 'Home';
const END_KEY = 'End';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const CLASS_DROPDOWN = 'dropdown';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = '.nav-item, .list-group-item';
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

/**
 * Class definition
 */

class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
      // TODO: should throw exception in v6
      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
    }

    // Set up initial aria attributes
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
  }

  // Getters
  static get NAME() {
    return NAME$1;
  }

  // Public
  show() {
    // Shows this elem and deactivate the active sibling if exists
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }

    // Search for active tab on same parent to deactivate it
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }

  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute('tabindex');
      element.setAttribute('aria-selected', true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute('aria-selected', false);
      element.setAttribute('tabindex', '-1');
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
    event.preventDefault();
    const children = this._getChildren().filter(element => !isDisabled(element));
    let nextActiveElement;
    if ([HOME_KEY, END_KEY].includes(event.key)) {
      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
    } else {
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
    }
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    // collection of inner elements
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find(child => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, 'role', 'tablist');
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute('aria-selected', isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
    }
    if (!isActive) {
      child.setAttribute('tabindex', '-1');
    }
    this._setAttributeIfNotExists(child, 'role', 'tab');

    // set attributes to the related panel too
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, 'role', 'tabpanel');
    if (child.id) {
      this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element = SelectorEngine.findOne(selector, outerElem);
      if (element) {
        element.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute('aria-expanded', open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }

  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }

  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tab.getOrCreateInstance(this);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});

/**
 * Initialize on focus
 */
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Tab);

/**
 * --------------------------------------------------------------------------
 * Bootstrap toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5000
};

/**
 * Class definition
 */

class Toast extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }

  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }

  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }

  // Private
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case 'mouseover':
      case 'mouseout':
        {
          this._hasMouseInteraction = isInteracting;
          break;
        }
      case 'focusin':
      case 'focusout':
        {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Toast.getOrCreateInstance(this, config);
      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      }
    });
  }
}

/**
 * Data API implementation
 */

enableDismissTrigger(Toast);

/**
 * jQuery
 */

defineJQueryPlugin(Toast);


//# sourceMappingURL=bootstrap.esm.js.map


/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACESFilmicToneMapping: () => (/* binding */ ACESFilmicToneMapping),
/* harmony export */   AddEquation: () => (/* binding */ AddEquation),
/* harmony export */   AddOperation: () => (/* binding */ AddOperation),
/* harmony export */   AdditiveAnimationBlendMode: () => (/* binding */ AdditiveAnimationBlendMode),
/* harmony export */   AdditiveBlending: () => (/* binding */ AdditiveBlending),
/* harmony export */   AgXToneMapping: () => (/* binding */ AgXToneMapping),
/* harmony export */   AlphaFormat: () => (/* binding */ AlphaFormat),
/* harmony export */   AlwaysCompare: () => (/* binding */ AlwaysCompare),
/* harmony export */   AlwaysDepth: () => (/* binding */ AlwaysDepth),
/* harmony export */   AlwaysStencilFunc: () => (/* binding */ AlwaysStencilFunc),
/* harmony export */   AmbientLight: () => (/* binding */ AmbientLight),
/* harmony export */   AnimationAction: () => (/* binding */ AnimationAction),
/* harmony export */   AnimationClip: () => (/* binding */ AnimationClip),
/* harmony export */   AnimationLoader: () => (/* binding */ AnimationLoader),
/* harmony export */   AnimationMixer: () => (/* binding */ AnimationMixer),
/* harmony export */   AnimationObjectGroup: () => (/* binding */ AnimationObjectGroup),
/* harmony export */   AnimationUtils: () => (/* binding */ AnimationUtils),
/* harmony export */   ArcCurve: () => (/* binding */ ArcCurve),
/* harmony export */   ArrayCamera: () => (/* binding */ ArrayCamera),
/* harmony export */   ArrowHelper: () => (/* binding */ ArrowHelper),
/* harmony export */   AttachedBindMode: () => (/* binding */ AttachedBindMode),
/* harmony export */   Audio: () => (/* binding */ Audio),
/* harmony export */   AudioAnalyser: () => (/* binding */ AudioAnalyser),
/* harmony export */   AudioContext: () => (/* binding */ AudioContext),
/* harmony export */   AudioListener: () => (/* binding */ AudioListener),
/* harmony export */   AudioLoader: () => (/* binding */ AudioLoader),
/* harmony export */   AxesHelper: () => (/* binding */ AxesHelper),
/* harmony export */   BackSide: () => (/* binding */ BackSide),
/* harmony export */   BasicDepthPacking: () => (/* binding */ BasicDepthPacking),
/* harmony export */   BasicShadowMap: () => (/* binding */ BasicShadowMap),
/* harmony export */   BatchedMesh: () => (/* binding */ BatchedMesh),
/* harmony export */   Bone: () => (/* binding */ Bone),
/* harmony export */   BooleanKeyframeTrack: () => (/* binding */ BooleanKeyframeTrack),
/* harmony export */   Box2: () => (/* binding */ Box2),
/* harmony export */   Box3: () => (/* binding */ Box3),
/* harmony export */   Box3Helper: () => (/* binding */ Box3Helper),
/* harmony export */   BoxGeometry: () => (/* binding */ BoxGeometry),
/* harmony export */   BoxHelper: () => (/* binding */ BoxHelper),
/* harmony export */   BufferAttribute: () => (/* binding */ BufferAttribute),
/* harmony export */   BufferGeometry: () => (/* binding */ BufferGeometry),
/* harmony export */   BufferGeometryLoader: () => (/* binding */ BufferGeometryLoader),
/* harmony export */   ByteType: () => (/* binding */ ByteType),
/* harmony export */   Cache: () => (/* binding */ Cache),
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   CameraHelper: () => (/* binding */ CameraHelper),
/* harmony export */   CanvasTexture: () => (/* binding */ CanvasTexture),
/* harmony export */   CapsuleGeometry: () => (/* binding */ CapsuleGeometry),
/* harmony export */   CatmullRomCurve3: () => (/* binding */ CatmullRomCurve3),
/* harmony export */   CineonToneMapping: () => (/* binding */ CineonToneMapping),
/* harmony export */   CircleGeometry: () => (/* binding */ CircleGeometry),
/* harmony export */   ClampToEdgeWrapping: () => (/* binding */ ClampToEdgeWrapping),
/* harmony export */   Clock: () => (/* binding */ Clock),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   ColorKeyframeTrack: () => (/* binding */ ColorKeyframeTrack),
/* harmony export */   ColorManagement: () => (/* binding */ ColorManagement),
/* harmony export */   CompressedArrayTexture: () => (/* binding */ CompressedArrayTexture),
/* harmony export */   CompressedCubeTexture: () => (/* binding */ CompressedCubeTexture),
/* harmony export */   CompressedTexture: () => (/* binding */ CompressedTexture),
/* harmony export */   CompressedTextureLoader: () => (/* binding */ CompressedTextureLoader),
/* harmony export */   ConeGeometry: () => (/* binding */ ConeGeometry),
/* harmony export */   ConstantAlphaFactor: () => (/* binding */ ConstantAlphaFactor),
/* harmony export */   ConstantColorFactor: () => (/* binding */ ConstantColorFactor),
/* harmony export */   CubeCamera: () => (/* binding */ CubeCamera),
/* harmony export */   CubeReflectionMapping: () => (/* binding */ CubeReflectionMapping),
/* harmony export */   CubeRefractionMapping: () => (/* binding */ CubeRefractionMapping),
/* harmony export */   CubeTexture: () => (/* binding */ CubeTexture),
/* harmony export */   CubeTextureLoader: () => (/* binding */ CubeTextureLoader),
/* harmony export */   CubeUVReflectionMapping: () => (/* binding */ CubeUVReflectionMapping),
/* harmony export */   CubicBezierCurve: () => (/* binding */ CubicBezierCurve),
/* harmony export */   CubicBezierCurve3: () => (/* binding */ CubicBezierCurve3),
/* harmony export */   CubicInterpolant: () => (/* binding */ CubicInterpolant),
/* harmony export */   CullFaceBack: () => (/* binding */ CullFaceBack),
/* harmony export */   CullFaceFront: () => (/* binding */ CullFaceFront),
/* harmony export */   CullFaceFrontBack: () => (/* binding */ CullFaceFrontBack),
/* harmony export */   CullFaceNone: () => (/* binding */ CullFaceNone),
/* harmony export */   Curve: () => (/* binding */ Curve),
/* harmony export */   CurvePath: () => (/* binding */ CurvePath),
/* harmony export */   CustomBlending: () => (/* binding */ CustomBlending),
/* harmony export */   CustomToneMapping: () => (/* binding */ CustomToneMapping),
/* harmony export */   CylinderGeometry: () => (/* binding */ CylinderGeometry),
/* harmony export */   Cylindrical: () => (/* binding */ Cylindrical),
/* harmony export */   Data3DTexture: () => (/* binding */ Data3DTexture),
/* harmony export */   DataArrayTexture: () => (/* binding */ DataArrayTexture),
/* harmony export */   DataTexture: () => (/* binding */ DataTexture),
/* harmony export */   DataTextureLoader: () => (/* binding */ DataTextureLoader),
/* harmony export */   DataUtils: () => (/* binding */ DataUtils),
/* harmony export */   DecrementStencilOp: () => (/* binding */ DecrementStencilOp),
/* harmony export */   DecrementWrapStencilOp: () => (/* binding */ DecrementWrapStencilOp),
/* harmony export */   DefaultLoadingManager: () => (/* binding */ DefaultLoadingManager),
/* harmony export */   DepthFormat: () => (/* binding */ DepthFormat),
/* harmony export */   DepthStencilFormat: () => (/* binding */ DepthStencilFormat),
/* harmony export */   DepthTexture: () => (/* binding */ DepthTexture),
/* harmony export */   DetachedBindMode: () => (/* binding */ DetachedBindMode),
/* harmony export */   DirectionalLight: () => (/* binding */ DirectionalLight),
/* harmony export */   DirectionalLightHelper: () => (/* binding */ DirectionalLightHelper),
/* harmony export */   DiscreteInterpolant: () => (/* binding */ DiscreteInterpolant),
/* harmony export */   DisplayP3ColorSpace: () => (/* binding */ DisplayP3ColorSpace),
/* harmony export */   DodecahedronGeometry: () => (/* binding */ DodecahedronGeometry),
/* harmony export */   DoubleSide: () => (/* binding */ DoubleSide),
/* harmony export */   DstAlphaFactor: () => (/* binding */ DstAlphaFactor),
/* harmony export */   DstColorFactor: () => (/* binding */ DstColorFactor),
/* harmony export */   DynamicCopyUsage: () => (/* binding */ DynamicCopyUsage),
/* harmony export */   DynamicDrawUsage: () => (/* binding */ DynamicDrawUsage),
/* harmony export */   DynamicReadUsage: () => (/* binding */ DynamicReadUsage),
/* harmony export */   EdgesGeometry: () => (/* binding */ EdgesGeometry),
/* harmony export */   EllipseCurve: () => (/* binding */ EllipseCurve),
/* harmony export */   EqualCompare: () => (/* binding */ EqualCompare),
/* harmony export */   EqualDepth: () => (/* binding */ EqualDepth),
/* harmony export */   EqualStencilFunc: () => (/* binding */ EqualStencilFunc),
/* harmony export */   EquirectangularReflectionMapping: () => (/* binding */ EquirectangularReflectionMapping),
/* harmony export */   EquirectangularRefractionMapping: () => (/* binding */ EquirectangularRefractionMapping),
/* harmony export */   Euler: () => (/* binding */ Euler),
/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher),
/* harmony export */   ExtrudeGeometry: () => (/* binding */ ExtrudeGeometry),
/* harmony export */   FileLoader: () => (/* binding */ FileLoader),
/* harmony export */   Float16BufferAttribute: () => (/* binding */ Float16BufferAttribute),
/* harmony export */   Float32BufferAttribute: () => (/* binding */ Float32BufferAttribute),
/* harmony export */   FloatType: () => (/* binding */ FloatType),
/* harmony export */   Fog: () => (/* binding */ Fog),
/* harmony export */   FogExp2: () => (/* binding */ FogExp2),
/* harmony export */   FramebufferTexture: () => (/* binding */ FramebufferTexture),
/* harmony export */   FrontSide: () => (/* binding */ FrontSide),
/* harmony export */   Frustum: () => (/* binding */ Frustum),
/* harmony export */   GLBufferAttribute: () => (/* binding */ GLBufferAttribute),
/* harmony export */   GLSL1: () => (/* binding */ GLSL1),
/* harmony export */   GLSL3: () => (/* binding */ GLSL3),
/* harmony export */   GreaterCompare: () => (/* binding */ GreaterCompare),
/* harmony export */   GreaterDepth: () => (/* binding */ GreaterDepth),
/* harmony export */   GreaterEqualCompare: () => (/* binding */ GreaterEqualCompare),
/* harmony export */   GreaterEqualDepth: () => (/* binding */ GreaterEqualDepth),
/* harmony export */   GreaterEqualStencilFunc: () => (/* binding */ GreaterEqualStencilFunc),
/* harmony export */   GreaterStencilFunc: () => (/* binding */ GreaterStencilFunc),
/* harmony export */   GridHelper: () => (/* binding */ GridHelper),
/* harmony export */   Group: () => (/* binding */ Group),
/* harmony export */   HalfFloatType: () => (/* binding */ HalfFloatType),
/* harmony export */   HemisphereLight: () => (/* binding */ HemisphereLight),
/* harmony export */   HemisphereLightHelper: () => (/* binding */ HemisphereLightHelper),
/* harmony export */   IcosahedronGeometry: () => (/* binding */ IcosahedronGeometry),
/* harmony export */   ImageBitmapLoader: () => (/* binding */ ImageBitmapLoader),
/* harmony export */   ImageLoader: () => (/* binding */ ImageLoader),
/* harmony export */   ImageUtils: () => (/* binding */ ImageUtils),
/* harmony export */   IncrementStencilOp: () => (/* binding */ IncrementStencilOp),
/* harmony export */   IncrementWrapStencilOp: () => (/* binding */ IncrementWrapStencilOp),
/* harmony export */   InstancedBufferAttribute: () => (/* binding */ InstancedBufferAttribute),
/* harmony export */   InstancedBufferGeometry: () => (/* binding */ InstancedBufferGeometry),
/* harmony export */   InstancedInterleavedBuffer: () => (/* binding */ InstancedInterleavedBuffer),
/* harmony export */   InstancedMesh: () => (/* binding */ InstancedMesh),
/* harmony export */   Int16BufferAttribute: () => (/* binding */ Int16BufferAttribute),
/* harmony export */   Int32BufferAttribute: () => (/* binding */ Int32BufferAttribute),
/* harmony export */   Int8BufferAttribute: () => (/* binding */ Int8BufferAttribute),
/* harmony export */   IntType: () => (/* binding */ IntType),
/* harmony export */   InterleavedBuffer: () => (/* binding */ InterleavedBuffer),
/* harmony export */   InterleavedBufferAttribute: () => (/* binding */ InterleavedBufferAttribute),
/* harmony export */   Interpolant: () => (/* binding */ Interpolant),
/* harmony export */   InterpolateDiscrete: () => (/* binding */ InterpolateDiscrete),
/* harmony export */   InterpolateLinear: () => (/* binding */ InterpolateLinear),
/* harmony export */   InterpolateSmooth: () => (/* binding */ InterpolateSmooth),
/* harmony export */   InvertStencilOp: () => (/* binding */ InvertStencilOp),
/* harmony export */   KeepStencilOp: () => (/* binding */ KeepStencilOp),
/* harmony export */   KeyframeTrack: () => (/* binding */ KeyframeTrack),
/* harmony export */   LOD: () => (/* binding */ LOD),
/* harmony export */   LatheGeometry: () => (/* binding */ LatheGeometry),
/* harmony export */   Layers: () => (/* binding */ Layers),
/* harmony export */   LessCompare: () => (/* binding */ LessCompare),
/* harmony export */   LessDepth: () => (/* binding */ LessDepth),
/* harmony export */   LessEqualCompare: () => (/* binding */ LessEqualCompare),
/* harmony export */   LessEqualDepth: () => (/* binding */ LessEqualDepth),
/* harmony export */   LessEqualStencilFunc: () => (/* binding */ LessEqualStencilFunc),
/* harmony export */   LessStencilFunc: () => (/* binding */ LessStencilFunc),
/* harmony export */   Light: () => (/* binding */ Light),
/* harmony export */   LightProbe: () => (/* binding */ LightProbe),
/* harmony export */   Line: () => (/* binding */ Line),
/* harmony export */   Line3: () => (/* binding */ Line3),
/* harmony export */   LineBasicMaterial: () => (/* binding */ LineBasicMaterial),
/* harmony export */   LineCurve: () => (/* binding */ LineCurve),
/* harmony export */   LineCurve3: () => (/* binding */ LineCurve3),
/* harmony export */   LineDashedMaterial: () => (/* binding */ LineDashedMaterial),
/* harmony export */   LineLoop: () => (/* binding */ LineLoop),
/* harmony export */   LineSegments: () => (/* binding */ LineSegments),
/* harmony export */   LinearDisplayP3ColorSpace: () => (/* binding */ LinearDisplayP3ColorSpace),
/* harmony export */   LinearFilter: () => (/* binding */ LinearFilter),
/* harmony export */   LinearInterpolant: () => (/* binding */ LinearInterpolant),
/* harmony export */   LinearMipMapLinearFilter: () => (/* binding */ LinearMipMapLinearFilter),
/* harmony export */   LinearMipMapNearestFilter: () => (/* binding */ LinearMipMapNearestFilter),
/* harmony export */   LinearMipmapLinearFilter: () => (/* binding */ LinearMipmapLinearFilter),
/* harmony export */   LinearMipmapNearestFilter: () => (/* binding */ LinearMipmapNearestFilter),
/* harmony export */   LinearSRGBColorSpace: () => (/* binding */ LinearSRGBColorSpace),
/* harmony export */   LinearToneMapping: () => (/* binding */ LinearToneMapping),
/* harmony export */   LinearTransfer: () => (/* binding */ LinearTransfer),
/* harmony export */   Loader: () => (/* binding */ Loader),
/* harmony export */   LoaderUtils: () => (/* binding */ LoaderUtils),
/* harmony export */   LoadingManager: () => (/* binding */ LoadingManager),
/* harmony export */   LoopOnce: () => (/* binding */ LoopOnce),
/* harmony export */   LoopPingPong: () => (/* binding */ LoopPingPong),
/* harmony export */   LoopRepeat: () => (/* binding */ LoopRepeat),
/* harmony export */   LuminanceAlphaFormat: () => (/* binding */ LuminanceAlphaFormat),
/* harmony export */   LuminanceFormat: () => (/* binding */ LuminanceFormat),
/* harmony export */   MOUSE: () => (/* binding */ MOUSE),
/* harmony export */   Material: () => (/* binding */ Material),
/* harmony export */   MaterialLoader: () => (/* binding */ MaterialLoader),
/* harmony export */   MathUtils: () => (/* binding */ MathUtils),
/* harmony export */   Matrix3: () => (/* binding */ Matrix3),
/* harmony export */   Matrix4: () => (/* binding */ Matrix4),
/* harmony export */   MaxEquation: () => (/* binding */ MaxEquation),
/* harmony export */   Mesh: () => (/* binding */ Mesh),
/* harmony export */   MeshBasicMaterial: () => (/* binding */ MeshBasicMaterial),
/* harmony export */   MeshDepthMaterial: () => (/* binding */ MeshDepthMaterial),
/* harmony export */   MeshDistanceMaterial: () => (/* binding */ MeshDistanceMaterial),
/* harmony export */   MeshLambertMaterial: () => (/* binding */ MeshLambertMaterial),
/* harmony export */   MeshMatcapMaterial: () => (/* binding */ MeshMatcapMaterial),
/* harmony export */   MeshNormalMaterial: () => (/* binding */ MeshNormalMaterial),
/* harmony export */   MeshPhongMaterial: () => (/* binding */ MeshPhongMaterial),
/* harmony export */   MeshPhysicalMaterial: () => (/* binding */ MeshPhysicalMaterial),
/* harmony export */   MeshStandardMaterial: () => (/* binding */ MeshStandardMaterial),
/* harmony export */   MeshToonMaterial: () => (/* binding */ MeshToonMaterial),
/* harmony export */   MinEquation: () => (/* binding */ MinEquation),
/* harmony export */   MirroredRepeatWrapping: () => (/* binding */ MirroredRepeatWrapping),
/* harmony export */   MixOperation: () => (/* binding */ MixOperation),
/* harmony export */   MultiplyBlending: () => (/* binding */ MultiplyBlending),
/* harmony export */   MultiplyOperation: () => (/* binding */ MultiplyOperation),
/* harmony export */   NearestFilter: () => (/* binding */ NearestFilter),
/* harmony export */   NearestMipMapLinearFilter: () => (/* binding */ NearestMipMapLinearFilter),
/* harmony export */   NearestMipMapNearestFilter: () => (/* binding */ NearestMipMapNearestFilter),
/* harmony export */   NearestMipmapLinearFilter: () => (/* binding */ NearestMipmapLinearFilter),
/* harmony export */   NearestMipmapNearestFilter: () => (/* binding */ NearestMipmapNearestFilter),
/* harmony export */   NeutralToneMapping: () => (/* binding */ NeutralToneMapping),
/* harmony export */   NeverCompare: () => (/* binding */ NeverCompare),
/* harmony export */   NeverDepth: () => (/* binding */ NeverDepth),
/* harmony export */   NeverStencilFunc: () => (/* binding */ NeverStencilFunc),
/* harmony export */   NoBlending: () => (/* binding */ NoBlending),
/* harmony export */   NoColorSpace: () => (/* binding */ NoColorSpace),
/* harmony export */   NoToneMapping: () => (/* binding */ NoToneMapping),
/* harmony export */   NormalAnimationBlendMode: () => (/* binding */ NormalAnimationBlendMode),
/* harmony export */   NormalBlending: () => (/* binding */ NormalBlending),
/* harmony export */   NotEqualCompare: () => (/* binding */ NotEqualCompare),
/* harmony export */   NotEqualDepth: () => (/* binding */ NotEqualDepth),
/* harmony export */   NotEqualStencilFunc: () => (/* binding */ NotEqualStencilFunc),
/* harmony export */   NumberKeyframeTrack: () => (/* binding */ NumberKeyframeTrack),
/* harmony export */   Object3D: () => (/* binding */ Object3D),
/* harmony export */   ObjectLoader: () => (/* binding */ ObjectLoader),
/* harmony export */   ObjectSpaceNormalMap: () => (/* binding */ ObjectSpaceNormalMap),
/* harmony export */   OctahedronGeometry: () => (/* binding */ OctahedronGeometry),
/* harmony export */   OneFactor: () => (/* binding */ OneFactor),
/* harmony export */   OneMinusConstantAlphaFactor: () => (/* binding */ OneMinusConstantAlphaFactor),
/* harmony export */   OneMinusConstantColorFactor: () => (/* binding */ OneMinusConstantColorFactor),
/* harmony export */   OneMinusDstAlphaFactor: () => (/* binding */ OneMinusDstAlphaFactor),
/* harmony export */   OneMinusDstColorFactor: () => (/* binding */ OneMinusDstColorFactor),
/* harmony export */   OneMinusSrcAlphaFactor: () => (/* binding */ OneMinusSrcAlphaFactor),
/* harmony export */   OneMinusSrcColorFactor: () => (/* binding */ OneMinusSrcColorFactor),
/* harmony export */   OrthographicCamera: () => (/* binding */ OrthographicCamera),
/* harmony export */   P3Primaries: () => (/* binding */ P3Primaries),
/* harmony export */   PCFShadowMap: () => (/* binding */ PCFShadowMap),
/* harmony export */   PCFSoftShadowMap: () => (/* binding */ PCFSoftShadowMap),
/* harmony export */   PMREMGenerator: () => (/* binding */ PMREMGenerator),
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera),
/* harmony export */   Plane: () => (/* binding */ Plane),
/* harmony export */   PlaneGeometry: () => (/* binding */ PlaneGeometry),
/* harmony export */   PlaneHelper: () => (/* binding */ PlaneHelper),
/* harmony export */   PointLight: () => (/* binding */ PointLight),
/* harmony export */   PointLightHelper: () => (/* binding */ PointLightHelper),
/* harmony export */   Points: () => (/* binding */ Points),
/* harmony export */   PointsMaterial: () => (/* binding */ PointsMaterial),
/* harmony export */   PolarGridHelper: () => (/* binding */ PolarGridHelper),
/* harmony export */   PolyhedronGeometry: () => (/* binding */ PolyhedronGeometry),
/* harmony export */   PositionalAudio: () => (/* binding */ PositionalAudio),
/* harmony export */   PropertyBinding: () => (/* binding */ PropertyBinding),
/* harmony export */   PropertyMixer: () => (/* binding */ PropertyMixer),
/* harmony export */   QuadraticBezierCurve: () => (/* binding */ QuadraticBezierCurve),
/* harmony export */   QuadraticBezierCurve3: () => (/* binding */ QuadraticBezierCurve3),
/* harmony export */   Quaternion: () => (/* binding */ Quaternion),
/* harmony export */   QuaternionKeyframeTrack: () => (/* binding */ QuaternionKeyframeTrack),
/* harmony export */   QuaternionLinearInterpolant: () => (/* binding */ QuaternionLinearInterpolant),
/* harmony export */   RED_GREEN_RGTC2_Format: () => (/* binding */ RED_GREEN_RGTC2_Format),
/* harmony export */   RED_RGTC1_Format: () => (/* binding */ RED_RGTC1_Format),
/* harmony export */   REVISION: () => (/* binding */ REVISION),
/* harmony export */   RGBADepthPacking: () => (/* binding */ RGBADepthPacking),
/* harmony export */   RGBAFormat: () => (/* binding */ RGBAFormat),
/* harmony export */   RGBAIntegerFormat: () => (/* binding */ RGBAIntegerFormat),
/* harmony export */   RGBA_ASTC_10x10_Format: () => (/* binding */ RGBA_ASTC_10x10_Format),
/* harmony export */   RGBA_ASTC_10x5_Format: () => (/* binding */ RGBA_ASTC_10x5_Format),
/* harmony export */   RGBA_ASTC_10x6_Format: () => (/* binding */ RGBA_ASTC_10x6_Format),
/* harmony export */   RGBA_ASTC_10x8_Format: () => (/* binding */ RGBA_ASTC_10x8_Format),
/* harmony export */   RGBA_ASTC_12x10_Format: () => (/* binding */ RGBA_ASTC_12x10_Format),
/* harmony export */   RGBA_ASTC_12x12_Format: () => (/* binding */ RGBA_ASTC_12x12_Format),
/* harmony export */   RGBA_ASTC_4x4_Format: () => (/* binding */ RGBA_ASTC_4x4_Format),
/* harmony export */   RGBA_ASTC_5x4_Format: () => (/* binding */ RGBA_ASTC_5x4_Format),
/* harmony export */   RGBA_ASTC_5x5_Format: () => (/* binding */ RGBA_ASTC_5x5_Format),
/* harmony export */   RGBA_ASTC_6x5_Format: () => (/* binding */ RGBA_ASTC_6x5_Format),
/* harmony export */   RGBA_ASTC_6x6_Format: () => (/* binding */ RGBA_ASTC_6x6_Format),
/* harmony export */   RGBA_ASTC_8x5_Format: () => (/* binding */ RGBA_ASTC_8x5_Format),
/* harmony export */   RGBA_ASTC_8x6_Format: () => (/* binding */ RGBA_ASTC_8x6_Format),
/* harmony export */   RGBA_ASTC_8x8_Format: () => (/* binding */ RGBA_ASTC_8x8_Format),
/* harmony export */   RGBA_BPTC_Format: () => (/* binding */ RGBA_BPTC_Format),
/* harmony export */   RGBA_ETC2_EAC_Format: () => (/* binding */ RGBA_ETC2_EAC_Format),
/* harmony export */   RGBA_PVRTC_2BPPV1_Format: () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),
/* harmony export */   RGBA_PVRTC_4BPPV1_Format: () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),
/* harmony export */   RGBA_S3TC_DXT1_Format: () => (/* binding */ RGBA_S3TC_DXT1_Format),
/* harmony export */   RGBA_S3TC_DXT3_Format: () => (/* binding */ RGBA_S3TC_DXT3_Format),
/* harmony export */   RGBA_S3TC_DXT5_Format: () => (/* binding */ RGBA_S3TC_DXT5_Format),
/* harmony export */   RGBFormat: () => (/* binding */ RGBFormat),
/* harmony export */   RGB_BPTC_SIGNED_Format: () => (/* binding */ RGB_BPTC_SIGNED_Format),
/* harmony export */   RGB_BPTC_UNSIGNED_Format: () => (/* binding */ RGB_BPTC_UNSIGNED_Format),
/* harmony export */   RGB_ETC1_Format: () => (/* binding */ RGB_ETC1_Format),
/* harmony export */   RGB_ETC2_Format: () => (/* binding */ RGB_ETC2_Format),
/* harmony export */   RGB_PVRTC_2BPPV1_Format: () => (/* binding */ RGB_PVRTC_2BPPV1_Format),
/* harmony export */   RGB_PVRTC_4BPPV1_Format: () => (/* binding */ RGB_PVRTC_4BPPV1_Format),
/* harmony export */   RGB_S3TC_DXT1_Format: () => (/* binding */ RGB_S3TC_DXT1_Format),
/* harmony export */   RGFormat: () => (/* binding */ RGFormat),
/* harmony export */   RGIntegerFormat: () => (/* binding */ RGIntegerFormat),
/* harmony export */   RawShaderMaterial: () => (/* binding */ RawShaderMaterial),
/* harmony export */   Ray: () => (/* binding */ Ray),
/* harmony export */   Raycaster: () => (/* binding */ Raycaster),
/* harmony export */   Rec709Primaries: () => (/* binding */ Rec709Primaries),
/* harmony export */   RectAreaLight: () => (/* binding */ RectAreaLight),
/* harmony export */   RedFormat: () => (/* binding */ RedFormat),
/* harmony export */   RedIntegerFormat: () => (/* binding */ RedIntegerFormat),
/* harmony export */   ReinhardToneMapping: () => (/* binding */ ReinhardToneMapping),
/* harmony export */   RenderTarget: () => (/* binding */ RenderTarget),
/* harmony export */   RepeatWrapping: () => (/* binding */ RepeatWrapping),
/* harmony export */   ReplaceStencilOp: () => (/* binding */ ReplaceStencilOp),
/* harmony export */   ReverseSubtractEquation: () => (/* binding */ ReverseSubtractEquation),
/* harmony export */   RingGeometry: () => (/* binding */ RingGeometry),
/* harmony export */   SIGNED_RED_GREEN_RGTC2_Format: () => (/* binding */ SIGNED_RED_GREEN_RGTC2_Format),
/* harmony export */   SIGNED_RED_RGTC1_Format: () => (/* binding */ SIGNED_RED_RGTC1_Format),
/* harmony export */   SRGBColorSpace: () => (/* binding */ SRGBColorSpace),
/* harmony export */   SRGBTransfer: () => (/* binding */ SRGBTransfer),
/* harmony export */   Scene: () => (/* binding */ Scene),
/* harmony export */   ShaderChunk: () => (/* binding */ ShaderChunk),
/* harmony export */   ShaderLib: () => (/* binding */ ShaderLib),
/* harmony export */   ShaderMaterial: () => (/* binding */ ShaderMaterial),
/* harmony export */   ShadowMaterial: () => (/* binding */ ShadowMaterial),
/* harmony export */   Shape: () => (/* binding */ Shape),
/* harmony export */   ShapeGeometry: () => (/* binding */ ShapeGeometry),
/* harmony export */   ShapePath: () => (/* binding */ ShapePath),
/* harmony export */   ShapeUtils: () => (/* binding */ ShapeUtils),
/* harmony export */   ShortType: () => (/* binding */ ShortType),
/* harmony export */   Skeleton: () => (/* binding */ Skeleton),
/* harmony export */   SkeletonHelper: () => (/* binding */ SkeletonHelper),
/* harmony export */   SkinnedMesh: () => (/* binding */ SkinnedMesh),
/* harmony export */   Source: () => (/* binding */ Source),
/* harmony export */   Sphere: () => (/* binding */ Sphere),
/* harmony export */   SphereGeometry: () => (/* binding */ SphereGeometry),
/* harmony export */   Spherical: () => (/* binding */ Spherical),
/* harmony export */   SphericalHarmonics3: () => (/* binding */ SphericalHarmonics3),
/* harmony export */   SplineCurve: () => (/* binding */ SplineCurve),
/* harmony export */   SpotLight: () => (/* binding */ SpotLight),
/* harmony export */   SpotLightHelper: () => (/* binding */ SpotLightHelper),
/* harmony export */   Sprite: () => (/* binding */ Sprite),
/* harmony export */   SpriteMaterial: () => (/* binding */ SpriteMaterial),
/* harmony export */   SrcAlphaFactor: () => (/* binding */ SrcAlphaFactor),
/* harmony export */   SrcAlphaSaturateFactor: () => (/* binding */ SrcAlphaSaturateFactor),
/* harmony export */   SrcColorFactor: () => (/* binding */ SrcColorFactor),
/* harmony export */   StaticCopyUsage: () => (/* binding */ StaticCopyUsage),
/* harmony export */   StaticDrawUsage: () => (/* binding */ StaticDrawUsage),
/* harmony export */   StaticReadUsage: () => (/* binding */ StaticReadUsage),
/* harmony export */   StereoCamera: () => (/* binding */ StereoCamera),
/* harmony export */   StreamCopyUsage: () => (/* binding */ StreamCopyUsage),
/* harmony export */   StreamDrawUsage: () => (/* binding */ StreamDrawUsage),
/* harmony export */   StreamReadUsage: () => (/* binding */ StreamReadUsage),
/* harmony export */   StringKeyframeTrack: () => (/* binding */ StringKeyframeTrack),
/* harmony export */   SubtractEquation: () => (/* binding */ SubtractEquation),
/* harmony export */   SubtractiveBlending: () => (/* binding */ SubtractiveBlending),
/* harmony export */   TOUCH: () => (/* binding */ TOUCH),
/* harmony export */   TangentSpaceNormalMap: () => (/* binding */ TangentSpaceNormalMap),
/* harmony export */   TetrahedronGeometry: () => (/* binding */ TetrahedronGeometry),
/* harmony export */   Texture: () => (/* binding */ Texture),
/* harmony export */   TextureLoader: () => (/* binding */ TextureLoader),
/* harmony export */   TorusGeometry: () => (/* binding */ TorusGeometry),
/* harmony export */   TorusKnotGeometry: () => (/* binding */ TorusKnotGeometry),
/* harmony export */   Triangle: () => (/* binding */ Triangle),
/* harmony export */   TriangleFanDrawMode: () => (/* binding */ TriangleFanDrawMode),
/* harmony export */   TriangleStripDrawMode: () => (/* binding */ TriangleStripDrawMode),
/* harmony export */   TrianglesDrawMode: () => (/* binding */ TrianglesDrawMode),
/* harmony export */   TubeGeometry: () => (/* binding */ TubeGeometry),
/* harmony export */   UVMapping: () => (/* binding */ UVMapping),
/* harmony export */   Uint16BufferAttribute: () => (/* binding */ Uint16BufferAttribute),
/* harmony export */   Uint32BufferAttribute: () => (/* binding */ Uint32BufferAttribute),
/* harmony export */   Uint8BufferAttribute: () => (/* binding */ Uint8BufferAttribute),
/* harmony export */   Uint8ClampedBufferAttribute: () => (/* binding */ Uint8ClampedBufferAttribute),
/* harmony export */   Uniform: () => (/* binding */ Uniform),
/* harmony export */   UniformsGroup: () => (/* binding */ UniformsGroup),
/* harmony export */   UniformsLib: () => (/* binding */ UniformsLib),
/* harmony export */   UniformsUtils: () => (/* binding */ UniformsUtils),
/* harmony export */   UnsignedByteType: () => (/* binding */ UnsignedByteType),
/* harmony export */   UnsignedInt248Type: () => (/* binding */ UnsignedInt248Type),
/* harmony export */   UnsignedInt5999Type: () => (/* binding */ UnsignedInt5999Type),
/* harmony export */   UnsignedIntType: () => (/* binding */ UnsignedIntType),
/* harmony export */   UnsignedShort4444Type: () => (/* binding */ UnsignedShort4444Type),
/* harmony export */   UnsignedShort5551Type: () => (/* binding */ UnsignedShort5551Type),
/* harmony export */   UnsignedShortType: () => (/* binding */ UnsignedShortType),
/* harmony export */   VSMShadowMap: () => (/* binding */ VSMShadowMap),
/* harmony export */   Vector2: () => (/* binding */ Vector2),
/* harmony export */   Vector3: () => (/* binding */ Vector3),
/* harmony export */   Vector4: () => (/* binding */ Vector4),
/* harmony export */   VectorKeyframeTrack: () => (/* binding */ VectorKeyframeTrack),
/* harmony export */   VideoTexture: () => (/* binding */ VideoTexture),
/* harmony export */   WebGL3DRenderTarget: () => (/* binding */ WebGL3DRenderTarget),
/* harmony export */   WebGLArrayRenderTarget: () => (/* binding */ WebGLArrayRenderTarget),
/* harmony export */   WebGLCoordinateSystem: () => (/* binding */ WebGLCoordinateSystem),
/* harmony export */   WebGLCubeRenderTarget: () => (/* binding */ WebGLCubeRenderTarget),
/* harmony export */   WebGLMultipleRenderTargets: () => (/* binding */ WebGLMultipleRenderTargets),
/* harmony export */   WebGLRenderTarget: () => (/* binding */ WebGLRenderTarget),
/* harmony export */   WebGLRenderer: () => (/* binding */ WebGLRenderer),
/* harmony export */   WebGLUtils: () => (/* binding */ WebGLUtils),
/* harmony export */   WebGPUCoordinateSystem: () => (/* binding */ WebGPUCoordinateSystem),
/* harmony export */   WireframeGeometry: () => (/* binding */ WireframeGeometry),
/* harmony export */   WrapAroundEnding: () => (/* binding */ WrapAroundEnding),
/* harmony export */   ZeroCurvatureEnding: () => (/* binding */ ZeroCurvatureEnding),
/* harmony export */   ZeroFactor: () => (/* binding */ ZeroFactor),
/* harmony export */   ZeroSlopeEnding: () => (/* binding */ ZeroSlopeEnding),
/* harmony export */   ZeroStencilOp: () => (/* binding */ ZeroStencilOp),
/* harmony export */   createCanvasElement: () => (/* binding */ createCanvasElement)
/* harmony export */ });
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '164';

const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = 'attached';
const DetachedBindMode = 'detached';

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const DisplayP3ColorSpace = 'display-p3';
const LinearDisplayP3ColorSpace = 'display-p3-linear';

const LinearTransfer = 'linear';
const SRGBTransfer = 'srgb';

const Rec709Primaries = 'rec709';
const P3Primaries = 'p3';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

const WebGLCoordinateSystem = 2000;
const WebGPUCoordinateSystem = 2001;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return value / 4294967295.0;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int32Array:

			return Math.max( value / 2147483647.0, - 1.0 );

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return Math.round( value * 4294967295.0 );

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int32Array:

			return Math.round( value * 2147483647.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

const MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize
};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	//

	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	makeTranslation( x, y ) {

		if ( x.isVector2 ) {

			this.set(

				1, 0, x.x,
				0, 1, x.y,
				0, 0, 1

			);

		} else {

			this.set(

				1, 0, x,
				0, 1, y,
				0, 0, 1

			);

		}

		return this;

	}

	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	//

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

const _cache = {};

function warnOnce( message ) {

	if ( message in _cache ) return;

	_cache[ message ] = true;

	console.warn( message );

}

/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */

const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(
	0.8224621, 0.177538, 0.0,
	0.0331941, 0.9668058, 0.0,
	0.0170827, 0.0723974, 0.9105199,
);

const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(
	1.2249401, - 0.2249404, 0.0,
	- 0.0420569, 1.0420571, 0.0,
	- 0.0196376, - 0.0786361, 1.0982735
);

/**
 * Defines supported color spaces by transfer function and primaries,
 * and provides conversions to/from the Linear-sRGB reference space.
 */
const COLOR_SPACES = {
	[ LinearSRGBColorSpace ]: {
		transfer: LinearTransfer,
		primaries: Rec709Primaries,
		toReference: ( color ) => color,
		fromReference: ( color ) => color,
	},
	[ SRGBColorSpace ]: {
		transfer: SRGBTransfer,
		primaries: Rec709Primaries,
		toReference: ( color ) => color.convertSRGBToLinear(),
		fromReference: ( color ) => color.convertLinearToSRGB(),
	},
	[ LinearDisplayP3ColorSpace ]: {
		transfer: LinearTransfer,
		primaries: P3Primaries,
		toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),
	},
	[ DisplayP3ColorSpace ]: {
		transfer: SRGBTransfer,
		primaries: P3Primaries,
		toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),
	},
};

const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );

const ColorManagement = {

	enabled: true,

	_workingColorSpace: LinearSRGBColorSpace,

	get workingColorSpace() {

		return this._workingColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {

			throw new Error( `Unsupported working color space, "${ colorSpace }".` );

		}

		this._workingColorSpace = colorSpace;

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;
		const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;

		return targetFromReference( sourceToReference( color ) );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this._workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this._workingColorSpace );

	},

	getPrimaries: function ( colorSpace ) {

		return COLOR_SPACES[ colorSpace ].primaries;

	},

	getTransfer: function ( colorSpace ) {

		if ( colorSpace === NoColorSpace ) return LinearTransfer;

		return COLOR_SPACES[ colorSpace ].transfer;

	},

};


function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement === 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

let _sourceId = 0;

class Source {

	constructor( data = null ) {

		this.isSource = true;

		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

		this.uuid = generateUUID();

		this.data = data;
		this.dataReady = true;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let _textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: _textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;
		this.channel = 0;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.colorSpace = colorSpace;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;
		this.channel = source.channel;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.6,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,
			channel: this.channel,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

	set needsPMREMUpdate( value ) {

		if ( value === true ) {

			this.pmremVersion ++;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Vector4.prototype.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );
		this.w = Math.trunc( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class RenderTarget extends EventDispatcher {

	constructor( width = 1, height = 1, options = {} ) {

		super();

		this.isRenderTarget = true;

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		options = Object.assign( {
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1
		}, options );

		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		texture.flipY = false;
		texture.generateMipmaps = options.generateMipmaps;
		texture.internalFormat = options.internalFormat;

		this.textures = [];

		const count = options.count;
		for ( let i = 0; i < count; i ++ ) {

			this.textures[ i ] = texture.clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		this.depthBuffer = options.depthBuffer;
		this.stencilBuffer = options.stencilBuffer;

		this.resolveDepthBuffer = options.resolveDepthBuffer;
		this.resolveStencilBuffer = options.resolveStencilBuffer;

		this.depthTexture = options.depthTexture;

		this.samples = options.samples;

	}

	get texture() {

		return this.textures[ 0 ];

	}

	set texture( value ) {

		this.textures[ 0 ] = value;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

				this.textures[ i ].image.width = width;
				this.textures[ i ].image.height = height;
				this.textures[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.scissor.copy( source.scissor );
		this.scissorTest = source.scissorTest;

		this.viewport.copy( source.viewport );

		this.textures.length = 0;

		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

			this.textures[ i ] = source.textures[ i ].clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		// ensure image object is not shared, see #20328

		const image = Object.assign( {}, source.texture.image );
		this.texture.source = new Source( image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class WebGLRenderTarget extends RenderTarget {

	constructor( width = 1, height = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLRenderTarget = true;

	}

}

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.isDataArrayTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGLArrayRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLArrayRenderTarget = true;

		this.depth = depth;

		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class Data3DTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.isData3DTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGL3DRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		this.isWebGL3DRenderTarget = true;

		this.depth = depth;

		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update = true ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize(); // normalize calls _onChangeCallback()

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// sets this quaternion to a uniform random unit quaternnion

		// Ken Shoemake
		// Uniform random rotations
		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();

		const x0 = Math.random();
		const r1 = Math.sqrt( 1 - x0 );
		const r2 = Math.sqrt( x0 );

		return this.set(
			r1 * Math.sin( theta1 ),
			r1 * Math.cos( theta1 ),
			r2 * Math.sin( theta2 ),
			r2 * Math.cos( theta2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		this._onChangeCallback();

		return this;

	}

	toJSON() {

		return this.toArray();

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		// quaternion q is assumed to have unit length

		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// t = 2 * cross( q.xyz, v );
		const tx = 2 * ( qy * vz - qz * vy );
		const ty = 2 * ( qz * vx - qx * vz );
		const tz = 2 * ( qx * vy - qy * vx );

		// v + q.w * t + cross( q.xyz, t );
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	setFromColor( c ) {

		this.x = c.r;
		this.y = c.g;
		this.z = c.b;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// https://mathworld.wolfram.com/SpherePointPicking.html

		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c = Math.sqrt( 1 - u * u );

		this.x = c * Math.cos( theta );
		this.y = u;
		this.z = c * Math.sin( theta );

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		this.makeEmpty();

		for ( let i = 0, il = array.length; i < il; i += 3 ) {

			this.expandByPoint( _vector$b.fromArray( array, i ) );

		}

		return this;

	}

	setFromBufferAttribute( attribute ) {

		this.makeEmpty();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

		}

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			const positionAttribute = geometry.getAttribute( 'position' );

			// precise AABB computation based on vertex data requires at least a position attribute.
			// instancing isn't supported so far and uses the normal (conservative) code path.

			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					if ( object.isMesh === true ) {

						object.getVertexPosition( i, _vector$b );

					} else {

						_vector$b.fromBufferAttribute( positionAttribute, i );

					}

					_vector$b.applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( object.boundingBox !== undefined ) {

					// object-level bounding box

					if ( object.boundingBox === null ) {

						object.computeBoundingBox();

					}

					_box$4.copy( object.boundingBox );


				} else {

					// geometry-level bounding box

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );

				}

				_box$4.applyMatrix4( object.matrixWorld );

				this.union( _box$4 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$4 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$3 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.isSphere = true;

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$3.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		if ( x.isVector3 ) {

			this.set(

				1, 0, 0, x.x,
				0, 1, 0, x.y,
				0, 0, 1, x.z,
				0, 0, 0, 1

			);

		} else {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

		}

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$4.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$4.elements[ 0 ] *= invSX;
		_m1$4.elements[ 1 ] *= invSX;
		_m1$4.elements[ 2 ] *= invSX;

		_m1$4.elements[ 4 ] *= invSY;
		_m1$4.elements[ 5 ] *= invSY;
		_m1$4.elements[ 6 ] *= invSY;

		_m1$4.elements[ 8 ] *= invSZ;
		_m1$4.elements[ 9 ] *= invSZ;
		_m1$4.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$4 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			c = - ( far + near ) / ( far - near );
			d = ( - 2 * far * near ) / ( far - near );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			c = - far / ( far - near );
			d = ( - far * near ) / ( far - near );

		} else {

			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;

		let z, zInv;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			z = ( far + near ) * p;
			zInv = - 2 * p;

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			z = near * p;
			zInv = - 1 * p;

		} else {

			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$4 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$2 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$2.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$2, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

Euler.DEFAULT_ORDER = 'XYZ';

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$3 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

const _childaddedEvent = { type: 'childadded', child: null };
const _childremovedEvent = { type: 'childremoved', child: null };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$3.lookAt( _position$3, _target, this.up );

		} else {

			_m1$3.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$3 );

		if ( parent ) {

			_m1$3.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$3 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

			_childremovedEvent.child = object;
			this.dispatchEvent( _childremovedEvent );
			_childremovedEvent.child = null;

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		return this.remove( ... this.children );

	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$3.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$3.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$3 );

		object.removeFromParent();
		object.parent = this;
		this.children.push( object );

		object.updateWorldMatrix( false, true );

		object.dispatchEvent( _addedEvent );

		_childaddedEvent.child = object;
		this.dispatchEvent( _childaddedEvent );
		_childaddedEvent.child = null;

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getObjectsByProperty( name, value, result = [] ) {

		if ( this[ name ] === value ) result.push( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].getObjectsByProperty( name, value, result );

		}

		return result;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			if ( child.matrixWorldAutoUpdate === true || force === true ) {

				child.updateMatrixWorld( force );

			}

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true ) {

					child.updateWorldMatrix( false, true );

				}

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.6,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		if ( this.isBatchedMesh ) {

			object.type = 'BatchedMesh';
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;

			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;

			object.visibility = this._visibility;
			object.active = this._active;
			object.bounds = this._bounds.map( bound => ( {
				boxInitialized: bound.boxInitialized,
				boxMin: bound.box.min.toArray(),
				boxMax: bound.box.max.toArray(),

				sphereInitialized: bound.sphereInitialized,
				sphereRadius: bound.sphere.radius,
				sphereCenter: bound.sphere.center.toArray()
			} ) );

			object.maxGeometryCount = this._maxGeometryCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;

			object.geometryInitialized = this._geometryInitialized;
			object.geometryCount = this._geometryCount;

			object.matricesTexture = this._matricesTexture.toJSON( meta );

			if ( this.boundingSphere !== null ) {

				object.boundingSphere = {
					center: object.boundingSphere.center.toArray(),
					radius: object.boundingSphere.radius
				};

			}

			if ( this.boundingBox !== null ) {

				object.boundingBox = {
					min: object.boundingBox.min.toArray(),
					max: object.boundingBox.max.toArray()
				};

			}

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.animations = source.animations.slice();

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$2 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			target.set( 0, 0, 0 );
			return null;

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		// if the triangle is degenerate then we can't contain a point
		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

			return false;

		}

		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

	}

	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

			target.x = 0;
			target.y = 0;
			if ( 'z' in target ) target.z = 0;
			if ( 'w' in target ) target.w = 0;
			return null;

		}

		target.setScalar( 0 );
		target.addScaledVector( v1, _v3$2.x );
		target.addScaledVector( v2, _v3$2.y );
		target.addScaledVector( v3, _v3$2.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getInterpolation( point, v1, v2, v3, target ) {

		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		return this.set( r, g, b );

	}

	set( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string

			const value = r;

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

		} else {

			this.setRGB( r, g, b );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
							colorSpace
						);

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
							colorSpace
						);

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setHSL(
							parseFloat( color[ 1 ] ) / 360,
							parseFloat( color[ 2 ] ) / 100,
							parseFloat( color[ 3 ] ) / 100,
							colorSpace
						);

					}

					break;

				default:

					console.warn( 'THREE.Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				return this.setRGB(
					parseInt( hex.charAt( 0 ), 16 ) / 15,
					parseInt( hex.charAt( 1 ), 16 ) / 15,
					parseInt( hex.charAt( 2 ), 16 ) / 15,
					colorSpace
				);

			} else if ( size === 6 ) {

				// #ff0000
				return this.setHex( parseInt( hex, 16 ), colorSpace );

			} else {

				console.warn( 'THREE.Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	setFromVector3( v ) {

		this.r = v.x;
		this.g = v.y;
		this.b = v.z;

		return this;

	}

	applyMatrix3( m ) {

		const r = this.r, g = this.g, b = this.b;
		const e = m.elements;

		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color = /*@__PURE__*/ new Color();

Color.NAMES = _colorKeywords;

let _materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: _materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;
		this.alphaHash = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.blendColor = new Color( 0, 0, 0 );
		this.blendAlpha = 0;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.forceSinglePass = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.6,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors === true ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = true;

		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
		if ( this.depthTest === false ) data.depthTest = this.depthTest;
		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaHash === true ) data.alphaHash = true;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

		if ( this.wireframe === true ) data.wireframe = true;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy( source.blendColor );
		this.blendAlpha = source.blendAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < - 27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < - 14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= ~ 0x00800000; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

// float32 to float16

function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp( val, - 65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

// float16 to float32

function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

const DataUtils = {
	toHalfFloat: toHalfFloat,
	fromHalfFloat: fromHalfFloat,
};

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized;

		this.usage = StaticDrawUsage;
		this._updateRange = { offset: 0, count: - 1 };
		this.updateRanges = [];
		this.gpuType = FloatType;

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	get updateRange() {

		warnOnce( 'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
		return this._updateRange;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;
		this.gpuType = source.gpuType;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.itemSize + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.array[ index * this.itemSize + component ] = value;

		return this;

	}

	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

		return data;

	}

}

//

class Int8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

class Uint8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

class Uint8ClampedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

class Int16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Int32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

		this.isFloat16BufferAttribute = true;

	}

	getX( index ) {

		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = toHalfFloat( x );

		return this;

	}

	getY( index ) {

		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

		return this;

	}

	getZ( index ) {

		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

		return this;

	}

	getW( index ) {

		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );
		this.array[ index + 3 ] = toHalfFloat( w );

		return this;

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$2 = 0;

const _m1$2 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$2 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1$2.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$8 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

		}

		const tangentAttribute = this.getAttribute( 'tangent' );

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			uvA.fromBufferAttribute( uvAttribute, a );
			uvB.fromBufferAttribute( uvAttribute, b );
			uvC.fromBufferAttribute( uvAttribute, c );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: index.count
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					index.getX( j + 0 ),
					index.getX( j + 1 ),
					index.getX( j + 2 )
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromBufferAttribute( normalAttribute, v );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( index.getX( j + 0 ) );
				handleVertex( index.getX( j + 1 ) );
				handleVertex( index.getX( j + 2 ) );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$6 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _normalA = /*@__PURE__*/ new Vector3();
const _normalB = /*@__PURE__*/ new Vector3();
const _normalC = /*@__PURE__*/ new Vector3();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		return target;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$6.copy( geometry.boundingSphere );
		_sphere$6.applyMatrix4( matrixWorld );

		// check distance from ray origin to bounding sphere

		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		// convert ray to local space of mesh

		_inverseMatrix$3.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		// test with bounding box in local space

		if ( geometry.boundingBox !== null ) {

			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$3 );

	}

	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

		let intersection;

		const geometry = this.geometry;
		const material = this.material;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv1 ) {

			_uvA$1.fromBufferAttribute( uv1, a );
			_uvB$1.fromBufferAttribute( uv1, b );
			_uvC$1.fromBufferAttribute( uv1, c );

			intersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( normal ) {

			_normalA.fromBufferAttribute( normal, a );
			_normalB.fromBufferAttribute( normal, b );
			_normalC.fromBufferAttribute( normal, c );

			intersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );

			if ( intersection.normal.dot( ray.direction ) > 0 ) {

				intersection.normal.multiplyScalar( - 1 );

			}

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				if ( property.isRenderTargetTexture ) {

					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
					dst[ u ][ p ] = null;

				} else {

					dst[ u ][ p ] = property.clone();

				}

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

function getUnlitUniformColorSpace( renderer ) {

	const currentRenderTarget = renderer.getRenderTarget();

	if ( currentRenderTarget === null ) {

		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
		return renderer.outputColorSpace;

	}

	// https://github.com/mrdoob/three.js/issues/27868
	if ( currentRenderTarget.isXRRenderTarget === true ) {

		return currentRenderTarget.texture.colorSpace;

	}

	return ColorManagement.workingColorSpace;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.forceSinglePass = true;

		this.extensions = {
			clipCullDistance: false, // set to use vertex shader clipping
			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv1': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		data.lights = this.lights;
		data.clipping = this.clipping;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

		this.coordinateSystem = WebGLCoordinateSystem;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		this.coordinateSystem = source.coordinateSystem;

		return this;

	}

	getWorldDirection( target ) {

		return super.getWorldDirection( target ).negate();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _v3$1 = /*@__PURE__*/ new Vector3();
const _minTarget = /*@__PURE__*/ new Vector2();
const _maxTarget = /*@__PURE__*/ new Vector2();


class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 */
	getViewBounds( distance, minTarget, maxTarget ) {

		_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

	}

	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Copies the result into the target Vector2, where x is width and y is height.
	 */
	getViewSize( distance, target ) {

		this.getViewBounds( distance, _minTarget, _maxTarget );

		return target.subVectors( _maxTarget, _minTarget );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = - 90; // negative fov is not an error
const aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		this.renderTarget = renderTarget;
		this.coordinateSystem = null;
		this.activeMipmapLevel = 0;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		this.add( cameraNZ );

	}

	updateCoordinateSystem() {

		const coordinateSystem = this.coordinateSystem;

		const cameras = this.children.concat();

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

		for ( const camera of cameras ) this.remove( camera );

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			cameraPX.up.set( 0, 1, 0 );
			cameraPX.lookAt( 1, 0, 0 );

			cameraNX.up.set( 0, 1, 0 );
			cameraNX.lookAt( - 1, 0, 0 );

			cameraPY.up.set( 0, 0, - 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, 1 );
			cameraNY.lookAt( 0, - 1, 0 );

			cameraPZ.up.set( 0, 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, 1, 0 );
			cameraNZ.lookAt( 0, 0, - 1 );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( - 1, 0, 0 );

			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( 1, 0, 0 );

			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( 0, - 1, 0 );

			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( 0, 0, - 1 );

		} else {

			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

		}

		for ( const camera of cameras ) {

			this.add( camera );

			camera.updateMatrixWorld();

		}

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const { renderTarget, activeMipmapLevel } = this;

		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

			this.coordinateSystem = renderer.coordinateSystem;

			this.updateCoordinateSystem();

		}

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

		const currentXrEnabled = renderer.xr.enabled;

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
		renderer.render( scene, cameraPZ );

		// mipmaps are generated during the last call of render()
		// at this point, all sides of the cube render target are defined

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isCubeTexture = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, size, options );

		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.colorSpace = texture.colorSpace;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$5 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

		} else {

			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

		}

		return this;

	}

	intersectsObject( object ) {

		if ( object.boundingSphere !== undefined ) {

			if ( object.boundingSphere === null ) object.computeBoundingSphere();

			_sphere$5.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

		} else {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$5.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		}

		return this.intersectsSphere( _sphere$5 );

	}

	intersectsSprite( sprite ) {

		_sphere$5.center.set( 0, 0, 0 );
		_sphere$5.radius = 0.7071067811865476;
		_sphere$5.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$5 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl ) {

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;
		const size = array.byteLength;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			size: size
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute._updateRange; // @deprecated, r159
		const updateRanges = attribute.updateRanges;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 && updateRanges.length === 0 ) {

			// Not using update ranges
			gl.bufferSubData( bufferType, 0, array );

		}

		if ( updateRanges.length !== 0 ) {

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			attribute.clearUpdateRanges();

		}

		// @deprecated, r159
		if ( updateRange.count !== - 1 ) {

			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
				array, updateRange.offset, updateRange.count );

			updateRange.count = - 1; // reset range

		}

		attribute.onUploadCallback();

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			if ( data.size !== attribute.array.byteLength ) {

				throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

			}

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var batching_pars_vertex = "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";

var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphahash_fragment: alphahash_fragment,
	alphahash_pars_fragment: alphahash_pars_fragment,
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	batching_pars_vertex: batching_pars_vertex,
	batching_vertex: batching_vertex,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	colorspace_fragment: colorspace_fragment,
	colorspace_pars_fragment: colorspace_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphinstance_vertex: morphinstance_vertex,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	opaque_fragment: opaque_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },
		specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	envmap: {

		envMap: { value: null },
		envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 }, // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 },
		aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 },
		lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	emissivemap: {

		emissiveMap: { value: null },
		emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	metalnessmap: {

		metalnessMap: { value: null },
		metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	roughnessmap: {

		roughnessMap: { value: null },
		roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotLightMap: { value: [] },
		spotShadowMap: { value: [] },
		spotLightMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	sprite: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 }

	}

};

const ShaderLib = {

	basic: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			t2D: { value: null },
			backgroundIntensity: { value: 1 }
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},

	backgroundCube: {

		uniforms: {
			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			backgroundBlurriness: { value: 0 },
			backgroundIntensity: { value: 1 },
			backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
		},

		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag

	},

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /*@__PURE__*/ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: /*@__PURE__*/ mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalMap: { value: null },
			clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			dispersion: { value: 0 },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheen: { value: 0 },
			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
			specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
			anisotropyMap: { value: null },
			anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /*@__PURE__*/ new Euler();
const _m1$1 = /*@__PURE__*/ new Matrix4();

function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function getBackground( scene ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

		}

		return background;

	}

	function render( scene ) {

		let forceClear = false;
		const background = getBackground( scene );

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

		if ( environmentBlendMode === 'additive' ) {

			state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

		} else if ( environmentBlendMode === 'alpha-blend' ) {

			state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

	}

	function addToRenderList( renderList, scene ) {

		const background = getBackground( scene );

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
						vertexShader: ShaderLib.backgroundCube.vertexShader,
						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			_e1$1.copy( scene.backgroundRotation );

			// accommodate left-handed frame
			_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;

			if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1$1.y *= - 1;
				_e1$1.z *= - 1;

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
			boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;
			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render,
		addToRenderList: addToRenderList

	};

}

function WebGLBindingStates( gl, attributes ) {

	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		const state = getBindingState( geometry, program, material );

		if ( currentState !== state ) {

			currentState = state;
			bindVertexArrayObject( currentState.object );

		}

		updateBuffers = needsUpdate( object, geometry, program, index );

		if ( updateBuffers ) saveCache( object, geometry, program, index );

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		return gl.createVertexArray();

	}

	function bindVertexArrayObject( vao ) {

		return gl.bindVertexArray( vao );

	}

	function deleteVertexArrayObject( vao ) {

		return gl.deleteVertexArray( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( object, geometry, program, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				const cachedAttribute = cachedAttributes[ name ];
				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( object, geometry, program, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let attribute = attributes[ name ];

				if ( attribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

				}

				const data = {};
				data.attribute = attribute;

				if ( attribute && attribute.data ) {

					data.data = attribute.data;

				}

				cache[ name ] = data;

				attributesNum ++;

			}

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			gl.vertexAttribDivisor( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

		if ( integer === true ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					// check for integer attributes

					const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
								integer
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement,
								integer
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawArraysInstanced( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ], counts[ i ] );

			}

		} else {

			extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			for ( let i = 0; i < primcount.length; i ++ ) {

				info.update( elementCount, mode, primcount[ i ] );

			}

		}

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLCapabilities( gl, extensions, parameters, utils ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function textureFormatReadable( textureFormat ) {

		if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

			return false;

		}

		return true;

	}

	function textureTypeReadable( textureType ) {

		const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

		if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
			textureType !== FloatType && ! halfFloatSupportedByExt ) {

			return false;

		}

		return true;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	const vertexTextures = maxVertexTextures > 0;

	const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

	return {

		isWebGL2: true, // keeping this for backwards compatibility

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		textureFormatReadable: textureFormatReadable,
		textureTypeReadable: textureTypeReadable,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;

	};

	this.setGlobalState = function ( planes, camera ) {

		globalState = projectPlanes( planes, camera, 0 );

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		this._setSize( 256 );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 * The smallest supported equirectangular image size is 64 x 32.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 * The smallest supported cube size is 16 x 16.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		this._renderer.xr.enabled = _oldXrEnabled;

		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n = this._lodPlanes.length;

		for ( let i = 1; i < n; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: - 1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				let renderTarget = cubeUVmaps.get( texture );

				const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

				if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					renderTarget.texture.pmremVersion = texture.pmremVersion;

					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( renderTarget !== undefined ) {

						return renderTarget.texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							renderTarget.texture.pmremVersion = texture.pmremVersion;

							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function () {

			getExtension( 'EXT_color_buffer_float' );
			getExtension( 'WEBGL_clip_cull_distance' );
			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );
			getExtension( 'WEBGL_render_shared_exponent' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		for ( const name in geometry.morphAttributes ) {

			const array = geometry.morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.remove( array[ i ] );

			}

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], gl.ARRAY_BUFFER );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else if ( geometryPosition !== undefined ) {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		} else {

			return;

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ] / bytesPerElement, counts[ i ] );

			}

		} else {

			extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			for ( let i = 0; i < primcount.length; i ++ ) {

				info.update( elementCount, mode, primcount[ i ] );

			}

		}

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const morphTextures = new WeakMap();
	const morph = new Vector4();

	function update( object, geometry, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// instead of using attributes, the WebGL 2 code path encodes morph targets
		// into an array of data textures. Each layer represents a single morph target.

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let entry = morphTextures.get( geometry );

		if ( entry === undefined || entry.count !== morphTargetsCount ) {

			if ( entry !== undefined ) entry.texture.dispose();

			const hasMorphPosition = geometry.morphAttributes.position !== undefined;
			const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
			const hasMorphColors = geometry.morphAttributes.color !== undefined;

			const morphTargets = geometry.morphAttributes.position || [];
			const morphNormals = geometry.morphAttributes.normal || [];
			const morphColors = geometry.morphAttributes.color || [];

			let vertexDataCount = 0;

			if ( hasMorphPosition === true ) vertexDataCount = 1;
			if ( hasMorphNormals === true ) vertexDataCount = 2;
			if ( hasMorphColors === true ) vertexDataCount = 3;

			let width = geometry.attributes.position.count * vertexDataCount;
			let height = 1;

			if ( width > capabilities.maxTextureSize ) {

				height = Math.ceil( width / capabilities.maxTextureSize );
				width = capabilities.maxTextureSize;

			}

			const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

			const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
			texture.type = FloatType;
			texture.needsUpdate = true;

			// fill buffer

			const vertexDataStride = vertexDataCount * 4;

			for ( let i = 0; i < morphTargetsCount; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const morphNormal = morphNormals[ i ];
				const morphColor = morphColors[ i ];

				const offset = width * height * 4 * i;

				for ( let j = 0; j < morphTarget.count; j ++ ) {

					const stride = j * vertexDataStride;

					if ( hasMorphPosition === true ) {

						morph.fromBufferAttribute( morphTarget, j );

						buffer[ offset + stride + 0 ] = morph.x;
						buffer[ offset + stride + 1 ] = morph.y;
						buffer[ offset + stride + 2 ] = morph.z;
						buffer[ offset + stride + 3 ] = 0;

					}

					if ( hasMorphNormals === true ) {

						morph.fromBufferAttribute( morphNormal, j );

						buffer[ offset + stride + 4 ] = morph.x;
						buffer[ offset + stride + 5 ] = morph.y;
						buffer[ offset + stride + 6 ] = morph.z;
						buffer[ offset + stride + 7 ] = 0;

					}

					if ( hasMorphColors === true ) {

						morph.fromBufferAttribute( morphColor, j );

						buffer[ offset + stride + 8 ] = morph.x;
						buffer[ offset + stride + 9 ] = morph.y;
						buffer[ offset + stride + 10 ] = morph.z;
						buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

					}

				}

			}

			entry = {
				count: morphTargetsCount,
				texture: texture,
				size: new Vector2( width, height )
			};

			morphTextures.set( geometry, entry );

			function disposeTexture() {

				texture.dispose();

				morphTextures.delete( geometry );

				geometry.removeEventListener( 'dispose', disposeTexture );

			}

			geometry.addEventListener( 'dispose', disposeTexture );

		}

		//
		if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

			program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

		} else {

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

		}

		program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
		program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			if ( updateMap.get( object ) !== frame ) {

				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

				}

				updateMap.set( object, frame );

			}

		}

		if ( object.isSkinnedMesh ) {

			const skeleton = object.skeleton;

			if ( updateMap.get( skeleton ) !== frame ) {

				skeleton.update();

				updateMap.set( skeleton, frame );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isDepthTexture = true;

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

		this.compareFunction = null;

	}


	copy( source ) {

		super.copy( source );

		this.compareFunction = source.compareFunction;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

		return data;

	}

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */


const emptyTexture = /*@__PURE__*/ new Texture();

const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );
emptyShadowTexture.compareFunction = LessEqualCompare;

const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2i( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3i( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2ui( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3ui( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	const emptyTexture2D = ( this.type === gl.SAMPLER_2D_SHADOW ) ? emptyShadowTexture : emptyTexture;

	textures.setTexture2D( v || emptyTexture2D, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

class SingleUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class PureArrayUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class StructuredUniform {

	constructor( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	setValue( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	}

}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

class WebGLUniforms {

	constructor( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	setValue( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	}

	setOptional( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	}

	static upload( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	}

	static seqWithValue( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	}

}

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
const COMPLETION_STATUS_KHR = 0x91B1;

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		const line = i + 1;
		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

	}

	return lines2.join( '\n' );

}

function getEncodingComponents( colorSpace ) {

	const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
	const encodingPrimaries = ColorManagement.getPrimaries( colorSpace );

	let gamutMapping;

	if ( workingPrimaries === encodingPrimaries ) {

		gamutMapping = '';

	} else if ( workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ) {

		gamutMapping = 'LinearDisplayP3ToLinearSRGB';

	} else if ( workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries ) {

		gamutMapping = 'LinearSRGBToLinearDisplayP3';

	}

	switch ( colorSpace ) {

		case LinearSRGBColorSpace:
		case LinearDisplayP3ColorSpace:
			return [ gamutMapping, 'LinearTransferOETF' ];

		case SRGBColorSpace:
		case DisplayP3ColorSpace:
			return [ gamutMapping, 'sRGBTransferOETF' ];

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );
			return [ gamutMapping, 'LinearTransferOETF' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
	if ( errorMatches ) {

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt( errorMatches[ 1 ] );
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	} else {

		return errors;

	}

}

function getTexelEncodingFunction( functionName, colorSpace ) {

	const components = getEncodingComponents( colorSpace );
	return `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`;

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case AgXToneMapping:
			toneMappingName = 'AgX';
			break;

		case NeutralToneMapping:
			toneMappingName = 'Neutral';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateVertexExtensions( parameters ) {

	const chunks = [
		parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
		parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
		if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
		if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

const shaderChunkMap = new Map();

function includeReplacer( match, include ) {

	let string = ShaderChunk[ include ];

	if ( string === undefined ) {

		const newInclude = shaderChunkMap.get( include );

		if ( newInclude !== undefined ) {

			string = ShaderChunk[ newInclude ];
			console.warn( 'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

		} else {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

	}

	return resolveIncludes( string );

}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string.replace( unrollLoopPattern, loopReplacer );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customVertexExtensions = generateVertexExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
			parameters.batching ? '#define USE_BATCHING' : '',
			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
			parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			//

			parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
			parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
			parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
			parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
			parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
			parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
			parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
			parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

			parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
			parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

			parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

			parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
			parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
			parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

			parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
			parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

			parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
			parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

			parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
			parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
			parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

			parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
			parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

			//

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'#ifdef USE_INSTANCING_MORPH',

			'	uniform sampler2D morphTexture;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_UV1',

			'	attribute vec2 uv1;',

			'#endif',

			'#ifdef USE_UV2',

			'	attribute vec2 uv2;',

			'#endif',

			'#ifdef USE_UV3',

			'	attribute vec2 uv3;',

			'#endif',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.dispersion ? '#define USE_DISPERSION' : '',

			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),

			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			customVertexExtensions,
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	function onFirstUse( self ) {

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				if ( typeof renderer.debug.onShaderError === 'function' ) {

					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
						'Material Name: ' + self.name + '\n' +
						'Material Type: ' + self.type + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				self.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		cachedUniforms = new WebGLUniforms( gl, program );
		cachedAttributes = fetchAttributeLocations( gl, program );

	}

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			// Populates cachedUniforms and cachedAttributes
			onFirstUse( this );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			// Populates cachedAttributes and cachedUniforms
			onFirstUse( this );

		}

		return cachedAttributes;

	};

	// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
	// flag the program as ready immediately. It may cause a stall when it's first used.

	let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

	this.isReady = function () {

		if ( programReady === false ) {

			programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

		}

		return programReady;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.type = parameters.shaderType;
	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id$1 = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;
		let set = cache.get( material );

		if ( set === undefined ) {

			set = new Set();
			cache.set( material, set );

		}

		return set;

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;
		let stage = cache.get( code );

		if ( stage === undefined ) {

			stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return stage;

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id$1 ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const _activeChannels = new Set();
	const programs = [];

	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getChannel( value ) {

		_activeChannels.add( value );

		if ( value === 0 ) return 'uv';

		return `uv${ value }`;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
		const IS_BATCHEDMESH = object.isBatchedMesh === true;

		const HAS_MAP = !! material.map;
		const HAS_MATCAP = !! material.matcap;
		const HAS_ENVMAP = !! envMap;
		const HAS_AOMAP = !! material.aoMap;
		const HAS_LIGHTMAP = !! material.lightMap;
		const HAS_BUMPMAP = !! material.bumpMap;
		const HAS_NORMALMAP = !! material.normalMap;
		const HAS_DISPLACEMENTMAP = !! material.displacementMap;
		const HAS_EMISSIVEMAP = !! material.emissiveMap;

		const HAS_METALNESSMAP = !! material.metalnessMap;
		const HAS_ROUGHNESSMAP = !! material.roughnessMap;

		const HAS_ANISOTROPY = material.anisotropy > 0;
		const HAS_CLEARCOAT = material.clearcoat > 0;
		const HAS_DISPERSION = material.dispersion > 0;
		const HAS_IRIDESCENCE = material.iridescence > 0;
		const HAS_SHEEN = material.sheen > 0;
		const HAS_TRANSMISSION = material.transmission > 0;

		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

		const HAS_SPECULARMAP = !! material.specularMap;
		const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
		const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

		const HAS_GRADIENTMAP = !! material.gradientMap;

		const HAS_ALPHAMAP = !! material.alphaMap;

		const HAS_ALPHATEST = material.alphaTest > 0;

		const HAS_ALPHAHASH = !! material.alphaHash;

		const HAS_EXTENSIONS = !! material.extensions;

		let toneMapping = NoToneMapping;

		if ( material.toneMapped ) {

			if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

				toneMapping = renderer.toneMapping;

			}

		}

		const parameters = {

			shaderID: shaderID,
			shaderType: material.type,
			shaderName: material.name,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			batching: IS_BATCHEDMESH,
			instancing: IS_INSTANCEDMESH,
			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
			outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
			alphaToCoverage: !! material.alphaToCoverage,

			map: HAS_MAP,
			matcap: HAS_MATCAP,
			envMap: HAS_ENVMAP,
			envMapMode: HAS_ENVMAP && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			aoMap: HAS_AOMAP,
			lightMap: HAS_LIGHTMAP,
			bumpMap: HAS_BUMPMAP,
			normalMap: HAS_NORMALMAP,
			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
			emissiveMap: HAS_EMISSIVEMAP,

			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

			metalnessMap: HAS_METALNESSMAP,
			roughnessMap: HAS_ROUGHNESSMAP,

			anisotropy: HAS_ANISOTROPY,
			anisotropyMap: HAS_ANISOTROPYMAP,

			clearcoat: HAS_CLEARCOAT,
			clearcoatMap: HAS_CLEARCOATMAP,
			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

			dispersion: HAS_DISPERSION,

			iridescence: HAS_IRIDESCENCE,
			iridescenceMap: HAS_IRIDESCENCEMAP,
			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

			sheen: HAS_SHEEN,
			sheenColorMap: HAS_SHEEN_COLORMAP,
			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

			specularMap: HAS_SPECULARMAP,
			specularColorMap: HAS_SPECULAR_COLORMAP,
			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

			transmission: HAS_TRANSMISSION,
			transmissionMap: HAS_TRANSMISSIONMAP,
			thicknessMap: HAS_THICKNESSMAP,

			gradientMap: HAS_GRADIENTMAP,

			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

			alphaMap: HAS_ALPHAMAP,
			alphaTest: HAS_ALPHATEST,
			alphaHash: HAS_ALPHAHASH,

			combine: material.combine,

			//

			mapUv: HAS_MAP && getChannel( material.map.channel ),
			aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
			lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
			bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
			normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
			emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

			metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

			specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
			thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

			alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

			//

			vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

			pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

			fog: !! fog,
			useFog: material.fog === true,
			fogExp2: ( !! fog && fog.isFogExp2 ),

			flatShading: material.flatShading === true,

			sizeAttenuation: material.sizeAttenuation === true,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

			numLightProbes: lights.numLightProbes,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: toneMapping,
			useLegacyLights: renderer._useLegacyLights,

			decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			useDepthPacking: material.depthPacking >= 0,
			depthPacking: material.depthPacking || 0,

			index0AttributeName: material.index0AttributeName,

			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
			extensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === true && extensions.has( 'WEBGL_multi_draw' ),

			rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		// the usage of getChannel() determines the active texture channels for this shader

		parameters.vertexUv1s = _activeChannels.has( 1 );
		parameters.vertexUv2s = _activeChannels.has( 2 );
		parameters.vertexUv3s = _activeChannels.has( 3 );

		_activeChannels.clear();

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputColorSpace );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputColorSpace );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.mapUv );
		array.push( parameters.alphaMapUv );
		array.push( parameters.lightMapUv );
		array.push( parameters.aoMapUv );
		array.push( parameters.bumpMapUv );
		array.push( parameters.normalMapUv );
		array.push( parameters.displacementMapUv );
		array.push( parameters.emissiveMapUv );
		array.push( parameters.metalnessMapUv );
		array.push( parameters.roughnessMapUv );
		array.push( parameters.anisotropyMapUv );
		array.push( parameters.clearcoatMapUv );
		array.push( parameters.clearcoatNormalMapUv );
		array.push( parameters.clearcoatRoughnessMapUv );
		array.push( parameters.iridescenceMapUv );
		array.push( parameters.iridescenceThicknessMapUv );
		array.push( parameters.sheenColorMapUv );
		array.push( parameters.sheenRoughnessMapUv );
		array.push( parameters.specularMapUv );
		array.push( parameters.specularColorMapUv );
		array.push( parameters.specularIntensityMapUv );
		array.push( parameters.transmissionMapUv );
		array.push( parameters.thicknessMapUv );
		array.push( parameters.combine );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numSpotLightMaps );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.numSpotLightShadowsWithMaps );
		array.push( parameters.numLightProbes );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );
		array.push( parameters.depthPacking );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 0 );
		if ( parameters.instancing )
			_programLayers.enable( 1 );
		if ( parameters.instancingColor )
			_programLayers.enable( 2 );
		if ( parameters.instancingMorph )
			_programLayers.enable( 3 );
		if ( parameters.matcap )
			_programLayers.enable( 4 );
		if ( parameters.envMap )
			_programLayers.enable( 5 );
		if ( parameters.normalMapObjectSpace )
			_programLayers.enable( 6 );
		if ( parameters.normalMapTangentSpace )
			_programLayers.enable( 7 );
		if ( parameters.clearcoat )
			_programLayers.enable( 8 );
		if ( parameters.iridescence )
			_programLayers.enable( 9 );
		if ( parameters.alphaTest )
			_programLayers.enable( 10 );
		if ( parameters.vertexColors )
			_programLayers.enable( 11 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 12 );
		if ( parameters.vertexUv1s )
			_programLayers.enable( 13 );
		if ( parameters.vertexUv2s )
			_programLayers.enable( 14 );
		if ( parameters.vertexUv3s )
			_programLayers.enable( 15 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 16 );
		if ( parameters.anisotropy )
			_programLayers.enable( 17 );
		if ( parameters.alphaHash )
			_programLayers.enable( 18 );
		if ( parameters.batching )
			_programLayers.enable( 19 );
		if ( parameters.dispersion )
			_programLayers.enable( 20 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.fog )
			_programLayers.enable( 0 );
		if ( parameters.useFog )
			_programLayers.enable( 1 );
		if ( parameters.flatShading )
			_programLayers.enable( 2 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 3 );
		if ( parameters.skinning )
			_programLayers.enable( 4 );
		if ( parameters.morphTargets )
			_programLayers.enable( 5 );
		if ( parameters.morphNormals )
			_programLayers.enable( 6 );
		if ( parameters.morphColors )
			_programLayers.enable( 7 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 8 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 9 );
		if ( parameters.useLegacyLights )
			_programLayers.enable( 10 );
		if ( parameters.doubleSided )
			_programLayers.enable( 11 );
		if ( parameters.flipSided )
			_programLayers.enable( 12 );
		if ( parameters.useDepthPacking )
			_programLayers.enable( 13 );
		if ( parameters.dithering )
			_programLayers.enable( 14 );
		if ( parameters.transmission )
			_programLayers.enable( 15 );
		if ( parameters.sheen )
			_programLayers.enable( 16 );
		if ( parameters.opaque )
			_programLayers.enable( 17 );
		if ( parameters.pointsUvs )
			_programLayers.enable( 18 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 19 );
		if ( parameters.alphaToCoverage )
			_programLayers.enable( 20 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		const listArray = lists.get( scene );
		let list;

		if ( listArray === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= listArray.length ) {

				list = new WebGLRenderList();
				listArray.push( list );

			} else {

				list = listArray[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

}

function WebGLLights( extensions ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1,
			numSpotMaps: - 1,

			numLightProbes: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0,
		numLightProbes: 0

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, useLegacyLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		let numLightProbes = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort( shadowCastingAndTexturingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

				numLightProbes ++;

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				state.spot[ spotLength ] = uniforms;

				const shadow = light.shadow;

				if ( light.map ) {

					state.spotLightMap[ numSpotMaps ] = light.map;
					numSpotMaps ++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices( light );

					if ( light.castShadow ) numSpotShadowsWithMaps ++;

				}

				state.spotLightMatrix[ spotLength ] = shadow.matrix;

				if ( light.castShadow ) {

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;

					numSpotShadows ++;

				}

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
				state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ||
			hash.numSpotMaps !== numSpotMaps ||
			hash.numLightProbes !== numLightProbes ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			state.numLightProbes = numLightProbes;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;

			hash.numLightProbes = numLightProbes;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions ) {

	const lights = new WebGLLights( extensions );

	const lightsArray = [];
	const shadowsArray = [];

	function init( camera ) {

		state.camera = camera;

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( useLegacyLights ) {

		lights.setup( lightsArray, useLegacyLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		camera: null,

		lights: lights,

		transmissionRenderTarget: {}
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		const renderStateArray = renderStates.get( scene );
		let renderState;

		if ( renderStateArray === undefined ) {

			renderState = new WebGLRenderState( extensions );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStateArray.length ) {

				renderState = new WebGLRenderState( extensions );
				renderStateArray.push( renderState );

			} else {

				renderState = renderStateArray[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( renderer, objects, capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = capabilities.maxTextureSize;

	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;
	let _previousType = this.type;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = renderer.getRenderTarget();
		const activeCubeFace = renderer.getActiveCubeFace();
		const activeMipmapLevel = renderer.getActiveMipmapLevel();

		const _state = renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// check for shadow map type changes

		const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
		const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null || toVSM === true || fromVSM === true ) {

				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

				if ( shadow.map !== null ) {

					shadow.map.dispose();

				}

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			renderer.setRenderTarget( shadow.map );
			renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		_previousType = this.type;

		scope.needsUpdate = false;

		renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		if ( shadow.mapPass === null ) {

			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.mapPass );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.map );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ||
				( material.map && material.alphaTest > 0 ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
					material.addEventListener( 'dispose', onMaterialDispose );

				}

				result = cachedMaterial;

			}

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;
		result.map = material.map;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			const materialProperties = renderer.properties.get( result );
			materialProperties.light = light;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

							object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

							renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, type );

					object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

					renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		// make sure to remove the unique distance/depth materials used for shadow map rendering

		for ( const id in _materialCache ) {

			const cache = _materialCache[ id ];

			const uuid = event.target.uuid;

			if ( uuid in cache ) {

				const shadowMaterial = cache[ uuid ];
				shadowMaterial.dispose();
				delete cache[ uuid ];

			}

		}

	}

}

function WebGLState( gl ) {

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					switch ( depthFunc ) {

						case NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	const uboBindings = new WeakMap();
	const uboProgramMap = new WeakMap();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentBlendColor = new Color( 0, 0, 0 );
	let currentBlendAlpha = 0;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( gl.VERSION );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
	const viewportParam = gl.getParameter( gl.VIEWPORT );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count, dimensions ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( let i = 0; i < count; i ++ ) {

			if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

				gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			} else {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
	emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( gl.CULL_FACE );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			const textures = renderTarget.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}

		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: gl.FUNC_ADD,
		[ SubtractEquation ]: gl.FUNC_SUBTRACT,
		[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
	};

	equationToGL[ MinEquation ] = gl.MIN;
	equationToGL[ MaxEquation ] = gl.MAX;

	const factorToGL = {
		[ ZeroFactor ]: gl.ZERO,
		[ OneFactor ]: gl.ONE,
		[ SrcColorFactor ]: gl.SRC_COLOR,
		[ SrcAlphaFactor ]: gl.SRC_ALPHA,
		[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
		[ DstColorFactor ]: gl.DST_COLOR,
		[ DstAlphaFactor ]: gl.DST_ALPHA,
		[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
		[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
		[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
		[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
		[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
		[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
		[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
		[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( gl.BLEND );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( gl.BLEND );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlendColor.set( 0, 0, 0 );
				currentBlendAlpha = 0;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

			gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

			currentBlendColor.copy( blendColor );
			currentBlendAlpha = blendAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = false;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture, webglSlot ) {

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexImage3D() {

		try {

			gl.compressedTexImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage3D() {

		try {

			gl.compressedTexSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	function updateUBOMapping( uniformsGroup, program ) {

		let mapping = uboProgramMap.get( program );

		if ( mapping === undefined ) {

			mapping = new WeakMap();

			uboProgramMap.set( program, mapping );

		}

		let blockIndex = mapping.get( uniformsGroup );

		if ( blockIndex === undefined ) {

			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

			mapping.set( uniformsGroup, blockIndex );

		}

	}

	function uniformBlockBinding( uniformsGroup, program ) {

		const mapping = uboProgramMap.get( program );
		const blockIndex = mapping.get( uniformsGroup );

		if ( uboBindings.get( program ) !== blockIndex ) {

			// bind shader specific block index to global block point
			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

			uboBindings.set( program, blockIndex );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( gl.BLEND );
		gl.disable( gl.CULL_FACE );
		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.POLYGON_OFFSET_FILL );
		gl.disable( gl.SCISSOR_TEST );
		gl.disable( gl.STENCIL_TEST );
		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.ONE, gl.ZERO );
		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
		gl.blendColor( 0, 0, 0, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( gl.LESS );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
		gl.clearStencil( 0 );

		gl.cullFace( gl.BACK );
		gl.frontFace( gl.CCW );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( gl.TEXTURE0 );

		gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentBlendColor = new Color( 0, 0, 0 );
		currentBlendAlpha = 0;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

	const _imageDimensions = new Vector2();
	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsNewCanvas, maxSize ) {

		let scale = 1;

		const dimensions = getDimensions( image );

		// handle case if texture exceeds max size

		if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

			scale = maxSize / Math.max( dimensions.width, dimensions.height );

		}

		// only perform resize if necessary

		if ( scale < 1 ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
				( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

				const width = Math.floor( scale * dimensions.width );
				const height = Math.floor( scale * dimensions.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function textureNeedsGenerateMipmaps( texture ) {

		return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === _gl.RED ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

		}

		if ( glFormat === _gl.RED_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
			if ( glType === _gl.INT ) internalFormat = _gl.R32I;

		}

		if ( glFormat === _gl.RG ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

		}

		if ( glFormat === _gl.RG_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
			if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

		}

		if ( glFormat === _gl.RGB ) {

			if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;

		}

		if ( glFormat === _gl.RGBA ) {

			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
			if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

		}

		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
			internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getMipLevels( texture, image ) {

		if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

				}

				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

				for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

			}

			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

			if ( renderTargetProperties.__webglColorRenderbuffer ) {

				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

			}

			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const attachmentProperties = properties.get( textures[ i ] );

			if ( attachmentProperties.__webglTexture ) {

				_gl.deleteTexture( attachmentProperties.__webglTexture );

				info.memory.textures --;

			}

			properties.remove( textures[ i ] );

		}

		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.wrapR || 0 );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.colorSpace );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: _gl.REPEAT,
		[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
		[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
	};

	const filterToGL = {
		[ NearestFilter ]: _gl.NEAREST,
		[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
		[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

		[ LinearFilter ]: _gl.LINEAR,
		[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
		[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
	};

	const compareToGL = {
		[ NeverCompare ]: _gl.NEVER,
		[ AlwaysCompare ]: _gl.ALWAYS,
		[ LessCompare ]: _gl.LESS,
		[ LessEqualCompare ]: _gl.LEQUAL,
		[ EqualCompare ]: _gl.EQUAL,
		[ GreaterEqualCompare ]: _gl.GEQUAL,
		[ GreaterCompare ]: _gl.GREATER,
		[ NotEqualCompare ]: _gl.NOTEQUAL
	};

	function setTextureParameters( textureType, texture ) {

		if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
			( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

			console.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

		if ( texture.compareFunction ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = _gl.TEXTURE_2D;

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
		if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
			image = verifyColorSpace( texture, image );

			const glFormat = utils.convert( texture.format, texture.colorSpace );

			const glType = utils.convert( texture.type );
			let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

			setTextureParameters( textureType, texture );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			const levels = getMipLevels( texture, image );

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( texture.type === FloatType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT24;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = _gl.DEPTH24_STENCIL8;

				}

				//

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						}

						if ( dataReady ) {

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( texture.isCompressedArrayTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

									}

								} else {

									state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					}

				} else {

					state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					}

				} else {

					state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

					} else {

						let width = image.width, height = image.height;

						for ( let i = 0; i < levels; i ++ ) {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

							width >>= 1;
							height >>= 1;

						}

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						const dimensions = getDimensions( mipmaps[ 0 ] );

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							const dimensions = getDimensions( image );

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

						}

						if ( dataReady ) {

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( textureType );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				glFormat = utils.convert( texture.format, texture.colorSpace ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			let levels = getMipLevels( texture, image );

			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					const dimensions = getDimensions( cubeImage[ 0 ] );

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

		const glFormat = utils.convert( texture.format, texture.colorSpace );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
		const renderTargetProperties = properties.get( renderTarget );

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			const width = Math.max( 1, renderTarget.width >> level );
			const height = Math.max( 1, renderTarget.height >> level );

			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

				state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}


	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = _gl.DEPTH_COMPONENT24;

			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT24;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			const textures = renderTarget.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				const glFormat = utils.convert( texture.format, texture.colorSpace );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		const textures = renderTarget.textures;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( textures.length > 1 );

		if ( ! isMultipleRenderTargets ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					renderTargetProperties.__webglFramebuffer[ i ] = [];

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			}

		} else {

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			if ( isMultipleRenderTargets ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( textures[ i ] );

					if ( attachmentProperties.__webglTexture === undefined ) {

						attachmentProperties.__webglTexture = _gl.createTexture();

						info.memory.textures ++;

					}

				}

			}

			if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];
					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

					}

				} else {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, attachment );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );

				if ( textureNeedsGenerateMipmaps( attachment ) ) {

					generateMipmap( _gl.TEXTURE_2D );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = _gl.TEXTURE_2D;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture );

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

				}

			} else {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target );
				state.unbindTexture();

			}

		}

	}

	const invalidationArrayRead = [];
	const invalidationArrayDraw = [];

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.samples > 0 ) {

			if ( useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.textures;
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( textures.length > 1 );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					if ( renderTarget.resolveDepthBuffer ) {

						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

						// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

						if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					if ( supportsInvalidateFramebuffer === true ) {

						invalidationArrayRead.length = 0;
						invalidationArrayDraw.length = 0;

						invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

						if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

							invalidationArrayRead.push( depthStyle );
							invalidationArrayDraw.push( depthStyle );

							_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

						}

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

			} else {

				if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

					_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

				}

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( capabilities.maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const colorSpace = texture.colorSpace;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

		if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

			// sRGB

			if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

				// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

				if ( format !== RGBAFormat || type !== UnsignedByteType ) {

					console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

				}

			} else {

				console.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );

			}

		}

		return image;

	}

	function getDimensions( image ) {

		if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

			// if intrinsic data are not available, fallback to width/height

			_imageDimensions.width = image.naturalWidth || image.width;
			_imageDimensions.height = image.naturalHeight || image.height;

		} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

			_imageDimensions.width = image.displayWidth;
			_imageDimensions.height = image.displayHeight;

		} else {

			_imageDimensions.width = image.width;
			_imageDimensions.height = image.height;

		}

		return _imageDimensions;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions ) {

	function convert( p, colorSpace = NoColorSpace ) {

		let extension;

		const transfer = ColorManagement.getTransfer( colorSpace );

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;
		if ( p === HalfFloatType ) return gl.HALF_FLOAT;

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( transfer === SRGBTransfer ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.isArrayCamera = true;

		this.cameras = array;

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	connect( inputSource ) {

		if ( inputSource && inputSource.hand ) {

			const hand = this._hand;

			if ( hand ) {

				for ( const inputjoint of inputSource.hand.values() ) {

					// Initialize hand with joints when connected
					this._getHandJoint( hand, inputjoint );

				}

			}

		}

		this.dispatchEvent( { type: 'connected', data: inputSource } );

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = this._getHandJoint( hand, inputjoint );

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.matrixWorldNeedsUpdate = true;
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
						grip.matrixWorldNeedsUpdate = true;

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if ( inputPose === null && gripPose !== null ) {

					inputPose = gripPose;

				}

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
					targetRay.matrixWorldNeedsUpdate = true;

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}


		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

	// private method

	_getHandJoint( hand, inputjoint ) {

		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[ inputjoint.jointName ] = joint;

			hand.add( joint );

		}

		return hand.joints[ inputjoint.jointName ];

	}

}

const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

class WebXRDepthSensing {

	constructor() {

		this.texture = null;
		this.mesh = null;

		this.depthNear = 0;
		this.depthFar = 0;

	}

	init( renderer, depthData, renderState ) {

		if ( this.texture === null ) {

			const texture = new Texture();

			const texProps = renderer.properties.get( texture );
			texProps.__webglTexture = depthData.texture;

			if ( ( depthData.depthNear != renderState.depthNear ) || ( depthData.depthFar != renderState.depthFar ) ) {

				this.depthNear = depthData.depthNear;
				this.depthFar = depthData.depthFar;

			}

			this.texture = texture;

		}

	}

	render( renderer, cameraXR ) {

		if ( this.texture !== null ) {

			if ( this.mesh === null ) {

				const viewport = cameraXR.cameras[ 0 ].viewport;
				const material = new ShaderMaterial( {
					vertexShader: _occlusion_vertex,
					fragmentShader: _occlusion_fragment,
					uniforms: {
						depthColor: { value: this.texture },
						depthWidth: { value: viewport.z },
						depthHeight: { value: viewport.w }
					}
				} );

				this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

			}

			renderer.render( this.mesh, cameraXR );

		}

	}

	reset() {

		this.texture = null;
		this.mesh = null;

	}

}

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;

		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		// Set default foveation to maximum.
		let foveation = 1.0;
		let customReferenceSpace = null;

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;

		const depthSensing = new WebXRDepthSensing();
		const attributes = gl.getContextAttributes();

		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const controllerInputSources = [];

		const currentSize = new Vector2();
		let currentPixelRatio = null;

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraXR = new ArrayCamera();
		cameraXR.layers.enable( 1 );
		cameraXR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

			if ( controllerIndex === - 1 ) {

				return;

			}

			const controller = controllers[ controllerIndex ];

			if ( controller !== undefined ) {

				controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			session.removeEventListener( 'select', onSessionEvent );
			session.removeEventListener( 'selectstart', onSessionEvent );
			session.removeEventListener( 'selectend', onSessionEvent );
			session.removeEventListener( 'squeeze', onSessionEvent );
			session.removeEventListener( 'squeezestart', onSessionEvent );
			session.removeEventListener( 'squeezeend', onSessionEvent );
			session.removeEventListener( 'end', onSessionEnd );
			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];

				if ( inputSource === null ) continue;

				controllerInputSources[ i ] = null;

				controllers[ i ].disconnect( inputSource );

			}

			_currentDepthNear = null;
			_currentDepthFar = null;

			depthSensing.reset();

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			renderer.setPixelRatio( currentPixelRatio );
			renderer.setSize( currentSize.width, currentSize.height, false );

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return customReferenceSpace || referenceSpace;

		};

		this.setReferenceSpace = function ( space ) {

			customReferenceSpace = space;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize( currentSize );

				if ( session.renderState.layers === undefined ) {

					const layerInit = {
						antialias: attributes.antialias,
						alpha: true,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							colorSpace: renderer.outputColorSpace,
							stencilBuffer: attributes.stencil
						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

					}

					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							colorSpace: renderer.outputColorSpace,
							samples: attributes.antialias ? 4 : 0,
							resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )
						} );

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				this.setFoveation( foveation );

				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		this.getEnvironmentBlendMode = function () {

			if ( session !== null ) {

				return session.environmentBlendMode;

			}

		};

		function onInputSourcesChange( event ) {

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const index = controllerInputSources.indexOf( inputSource );

				if ( index >= 0 ) {

					controllerInputSources[ index ] = null;
					controllers[ index ].disconnect( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];

				let controllerIndex = controllerInputSources.indexOf( inputSource );

				if ( controllerIndex === - 1 ) {

					// Assign input source a controller that currently has no input source

					for ( let i = 0; i < controllers.length; i ++ ) {

						if ( i >= controllerInputSources.length ) {

							controllerInputSources.push( inputSource );
							controllerIndex = i;
							break;

						} else if ( controllerInputSources[ i ] === null ) {

							controllerInputSources[ i ] = inputSource;
							controllerIndex = i;
							break;

						}

					}

					// If all controllers do currently receive input we ignore new ones

					if ( controllerIndex === - 1 ) break;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller ) {

					controller.connect( inputSource );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
			camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			if ( depthSensing.texture !== null ) {

				camera.near = depthSensing.depthNear;
				camera.far = depthSensing.depthFar;

			}

			cameraXR.near = cameraR.near = cameraL.near = camera.near;
			cameraXR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraXR.near,
					depthFar: cameraXR.far
				} );

				_currentDepthNear = cameraXR.near;
				_currentDepthFar = cameraXR.far;

				cameraL.near = _currentDepthNear;
				cameraL.far = _currentDepthFar;
				cameraR.near = _currentDepthNear;
				cameraR.far = _currentDepthFar;

				cameraL.updateProjectionMatrix();
				cameraR.updateProjectionMatrix();
				camera.updateProjectionMatrix();

			}

			const parent = camera.parent;
			const cameras = cameraXR.cameras;

			updateCamera( cameraXR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraXR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			// update user camera and its children

			updateUserCamera( camera, cameraXR, parent );

		};

		function updateUserCamera( camera, cameraXR, parent ) {

			if ( parent === null ) {

				camera.matrix.copy( cameraXR.matrixWorld );

			} else {

				camera.matrix.copy( parent.matrixWorld );
				camera.matrix.invert();
				camera.matrix.multiply( cameraXR.matrixWorld );

			}

			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
			camera.updateMatrixWorld( true );

			camera.projectionMatrix.copy( cameraXR.projectionMatrix );
			camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

			if ( camera.isPerspectiveCamera ) {

				camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
				camera.zoom = 1;

			}

		}

		this.getCamera = function () {

			return cameraXR;

		};

		this.getFoveation = function () {

			if ( glProjLayer === null && glBaseLayer === null ) {

				return undefined;

			}

			return foveation;

		};

		this.setFoveation = function ( value ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			foveation = value;

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = value;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = value;

			}

		};

		this.hasDepthSensing = function () {

			return depthSensing.texture !== null;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraXRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraXR's camera list

				if ( views.length !== cameraXR.cameras.length ) {

					cameraXR.cameras.length = 0;
					cameraXRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					let camera = cameras[ i ];

					if ( camera === undefined ) {

						camera = new PerspectiveCamera();
						camera.layers.enable( i );
						camera.viewport = new Vector4();
						cameras[ i ] = camera;

					}

					camera.matrix.fromArray( view.transform.matrix );
					camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraXR.matrix.copy( camera.matrix );
						cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

					}

					if ( cameraXRNeedsUpdate === true ) {

						cameraXR.cameras.push( camera );

					}

				}

				//

				const enabledFeatures = session.enabledFeatures;

				if ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {

					const depthData = glBinding.getDepthInformation( views[ 0 ] );

					if ( depthData && depthData.isValid && depthData.texture ) {

						depthSensing.init( renderer, depthData, session.renderState );

					}

				}

			}

			//

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];
				const controller = controllers[ i ];

				if ( inputSource !== null && controller !== undefined ) {

					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

				}

			}

			depthSensing.render( renderer, cameraXR );

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			if ( frame.detectedPlanes ) {

				scope.dispatchEvent( { type: 'planesdetected', data: frame } );

			}

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

function WebGLMaterials( renderer, properties ) {

	function refreshTransformUniform( map, uniform ) {

		if ( map.matrixAutoUpdate === true ) {

			map.updateMatrix();

		}

		uniform.value.copy( map.matrix );

	}

	function refreshFogUniforms( uniforms, fog ) {

		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;

			refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

			uniforms.bumpScale.value = material.bumpScale;

			if ( material.side === BackSide ) {

				uniforms.bumpScale.value *= - 1;

			}

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;

			refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

			uniforms.normalScale.value.copy( material.normalScale );

			if ( material.side === BackSide ) {

				uniforms.normalScale.value.negate();

			}

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;

			refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

			refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

			refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const materialProperties = properties.get( material );

		const envMap = materialProperties.envMap;
		const envMapRotation = materialProperties.envMapRotation;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			_e1.copy( envMapRotation );

			// accommodate left-handed frame
			_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;

			if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1.y *= - 1;
				_e1.z *= - 1;

			}

			uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( renderer._useLegacyLights === true ) ? Math.PI : 1;

			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

			refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

			refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.uvTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.metalness.value = material.metalness;

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

			refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

		}

		uniforms.roughness.value = material.roughness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

			refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common

			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

				refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

				refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

				refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.dispersion > 0 ) {

			uniforms.dispersion.value = material.dispersion;

		}

		if ( material.iridescence > 0 ) {

			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

			if ( material.iridescenceMap ) {

				uniforms.iridescenceMap.value = material.iridescenceMap;

				refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

			}

			if ( material.iridescenceThicknessMap ) {

				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

				refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

				refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

				refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		if ( material.anisotropy > 0 ) {

			uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

			if ( material.anisotropyMap ) {

				uniforms.anisotropyMap.value = material.anisotropyMap;

				refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

			}

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

			refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

		}

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

			refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		const light = properties.get( material ).light;

		uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
		uniforms.nearDistance.value = light.shadow.camera.near;
		uniforms.farDistance.value = light.shadow.camera.far;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function WebGLUniformsGroups( gl, info, capabilities, state ) {

	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];

	const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

	function bind( uniformsGroup, program ) {

		const webglProgram = program.program;
		state.uniformBlockBinding( uniformsGroup, webglProgram );

	}

	function update( uniformsGroup, program ) {

		let buffer = buffers[ uniformsGroup.id ];

		if ( buffer === undefined ) {

			prepareUniformsGroup( uniformsGroup );

			buffer = createBuffer( uniformsGroup );
			buffers[ uniformsGroup.id ] = buffer;

			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping( uniformsGroup, webglProgram );

		// update UBO once per frame

		const frame = info.render.frame;

		if ( updateList[ uniformsGroup.id ] !== frame ) {

			updateBufferData( uniformsGroup );

			updateList[ uniformsGroup.id ] = frame;

		}

	}

	function createBuffer( uniformsGroup ) {

		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;

		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
		gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
		gl.bindBuffer( gl.UNIFORM_BUFFER, null );
		gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

		return buffer;

	}

	function allocateBindingPointIndex() {

		for ( let i = 0; i < maxBindingPoints; i ++ ) {

			if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

				allocatedBindingPoints.push( i );
				return i;

			}

		}

		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

		return 0;

	}

	function updateBufferData( uniformsGroup ) {

		const buffer = buffers[ uniformsGroup.id ];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

					const offset = uniform.__offset;

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					let arrayOffset = 0;

					for ( let k = 0; k < values.length; k ++ ) {

						const value = values[ k ];

						const info = getUniformSize( value );

						// TODO add integer and struct support
						if ( typeof value === 'number' || typeof value === 'boolean' ) {

							uniform.__data[ 0 ] = value;
							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

						} else if ( value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = value.elements[ 0 ];
							uniform.__data[ 1 ] = value.elements[ 1 ];
							uniform.__data[ 2 ] = value.elements[ 2 ];
							uniform.__data[ 3 ] = 0;
							uniform.__data[ 4 ] = value.elements[ 3 ];
							uniform.__data[ 5 ] = value.elements[ 4 ];
							uniform.__data[ 6 ] = value.elements[ 5 ];
							uniform.__data[ 7 ] = 0;
							uniform.__data[ 8 ] = value.elements[ 6 ];
							uniform.__data[ 9 ] = value.elements[ 7 ];
							uniform.__data[ 10 ] = value.elements[ 8 ];
							uniform.__data[ 11 ] = 0;

						} else {

							value.toArray( uniform.__data, arrayOffset );

							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

						}

					}

					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

				}

			}

		}

		gl.bindBuffer( gl.UNIFORM_BUFFER, null );

	}

	function hasUniformChanged( uniform, index, indexArray, cache ) {

		const value = uniform.value;
		const indexString = index + '_' + indexArray;

		if ( cache[ indexString ] === undefined ) {

			// cache entry does not exist so far

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				cache[ indexString ] = value;

			} else {

				cache[ indexString ] = value.clone();

			}

			return true;

		} else {

			const cachedObject = cache[ indexString ];

			// compare current value with cached entry

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				if ( cachedObject !== value ) {

					cache[ indexString ] = value;
					return true;

				}

			} else {

				if ( cachedObject.equals( value ) === false ) {

					cachedObject.copy( value );
					return true;

				}

			}

		}

		return false;

	}

	function prepareUniformsGroup( uniformsGroup ) {

		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;

		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes

		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				for ( let k = 0, kl = values.length; k < kl; k ++ ) {

					const value = values[ k ];

					const info = getUniformSize( value );

					// Calculate the chunk offset
					const chunkOffsetUniform = offset % chunkSize;

					// Check for chunk overflow
					if ( chunkOffsetUniform !== 0 && ( chunkSize - chunkOffsetUniform ) < info.boundary ) {

						// Add padding and adjust offset
						offset += ( chunkSize - chunkOffsetUniform );

					}

					// the following two properties will be used for partial buffer updates

					uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
					uniform.__offset = offset;


					// Update the global offset
					offset += info.storage;


				}

			}

		}

		// ensure correct final padding

		const chunkOffset = offset % chunkSize;

		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};

		return this;

	}

	function getUniformSize( value ) {

		const info = {
			boundary: 0, // bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if ( typeof value === 'number' || typeof value === 'boolean' ) {

			// float/int/bool

			info.boundary = 4;
			info.storage = 4;

		} else if ( value.isVector2 ) {

			// vec2

			info.boundary = 8;
			info.storage = 8;

		} else if ( value.isVector3 || value.isColor ) {

			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

		} else if ( value.isVector4 ) {

			// vec4

			info.boundary = 16;
			info.storage = 16;

		} else if ( value.isMatrix3 ) {

			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;

		} else if ( value.isMatrix4 ) {

			// mat4

			info.boundary = 64;
			info.storage = 64;

		} else if ( value.isTexture ) {

			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

		} else {

			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

		}

		return info;

	}

	function onUniformsGroupsDispose( event ) {

		const uniformsGroup = event.target;

		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
		allocatedBindingPoints.splice( index, 1 );

		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

		delete buffers[ uniformsGroup.id ];
		delete updateList[ uniformsGroup.id ];

	}

	function dispose() {

		for ( const id in buffers ) {

			gl.deleteBuffer( buffers[ id ] );

		}

		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};

	}

	return {

		bind: bind,
		update: update,

		dispose: dispose

	};

}

class WebGLRenderer {

	constructor( parameters = {} ) {

		const {
			canvas = createCanvasElement(),
			context = null,
			depth = true,
			stencil = false,
			alpha = false,
			antialias = false,
			premultipliedAlpha = true,
			preserveDrawingBuffer = false,
			powerPreference = 'default',
			failIfMajorPerformanceCaveat = false,
		} = parameters;

		this.isWebGLRenderer = true;

		let _alpha;

		if ( context !== null ) {

			if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

				throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

			}

			_alpha = context.getContextAttributes().alpha;

		} else {

			_alpha = alpha;

		}

		const uintClearColor = new Uint32Array( 4 );
		const intClearColor = new Int32Array( 4 );

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		this.domElement = canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true,
			/**
			 * Callback for custom error reporting.
			 * @type {?Function}
			 */
			onShaderError: null
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this._outputColorSpace = SRGBColorSpace;

		// physical lights

		this._useLegacyLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		const _currentClearColor = new Color( 0x000000 );
		let _currentClearAlpha = 0;

		//

		let _width = canvas.width;
		let _height = canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = context;

		function getContext( contextName, contextAttributes ) {

			return canvas.getContext( contextName, contextAttributes );

		}

		try {

			const contextAttributes = {
				alpha: true,
				depth,
				stencil,
				antialias,
				premultipliedAlpha,
				preserveDrawingBuffer,
				powerPreference,
				failIfMajorPerformanceCaveat,
			};

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

			// event listeners must be registered before WebGL context is created, see #12753
			canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			if ( _gl === null ) {

				const contextName = 'webgl2';

				_gl = getContext( contextName, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextName ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates, uniformsGroups;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.init();

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

			state = new WebGLState( _gl );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			cubeuvmaps = new WebGLCubeUVMaps( _this );
			attributes = new WebGLAttributes( _gl );
			bindingStates = new WebGLBindingStates( _gl, attributes );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( _this, properties );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates( extensions );
			background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle = true ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			canvas.width = Math.floor( width * _pixelRatio );
			canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle === true ) {

				canvas.style.width = width + 'px';
				canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			canvas.width = Math.floor( width * pixelRatio );
			canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color = true, depth = true, stencil = true ) {

			let bits = 0;

			if ( color ) {

				// check if we're trying to clear an integer target
				let isIntegerFormat = false;
				if ( _currentRenderTarget !== null ) {

					const targetFormat = _currentRenderTarget.texture.format;
					isIntegerFormat = targetFormat === RGBAIntegerFormat ||
						targetFormat === RGIntegerFormat ||
						targetFormat === RedIntegerFormat;

				}

				// use the appropriate clear functions to clear the target if it's a signed
				// or unsigned integer target
				if ( isIntegerFormat ) {

					const targetType = _currentRenderTarget.texture.type;
					const isUnsignedType = targetType === UnsignedByteType ||
						targetType === UnsignedIntType ||
						targetType === UnsignedShortType ||
						targetType === UnsignedInt248Type ||
						targetType === UnsignedShort4444Type ||
						targetType === UnsignedShort5551Type;

					const clearColor = background.getClearColor();
					const a = background.getClearAlpha();
					const r = clearColor.r;
					const g = clearColor.g;
					const b = clearColor.b;

					if ( isUnsignedType ) {

						uintClearColor[ 0 ] = r;
						uintClearColor[ 1 ] = g;
						uintClearColor[ 2 ] = b;
						uintClearColor[ 3 ] = a;
						_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

					} else {

						intClearColor[ 0 ] = r;
						intClearColor[ 1 ] = g;
						intClearColor[ 2 ] = b;
						intClearColor[ 3 ] = a;
						_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

					}

				} else {

					bits |= _gl.COLOR_BUFFER_BIT;

				}

			}

			if ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil ) {

				bits |= _gl.STENCIL_BUFFER_BIT;
				this.state.buffers.stencil.setMask( 0xffffffff );

			}

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onContextCreationError( event ) {

			console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			const programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

				if ( material.isShaderMaterial ) {

					programCache.releaseShaderCache( material );

				}

			}

		}

		// Buffer rendering

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, geometry, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );

				if ( index === undefined ) return;

				rangeFactor = 2;

			}

			//

			const drawRange = geometry.drawRange;
			const position = geometry.attributes.position;

			let drawStart = drawRange.start * rangeFactor;
			let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

			if ( group !== null ) {

				drawStart = Math.max( drawStart, group.start * rangeFactor );
				drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

			}

			if ( index !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, index.count );

			} else if ( position !== undefined && position !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, position.count );

			}

			const drawCount = drawEnd - drawStart;

			if ( drawCount < 0 || drawCount === Infinity ) return;

			//

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( object.isBatchedMesh ) {

				if ( object._multiDrawInstances !== null ) {

					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

				} else {

					renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

				}

			} else if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
				const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		function prepareMaterial( material, scene, object ) {

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = DoubleSide;

			} else {

				getProgram( material, scene, object );

			}

		}

		this.compile = function ( scene, camera, targetScene = null ) {

			if ( targetScene === null ) targetScene = scene;

			currentRenderState = renderStates.get( targetScene );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			// gather lights from both the target scene and the new object that will be added to the scene.

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			if ( scene !== targetScene ) {

				scene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

			}

			currentRenderState.setupLights( _this._useLegacyLights );

			// Only initialize materials in the new scene, not the targetScene.

			const materials = new Set();

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							prepareMaterial( material2, targetScene, object );
							materials.add( material2 );

						}

					} else {

						prepareMaterial( material, targetScene, object );
						materials.add( material );

					}

				}

			} );

			renderStateStack.pop();
			currentRenderState = null;

			return materials;

		};

		// compileAsync

		this.compileAsync = function ( scene, camera, targetScene = null ) {

			const materials = this.compile( scene, camera, targetScene );

			// Wait for all the materials in the new object to indicate that they're
			// ready to be used before resolving the promise.

			return new Promise( ( resolve ) => {

				function checkMaterialsReady() {

					materials.forEach( function ( material ) {

						const materialProperties = properties.get( material );
						const program = materialProperties.currentProgram;

						if ( program.isReady() ) {

							// remove any programs that report they're ready to use from the list
							materials.delete( material );

						}

					} );

					// once the list of compiling materials is empty, call the callback

					if ( materials.size === 0 ) {

						resolve( scene );
						return;

					}

					// if some materials are still not ready, wait a bit and check again

					setTimeout( checkMaterialsReady, 10 );

				}

				if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

					// If we can check the compilation status of the materials without
					// blocking then do so right away.

					checkMaterialsReady();

				} else {

					// Otherwise start by waiting a bit to give the materials we just
					// initialized a chance to finish.

					setTimeout( checkMaterialsReady, 10 );

				}

			} );

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof self !== 'undefined' ) animation.setContext( self );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		this.render = function ( scene, camera ) {

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// update scene graph

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

				camera = xr.getCamera(); // use XR camera for rendering

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			const renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
			if ( renderBackground ) {

				background.addToRenderList( currentRenderList, scene );

			}

			//

			this.info.render.frame ++;

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;

			currentRenderState.setupLights( _this._useLegacyLights );

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				if ( transmissiveObjects.length > 0 ) {

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

					}

				}

				if ( renderBackground ) background.render( scene );

				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

					const camera2 = cameras[ i ];

					renderScene( currentRenderList, scene, camera2, camera2.viewport );

				}

			} else {

				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

				if ( renderBackground ) background.render( scene );

				renderScene( currentRenderList, scene, camera );

			}

			//

			if ( _currentRenderTarget !== null ) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						const geometry = objects.update( object );
						const material = object.material;

						if ( sortObjects ) {

							if ( object.boundingSphere !== undefined ) {

								if ( object.boundingSphere === null ) object.computeBoundingSphere();
								_vector3.copy( object.boundingSphere.center );

							} else {

								if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
								_vector3.copy( geometry.boundingSphere.center );

							}

							_vector3
								.applyMatrix4( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderScene( currentRenderList, scene, camera, viewport ) {

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

		}

		function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			if ( overrideMaterial !== null ) {

				return;

			}

			if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

				currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
					generateMipmaps: true,
					type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: 4,
					stencilBuffer: stencil,
					resolveDepthBuffer: false,
					resolveStencilBuffer: false
				} );

				// debug

				/*
				const geometry = new PlaneGeometry();
				const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

				const mesh = new Mesh( geometry, material );
				scene.add( mesh );
				*/

			}

			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

			const activeViewport = camera.viewport || _currentViewport;
			transmissionRenderTarget.setSize( activeViewport.z, activeViewport.w );

			//

			const currentRenderTarget = _this.getRenderTarget();
			_this.setRenderTarget( transmissionRenderTarget );

			_this.getClearColor( _currentClearColor );
			_currentClearAlpha = _this.getClearAlpha();
			if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

			_this.clear();

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;

			// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
			// Transmission render pass requires viewport to match the transmissionRenderTarget.
			const currentCameraViewport = camera.viewport;
			if ( camera.viewport !== undefined ) camera.viewport = undefined;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			renderObjects( opaqueObjects, scene, camera );

			textures.updateMultisampleRenderTarget( transmissionRenderTarget );
			textures.updateRenderTargetMipmap( transmissionRenderTarget );

			if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

				let renderTargetNeedsUpdate = false;

				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

					const renderItem = transmissiveObjects[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = renderItem.material;
					const group = renderItem.group;

					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

						const currentSide = material.side;

						material.side = BackSide;
						material.needsUpdate = true;

						renderObject( object, scene, camera, geometry, material, group );

						material.side = currentSide;
						material.needsUpdate = true;

						renderTargetNeedsUpdate = true;

					}

				}

				if ( renderTargetNeedsUpdate === true ) {

					textures.updateMultisampleRenderTarget( transmissionRenderTarget );
					textures.updateRenderTargetMipmap( transmissionRenderTarget );

				}

			}

			_this.setRenderTarget( currentRenderTarget );

			_this.setClearColor( _currentClearColor, _currentClearAlpha );

			if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

			_this.toneMapping = currentToneMapping;

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( object.layers.test( camera.layers ) ) {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			material.onBeforeRender( _this, scene, camera, geometry, object, group );

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = DoubleSide;

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
			materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			let program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBuild( object, parameters, _this );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			const uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
				uniforms.spotLightMap.value = lights.state.spotLightMap;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = null;

			return program;

		}

		function getUniformList( materialProperties ) {

			if ( materialProperties.uniformsList === null ) {

				const progUniforms = materialProperties.currentProgram.getUniforms();
				materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

			}

			return materialProperties.uniformsList;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			const materialProperties = properties.get( material );

			materialProperties.outputColorSpace = parameters.outputColorSpace;
			materialProperties.batching = parameters.batching;
			materialProperties.instancing = parameters.instancing;
			materialProperties.instancingColor = parameters.instancingColor;
			materialProperties.instancingMorph = parameters.instancingMorph;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;

		}

		function setProgram( camera, scene, geometry, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
			const morphTargets = !! geometry.morphAttributes.position;
			const morphNormals = !! geometry.morphAttributes.normal;
			const morphColors = !! geometry.morphAttributes.color;

			let toneMapping = NoToneMapping;

			if ( material.toneMapped ) {

				if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

					toneMapping = _this.toneMapping;

				}

			}

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			let needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputColorSpace !== colorSpace ) {

					needsProgramChange = true;

				} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

					needsProgramChange = true;

				} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

					needsProgramChange = true;

				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog === true && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargets !== morphTargets ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphNormals !== morphNormals ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphColors !== morphColors ) {

					needsProgramChange = true;

				} else if ( materialProperties.toneMapping !== toneMapping ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			let program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				// common camera uniforms

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

			}

			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

			if ( object.isSkinnedMesh ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

				}

			}

			if ( object.isBatchedMesh ) {

				p_uniforms.setOptional( _gl, object, 'batchingTexture' );
				p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

			}

			const morphAttributes = geometry.morphAttributes;

			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

				morphtargets.update( object, geometry, program );

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

			if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

				m_uniforms.envMap.value = envMap;

				m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			}

			if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

				m_uniforms.envMapIntensity.value = scene.environmentIntensity;

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog === true ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			// UBOs

			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

				const groups = material.uniformsGroups;

				for ( let i = 0, l = groups.length; i < l; i ++ ) {

					const group = groups[ i ];

					uniformsGroups.update( group, program );
					uniformsGroups.bind( group, program );

				}

			}

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
			properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__hasExternalTextures = true;

			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
					renderTargetProperties.__useRenderToTexture = false;

				}

			}

		};

		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			let useDefaultFramebuffer = true;
			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const renderTargetProperties = properties.get( renderTarget );

				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer( _gl.FRAMEBUFFER, null );
					useDefaultFramebuffer = false;

				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				} else if ( renderTargetProperties.__hasExternalTextures ) {

					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

				}

				const texture = renderTarget.texture;

				if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

						framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer[ activeCubeFace ];

					}

					isCube = true;

				} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					if ( Array.isArray( __webglFramebuffer ) ) {

						framebuffer = __webglFramebuffer[ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer;

					}

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( framebufferBound && useDefaultFramebuffer ) {

				state.drawBuffers( renderTarget, framebuffer );

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const textureProperties = properties.get( renderTarget.texture );
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

			}

			_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( ! capabilities.textureTypeReadable( textureType ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

			const width = sourceBox.max.x - sourceBox.min.x;
			const height = sourceBox.max.y - sourceBox.min.y;
			const depth = sourceBox.max.z - sourceBox.min.z;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isData3DTexture ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = _gl.TEXTURE_3D;

			} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = _gl.TEXTURE_2D_ARRAY;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
			const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
			const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
			const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
			const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

			if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

			} else {

				if ( dstTexture.isCompressedArrayTexture ) {

					_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

				} else {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

				}

			}

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			if ( texture.isCubeTexture ) {

				textures.setTextureCube( texture, 0 );

			} else if ( texture.isData3DTexture ) {

				textures.setTexture3D( texture, 0 );

			} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( texture, 0 );

			} else {

				textures.setTexture2D( texture, 0 );

			}

			state.unbindTexture();

		};

		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	get outputColorSpace() {

		return this._outputColorSpace;

	}

	set outputColorSpace( colorSpace ) {

		this._outputColorSpace = colorSpace;

		const gl = this.getContext();
		gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
		gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';

	}

	get useLegacyLights() { // @deprecated, r155

		console.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );
		return this._useLegacyLights;

	}

	set useLegacyLights( value ) { // @deprecated, r155

		console.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );
		this._useLegacyLights = value;

	}

}

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.isFogExp2 = true;

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			name: this.name,
			color: this.color.getHex(),
			density: this.density
		};

	}

}

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.isFog = true;

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			name: this.name,
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

class Scene extends Object3D {

	constructor() {

		super();

		this.isScene = true;

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.backgroundBlurriness = 0;
		this.backgroundIntensity = 1;
		this.backgroundRotation = new Euler();

		this.environmentIntensity = 1;
		this.environmentRotation = new Euler();

		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy( source.backgroundRotation );

		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy( source.environmentRotation );

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();

		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();

		return data;

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this._updateRange = { offset: 0, count: - 1 };
		this.updateRanges = [];

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	get updateRange() {

		warnOnce( 'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
		return this._updateRange;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.data.stride + this.offset + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.data.array[ index * this.data.stride + this.offset + component ] = value;

		return this;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material = new SpriteMaterial() ) {

		super();

		this.isSprite = true;

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = material;

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance, level.hysteresis );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0, hysteresis = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}



	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance < levelDistance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance >= levelDistance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance,
				hysteresis: level.hysteresis
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector3 = /*@__PURE__*/ new Vector3();
const _matrix4 = /*@__PURE__*/ new Matrix4();
const _vertex = /*@__PURE__*/ new Vector3();

const _sphere$4 = /*@__PURE__*/ new Sphere();
const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		this.bindMode = AttachedBindMode;
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		this.boundingBox = null;
		this.boundingSphere = null;

	}

	computeBoundingBox() {

		const geometry = this.geometry;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingBox.expandByPoint( _vertex );

		}

	}

	computeBoundingSphere() {

		const geometry = this.geometry;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingSphere.expandByPoint( _vertex );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	raycast( raycaster, intersects ) {

		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$4.copy( this.boundingSphere );
		_sphere$4.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		// convert ray to local space of skinned mesh

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// test with bounding box in local space

		if ( this.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$2 );

	}

	getVertexPosition( index, target ) {

		super.getVertexPosition( index, target );

		this.applyBoneTransform( index, target );

		return target;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === AttachedBindMode ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === DetachedBindMode ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	applyBoneTransform( index, vector ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );

		vector.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				vector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

			}

		}

		return vector.applyMatrix4( this.bindMatrixInverse );

	}

}

class Bone extends Object3D {

	constructor() {

		super();

		this.isBone = true;

		this.type = 'Bone';

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix$1 = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		super( array, itemSize, normalized );

		this.isInstancedBufferAttribute = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _box3 = /*@__PURE__*/ new Box3();
const _identity = /*@__PURE__*/ new Matrix4();
const _mesh$1 = /*@__PURE__*/ new Mesh();
const _sphere$3 = /*@__PURE__*/ new Sphere();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.isInstancedMesh = true;

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;
		this.morphTexture = null;

		this.count = count;

		this.boundingBox = null;
		this.boundingSphere = null;

		for ( let i = 0; i < count; i ++ ) {

			this.setMatrixAt( i, _identity );

		}

	}

	computeBoundingBox() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		this.boundingBox.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

			this.boundingBox.union( _box3 );

		}

	}

	computeBoundingSphere() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		this.boundingSphere.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

			this.boundingSphere.union( _sphere$3 );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	getMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const array = this.morphTexture.source.data.data;

		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			objectInfluences[ i ] = array[ dataIndex + i ];

		}

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh$1.geometry = this.geometry;
		_mesh$1.material = this.material;

		if ( _mesh$1.material === undefined ) return;

		// test with bounding sphere first

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$3.copy( this.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		// now test each instance

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh$1.matrixWorld = _instanceWorldMatrix;

			_mesh$1.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	setMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

		if ( this.morphTexture === null ) {

			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

		}

		const array = this.morphTexture.source.data.data;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			morphInfluencesSum += objectInfluences[ i ];

		}

		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		const dataIndex = len * index;

		array[ dataIndex ] = morphBaseInfluence;

		array.set( objectInfluences, dataIndex + 1 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		if ( this.morphTexture !== null ) {

			this.morphTexture.dispose();
			this.morphTexture = null;

		}

		return this;

	}

}

function sortOpaque( a, b ) {

	return a.z - b.z;

}

function sortTransparent( a, b ) {

	return b.z - a.z;

}

class MultiDrawRenderList {

	constructor() {

		this.index = 0;
		this.pool = [];
		this.list = [];

	}

	push( drawRange, z ) {

		const pool = this.pool;
		const list = this.list;
		if ( this.index >= pool.length ) {

			pool.push( {

				start: - 1,
				count: - 1,
				z: - 1,

			} );

		}

		const item = pool[ this.index ];
		list.push( item );
		this.index ++;

		item.start = drawRange.start;
		item.count = drawRange.count;
		item.z = z;

	}

	reset() {

		this.list.length = 0;
		this.index = 0;

	}

}

const ID_ATTR_NAME = 'batchId';
const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _invMatrixWorld = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();
const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
const _frustum = /*@__PURE__*/ new Frustum();
const _box$1 = /*@__PURE__*/ new Box3();
const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$5 = /*@__PURE__*/ new Vector3();
const _renderList = /*@__PURE__*/ new MultiDrawRenderList();
const _mesh = /*@__PURE__*/ new Mesh();
const _batchIntersects = [];

// @TODO: SkinnedMesh support?
// @TODO: geometry.groups support?
// @TODO: geometry.drawRange support?
// @TODO: geometry.morphAttributes support?
// @TODO: Support uniform parameter per geometry
// @TODO: Add an "optimize" function to pack geometry and remove data gaps

// copies data from attribute "src" into "target" starting at "targetOffset"
function copyAttributeData( src, target, targetOffset = 0 ) {

	const itemSize = target.itemSize;
	if ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {

		// use the component getters and setters if the array data cannot
		// be copied directly
		const vertexCount = src.count;
		for ( let i = 0; i < vertexCount; i ++ ) {

			for ( let c = 0; c < itemSize; c ++ ) {

				target.setComponent( i + targetOffset, c, src.getComponent( i, c ) );

			}

		}

	} else {

		// faster copy approach using typed array set function
		target.array.set( src.array, targetOffset * itemSize );

	}

	target.needsUpdate = true;

}

class BatchedMesh extends Mesh {

	get maxGeometryCount() {

		return this._maxGeometryCount;

	}

	constructor( maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {

		super( new BufferGeometry(), material );

		this.isBatchedMesh = true;
		this.perObjectFrustumCulled = true;
		this.sortObjects = true;
		this.boundingBox = null;
		this.boundingSphere = null;
		this.customSort = null;

		this._drawRanges = [];
		this._reservedRanges = [];

		this._visibility = [];
		this._active = [];
		this._bounds = [];

		this._maxGeometryCount = maxGeometryCount;
		this._maxVertexCount = maxVertexCount;
		this._maxIndexCount = maxIndexCount;

		this._geometryInitialized = false;
		this._geometryCount = 0;
		this._multiDrawCounts = new Int32Array( maxGeometryCount );
		this._multiDrawStarts = new Int32Array( maxGeometryCount );
		this._multiDrawCount = 0;
		this._multiDrawInstances = null;
		this._visibilityChanged = true;

		// Local matrix per geometry by using data texture
		this._matricesTexture = null;

		this._initMatricesTexture();

	}

	_initMatricesTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

		let size = Math.sqrt( this._maxGeometryCount * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		const matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );

		this._matricesTexture = matricesTexture;

	}

	_initializeGeometry( reference ) {

		const geometry = this.geometry;
		const maxVertexCount = this._maxVertexCount;
		const maxGeometryCount = this._maxGeometryCount;
		const maxIndexCount = this._maxIndexCount;
		if ( this._geometryInitialized === false ) {

			for ( const attributeName in reference.attributes ) {

				const srcAttribute = reference.getAttribute( attributeName );
				const { array, itemSize, normalized } = srcAttribute;

				const dstArray = new array.constructor( maxVertexCount * itemSize );
				const dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );

				geometry.setAttribute( attributeName, dstAttribute );

			}

			if ( reference.getIndex() !== null ) {

				const indexArray = maxVertexCount > 65536
					? new Uint32Array( maxIndexCount )
					: new Uint16Array( maxIndexCount );

				geometry.setIndex( new BufferAttribute( indexArray, 1 ) );

			}

			const idArray = maxGeometryCount > 65536
				? new Uint32Array( maxVertexCount )
				: new Uint16Array( maxVertexCount );
			geometry.setAttribute( ID_ATTR_NAME, new BufferAttribute( idArray, 1 ) );

			this._geometryInitialized = true;

		}

	}

	// Make sure the geometry is compatible with the existing combined geometry attributes
	_validateGeometry( geometry ) {

		// check that the geometry doesn't have a version of our reserved id attribute
		if ( geometry.getAttribute( ID_ATTR_NAME ) ) {

			throw new Error( `BatchedMesh: Geometry cannot use attribute "${ ID_ATTR_NAME }"` );

		}

		// check to ensure the geometries are using consistent attributes and indices
		const batchGeometry = this.geometry;
		if ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {

			throw new Error( 'BatchedMesh: All geometries must consistently have "index".' );

		}

		for ( const attributeName in batchGeometry.attributes ) {

			if ( attributeName === ID_ATTR_NAME ) {

				continue;

			}

			if ( ! geometry.hasAttribute( attributeName ) ) {

				throw new Error( `BatchedMesh: Added geometry missing "${ attributeName }". All geometries must have consistent attributes.` );

			}

			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			if ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {

				throw new Error( 'BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );

			}

		}

	}

	setCustomSort( func ) {

		this.customSort = func;
		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const geometryCount = this._geometryCount;
		const boundingBox = this.boundingBox;
		const active = this._active;

		boundingBox.makeEmpty();
		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( active[ i ] === false ) continue;

			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingBoxAt( i, _box$1 ).applyMatrix4( _matrix$1 );
			boundingBox.union( _box$1 );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const geometryCount = this._geometryCount;
		const boundingSphere = this.boundingSphere;
		const active = this._active;

		boundingSphere.makeEmpty();
		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( active[ i ] === false ) continue;

			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );
			boundingSphere.union( _sphere$2 );

		}

	}

	addGeometry( geometry, vertexCount = - 1, indexCount = - 1 ) {

		this._initializeGeometry( geometry );

		this._validateGeometry( geometry );

		// ensure we're not over geometry
		if ( this._geometryCount >= this._maxGeometryCount ) {

			throw new Error( 'BatchedMesh: Maximum geometry count reached.' );

		}

		// get the necessary range fo the geometry
		const reservedRange = {
			vertexStart: - 1,
			vertexCount: - 1,
			indexStart: - 1,
			indexCount: - 1,
		};

		let lastRange = null;
		const reservedRanges = this._reservedRanges;
		const drawRanges = this._drawRanges;
		const bounds = this._bounds;
		if ( this._geometryCount !== 0 ) {

			lastRange = reservedRanges[ reservedRanges.length - 1 ];

		}

		if ( vertexCount === - 1 ) {

			reservedRange.vertexCount = geometry.getAttribute( 'position' ).count;

		} else {

			reservedRange.vertexCount = vertexCount;

		}

		if ( lastRange === null ) {

			reservedRange.vertexStart = 0;

		} else {

			reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;

		}

		const index = geometry.getIndex();
		const hasIndex = index !== null;
		if ( hasIndex ) {

			if ( indexCount	=== - 1 ) {

				reservedRange.indexCount = index.count;

			} else {

				reservedRange.indexCount = indexCount;

			}

			if ( lastRange === null ) {

				reservedRange.indexStart = 0;

			} else {

				reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;

			}

		}

		if (
			reservedRange.indexStart !== - 1 &&
			reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount ||
			reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount
		) {

			throw new Error( 'BatchedMesh: Reserved space request exceeds the maximum buffer size.' );

		}

		const visibility = this._visibility;
		const active = this._active;
		const matricesTexture = this._matricesTexture;
		const matricesArray = this._matricesTexture.image.data;

		// push new visibility states
		visibility.push( true );
		active.push( true );

		// update id
		const geometryId = this._geometryCount;
		this._geometryCount ++;

		// initialize matrix information
		_identityMatrix.toArray( matricesArray, geometryId * 16 );
		matricesTexture.needsUpdate = true;

		// add the reserved range and draw range objects
		reservedRanges.push( reservedRange );
		drawRanges.push( {
			start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
			count: - 1
		} );
		bounds.push( {
			boxInitialized: false,
			box: new Box3(),

			sphereInitialized: false,
			sphere: new Sphere()
		} );

		// set the id for the geometry
		const idAttribute = this.geometry.getAttribute( ID_ATTR_NAME );
		for ( let i = 0; i < reservedRange.vertexCount; i ++ ) {

			idAttribute.setX( reservedRange.vertexStart + i, geometryId );

		}

		idAttribute.needsUpdate = true;

		// update the geometry
		this.setGeometryAt( geometryId, geometry );

		return geometryId;

	}

	setGeometryAt( id, geometry ) {

		if ( id >= this._geometryCount ) {

			throw new Error( 'BatchedMesh: Maximum geometry count reached.' );

		}

		this._validateGeometry( geometry );

		const batchGeometry = this.geometry;
		const hasIndex = batchGeometry.getIndex() !== null;
		const dstIndex = batchGeometry.getIndex();
		const srcIndex = geometry.getIndex();
		const reservedRange = this._reservedRanges[ id ];
		if (
			hasIndex &&
			srcIndex.count > reservedRange.indexCount ||
			geometry.attributes.position.count > reservedRange.vertexCount
		) {

			throw new Error( 'BatchedMesh: Reserved space not large enough for provided geometry.' );

		}

		// copy geometry over
		const vertexStart = reservedRange.vertexStart;
		const vertexCount = reservedRange.vertexCount;
		for ( const attributeName in batchGeometry.attributes ) {

			if ( attributeName === ID_ATTR_NAME ) {

				continue;

			}

			// copy attribute data
			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			copyAttributeData( srcAttribute, dstAttribute, vertexStart );

			// fill the rest in with zeroes
			const itemSize = srcAttribute.itemSize;
			for ( let i = srcAttribute.count, l = vertexCount; i < l; i ++ ) {

				const index = vertexStart + i;
				for ( let c = 0; c < itemSize; c ++ ) {

					dstAttribute.setComponent( index, c, 0 );

				}

			}

			dstAttribute.needsUpdate = true;
			dstAttribute.addUpdateRange( vertexStart * itemSize, vertexCount * itemSize );

		}

		// copy index
		if ( hasIndex ) {

			const indexStart = reservedRange.indexStart;

			// copy index data over
			for ( let i = 0; i < srcIndex.count; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );

			}

			// fill the rest in with zeroes
			for ( let i = srcIndex.count, l = reservedRange.indexCount; i < l; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart );

			}

			dstIndex.needsUpdate = true;
			dstIndex.addUpdateRange( indexStart, reservedRange.indexCount );

		}

		// store the bounding boxes
		const bound = this._bounds[ id ];
		if ( geometry.boundingBox !== null ) {

			bound.box.copy( geometry.boundingBox );
			bound.boxInitialized = true;

		} else {

			bound.boxInitialized = false;

		}

		if ( geometry.boundingSphere !== null ) {

			bound.sphere.copy( geometry.boundingSphere );
			bound.sphereInitialized = true;

		} else {

			bound.sphereInitialized = false;

		}

		// set drawRange count
		const drawRange = this._drawRanges[ id ];
		const posAttr = geometry.getAttribute( 'position' );
		drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
		this._visibilityChanged = true;

		return id;

	}

	deleteGeometry( geometryId ) {

		// Note: User needs to call optimize() afterward to pack the data.

		const active = this._active;
		if ( geometryId >= active.length || active[ geometryId ] === false ) {

			return this;

		}

		active[ geometryId ] = false;
		this._visibilityChanged = true;

		return this;

	}

	getInstanceCountAt( id ) {

		if ( this._multiDrawInstances === null ) return null;

		return this._multiDrawInstances[ id ];

	}

	setInstanceCountAt( id, instanceCount ) {

		if ( this._multiDrawInstances === null ) {

			this._multiDrawInstances = new Int32Array( this._maxGeometryCount ).fill( 1 );

		}

		this._multiDrawInstances[ id ] = instanceCount;

		return id;

	}

	// get bounding box and compute it if it doesn't exist
	getBoundingBoxAt( id, target ) {

		const active = this._active;
		if ( active[ id ] === false ) {

			return null;

		}

		// compute bounding box
		const bound = this._bounds[ id ];
		const box = bound.box;
		const geometry = this.geometry;
		if ( bound.boxInitialized === false ) {

			box.makeEmpty();

			const index = geometry.index;
			const position = geometry.attributes.position;
			const drawRange = this._drawRanges[ id ];
			for ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				box.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );

			}

			bound.boxInitialized = true;

		}

		target.copy( box );
		return target;

	}

	// get bounding sphere and compute it if it doesn't exist
	getBoundingSphereAt( id, target ) {

		const active = this._active;
		if ( active[ id ] === false ) {

			return null;

		}

		// compute bounding sphere
		const bound = this._bounds[ id ];
		const sphere = bound.sphere;
		const geometry = this.geometry;
		if ( bound.sphereInitialized === false ) {

			sphere.makeEmpty();

			this.getBoundingBoxAt( id, _box$1 );
			_box$1.getCenter( sphere.center );

			const index = geometry.index;
			const position = geometry.attributes.position;
			const drawRange = this._drawRanges[ id ];

			let maxRadiusSq = 0;
			for ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				_vector$5.fromBufferAttribute( position, iv );
				maxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );

			}

			sphere.radius = Math.sqrt( maxRadiusSq );
			bound.sphereInitialized = true;

		}

		target.copy( sphere );
		return target;

	}

	setMatrixAt( geometryId, matrix ) {

		// @TODO: Map geometryId to index of the arrays because
		//        optimize() can make geometryId mismatch the index

		const active = this._active;
		const matricesTexture = this._matricesTexture;
		const matricesArray = this._matricesTexture.image.data;
		const geometryCount = this._geometryCount;
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return this;

		}

		matrix.toArray( matricesArray, geometryId * 16 );
		matricesTexture.needsUpdate = true;

		return this;

	}

	getMatrixAt( geometryId, matrix ) {

		const active = this._active;
		const matricesArray = this._matricesTexture.image.data;
		const geometryCount = this._geometryCount;
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return null;

		}

		return matrix.fromArray( matricesArray, geometryId * 16 );

	}

	setVisibleAt( geometryId, value ) {

		const visibility = this._visibility;
		const active = this._active;
		const geometryCount = this._geometryCount;

		// if the geometry is out of range, not active, or visibility state
		// does not change then return early
		if (
			geometryId >= geometryCount ||
			active[ geometryId ] === false ||
			visibility[ geometryId ] === value
		) {

			return this;

		}

		visibility[ geometryId ] = value;
		this._visibilityChanged = true;

		return this;

	}

	getVisibleAt( geometryId ) {

		const visibility = this._visibility;
		const active = this._active;
		const geometryCount = this._geometryCount;

		// return early if the geometry is out of range or not active
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return false;

		}

		return visibility[ geometryId ];

	}

	raycast( raycaster, intersects ) {

		const visibility = this._visibility;
		const active = this._active;
		const drawRanges = this._drawRanges;
		const geometryCount = this._geometryCount;
		const matrixWorld = this.matrixWorld;
		const batchGeometry = this.geometry;

		// iterate over each geometry
		_mesh.material = this.material;
		_mesh.geometry.index = batchGeometry.index;
		_mesh.geometry.attributes = batchGeometry.attributes;
		if ( _mesh.geometry.boundingBox === null ) {

			_mesh.geometry.boundingBox = new Box3();

		}

		if ( _mesh.geometry.boundingSphere === null ) {

			_mesh.geometry.boundingSphere = new Sphere();

		}

		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( ! visibility[ i ] || ! active[ i ] ) {

				continue;

			}

			const drawRange = drawRanges[ i ];
			_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );

			// ge the intersects
			this.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );
			this.getBoundingBoxAt( i, _mesh.geometry.boundingBox );
			this.getBoundingSphereAt( i, _mesh.geometry.boundingSphere );
			_mesh.raycast( raycaster, _batchIntersects );

			// add batch id to the intersects
			for ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {

				const intersect = _batchIntersects[ j ];
				intersect.object = this;
				intersect.batchId = i;
				intersects.push( intersect );

			}

			_batchIntersects.length = 0;

		}

		_mesh.material = null;
		_mesh.geometry.index = null;
		_mesh.geometry.attributes = {};
		_mesh.geometry.setDrawRange( 0, Infinity );

	}

	copy( source ) {

		super.copy( source );

		this.geometry = source.geometry.clone();
		this.perObjectFrustumCulled = source.perObjectFrustumCulled;
		this.sortObjects = source.sortObjects;
		this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
		this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;

		this._drawRanges = source._drawRanges.map( range => ( { ...range } ) );
		this._reservedRanges = source._reservedRanges.map( range => ( { ...range } ) );

		this._visibility = source._visibility.slice();
		this._active = source._active.slice();
		this._bounds = source._bounds.map( bound => ( {
			boxInitialized: bound.boxInitialized,
			box: bound.box.clone(),

			sphereInitialized: bound.sphereInitialized,
			sphere: bound.sphere.clone()
		} ) );

		this._maxGeometryCount = source._maxGeometryCount;
		this._maxVertexCount = source._maxVertexCount;
		this._maxIndexCount = source._maxIndexCount;

		this._geometryInitialized = source._geometryInitialized;
		this._geometryCount = source._geometryCount;
		this._multiDrawCounts = source._multiDrawCounts.slice();
		this._multiDrawStarts = source._multiDrawStarts.slice();

		this._matricesTexture = source._matricesTexture.clone();
		this._matricesTexture.image.data = this._matricesTexture.image.slice();

		return this;

	}

	dispose() {

		// Assuming the geometry is not shared with other meshes
		this.geometry.dispose();

		this._matricesTexture.dispose();
		this._matricesTexture = null;
		return this;

	}

	onBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {

		// if visibility has not changed and frustum culling and object sorting is not required
		// then skip iterating over all items
		if ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {

			return;

		}

		// the indexed version of the multi draw function requires specifying the start
		// offset in bytes.
		const index = geometry.getIndex();
		const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;

		const active = this._active;
		const visibility = this._visibility;
		const multiDrawStarts = this._multiDrawStarts;
		const multiDrawCounts = this._multiDrawCounts;
		const drawRanges = this._drawRanges;
		const perObjectFrustumCulled = this.perObjectFrustumCulled;

		// prepare the frustum in the local frame
		if ( perObjectFrustumCulled ) {

			_projScreenMatrix$2
				.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )
				.multiply( this.matrixWorld );
			_frustum.setFromProjectionMatrix(
				_projScreenMatrix$2,
				renderer.coordinateSystem
			);

		}

		let count = 0;
		if ( this.sortObjects ) {

			// get the camera position in the local frame
			_invMatrixWorld.copy( this.matrixWorld ).invert();
			_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _invMatrixWorld );

			for ( let i = 0, l = visibility.length; i < l; i ++ ) {

				if ( visibility[ i ] && active[ i ] ) {

					// get the bounds in world space
					this.getMatrixAt( i, _matrix$1 );
					this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						culled = ! _frustum.intersectsSphere( _sphere$2 );

					}

					if ( ! culled ) {

						// get the distance from camera used for sorting
						const z = _vector$5.distanceTo( _sphere$2.center );
						_renderList.push( drawRanges[ i ], z );

					}

				}

			}

			// Sort the draw ranges and prep for rendering
			const list = _renderList.list;
			const customSort = this.customSort;
			if ( customSort === null ) {

				list.sort( material.transparent ? sortTransparent : sortOpaque );

			} else {

				customSort.call( this, list, camera );

			}

			for ( let i = 0, l = list.length; i < l; i ++ ) {

				const item = list[ i ];
				multiDrawStarts[ count ] = item.start * bytesPerElement;
				multiDrawCounts[ count ] = item.count;
				count ++;

			}

			_renderList.reset();

		} else {

			for ( let i = 0, l = visibility.length; i < l; i ++ ) {

				if ( visibility[ i ] && active[ i ] ) {

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						// get the bounds in world space
						this.getMatrixAt( i, _matrix$1 );
						this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );
						culled = ! _frustum.intersectsSphere( _sphere$2 );

					}

					if ( ! culled ) {

						const range = drawRanges[ i ];
						multiDrawStarts[ count ] = range.start * bytesPerElement;
						multiDrawCounts[ count ] = range.count;
						count ++;

					}

				}

			}

		}

		this._multiDrawCount = count;
		this._visibilityChanged = false;

	}

	onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {

		this.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vStart = /*@__PURE__*/ new Vector3();
const _vEnd = /*@__PURE__*/ new Vector3();

const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.isLine = true;

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
				_vEnd.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const a = index.getX( end - 1 );
				const b = index.getX( start );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {

	const positionAttribute = object.geometry.attributes.position;

	_vStart.fromBufferAttribute( positionAttribute, a );
	_vEnd.fromBufferAttribute( positionAttribute, b );

	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

	if ( distSq > thresholdSq ) return;

	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

	if ( distance < raycaster.near || distance > raycaster.far ) return;

	return {

		distance: distance,
		// What do we want? intersection point on the ray or on the segment??
		// point: raycaster.ray.at( distance ),
		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
		index: a,
		face: null,
		faceIndex: null,
		object: object

	};

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isVideoTexture = true;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

class FramebufferTexture extends Texture {

	constructor( width, height ) {

		super( { width, height } );

		this.isFramebufferTexture = true;

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isCompressedTexture = true;

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

class CompressedArrayTexture extends CompressedTexture {

	constructor( mipmaps, width, height, depth, format, type ) {

		super( mipmaps, width, height, format, type );

		this.isCompressedArrayTexture = true;
		this.image.depth = depth;
		this.wrapR = ClampToEdgeWrapping;

	}

}

class CompressedCubeTexture extends CompressedTexture {

	constructor( images, format, type ) {

		super( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );

		this.isCompressedCubeTexture = true;
		this.isCubeTexture = true;

		this.image = images;

	}

}

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isCanvasTexture = true;

		this.needsUpdate = true;

	}

}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.isEllipseCurve = true;

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.isArcCurve = true;

		this.type = 'ArcCurve';

	}

}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = /*@__PURE__*/ new Vector3();
const px = /*@__PURE__*/ new CubicPoly();
const py = /*@__PURE__*/ new CubicPoly();
const pz = /*@__PURE__*/ new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.isCatmullRomCurve3 = true;

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.isCubicBezierCurve = true;

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.isCubicBezierCurve3 = true;

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isLineCurve = true;

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector2() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isLineCurve3 = true;

		this.type = 'LineCurve3';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isQuadraticBezierCurve = true;

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isQuadraticBezierCurve3 = true;

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.isSplineCurve = true;

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			const lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';
			this.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );

		}

		return this;

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class CapsuleGeometry extends LatheGeometry {

	constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

		const path = new Path();
		path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
		path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

		super( path.getPoints( capSegments ), radialSegments );

		this.type = 'CapsuleGeometry';

		this.parameters = {
			radius: radius,
			length: length,
			capSegments: capSegments,
			radialSegments: radialSegments,
		};

	}

	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

	}

}

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (Â±1, Â±1, Â±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, Â±1/Ï, Â±Ï)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (Â±1/Ï, Â±Ï, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (Â±Ï, 0, Â±1/Ï)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = /*@__PURE__*/ new Vector3();
const _v1$1 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();
const _triangle = /*@__PURE__*/ new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry = null, thresholdAngle = 1 ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 32767 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim | 0 );
			triangles.push( ear.i / dim | 0 );
			triangles.push( next.i / dim | 0 );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	let p = c.next;
	while ( p !== a ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( x0, y0, minX, minY, invSize ),
		maxZ = zOrder( x1, y1, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim | 0 );
			triangles.push( p.i / dim | 0 );
			triangles.push( b.i / dim | 0 );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
				earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		outerNode = eliminateHole( queue[ i ], outerNode );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole( hole, outerNode ) {

	const bridge = findHoleBridge( hole, outerNode );
	if ( ! bridge ) {

		return outerNode;

	}

	const bridgeReverse = splitPolygon( bridge, hole );

	// filter collinear points around the cuts
	filterPoints( bridgeReverse, bridgeReverse.next );
	return filterPoints( bridge, bridge.next );

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode,
		qx = - Infinity,
		m;

	const hx = hole.x, hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = ( x - minX ) * invSize | 0;
	y = ( y - minY ) * invSize | 0;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
			intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */


class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return pt.clone().addScaledVector( vec, size );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	data.options = Object.assign( {}, options );

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

		super();

		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// indices

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 && thetaStart === 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();

		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.isRawShaderMaterial = true;

		this.type = 'RawShaderMaterial';

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.anisotropyRotation = 0;
		this.anisotropyMap = null;

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = Infinity;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0.0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get anisotropy() {

		return this._anisotropy;

	}

	set anisotropy( value ) {

		if ( this._anisotropy > 0 !== value > 0 ) {

			this.version ++;

		}

		this._anisotropy = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get dispersion() {

		return this._dispersion;

	}

	set dispersion( value ) {

		if ( this._dispersion > 0 !== value > 0 ) {

			this.version ++;

		}

		this._dispersion = value;

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.dispersion = source.dispersion;
		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.isLineDashedMaterial = true;

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

// converts an array to a specific type
function convertArray( array, type, forceClone ) {

	if ( ! array || // let 'undefined' and 'null' pass
		! forceClone && array.constructor === type ) return array;

	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

		return new type( array ); // create typed array

	}

	return Array.prototype.slice.call( array ); // create Array

}

function isTypedArray( object ) {

	return ArrayBuffer.isView( object ) &&
		! ( object instanceof DataView );

}

// returns an array by which times and values can be sorted
function getKeyframeOrder( times ) {

	function compareTime( i, j ) {

		return times[ i ] - times[ j ];

	}

	const n = times.length;
	const result = new Array( n );
	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

	result.sort( compareTime );

	return result;

}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray( values, stride, order ) {

	const nValues = values.length;
	const result = new values.constructor( nValues );

	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

		const srcOffset = order[ i ] * stride;

		for ( let j = 0; j !== stride; ++ j ) {

			result[ dstOffset ++ ] = values[ srcOffset + j ];

		}

	}

	return result;

}

// function for parsing AOS keyframe formats
function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

	let i = 1, key = jsonKeys[ 0 ];

	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

		key = jsonKeys[ i ++ ];

	}

	if ( key === undefined ) return; // no data

	let value = key[ valuePropertyName ];
	if ( value === undefined ) return; // no data

	if ( Array.isArray( value ) ) {

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push.apply( values, value ); // push all elements

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else if ( value.toArray !== undefined ) {

		// ...assume THREE.Math-ish

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				value.toArray( values, values.length );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else {

		// otherwise push as-is

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( value );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	}

}

function subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

	const clip = sourceClip.clone();

	clip.name = name;

	const tracks = [];

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		const track = clip.tracks[ i ];
		const valueSize = track.getValueSize();

		const times = [];
		const values = [];

		for ( let j = 0; j < track.times.length; ++ j ) {

			const frame = track.times[ j ] * fps;

			if ( frame < startFrame || frame >= endFrame ) continue;

			times.push( track.times[ j ] );

			for ( let k = 0; k < valueSize; ++ k ) {

				values.push( track.values[ j * valueSize + k ] );

			}

		}

		if ( times.length === 0 ) continue;

		track.times = convertArray( times, track.times.constructor );
		track.values = convertArray( values, track.values.constructor );

		tracks.push( track );

	}

	clip.tracks = tracks;

	// find minimum .times value across all tracks in the trimmed clip

	let minStartTime = Infinity;

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

			minStartTime = clip.tracks[ i ].times[ 0 ];

		}

	}

	// shift all tracks such that clip begins at t=0

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		clip.tracks[ i ].shift( - 1 * minStartTime );

	}

	clip.resetDuration();

	return clip;

}

function makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

	if ( fps <= 0 ) fps = 30;

	const numTracks = referenceClip.tracks.length;
	const referenceTime = referenceFrame / fps;

	// Make each track's values relative to the values at the reference frame
	for ( let i = 0; i < numTracks; ++ i ) {

		const referenceTrack = referenceClip.tracks[ i ];
		const referenceTrackType = referenceTrack.ValueTypeName;

		// Skip this track if it's non-numeric
		if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

		// Find the track in the target clip whose name and type matches the reference track
		const targetTrack = targetClip.tracks.find( function ( track ) {

			return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

		} );

		if ( targetTrack === undefined ) continue;

		let referenceOffset = 0;
		const referenceValueSize = referenceTrack.getValueSize();

		if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			referenceOffset = referenceValueSize / 3;

		}

		let targetOffset = 0;
		const targetValueSize = targetTrack.getValueSize();

		if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			targetOffset = targetValueSize / 3;

		}

		const lastIndex = referenceTrack.times.length - 1;
		let referenceValue;

		// Find the value to subtract out of the track
		if ( referenceTime <= referenceTrack.times[ 0 ] ) {

			// Reference frame is earlier than the first keyframe, so just use the first keyframe
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

			// Reference frame is after the last keyframe, so just use the last keyframe
			const startIndex = lastIndex * referenceValueSize + referenceOffset;
			const endIndex = startIndex + referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else {

			// Interpolate to the reference value
			const interpolant = referenceTrack.createInterpolant();
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			interpolant.evaluate( referenceTime );
			referenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );

		}

		// Conjugate the quaternion
		if ( referenceTrackType === 'quaternion' ) {

			const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
			referenceQuat.toArray( referenceValue );

		}

		// Subtract the reference value from all of the track values

		const numTimes = targetTrack.times.length;
		for ( let j = 0; j < numTimes; ++ j ) {

			const valueStart = j * targetValueSize + targetOffset;

			if ( referenceTrackType === 'quaternion' ) {

				// Multiply the conjugate for quaternion track types
				Quaternion.multiplyQuaternionsFlat(
					targetTrack.values,
					valueStart,
					referenceValue,
					0,
					targetTrack.values,
					valueStart
				);

			} else {

				const valueEnd = targetValueSize - targetOffset * 2;

				// Subtract each value for all other numeric track types
				for ( let k = 0; k < valueEnd; ++ k ) {

					targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

				}

			}

		}

	}

	targetClip.blendMode = AdditiveAnimationBlendMode;

	return targetClip;

}

const AnimationUtils = {
	convertArray: convertArray,
	isTypedArray: isTypedArray,
	getKeyframeOrder: getKeyframeOrder,
	sortedArray: sortedArray,
	flattenJSON: flattenJSON,
	subclip: subclip,
	makeClipAdditive: makeClipAdditive
};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = convertArray( times, this.TimeBufferType );
		this.values = convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': convertArray( track.times, Array ),
				'values': convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = times.slice( from, to );
			this.values = this.values.slice( from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = this.times.slice(),
			values = this.values.slice(),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = times.slice( 0, writeIndex );
			this.values = values.slice( 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = this.times.slice();
		const values = this.values.slice();

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = getKeyframeOrder( times );
			times = sortedArray( times, 1, order );
			values = sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();

					// Nginx needs X-File-Size check
					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();
		texture.colorSpace = SRGBColorSpace;

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			let texData;

			try {

				texData = scope.parse( buffer );

			} catch ( error ) {

				if ( onError !== undefined ) {

					onError( error );

				} else {

					console.error( error );
					return;

				}

			}

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.colorSpace !== undefined ) {

				texture.colorSpace = texData.colorSpace;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( _projScreenMatrix$1 );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay;

		this.map = null;

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = Ï * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay;

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 Ï luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.isRectAreaLight = true;

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.isSphericalHarmonics3 = true;

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // Ï * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * Ï / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( Ï / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( Ï / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( Ï / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.isLightProbe = true;

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = MaterialLoader.createMaterialFromType( json.type );

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.dispersion !== undefined ) material.dispersion = json.dispersion;
		if ( json.iridescence !== undefined ) material.iridescence = json.iridescence;
		if ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;
		if ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;
		if ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;
		if ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;
		if ( json.blendDst !== undefined ) material.blendDst = json.blendDst;
		if ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;
		if ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;
		if ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;
		if ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;
		if ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );
		if ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;
		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== undefined ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;
		if ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		if ( json.lights !== undefined ) material.lights = json.lights;
		if ( json.clipping !== undefined ) material.clipping = json.clipping;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );
		if ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

	static createMaterialFromType( type ) {

		const materialLib = {
			ShadowMaterial,
			SpriteMaterial,
			RawShaderMaterial,
			ShaderMaterial,
			PointsMaterial,
			MeshPhysicalMaterial,
			MeshStandardMaterial,
			MeshPhongMaterial,
			MeshToonMaterial,
			MeshNormalMaterial,
			MeshLambertMaterial,
			MeshDepthMaterial,
			MeshDistanceMaterial,
			MeshBasicMaterial,
			MeshMatcapMaterial,
			LineDashedMaterial,
			LineBasicMaterial,
			Material
		};

		return new materialLib[ type ]();

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.isInstancedBufferGeometry = true;

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				if ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\'t load ' + url ) );

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ].data instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );
						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( cache[ data.uuid ] === undefined ) {

					cache[ data.uuid ] = loader.parse( data );

				}

				materials[ data.uuid ] = cache[ data.uuid ];

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );


				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				const source = images[ data.image ];
				const image = source.data;

				let texture;

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture();

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture();

					} else {

						texture = new Texture();

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.source = source;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
				if ( data.channel !== undefined ) texture.channel = data.channel;

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;
				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
				if ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

					if ( data.fog.name !== '' ) {

						object.fog.name = data.fog.name;

					}

				}

				if ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;
				if ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;
				if ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );

				if ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;
				if ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'BatchedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new BatchedMesh( data.maxGeometryCount, data.maxVertexCount, data.maxIndexCount, material );
				object.geometry = geometry;
				object.perObjectFrustumCulled = data.perObjectFrustumCulled;
				object.sortObjects = data.sortObjects;

				object._drawRanges = data.drawRanges;
				object._reservedRanges = data.reservedRanges;

				object._visibility = data.visibility;
				object._active = data.active;
				object._bounds = data.bounds.map( bound => {

					const box = new Box3();
					box.min.fromArray( bound.boxMin );
					box.max.fromArray( bound.boxMax );

					const sphere = new Sphere();
					sphere.radius = bound.sphereRadius;
					sphere.center.fromArray( bound.sphereCenter );

					return {
						boxInitialized: bound.boxInitialized,
						box: box,

						sphereInitialized: bound.sphereInitialized,
						sphere: sphere
					};

				} );

				object._maxGeometryCount = data.maxGeometryCount;
				object._maxVertexCount = data.maxVertexCount;
				object._maxIndexCount = data.maxIndexCount;

				object._geometryInitialized = data.geometryInitialized;
				object._geometryCount = data.geometryCount;

				object._matricesTexture = getTexture( data.matricesTexture.uuid );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.up !== undefined ) object.up.fromArray( data.up );

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance, level.hysteresis );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			// If cached is a promise, wait for it to resolve
			if ( cached.then ) {

				cached.then( imageBitmap => {

					if ( onLoad ) onLoad( imageBitmap );

					scope.manager.itemEnd( url );

				} ).catch( e => {

					if ( onError ) onError( e );

				} );
				return;

			}

			// If cached is not a promise (i.e., it's already an imageBitmap)
			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		const promise = fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

			return imageBitmap;

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			Cache.remove( url );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		Cache.add( url, promise );
		scope.manager.itemStart( url );

	}

}

let _context;

class AudioContext {

	static getContext() {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	}

	static setContext( value ) {

		_context = value;

	}

}

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} ).catch( handleError );

			} catch ( e ) {

				handleError( e );

			}

		}, onProgress, onError );

		function handleError( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );

		}

	}

}

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
const _projectionMatrix = /*@__PURE__*/ new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy( camera.projectionMatrix );
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( _projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( _projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		if ( this.source !== null ) {

			this.source.stop();
			this.source.onended = null;

		}

		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this._connected === false ) {

			return;

		}

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.isPlaying === true && this.source.detune !== undefined ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	connect() {

		super.connect();

		this.panner.connect( this.gain );

	}

	disconnect() {

		super.disconnect();

		this.panner.disconnect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				case 'map':

					if ( 'map' in targetObject ) {

						targetObject = targetObject.map;
						break;

					}

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.map ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
						return;

					}

					targetObject = targetObject.material.map;
					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.isAnimationObjectGroup = true;

		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				deltaTime = 0;

			} else {


				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

const _controlInterpolantsResultBuffer = new Float32Array( 1 );


class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				++ binding.referenceCount;
				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, _controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

class Uniform {

	constructor( value ) {

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

let _id = 0;

class UniformsGroup extends EventDispatcher {

	constructor() {

		super();

		this.isUniformsGroup = true;

		Object.defineProperty( this, 'id', { value: _id ++ } );

		this.name = '';

		this.usage = StaticDrawUsage;
		this.uniforms = [];

	}

	add( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	remove( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== - 1 ) this.uniforms.splice( index, 1 );

		return this;

	}

	setName( name ) {

		this.name = name;

		return this;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.usage = source.usage;

		const uniformsSource = source.uniforms;

		this.uniforms.length = 0;

		for ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {

			const uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];

			for ( let j = 0; j < uniforms.length; j ++ ) {

				this.uniforms.push( uniforms[ j ].clone() );

			}

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.isInstancedInterleavedBuffer = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

class GLBufferAttribute {

	constructor( buffer, type, itemSize, elementSize, count ) {

		this.isGLBufferAttribute = true;

		this.name = '';

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	setCount( count ) {

		this.count = count;

		return this;

	}

}

const _matrix = /*@__PURE__*/ new Matrix4();

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	setFromXRController( controller ) {

		_matrix.identity().extractRotation( controller.matrixWorld );

		this.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		this.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );

		return this;

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersect( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersect( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersect( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersect( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
 * theta (the azimuthal angle) is measured from the positive z-axis.
 */
class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.isBox2 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$4 ).distanceTo( point );

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();

		this.light = light;

		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'SpotLightHelper';

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		// update the local matrix based on the parent and light target transforms
		if ( this.parent ) {

			this.parent.updateWorldMatrix( true );

			this.matrix
				.copy( this.parent.matrixWorld )
				.invert()
				.multiply( this.light.matrixWorld );

		} else {

			this.matrix.copy( this.light.matrixWorld );

		}

		this.matrixWorld.copy( this.light.matrixWorld );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.isSkeletonHelper = true;

		this.type = 'SkeletonHelper';

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object.isBone === true ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'HemisphereLightHelper';

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		this.light.updateWorldMatrix( true, false );

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the sectors

		if ( sectors > 1 ) {

			for ( let i = 0; i < sectors; i ++ ) {

				const v = ( i / sectors ) * ( Math.PI * 2 );

				const x = Math.sin( v ) * radius;
				const z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				const color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

		}

		// create the rings

		for ( let i = 0; i < rings; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / rings * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'DirectionalLightHelper';

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// near

		addLine( 'n1', 'n2' );
		addLine( 'n2', 'n4' );
		addLine( 'n4', 'n3' );
		addLine( 'n3', 'n1' );

		// far

		addLine( 'f1', 'f2' );
		addLine( 'f2', 'f4' );
		addLine( 'f4', 'f3' );
		addLine( 'f3', 'f1' );

		// sides

		addLine( 'n1', 'f1' );
		addLine( 'n2', 'f2' );
		addLine( 'n3', 'f3' );
		addLine( 'n4', 'f4' );

		// cone

		addLine( 'p', 'n1' );
		addLine( 'p', 'n2' );
		addLine( 'p', 'n3' );
		addLine( 'p', 'n4' );

		// up

		addLine( 'u1', 'u2' );
		addLine( 'u2', 'u3' );
		addLine( 'u3', 'u1' );

		// target

		addLine( 'c', 't' );
		addLine( 'p', 'c' );

		// cross

		addLine( 'cn1', 'cn2' );
		addLine( 'cn3', 'cn4' );

		addLine( 'cf1', 'cf2' );
		addLine( 'cf3', 'cf4' );

		function addLine( a, b ) {

			addPoint( a );
			addPoint( b );

		}

		function addPoint( id ) {

			vertices.push( 0, 0, 0 );
			colors.push( 0, 0, 0 );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		this.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );

	}

	setColors( frustum, cone, up, target, cross ) {

		const geometry = this.geometry;

		const colorAttribute = geometry.getAttribute( 'color' );

		// near

		colorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2
		colorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4
		colorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3
		colorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1

		// far

		colorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2
		colorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4
		colorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3
		colorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1

		// sides

		colorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1
		colorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2
		colorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3
		colorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4

		// cone

		colorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1
		colorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2
		colorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3
		colorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4

		// up

		colorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2
		colorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3
		colorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1

		// target

		colorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t
		colorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c

		// cross

		colorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2
		colorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4

		colorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2
		colorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4

		colorAttribute.needsUpdate = true;

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.object = source.object;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		this.position.set( 0, 0, 0 );

		this.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );

		this.lookAt( this.plane.normal );

		this.translateZ( - this.plane.constant );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

	dispose() {

		this.line.geometry.dispose();
		this.line.material.dispose();
		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			let toChange = 0;

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange ++;

							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}

			if ( toChange > 0 && ambiguous === false ) {

				newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

class WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162

	constructor( width = 1, height = 1, count = 1, options = {} ) {

		console.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.' );

		super( width, height, { ...options, count } );

		this.isWebGLMultipleRenderTargets = true;

	}

	get texture() {

		return this.textures;

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };
const _ray = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();
const _plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();
const TILT_LIMIT = Math.cos( 70 * three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD );

class OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
		this.cursor = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// Limit camera target within a spherical area around the cursor
		this.minTargetRadius = 0;
		this.maxTargetRadius = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
		this.zoomToCursor = false;

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			// so camera.up is the orbit axis
			const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			const lastTargetPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			const twoPI = 2 * Math.PI;

			return function update( deltaTime = null ) {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle( deltaTime ) );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				// Limit the target distance from the cursor to create a sphere around the center of interest
				scope.target.sub( scope.cursor );
				scope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );
				scope.target.add( scope.cursor );

				let zoomChanged = false;
				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
				// we adjust zoom later in these cases
				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

					spherical.radius = clampDistance( spherical.radius );

				} else {

					const prevRadius = spherical.radius;
					spherical.radius = clampDistance( spherical.radius * scale );
					zoomChanged = prevRadius != spherical.radius;

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				// adjust camera position
				if ( scope.zoomToCursor && performCursorZoom ) {

					let newRadius = null;
					if ( scope.object.isPerspectiveCamera ) {

						// move the camera down the pointer ray
						// this method avoids floating point error
						const prevRadius = offset.length();
						newRadius = clampDistance( prevRadius * scale );

						const radiusDelta = prevRadius - newRadius;
						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
						scope.object.updateMatrixWorld();

						zoomChanged = !! radiusDelta;

					} else if ( scope.object.isOrthographicCamera ) {

						// adjust the ortho camera position based on zoom changes
						const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( mouse.x, mouse.y, 0 );
						mouseBefore.unproject( scope.object );

						const prevZoom = scope.object.zoom;
						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
						scope.object.updateProjectionMatrix();

						zoomChanged = prevZoom !== scope.object.zoom;

						const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( mouse.x, mouse.y, 0 );
						mouseAfter.unproject( scope.object );

						scope.object.position.sub( mouseAfter ).add( mouseBefore );
						scope.object.updateMatrixWorld();

						newRadius = offset.length();

					} else {

						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
						scope.zoomToCursor = false;

					}

					// handle the placement of the target
					if ( newRadius !== null ) {

						if ( this.screenSpacePanning ) {

							// position the orbit target in front of the new camera position
							scope.target.set( 0, 0, - 1 )
								.transformDirection( scope.object.matrix )
								.multiplyScalar( newRadius )
								.add( scope.object.position );

						} else {

							// get the ray and translation plane to compute target
							_ray.origin.copy( scope.object.position );
							_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );

							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
							// extremely large values
							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

								object.lookAt( scope.target );

							} else {

								_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
								_ray.intersectPlane( _plane, scope.target );

							}

						}

					}

				} else if ( scope.object.isOrthographicCamera ) {

					const prevZoom = scope.object.zoom;
					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );

					if ( prevZoom !== scope.object.zoom ) {

						scope.object.updateProjectionMatrix();
						zoomChanged = true;

					}

				}

				scale = 1;
				performCursorZoom = false;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
					lastTargetPosition.distanceToSquared( scope.target ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					lastTargetPosition.copy( scope.target );

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

			document.removeEventListener( 'keydown', interceptControlDown, { capture: true } );

			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();
		const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();

		let scale = 1;
		const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		let performCursorZoom = false;

		const pointers = [];
		const pointerPositions = {};

		let controlActive = false;

		function getAutoRotationAngle( deltaTime ) {

			if ( deltaTime !== null ) {

				return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;

			} else {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

		}

		function getZoomScale( delta ) {

			const normalizedDelta = Math.abs( delta * 0.01 );
			return Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale /= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale *= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function updateZoomParameters( x, y ) {

			if ( ! scope.zoomToCursor ) {

				return;

			}

			performCursorZoom = true;

			const rect = scope.domElement.getBoundingClientRect();
			const dx = x - rect.left;
			const dy = y - rect.top;
			const w = rect.width;
			const h = rect.height;

			mouse.x = ( dx / w ) * 2 - 1;
			mouse.y = - ( dy / h ) * 2 + 1;

			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();

		}

		function clampDistance( dist ) {

			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			updateZoomParameters( event.clientX, event.clientX );
			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale( dollyDelta.y ) );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale( dollyDelta.y ) );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			updateZoomParameters( event.clientX, event.clientY );

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale( event.deltaY ) );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale( event.deltaY ) );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate( event ) {

			if ( pointers.length === 1 ) {

				rotateStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan( event ) {

			if ( pointers.length === 1 ) {

				panStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enablePan ) handleTouchStartPan( event );

		}

		function handleTouchStartDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enableRotate ) handleTouchStartRotate( event );

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

			const centerX = ( event.pageX + position.x ) * 0.5;
			const centerY = ( event.pageY + position.y ) * 0.5;

			updateZoomParameters( centerX, centerY );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			if ( isTrackingPointer( event ) ) return;

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			removePointer( event );

			switch ( pointers.length ) {

				case 0:

					scope.domElement.releasePointerCapture( event.pointerId );

					scope.domElement.removeEventListener( 'pointermove', onPointerMove );
					scope.domElement.removeEventListener( 'pointerup', onPointerUp );

					scope.dispatchEvent( _endEvent );

					state = STATE.NONE;

					break;

				case 1:

					const pointerId = pointers[ 0 ];
					const position = pointerPositions[ pointerId ];

					// minimal placeholder event - allows state correction on pointer-up
					onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

					break;

			}

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( customWheelEvent( event ) );

			scope.dispatchEvent( _endEvent );

		}

		function customWheelEvent( event ) {

			const mode = event.deltaMode;

			// minimal wheel event altered to meet delta-zoom demand
			const newEvent = {
				clientX: event.clientX,
				clientY: event.clientY,
				deltaY: event.deltaY,
			};

			switch ( mode ) {

				case 1: // LINE_MODE
					newEvent.deltaY *= 16;
					break;

				case 2: // PAGE_MODE
					newEvent.deltaY *= 100;
					break;

			}

			// detect if event was triggered by pinching
			if ( event.ctrlKey && ! controlActive ) {

				newEvent.deltaY *= 10;

			}

			return newEvent;

		}

		function interceptControlDown( event ) {

			if ( event.key === 'Control' ) {

				controlActive = true;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function interceptControlUp( event ) {

			if ( event.key === 'Control' ) {

				controlActive = false;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate( event );

							state = STATE.TOUCH_ROTATE;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan( event );

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan( event );

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate( event );

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event.pointerId );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function isTrackingPointer( event ) {

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) return true;

			}

			return false;

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

		document.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );

		// force an update at start

		this.update();

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/GLTFExporter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/GLTFExporter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFExporter: () => (/* binding */ GLTFExporter)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _utils_TextureUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils/TextureUtils.js */ "./node_modules/three/examples/jsm/utils/TextureUtils.js");




/**
 * The KHR_mesh_quantization extension allows these extra attribute component types
 *
 * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes
 */
const KHR_mesh_quantization_ExtraAttrTypes = {
	POSITION: [
		'byte',
		'byte normalized',
		'unsigned byte',
		'unsigned byte normalized',
		'short',
		'short normalized',
		'unsigned short',
		'unsigned short normalized',
	],
	NORMAL: [
		'byte normalized',
		'short normalized',
	],
	TANGENT: [
		'byte normalized',
		'short normalized',
	],
	TEXCOORD: [
		'byte',
		'byte normalized',
		'unsigned byte',
		'short',
		'short normalized',
		'unsigned short',
	],
};


class GLTFExporter {

	constructor() {

		this.pluginCallbacks = [];

		this.register( function ( writer ) {

			return new GLTFLightExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsUnlitExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsTransmissionExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsVolumeExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsIorExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsSpecularExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsClearcoatExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsDispersionExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsIridescenceExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsSheenExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsAnisotropyExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsEmissiveStrengthExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsBumpExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMeshGpuInstancing( writer );

		} );

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Function} onError  Callback on errors
	 * @param  {Object} options options
	 */
	parse( input, onDone, onError, options ) {

		const writer = new GLTFWriter();
		const plugins = [];

		for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {

			plugins.push( this.pluginCallbacks[ i ]( writer ) );

		}

		writer.setPlugins( plugins );
		writer.write( input, onDone, options ).catch( onError );

	}

	parseAsync( input, options ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( input, resolve, reject, options );

		} );

	}

}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const WEBGL_CONSTANTS = {
	POINTS: 0x0000,
	LINES: 0x0001,
	LINE_LOOP: 0x0002,
	LINE_STRIP: 0x0003,
	TRIANGLES: 0x0004,
	TRIANGLE_STRIP: 0x0005,
	TRIANGLE_FAN: 0x0006,

	BYTE: 0x1400,
	UNSIGNED_BYTE: 0x1401,
	SHORT: 0x1402,
	UNSIGNED_SHORT: 0x1403,
	INT: 0x1404,
	UNSIGNED_INT: 0x1405,
	FLOAT: 0x1406,

	ARRAY_BUFFER: 0x8892,
	ELEMENT_ARRAY_BUFFER: 0x8893,

	NEAREST: 0x2600,
	LINEAR: 0x2601,
	NEAREST_MIPMAP_NEAREST: 0x2700,
	LINEAR_MIPMAP_NEAREST: 0x2701,
	NEAREST_MIPMAP_LINEAR: 0x2702,
	LINEAR_MIPMAP_LINEAR: 0x2703,

	CLAMP_TO_EDGE: 33071,
	MIRRORED_REPEAT: 33648,
	REPEAT: 10497
};

const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';

const THREE_TO_WEBGL = {};

THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;

THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;

const PATH_PROPERTIES = {
	scale: 'scale',
	position: 'translation',
	quaternion: 'rotation',
	morphTargetInfluences: 'weights'
};

const DEFAULT_SPECULAR_COLOR = new three__WEBPACK_IMPORTED_MODULE_0__.Color();

// GLB constants
// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

const GLB_HEADER_BYTES = 12;
const GLB_HEADER_MAGIC = 0x46546C67;
const GLB_VERSION = 2;

const GLB_CHUNK_PREFIX_BYTES = 8;
const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
const GLB_CHUNK_TYPE_BIN = 0x004E4942;

//------------------------------------------------------------------------------
// Utility functions
//------------------------------------------------------------------------------

/**
 * Compare two arrays
 * @param  {Array} array1 Array 1 to compare
 * @param  {Array} array2 Array 2 to compare
 * @return {Boolean}        Returns true if both arrays are equal
 */
function equalArray( array1, array2 ) {

	return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

		return element === array2[ index ];

	} );

}

/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */
function stringToArrayBuffer( text ) {

	return new TextEncoder().encode( text ).buffer;

}

/**
 * Is identity matrix
 *
 * @param {Matrix4} matrix
 * @returns {Boolean} Returns true, if parameter is identity matrix
 */
function isIdentityMatrix( matrix ) {

	return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );

}

/**
 * Get the min and max vectors from the given attribute
 * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
 * @param  {Integer} start
 * @param  {Integer} count
 * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
 */
function getMinMax( attribute, start, count ) {

	const output = {

		min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
		max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

	};

	for ( let i = start; i < start + count; i ++ ) {

		for ( let a = 0; a < attribute.itemSize; a ++ ) {

			let value;

			if ( attribute.itemSize > 4 ) {

				 // no support for interleaved data for itemSize > 4

				value = attribute.array[ i * attribute.itemSize + a ];

			} else {

				if ( a === 0 ) value = attribute.getX( i );
				else if ( a === 1 ) value = attribute.getY( i );
				else if ( a === 2 ) value = attribute.getZ( i );
				else if ( a === 3 ) value = attribute.getW( i );

				if ( attribute.normalized === true ) {

					value = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.normalize( value, attribute.array );

				}

			}

			output.min[ a ] = Math.min( output.min[ a ], value );
			output.max[ a ] = Math.max( output.max[ a ], value );

		}

	}

	return output;

}

/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */
function getPaddedBufferSize( bufferSize ) {

	return Math.ceil( bufferSize / 4 ) * 4;

}

/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {ArrayBuffer} arrayBuffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */
function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {

	const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

	if ( paddedLength !== arrayBuffer.byteLength ) {

		const array = new Uint8Array( paddedLength );
		array.set( new Uint8Array( arrayBuffer ) );

		if ( paddingByte !== 0 ) {

			for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

				array[ i ] = paddingByte;

			}

		}

		return array.buffer;

	}

	return arrayBuffer;

}

function getCanvas() {

	if ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {

		return new OffscreenCanvas( 1, 1 );

	}

	return document.createElement( 'canvas' );

}

function getToBlobPromise( canvas, mimeType ) {

	if ( canvas.toBlob !== undefined ) {

		return new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );

	}

	let quality;

	// Blink's implementation of convertToBlob seems to default to a quality level of 100%
	// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.
	if ( mimeType === 'image/jpeg' ) {

		quality = 0.92;

	} else if ( mimeType === 'image/webp' ) {

		quality = 0.8;

	}

	return canvas.convertToBlob( {

		type: mimeType,
		quality: quality

	} );

}

/**
 * Writer
 */
class GLTFWriter {

	constructor() {

		this.plugins = [];

		this.options = {};
		this.pending = [];
		this.buffers = [];

		this.byteOffset = 0;
		this.buffers = [];
		this.nodeMap = new Map();
		this.skins = [];

		this.extensionsUsed = {};
		this.extensionsRequired = {};

		this.uids = new Map();
		this.uid = 0;

		this.json = {
			asset: {
				version: '2.0',
				generator: 'THREE.GLTFExporter r' + three__WEBPACK_IMPORTED_MODULE_0__.REVISION
			}
		};

		this.cache = {
			meshes: new Map(),
			attributes: new Map(),
			attributesNormalized: new Map(),
			materials: new Map(),
			textures: new Map(),
			images: new Map()
		};

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Object} options options
	 */
	async write( input, onDone, options = {} ) {

		this.options = Object.assign( {
			// default options
			binary: false,
			trs: false,
			onlyVisible: true,
			maxTextureSize: Infinity,
			animations: [],
			includeCustomExtensions: false
		}, options );

		if ( this.options.animations.length > 0 ) {

			// Only TRS properties, and not matrices, may be targeted by animation.
			this.options.trs = true;

		}

		this.processInput( input );

		await Promise.all( this.pending );

		const writer = this;
		const buffers = writer.buffers;
		const json = writer.json;
		options = writer.options;

		const extensionsUsed = writer.extensionsUsed;
		const extensionsRequired = writer.extensionsRequired;

		// Merge buffers.
		const blob = new Blob( buffers, { type: 'application/octet-stream' } );

		// Declare extensions.
		const extensionsUsedList = Object.keys( extensionsUsed );
		const extensionsRequiredList = Object.keys( extensionsRequired );

		if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;
		if ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;

		// Update bytelength of the single buffer.
		if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

		if ( options.binary === true ) {

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

			const reader = new FileReader();
			reader.readAsArrayBuffer( blob );
			reader.onloadend = function () {

				// Binary chunk.
				const binaryChunk = getPaddedArrayBuffer( reader.result );
				const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
				binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
				binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

				// JSON chunk.
				const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );
				const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
				jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
				jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

				// GLB header.
				const header = new ArrayBuffer( GLB_HEADER_BYTES );
				const headerView = new DataView( header );
				headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
				headerView.setUint32( 4, GLB_VERSION, true );
				const totalByteLength = GLB_HEADER_BYTES
					+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
					+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
				headerView.setUint32( 8, totalByteLength, true );

				const glbBlob = new Blob( [
					header,
					jsonChunkPrefix,
					jsonChunk,
					binaryChunkPrefix,
					binaryChunk
				], { type: 'application/octet-stream' } );

				const glbReader = new FileReader();
				glbReader.readAsArrayBuffer( glbBlob );
				glbReader.onloadend = function () {

					onDone( glbReader.result );

				};

			};

		} else {

			if ( json.buffers && json.buffers.length > 0 ) {

				const reader = new FileReader();
				reader.readAsDataURL( blob );
				reader.onloadend = function () {

					const base64data = reader.result;
					json.buffers[ 0 ].uri = base64data;
					onDone( json );

				};

			} else {

				onDone( json );

			}

		}


	}

	/**
	 * Serializes a userData.
	 *
	 * @param {THREE.Object3D|THREE.Material} object
	 * @param {Object} objectDef
	 */
	serializeUserData( object, objectDef ) {

		if ( Object.keys( object.userData ).length === 0 ) return;

		const options = this.options;
		const extensionsUsed = this.extensionsUsed;

		try {

			const json = JSON.parse( JSON.stringify( object.userData ) );

			if ( options.includeCustomExtensions && json.gltfExtensions ) {

				if ( objectDef.extensions === undefined ) objectDef.extensions = {};

				for ( const extensionName in json.gltfExtensions ) {

					objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];
					extensionsUsed[ extensionName ] = true;

				}

				delete json.gltfExtensions;

			}

			if ( Object.keys( json ).length > 0 ) objectDef.extras = json;

		} catch ( error ) {

			console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' +
				'won\'t be serialized because of JSON.stringify error - ' + error.message );

		}

	}

	/**
	 * Returns ids for buffer attributes.
	 * @param  {Object} object
	 * @return {Integer}
	 */
	getUID( attribute, isRelativeCopy = false ) {

		if ( this.uids.has( attribute ) === false ) {

			const uids = new Map();

			uids.set( true, this.uid ++ );
			uids.set( false, this.uid ++ );

			this.uids.set( attribute, uids );

		}

		const uids = this.uids.get( attribute );

		return uids.get( isRelativeCopy );

	}

	/**
	 * Checks if normal attribute values are normalized.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {Boolean}
	 */
	isNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) ) return false;

		const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		for ( let i = 0, il = normal.count; i < il; i ++ ) {

			// 0.0005 is from glTF-validator
			if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;

		}

		return true;

	}

	/**
	 * Creates normalized normal buffer attribute.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {BufferAttribute}
	 *
	 */
	createNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) )	return cache.attributesNormalized.get( normal );

		const attribute = normal.clone();
		const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			v.fromBufferAttribute( attribute, i );

			if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

				// if values can't be normalized set (1, 0, 0)
				v.setX( 1.0 );

			} else {

				v.normalize();

			}

			attribute.setXYZ( i, v.x, v.y, v.z );

		}

		cache.attributesNormalized.set( normal, attribute );

		return attribute;

	}

	/**
	 * Applies a texture transform, if present, to the map definition. Requires
	 * the KHR_texture_transform extension.
	 *
	 * @param {Object} mapDef
	 * @param {THREE.Texture} texture
	 */
	applyTextureTransform( mapDef, texture ) {

		let didTransform = false;
		const transformDef = {};

		if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

			transformDef.offset = texture.offset.toArray();
			didTransform = true;

		}

		if ( texture.rotation !== 0 ) {

			transformDef.rotation = texture.rotation;
			didTransform = true;

		}

		if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

			transformDef.scale = texture.repeat.toArray();
			didTransform = true;

		}

		if ( didTransform ) {

			mapDef.extensions = mapDef.extensions || {};
			mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
			this.extensionsUsed[ 'KHR_texture_transform' ] = true;

		}

	}

	buildMetalRoughTexture( metalnessMap, roughnessMap ) {

		if ( metalnessMap === roughnessMap ) return metalnessMap;

		function getEncodingConversion( map ) {

			if ( map.colorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace ) {

				return function SRGBToLinear( c ) {

					return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

				};

			}

			return function LinearToLinear( c ) {

				return c;

			};

		}

		console.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );

		if ( metalnessMap instanceof three__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture ) {

			metalnessMap = (0,_utils_TextureUtils_js__WEBPACK_IMPORTED_MODULE_1__.decompress)( metalnessMap );

		}

		if ( roughnessMap instanceof three__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture ) {

			roughnessMap = (0,_utils_TextureUtils_js__WEBPACK_IMPORTED_MODULE_1__.decompress)( roughnessMap );

		}

		const metalness = metalnessMap ? metalnessMap.image : null;
		const roughness = roughnessMap ? roughnessMap.image : null;

		const width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );
		const height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );

		const canvas = getCanvas();
		canvas.width = width;
		canvas.height = height;

		const context = canvas.getContext( '2d' );
		context.fillStyle = '#00ffff';
		context.fillRect( 0, 0, width, height );

		const composite = context.getImageData( 0, 0, width, height );

		if ( metalness ) {

			context.drawImage( metalness, 0, 0, width, height );

			const convert = getEncodingConversion( metalnessMap );
			const data = context.getImageData( 0, 0, width, height ).data;

			for ( let i = 2; i < data.length; i += 4 ) {

				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

			}

		}

		if ( roughness ) {

			context.drawImage( roughness, 0, 0, width, height );

			const convert = getEncodingConversion( roughnessMap );
			const data = context.getImageData( 0, 0, width, height ).data;

			for ( let i = 1; i < data.length; i += 4 ) {

				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

			}

		}

		context.putImageData( composite, 0, 0 );

		//

		const reference = metalnessMap || roughnessMap;

		const texture = reference.clone();

		texture.source = new three__WEBPACK_IMPORTED_MODULE_0__.Source( canvas );
		texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;
		texture.channel = ( metalnessMap || roughnessMap ).channel;

		if ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {

			console.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );

		}

		return texture;

	}

	/**
	 * Process a buffer to append to the default one.
	 * @param  {ArrayBuffer} buffer
	 * @return {Integer}
	 */
	processBuffer( buffer ) {

		const json = this.json;
		const buffers = this.buffers;

		if ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];

		// All buffers are merged before export.
		buffers.push( buffer );

		return 0;

	}

	/**
	 * Process and generate a BufferView
	 * @param  {BufferAttribute} attribute
	 * @param  {number} componentType
	 * @param  {number} start
	 * @param  {number} count
	 * @param  {number} target (Optional) Target usage of the BufferView
	 * @return {Object}
	 */
	processBufferView( attribute, componentType, start, count, target ) {

		const json = this.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		// Create a new dataview and dump the attribute's array into it

		let componentSize;

		switch ( componentType ) {

			case WEBGL_CONSTANTS.BYTE:
			case WEBGL_CONSTANTS.UNSIGNED_BYTE:

				componentSize = 1;

				break;

			case WEBGL_CONSTANTS.SHORT:
			case WEBGL_CONSTANTS.UNSIGNED_SHORT:

				componentSize = 2;

				break;

			default:

				componentSize = 4;

		}

		let byteStride = attribute.itemSize * componentSize;

		if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

			// Each element of a vertex attribute MUST be aligned to 4-byte boundaries
			// inside a bufferView
			byteStride = Math.ceil( byteStride / 4 ) * 4;

		}

		const byteLength = getPaddedBufferSize( count * byteStride );
		const dataView = new DataView( new ArrayBuffer( byteLength ) );
		let offset = 0;

		for ( let i = start; i < start + count; i ++ ) {

			for ( let a = 0; a < attribute.itemSize; a ++ ) {

				let value;

				if ( attribute.itemSize > 4 ) {

					 // no support for interleaved data for itemSize > 4

					value = attribute.array[ i * attribute.itemSize + a ];

				} else {

					if ( a === 0 ) value = attribute.getX( i );
					else if ( a === 1 ) value = attribute.getY( i );
					else if ( a === 2 ) value = attribute.getZ( i );
					else if ( a === 3 ) value = attribute.getW( i );

					if ( attribute.normalized === true ) {

						value = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.normalize( value, attribute.array );

					}

				}

				if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

					dataView.setFloat32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.INT ) {

					dataView.setInt32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

					dataView.setUint32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {

					dataView.setInt16( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

					dataView.setUint16( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {

					dataView.setInt8( offset, value );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

					dataView.setUint8( offset, value );

				}

				offset += componentSize;

			}

			if ( ( offset % byteStride ) !== 0 ) {

				offset += byteStride - ( offset % byteStride );

			}

		}

		const bufferViewDef = {

			buffer: this.processBuffer( dataView.buffer ),
			byteOffset: this.byteOffset,
			byteLength: byteLength

		};

		if ( target !== undefined ) bufferViewDef.target = target;

		if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

			// Only define byteStride for vertex attributes.
			bufferViewDef.byteStride = byteStride;

		}

		this.byteOffset += byteLength;

		json.bufferViews.push( bufferViewDef );

		// @TODO Merge bufferViews where possible.
		const output = {

			id: json.bufferViews.length - 1,
			byteLength: 0

		};

		return output;

	}

	/**
	 * Process and generate a BufferView from an image Blob.
	 * @param {Blob} blob
	 * @return {Promise<Integer>}
	 */
	processBufferViewImage( blob ) {

		const writer = this;
		const json = writer.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		return new Promise( function ( resolve ) {

			const reader = new FileReader();
			reader.readAsArrayBuffer( blob );
			reader.onloadend = function () {

				const buffer = getPaddedArrayBuffer( reader.result );

				const bufferViewDef = {
					buffer: writer.processBuffer( buffer ),
					byteOffset: writer.byteOffset,
					byteLength: buffer.byteLength
				};

				writer.byteOffset += buffer.byteLength;
				resolve( json.bufferViews.push( bufferViewDef ) - 1 );

			};

		} );

	}

	/**
	 * Process attribute to generate an accessor
	 * @param  {BufferAttribute} attribute Attribute to process
	 * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
	 * @param  {Integer} start (Optional)
	 * @param  {Integer} count (Optional)
	 * @return {Integer|null} Index of the processed accessor on the "accessors" array
	 */
	processAccessor( attribute, geometry, start, count ) {

		const json = this.json;

		const types = {

			1: 'SCALAR',
			2: 'VEC2',
			3: 'VEC3',
			4: 'VEC4',
			9: 'MAT3',
			16: 'MAT4'

		};

		let componentType;

		// Detect the component type of the attribute array
		if ( attribute.array.constructor === Float32Array ) {

			componentType = WEBGL_CONSTANTS.FLOAT;

		} else if ( attribute.array.constructor === Int32Array ) {

			componentType = WEBGL_CONSTANTS.INT;

		} else if ( attribute.array.constructor === Uint32Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

		} else if ( attribute.array.constructor === Int16Array ) {

			componentType = WEBGL_CONSTANTS.SHORT;

		} else if ( attribute.array.constructor === Uint16Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

		} else if ( attribute.array.constructor === Int8Array ) {

			componentType = WEBGL_CONSTANTS.BYTE;

		} else if ( attribute.array.constructor === Uint8Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );

		}

		if ( start === undefined ) start = 0;
		if ( count === undefined || count === Infinity ) count = attribute.count;

		// Skip creating an accessor if the attribute doesn't have data to export
		if ( count === 0 ) return null;

		const minMax = getMinMax( attribute, start, count );
		let bufferViewTarget;

		// If geometry isn't provided, don't infer the target usage of the bufferView. For
		// animation samplers, target must not be set.
		if ( geometry !== undefined ) {

			bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

		}

		const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );

		const accessorDef = {

			bufferView: bufferView.id,
			byteOffset: bufferView.byteOffset,
			componentType: componentType,
			count: count,
			max: minMax.max,
			min: minMax.min,
			type: types[ attribute.itemSize ]

		};

		if ( attribute.normalized === true ) accessorDef.normalized = true;
		if ( ! json.accessors ) json.accessors = [];

		return json.accessors.push( accessorDef ) - 1;

	}

	/**
	 * Process image
	 * @param  {Image} image to process
	 * @param  {Integer} format of the image (RGBAFormat)
	 * @param  {Boolean} flipY before writing out the image
	 * @param  {String} mimeType export format
	 * @return {Integer}     Index of the processed texture in the "images" array
	 */
	processImage( image, format, flipY, mimeType = 'image/png' ) {

		if ( image !== null ) {

			const writer = this;
			const cache = writer.cache;
			const json = writer.json;
			const options = writer.options;
			const pending = writer.pending;

			if ( ! cache.images.has( image ) ) cache.images.set( image, {} );

			const cachedImages = cache.images.get( image );

			const key = mimeType + ':flipY/' + flipY.toString();

			if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];

			if ( ! json.images ) json.images = [];

			const imageDef = { mimeType: mimeType };

			const canvas = getCanvas();

			canvas.width = Math.min( image.width, options.maxTextureSize );
			canvas.height = Math.min( image.height, options.maxTextureSize );

			const ctx = canvas.getContext( '2d' );

			if ( flipY === true ) {

				ctx.translate( 0, canvas.height );
				ctx.scale( 1, - 1 );

			}

			if ( image.data !== undefined ) { // THREE.DataTexture

				if ( format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ) {

					console.error( 'GLTFExporter: Only RGBAFormat is supported.', format );

				}

				if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {

					console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );

				}

				const data = new Uint8ClampedArray( image.height * image.width * 4 );

				for ( let i = 0; i < data.length; i += 4 ) {

					data[ i + 0 ] = image.data[ i + 0 ];
					data[ i + 1 ] = image.data[ i + 1 ];
					data[ i + 2 ] = image.data[ i + 2 ];
					data[ i + 3 ] = image.data[ i + 3 ];

				}

				ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );

			} else {

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
					( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {

					ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

				} else {

					throw new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );

				}

			}

			if ( options.binary === true ) {

				pending.push(

					getToBlobPromise( canvas, mimeType )
						.then( blob => writer.processBufferViewImage( blob ) )
						.then( bufferViewIndex => {

							imageDef.bufferView = bufferViewIndex;

						} )

				);

			} else {

				if ( canvas.toDataURL !== undefined ) {

					imageDef.uri = canvas.toDataURL( mimeType );

				} else {

					pending.push(

						getToBlobPromise( canvas, mimeType )
							.then( blob => new FileReader().readAsDataURL( blob ) )
							.then( dataURL => {

								imageDef.uri = dataURL;

							} )

					);

				}

			}

			const index = json.images.push( imageDef ) - 1;
			cachedImages[ key ] = index;
			return index;

		} else {

			throw new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );

		}

	}

	/**
	 * Process sampler
	 * @param  {Texture} map Texture to process
	 * @return {Integer}     Index of the processed texture in the "samplers" array
	 */
	processSampler( map ) {

		const json = this.json;

		if ( ! json.samplers ) json.samplers = [];

		const samplerDef = {
			magFilter: THREE_TO_WEBGL[ map.magFilter ],
			minFilter: THREE_TO_WEBGL[ map.minFilter ],
			wrapS: THREE_TO_WEBGL[ map.wrapS ],
			wrapT: THREE_TO_WEBGL[ map.wrapT ]
		};

		return json.samplers.push( samplerDef ) - 1;

	}

	/**
	 * Process texture
	 * @param  {Texture} map Map to process
	 * @return {Integer} Index of the processed texture in the "textures" array
	 */
	processTexture( map ) {

		const writer = this;
		const options = writer.options;
		const cache = this.cache;
		const json = this.json;

		if ( cache.textures.has( map ) ) return cache.textures.get( map );

		if ( ! json.textures ) json.textures = [];

		// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture
		if ( map instanceof three__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture ) {

			map = (0,_utils_TextureUtils_js__WEBPACK_IMPORTED_MODULE_1__.decompress)( map, options.maxTextureSize );

		}

		let mimeType = map.userData.mimeType;

		if ( mimeType === 'image/webp' ) mimeType = 'image/png';

		const textureDef = {
			sampler: this.processSampler( map ),
			source: this.processImage( map.image, map.format, map.flipY, mimeType )
		};

		if ( map.name ) textureDef.name = map.name;

		this._invokeAll( function ( ext ) {

			ext.writeTexture && ext.writeTexture( map, textureDef );

		} );

		const index = json.textures.push( textureDef ) - 1;
		cache.textures.set( map, index );
		return index;

	}

	/**
	 * Process material
	 * @param  {THREE.Material} material Material to process
	 * @return {Integer|null} Index of the processed material in the "materials" array
	 */
	processMaterial( material ) {

		const cache = this.cache;
		const json = this.json;

		if ( cache.materials.has( material ) ) return cache.materials.get( material );

		if ( material.isShaderMaterial ) {

			console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
			return null;

		}

		if ( ! json.materials ) json.materials = [];

		// @QUESTION Should we avoid including any attribute that has the default value?
		const materialDef = {	pbrMetallicRoughness: {} };

		if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {

			console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

		}

		// pbrMetallicRoughness.baseColorFactor
		const color = material.color.toArray().concat( [ material.opacity ] );

		if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

			materialDef.pbrMetallicRoughness.baseColorFactor = color;

		}

		if ( material.isMeshStandardMaterial ) {

			materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
			materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;

		} else {

			materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
			materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;

		}

		// pbrMetallicRoughness.metallicRoughnessTexture
		if ( material.metalnessMap || material.roughnessMap ) {

			const metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );

			const metalRoughMapDef = {
				index: this.processTexture( metalRoughTexture ),
				channel: metalRoughTexture.channel
			};
			this.applyTextureTransform( metalRoughMapDef, metalRoughTexture );
			materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

		}

		// pbrMetallicRoughness.baseColorTexture
		if ( material.map ) {

			const baseColorMapDef = {
				index: this.processTexture( material.map ),
				texCoord: material.map.channel
			};
			this.applyTextureTransform( baseColorMapDef, material.map );
			materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

		}

		if ( material.emissive ) {

			const emissive = material.emissive;
			const maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );

			if ( maxEmissiveComponent > 0 ) {

				materialDef.emissiveFactor = material.emissive.toArray();

			}

			// emissiveTexture
			if ( material.emissiveMap ) {

				const emissiveMapDef = {
					index: this.processTexture( material.emissiveMap ),
					texCoord: material.emissiveMap.channel
				};
				this.applyTextureTransform( emissiveMapDef, material.emissiveMap );
				materialDef.emissiveTexture = emissiveMapDef;

			}

		}

		// normalTexture
		if ( material.normalMap ) {

			const normalMapDef = {
				index: this.processTexture( material.normalMap ),
				texCoord: material.normalMap.channel
			};

			if ( material.normalScale && material.normalScale.x !== 1 ) {

				// glTF normal scale is univariate. Ignore `y`, which may be flipped.
				// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				normalMapDef.scale = material.normalScale.x;

			}

			this.applyTextureTransform( normalMapDef, material.normalMap );
			materialDef.normalTexture = normalMapDef;

		}

		// occlusionTexture
		if ( material.aoMap ) {

			const occlusionMapDef = {
				index: this.processTexture( material.aoMap ),
				texCoord: material.aoMap.channel
			};

			if ( material.aoMapIntensity !== 1.0 ) {

				occlusionMapDef.strength = material.aoMapIntensity;

			}

			this.applyTextureTransform( occlusionMapDef, material.aoMap );
			materialDef.occlusionTexture = occlusionMapDef;

		}

		// alphaMode
		if ( material.transparent ) {

			materialDef.alphaMode = 'BLEND';

		} else {

			if ( material.alphaTest > 0.0 ) {

				materialDef.alphaMode = 'MASK';
				materialDef.alphaCutoff = material.alphaTest;

			}

		}

		// doubleSided
		if ( material.side === three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide ) materialDef.doubleSided = true;
		if ( material.name !== '' ) materialDef.name = material.name;

		this.serializeUserData( material, materialDef );

		this._invokeAll( function ( ext ) {

			ext.writeMaterial && ext.writeMaterial( material, materialDef );

		} );

		const index = json.materials.push( materialDef ) - 1;
		cache.materials.set( material, index );
		return index;

	}

	/**
	 * Process mesh
	 * @param  {THREE.Mesh} mesh Mesh to process
	 * @return {Integer|null} Index of the processed mesh in the "meshes" array
	 */
	processMesh( mesh ) {

		const cache = this.cache;
		const json = this.json;

		const meshCacheKeyParts = [ mesh.geometry.uuid ];

		if ( Array.isArray( mesh.material ) ) {

			for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {

				meshCacheKeyParts.push( mesh.material[ i ].uuid	);

			}

		} else {

			meshCacheKeyParts.push( mesh.material.uuid );

		}

		const meshCacheKey = meshCacheKeyParts.join( ':' );

		if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );

		const geometry = mesh.geometry;

		let mode;

		// Use the correct mode
		if ( mesh.isLineSegments ) {

			mode = WEBGL_CONSTANTS.LINES;

		} else if ( mesh.isLineLoop ) {

			mode = WEBGL_CONSTANTS.LINE_LOOP;

		} else if ( mesh.isLine ) {

			mode = WEBGL_CONSTANTS.LINE_STRIP;

		} else if ( mesh.isPoints ) {

			mode = WEBGL_CONSTANTS.POINTS;

		} else {

			mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

		}

		const meshDef = {};
		const attributes = {};
		const primitives = [];
		const targets = [];

		// Conversion between attributes names in threejs and gltf spec
		const nameConversion = {
			uv: 'TEXCOORD_0',
			uv1: 'TEXCOORD_1',
			uv2: 'TEXCOORD_2',
			uv3: 'TEXCOORD_3',
			color: 'COLOR_0',
			skinWeight: 'WEIGHTS_0',
			skinIndex: 'JOINTS_0'
		};

		const originalNormal = geometry.getAttribute( 'normal' );

		if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {

			console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

			geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );

		}

		// @QUESTION Detect if .vertexColors = true?
		// For every attribute create an accessor
		let modifiedAttribute = null;

		for ( let attributeName in geometry.attributes ) {

			// Ignore morph target attributes, which are exported later.
			if ( attributeName.slice( 0, 5 ) === 'morph' ) continue;

			const attribute = geometry.attributes[ attributeName ];
			attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

			// Prefix all geometry attributes except the ones specifically
			// listed in the spec; non-spec attributes are considered custom.
			const validVertexAttributes =
					/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;

			if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;

			if ( cache.attributes.has( this.getUID( attribute ) ) ) {

				attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );
				continue;

			}

			// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
			modifiedAttribute = null;
			const array = attribute.array;

			if ( attributeName === 'JOINTS_0' &&
				! ( array instanceof Uint16Array ) &&
				! ( array instanceof Uint8Array ) ) {

				console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
				modifiedAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

			}

			const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );

			if ( accessor !== null ) {

				if ( ! attributeName.startsWith( '_' ) ) {

					this.detectMeshQuantization( attributeName, attribute );

				}

				attributes[ attributeName ] = accessor;
				cache.attributes.set( this.getUID( attribute ), accessor );

			}

		}

		if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );

		// Skip if no exportable attributes found
		if ( Object.keys( attributes ).length === 0 ) return null;

		// Morph targets
		if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

			const weights = [];
			const targetNames = [];
			const reverseDictionary = {};

			if ( mesh.morphTargetDictionary !== undefined ) {

				for ( const key in mesh.morphTargetDictionary ) {

					reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

				}

			}

			for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

				const target = {};
				let warned = false;

				for ( const attributeName in geometry.morphAttributes ) {

					// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
					// Three.js doesn't support TANGENT yet.

					if ( attributeName !== 'position' && attributeName !== 'normal' ) {

						if ( ! warned ) {

							console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
							warned = true;

						}

						continue;

					}

					const attribute = geometry.morphAttributes[ attributeName ][ i ];
					const gltfAttributeName = attributeName.toUpperCase();

					// Three.js morph attribute has absolute values while the one of glTF has relative values.
					//
					// glTF 2.0 Specification:
					// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

					const baseAttribute = geometry.attributes[ attributeName ];

					if ( cache.attributes.has( this.getUID( attribute, true ) ) ) {

						target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );
						continue;

					}

					// Clones attribute not to override
					const relativeAttribute = attribute.clone();

					if ( ! geometry.morphTargetsRelative ) {

						for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {

							for ( let a = 0; a < attribute.itemSize; a ++ ) {

								if ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );
								if ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );
								if ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );
								if ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );

							}

						}

					}

					target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );
					cache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );

				}

				targets.push( target );

				weights.push( mesh.morphTargetInfluences[ i ] );

				if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

			}

			meshDef.weights = weights;

			if ( targetNames.length > 0 ) {

				meshDef.extras = {};
				meshDef.extras.targetNames = targetNames;

			}

		}

		const isMultiMaterial = Array.isArray( mesh.material );

		if ( isMultiMaterial && geometry.groups.length === 0 ) return null;

		let didForceIndices = false;

		if ( isMultiMaterial && geometry.index === null ) {

			const indices = [];

			for ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {

				indices[ i ] = i;

			}

			geometry.setIndex( indices );

			didForceIndices = true;

		}

		const materials = isMultiMaterial ? mesh.material : [ mesh.material ];
		const groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

		for ( let i = 0, il = groups.length; i < il; i ++ ) {

			const primitive = {
				mode: mode,
				attributes: attributes,
			};

			this.serializeUserData( geometry, primitive );

			if ( targets.length > 0 ) primitive.targets = targets;

			if ( geometry.index !== null ) {

				let cacheKey = this.getUID( geometry.index );

				if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {

					cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;

				}

				if ( cache.attributes.has( cacheKey ) ) {

					primitive.indices = cache.attributes.get( cacheKey );

				} else {

					primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
					cache.attributes.set( cacheKey, primitive.indices );

				}

				if ( primitive.indices === null ) delete primitive.indices;

			}

			const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );

			if ( material !== null ) primitive.material = material;

			primitives.push( primitive );

		}

		if ( didForceIndices === true ) {

			geometry.setIndex( null );

		}

		meshDef.primitives = primitives;

		if ( ! json.meshes ) json.meshes = [];

		this._invokeAll( function ( ext ) {

			ext.writeMesh && ext.writeMesh( mesh, meshDef );

		} );

		const index = json.meshes.push( meshDef ) - 1;
		cache.meshes.set( meshCacheKey, index );
		return index;

	}

	/**
	 * If a vertex attribute with a
	 * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
	 * is used, it is checked whether it is a valid data type according to the
	 * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
	 * extension.
	 * In this case the extension is automatically added to the list of used extensions.
	 *
	 * @param {string} attributeName
	 * @param {THREE.BufferAttribute} attribute
	 */
	detectMeshQuantization( attributeName, attribute ) {

		if ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;

		let attrType = undefined;

		switch ( attribute.array.constructor ) {

			case Int8Array:

				attrType = 'byte';

				break;

			case Uint8Array:

				attrType = 'unsigned byte';

				break;

			case Int16Array:

				attrType = 'short';

				break;

			case Uint16Array:

				attrType = 'unsigned short';

				break;

			default:

				return;

		}

		if ( attribute.normalized ) attrType += ' normalized';

		const attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];

		if ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {

			this.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;
			this.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;

		}

	}

	/**
	 * Process camera
	 * @param  {THREE.Camera} camera Camera to process
	 * @return {Integer}      Index of the processed mesh in the "camera" array
	 */
	processCamera( camera ) {

		const json = this.json;

		if ( ! json.cameras ) json.cameras = [];

		const isOrtho = camera.isOrthographicCamera;

		const cameraDef = {
			type: isOrtho ? 'orthographic' : 'perspective'
		};

		if ( isOrtho ) {

			cameraDef.orthographic = {
				xmag: camera.right * 2,
				ymag: camera.top * 2,
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		} else {

			cameraDef.perspective = {
				aspectRatio: camera.aspect,
				yfov: three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( camera.fov ),
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		}

		// Question: Is saving "type" as name intentional?
		if ( camera.name !== '' ) cameraDef.name = camera.type;

		return json.cameras.push( cameraDef ) - 1;

	}

	/**
	 * Creates glTF animation entry from AnimationClip object.
	 *
	 * Status:
	 * - Only properties listed in PATH_PROPERTIES may be animated.
	 *
	 * @param {THREE.AnimationClip} clip
	 * @param {THREE.Object3D} root
	 * @return {number|null}
	 */
	processAnimation( clip, root ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		if ( ! json.animations ) json.animations = [];

		clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );

		const tracks = clip.tracks;
		const channels = [];
		const samplers = [];

		for ( let i = 0; i < tracks.length; ++ i ) {

			const track = tracks[ i ];
			const trackBinding = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.parseTrackName( track.name );
			let trackNode = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.findNode( root, trackBinding.nodeName );
			const trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

			if ( trackBinding.objectName === 'bones' ) {

				if ( trackNode.isSkinnedMesh === true ) {

					trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

				} else {

					trackNode = undefined;

				}

			}

			if ( ! trackNode || ! trackProperty ) {

				console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
				return null;

			}

			const inputItemSize = 1;
			let outputItemSize = track.values.length / track.times.length;

			if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

				outputItemSize /= trackNode.morphTargetInfluences.length;

			}

			let interpolation;

			// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

			// Detecting glTF cubic spline interpolant by checking factory method's special property
			// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
			// valid value from .getInterpolation().
			if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

				interpolation = 'CUBICSPLINE';

				// itemSize of CUBICSPLINE keyframe is 9
				// (VEC3 * 3: inTangent, splineVertex, and outTangent)
				// but needs to be stored as VEC3 so dividing by 3 here.
				outputItemSize /= 3;

			} else if ( track.getInterpolation() === three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete ) {

				interpolation = 'STEP';

			} else {

				interpolation = 'LINEAR';

			}

			samplers.push( {
				input: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( track.times, inputItemSize ) ),
				output: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( track.values, outputItemSize ) ),
				interpolation: interpolation
			} );

			channels.push( {
				sampler: samplers.length - 1,
				target: {
					node: nodeMap.get( trackNode ),
					path: trackProperty
				}
			} );

		}

		json.animations.push( {
			name: clip.name || 'clip_' + json.animations.length,
			samplers: samplers,
			channels: channels
		} );

		return json.animations.length - 1;

	}

	/**
	 * @param {THREE.Object3D} object
	 * @return {number|null}
	 */
	 processSkin( object ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		const node = json.nodes[ nodeMap.get( object ) ];

		const skeleton = object.skeleton;

		if ( skeleton === undefined ) return null;

		const rootJoint = object.skeleton.bones[ 0 ];

		if ( rootJoint === undefined ) return null;

		const joints = [];
		const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );
		const temporaryBoneInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();

		for ( let i = 0; i < skeleton.bones.length; ++ i ) {

			joints.push( nodeMap.get( skeleton.bones[ i ] ) );
			temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );
			temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );

		}

		if ( json.skins === undefined ) json.skins = [];

		json.skins.push( {
			inverseBindMatrices: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( inverseBindMatrices, 16 ) ),
			joints: joints,
			skeleton: nodeMap.get( rootJoint )
		} );

		const skinIndex = node.skin = json.skins.length - 1;

		return skinIndex;

	}

	/**
	 * Process Object3D node
	 * @param  {THREE.Object3D} node Object3D to processNode
	 * @return {Integer} Index of the node in the nodes list
	 */
	processNode( object ) {

		const json = this.json;
		const options = this.options;
		const nodeMap = this.nodeMap;

		if ( ! json.nodes ) json.nodes = [];

		const nodeDef = {};

		if ( options.trs ) {

			const rotation = object.quaternion.toArray();
			const position = object.position.toArray();
			const scale = object.scale.toArray();

			if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

				nodeDef.rotation = rotation;

			}

			if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

				nodeDef.translation = position;

			}

			if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

				nodeDef.scale = scale;

			}

		} else {

			if ( object.matrixAutoUpdate ) {

				object.updateMatrix();

			}

			if ( isIdentityMatrix( object.matrix ) === false ) {

				nodeDef.matrix = object.matrix.elements;

			}

		}

		// We don't export empty strings name because it represents no-name in Three.js.
		if ( object.name !== '' ) nodeDef.name = String( object.name );

		this.serializeUserData( object, nodeDef );

		if ( object.isMesh || object.isLine || object.isPoints ) {

			const meshIndex = this.processMesh( object );

			if ( meshIndex !== null ) nodeDef.mesh = meshIndex;

		} else if ( object.isCamera ) {

			nodeDef.camera = this.processCamera( object );

		}

		if ( object.isSkinnedMesh ) this.skins.push( object );

		if ( object.children.length > 0 ) {

			const children = [];

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				const child = object.children[ i ];

				if ( child.visible || options.onlyVisible === false ) {

					const nodeIndex = this.processNode( child );

					if ( nodeIndex !== null ) children.push( nodeIndex );

				}

			}

			if ( children.length > 0 ) nodeDef.children = children;

		}

		this._invokeAll( function ( ext ) {

			ext.writeNode && ext.writeNode( object, nodeDef );

		} );

		const nodeIndex = json.nodes.push( nodeDef ) - 1;
		nodeMap.set( object, nodeIndex );
		return nodeIndex;

	}

	/**
	 * Process Scene
	 * @param  {Scene} node Scene to process
	 */
	processScene( scene ) {

		const json = this.json;
		const options = this.options;

		if ( ! json.scenes ) {

			json.scenes = [];
			json.scene = 0;

		}

		const sceneDef = {};

		if ( scene.name !== '' ) sceneDef.name = scene.name;

		json.scenes.push( sceneDef );

		const nodes = [];

		for ( let i = 0, l = scene.children.length; i < l; i ++ ) {

			const child = scene.children[ i ];

			if ( child.visible || options.onlyVisible === false ) {

				const nodeIndex = this.processNode( child );

				if ( nodeIndex !== null ) nodes.push( nodeIndex );

			}

		}

		if ( nodes.length > 0 ) sceneDef.nodes = nodes;

		this.serializeUserData( scene, sceneDef );

	}

	/**
	 * Creates a Scene to hold a list of objects and parse it
	 * @param  {Array} objects List of objects to process
	 */
	processObjects( objects ) {

		const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();
		scene.name = 'AuxScene';

		for ( let i = 0; i < objects.length; i ++ ) {

			// We push directly to children instead of calling `add` to prevent
			// modify the .parent and break its original scene and hierarchy
			scene.children.push( objects[ i ] );

		}

		this.processScene( scene );

	}

	/**
	 * @param {THREE.Object3D|Array<THREE.Object3D>} input
	 */
	processInput( input ) {

		const options = this.options;

		input = input instanceof Array ? input : [ input ];

		this._invokeAll( function ( ext ) {

			ext.beforeParse && ext.beforeParse( input );

		} );

		const objectsWithoutScene = [];

		for ( let i = 0; i < input.length; i ++ ) {

			if ( input[ i ] instanceof three__WEBPACK_IMPORTED_MODULE_0__.Scene ) {

				this.processScene( input[ i ] );

			} else {

				objectsWithoutScene.push( input[ i ] );

			}

		}

		if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );

		for ( let i = 0; i < this.skins.length; ++ i ) {

			this.processSkin( this.skins[ i ] );

		}

		for ( let i = 0; i < options.animations.length; ++ i ) {

			this.processAnimation( options.animations[ i ], input[ 0 ] );

		}

		this._invokeAll( function ( ext ) {

			ext.afterParse && ext.afterParse( input );

		} );

	}

	_invokeAll( func ) {

		for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {

			func( this.plugins[ i ] );

		}

	}

}

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_lights_punctual';

	}

	writeNode( light, nodeDef ) {

		if ( ! light.isLight ) return;

		if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {

			console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );
			return;

		}

		const writer = this.writer;
		const json = writer.json;
		const extensionsUsed = writer.extensionsUsed;

		const lightDef = {};

		if ( light.name ) lightDef.name = light.name;

		lightDef.color = light.color.toArray();

		lightDef.intensity = light.intensity;

		if ( light.isDirectionalLight ) {

			lightDef.type = 'directional';

		} else if ( light.isPointLight ) {

			lightDef.type = 'point';

			if ( light.distance > 0 ) lightDef.range = light.distance;

		} else if ( light.isSpotLight ) {

			lightDef.type = 'spot';

			if ( light.distance > 0 ) lightDef.range = light.distance;

			lightDef.spot = {};
			lightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;
			lightDef.spot.outerConeAngle = light.angle;

		}

		if ( light.decay !== undefined && light.decay !== 2 ) {

			console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '
				+ 'and expects light.decay=2.' );

		}

		if ( light.target
				&& ( light.target.parent !== light
				|| light.target.position.x !== 0
				|| light.target.position.y !== 0
				|| light.target.position.z !== - 1 ) ) {

			console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '
				+ 'make light.target a child of the light with position 0,0,-1.' );

		}

		if ( ! extensionsUsed[ this.name ] ) {

			json.extensions = json.extensions || {};
			json.extensions[ this.name ] = { lights: [] };
			extensionsUsed[ this.name ] = true;

		}

		const lights = json.extensions[ this.name ].lights;
		lights.push( lightDef );

		nodeDef.extensions = nodeDef.extensions || {};
		nodeDef.extensions[ this.name ] = { light: lights.length - 1 };

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_unlit';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshBasicMaterial ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = {};

		extensionsUsed[ this.name ] = true;

		materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
		materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_clearcoat';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.clearcoatFactor = material.clearcoat;

		if ( material.clearcoatMap ) {

			const clearcoatMapDef = {
				index: writer.processTexture( material.clearcoatMap ),
				texCoord: material.clearcoatMap.channel
			};
			writer.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );
			extensionDef.clearcoatTexture = clearcoatMapDef;

		}

		extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;

		if ( material.clearcoatRoughnessMap ) {

			const clearcoatRoughnessMapDef = {
				index: writer.processTexture( material.clearcoatRoughnessMap ),
				texCoord: material.clearcoatRoughnessMap.channel
			};
			writer.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );
			extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;

		}

		if ( material.clearcoatNormalMap ) {

			const clearcoatNormalMapDef = {
				index: writer.processTexture( material.clearcoatNormalMap ),
				texCoord: material.clearcoatNormalMap.channel
			};

			if ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;

			writer.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );
			extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;


	}

}

/**
 * Materials dispersion Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion
 */
class GLTFMaterialsDispersionExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_dispersion';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.dispersion = material.dispersion;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_iridescence';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.iridescenceFactor = material.iridescence;

		if ( material.iridescenceMap ) {

			const iridescenceMapDef = {
				index: writer.processTexture( material.iridescenceMap ),
				texCoord: material.iridescenceMap.channel
			};
			writer.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );
			extensionDef.iridescenceTexture = iridescenceMapDef;

		}

		extensionDef.iridescenceIor = material.iridescenceIOR;
		extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];
		extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];

		if ( material.iridescenceThicknessMap ) {

			const iridescenceThicknessMapDef = {
				index: writer.processTexture( material.iridescenceThicknessMap ),
				texCoord: material.iridescenceThicknessMap.channel
			};
			writer.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );
			extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 */
class GLTFMaterialsTransmissionExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_transmission';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.transmissionFactor = material.transmission;

		if ( material.transmissionMap ) {

			const transmissionMapDef = {
				index: writer.processTexture( material.transmissionMap ),
				texCoord: material.transmissionMap.channel
			};
			writer.applyTextureTransform( transmissionMapDef, material.transmissionMap );
			extensionDef.transmissionTexture = transmissionMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_volume';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.thicknessFactor = material.thickness;

		if ( material.thicknessMap ) {

			const thicknessMapDef = {
				index: writer.processTexture( material.thicknessMap ),
				texCoord: material.thicknessMap.channel
			};
			writer.applyTextureTransform( thicknessMapDef, material.thicknessMap );
			extensionDef.thicknessTexture = thicknessMapDef;

		}

		extensionDef.attenuationDistance = material.attenuationDistance;
		extensionDef.attenuationColor = material.attenuationColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_ior';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.ior = material.ior;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_specular';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&
		       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&
		     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.specularIntensityMap ) {

			const specularIntensityMapDef = {
				index: writer.processTexture( material.specularIntensityMap ),
				texCoord: material.specularIntensityMap.channel
			};
			writer.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );
			extensionDef.specularTexture = specularIntensityMapDef;

		}

		if ( material.specularColorMap ) {

			const specularColorMapDef = {
				index: writer.processTexture( material.specularColorMap ),
				texCoord: material.specularColorMap.channel
			};
			writer.applyTextureTransform( specularColorMapDef, material.specularColorMap );
			extensionDef.specularColorTexture = specularColorMapDef;

		}

		extensionDef.specularFactor = material.specularIntensity;
		extensionDef.specularColorFactor = material.specularColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_sheen';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.sheenRoughnessMap ) {

			const sheenRoughnessMapDef = {
				index: writer.processTexture( material.sheenRoughnessMap ),
				texCoord: material.sheenRoughnessMap.channel
			};
			writer.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );
			extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;

		}

		if ( material.sheenColorMap ) {

			const sheenColorMapDef = {
				index: writer.processTexture( material.sheenColorMap ),
				texCoord: material.sheenColorMap.channel
			};
			writer.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );
			extensionDef.sheenColorTexture = sheenColorMapDef;

		}

		extensionDef.sheenRoughnessFactor = material.sheenRoughness;
		extensionDef.sheenColorFactor = material.sheenColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Anisotropy Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
 */
class GLTFMaterialsAnisotropyExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_anisotropy';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.anisotropyMap ) {

			const anisotropyMapDef = { index: writer.processTexture( material.anisotropyMap ) };
			writer.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );
			extensionDef.anisotropyTexture = anisotropyMapDef;

		}

		extensionDef.anisotropyStrength = material.anisotropy;
		extensionDef.anisotropyRotation = material.anisotropyRotation;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_emissive_strength';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.emissiveStrength = material.emissiveIntensity;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}


/**
 * Materials bump Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
 */
class GLTFMaterialsBumpExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'EXT_materials_bump';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshStandardMaterial || (
		       material.bumpScale === 1 &&
		     ! material.bumpMap ) ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.bumpMap ) {

			const bumpMapDef = {
				index: writer.processTexture( material.bumpMap ),
				texCoord: material.bumpMap.channel
			};
			writer.applyTextureTransform( bumpMapDef, material.bumpMap );
			extensionDef.bumpTexture = bumpMapDef;

		}

		extensionDef.bumpFactor = material.bumpScale;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 */
class GLTFMeshGpuInstancing {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'EXT_mesh_gpu_instancing';

	}

	writeNode( object, nodeDef ) {

		if ( ! object.isInstancedMesh ) return;

		const writer = this.writer;

		const mesh = object;

		const translationAttr = new Float32Array( mesh.count * 3 );
		const rotationAttr = new Float32Array( mesh.count * 4 );
		const scaleAttr = new Float32Array( mesh.count * 3 );

		const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
		const position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const quaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		const scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		for ( let i = 0; i < mesh.count; i ++ ) {

			mesh.getMatrixAt( i, matrix );
			matrix.decompose( position, quaternion, scale );

			position.toArray( translationAttr, i * 3 );
			quaternion.toArray( rotationAttr, i * 4 );
			scale.toArray( scaleAttr, i * 3 );

		}

		const attributes = {
			TRANSLATION: writer.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( translationAttr, 3 ) ),
			ROTATION: writer.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( rotationAttr, 4 ) ),
			SCALE: writer.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( scaleAttr, 3 ) ),
		};

		if ( mesh.instanceColor )
			attributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );

		nodeDef.extensions = nodeDef.extensions || {};
		nodeDef.extensions[ this.name ] = { attributes };

		writer.extensionsUsed[ this.name ] = true;
		writer.extensionsRequired[ this.name ] = true;

	}

}

/**
 * Static utility functions
 */
GLTFExporter.Utils = {

	insertKeyframe: function ( track, time ) {

		const tolerance = 0.001; // 1ms
		const valueSize = track.getValueSize();

		const times = new track.TimeBufferType( track.times.length + 1 );
		const values = new track.ValueBufferType( track.values.length + valueSize );
		const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );

		let index;

		if ( track.times.length === 0 ) {

			times[ 0 ] = time;

			for ( let i = 0; i < valueSize; i ++ ) {

				values[ i ] = 0;

			}

			index = 0;

		} else if ( time < track.times[ 0 ] ) {

			if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;

			times[ 0 ] = time;
			times.set( track.times, 1 );

			values.set( interpolant.evaluate( time ), 0 );
			values.set( track.values, valueSize );

			index = 0;

		} else if ( time > track.times[ track.times.length - 1 ] ) {

			if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

				return track.times.length - 1;

			}

			times[ times.length - 1 ] = time;
			times.set( track.times, 0 );

			values.set( track.values, 0 );
			values.set( interpolant.evaluate( time ), track.values.length );

			index = times.length - 1;

		} else {

			for ( let i = 0; i < track.times.length; i ++ ) {

				if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;

				if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

					times.set( track.times.slice( 0, i + 1 ), 0 );
					times[ i + 1 ] = time;
					times.set( track.times.slice( i + 1 ), i + 2 );

					values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
					values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
					values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );

					index = i + 1;

					break;

				}

			}

		}

		track.times = times;
		track.values = values;

		return index;

	},

	mergeMorphTargetTracks: function ( clip, root ) {

		const tracks = [];
		const mergedTracks = {};
		const sourceTracks = clip.tracks;

		for ( let i = 0; i < sourceTracks.length; ++ i ) {

			let sourceTrack = sourceTracks[ i ];
			const sourceTrackBinding = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.parseTrackName( sourceTrack.name );
			const sourceTrackNode = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );

			if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

				// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
				tracks.push( sourceTrack );
				continue;

			}

			if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete
				&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

				if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					// This should never happen, because glTF morph target animations
					// affect all targets already.
					throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

				}

				console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );

				sourceTrack = sourceTrack.clone();
				sourceTrack.setInterpolation( three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear );

			}

			const targetCount = sourceTrackNode.morphTargetInfluences.length;
			const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

			if ( targetIndex === undefined ) {

				throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

			}

			let mergedTrack;

			// If this is the first time we've seen this object, create a new
			// track to store merged keyframe data for each morph target.
			if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

				mergedTrack = sourceTrack.clone();

				const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

				for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

					values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

				}

				// We need to take into consideration the intended target node
				// of our original un-merged morphTarget animation.
				mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';
				mergedTrack.values = values;

				mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
				tracks.push( mergedTrack );

				continue;

			}

			const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );

			mergedTrack = mergedTracks[ sourceTrackNode.uuid ];

			// For every existing keyframe of the merged track, write a (possibly
			// interpolated) value from the source track.
			for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

				mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

			}

			// For every existing keyframe of the source track, write a (possibly
			// new) keyframe to the merged track. Values from the previous loop may
			// be written again, but keyframes are de-duplicated.
			for ( let j = 0; j < sourceTrack.times.length; j ++ ) {

				const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
				mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

			}

		}

		clip.tracks = tracks;

		return clip;

	}

};




/***/ }),

/***/ "./node_modules/three/examples/jsm/geometries/TextGeometry.js":
/*!********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/geometries/TextGeometry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextGeometry: () => (/* binding */ TextGeometry)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  depth: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */



class TextGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.ExtrudeGeometry {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( font === undefined ) {

			super(); // generate default extrude geometry

		} else {

			const shapes = font.generateShapes( text, parameters.size );

			// translate parameters to ExtrudeGeometry API

			if ( parameters.depth === undefined && parameters.height !== undefined ) {

				console.warn( 'THREE.TextGeometry: .height is now depreciated. Please use .depth instead' ); // @deprecated, r163

			}

			parameters.depth = parameters.depth !== undefined ?
				parameters.depth : parameters.height !== undefined ?
					parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			super( shapes, parameters );

		}

		this.type = 'TextGeometry';

	}

}





/***/ }),

/***/ "./node_modules/three/examples/jsm/libs/lil-gui.module.min.js":
/*!********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/libs/lil-gui.module.min.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BooleanController: () => (/* binding */ i),
/* harmony export */   ColorController: () => (/* binding */ a),
/* harmony export */   Controller: () => (/* binding */ t),
/* harmony export */   FunctionController: () => (/* binding */ h),
/* harmony export */   GUI: () => (/* binding */ g),
/* harmony export */   NumberController: () => (/* binding */ d),
/* harmony export */   OptionController: () => (/* binding */ c),
/* harmony export */   StringController: () => (/* binding */ u),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.17.0
 * @author George Michael Brower
 * @license MIT
 */
class t{constructor(i,e,s,n,l="div"){this.parent=i,this.object=e,this.property=s,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement("div"),this.domElement.classList.add("controller"),this.domElement.classList.add(n),this.$name=document.createElement("div"),this.$name.classList.add("name"),t.nextNameID=t.nextNameID||0,this.$name.id="lil-gui-name-"+ ++t.nextNameID,this.$widget=document.createElement(l),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(s)}name(t){return this._name=t,this.$name.innerHTML=t,this}onChange(t){return this._onChange=t,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(t=!0){return this.disable(!t)}disable(t=!0){return t===this._disabled||(this._disabled=t,this.domElement.classList.toggle("disabled",t),this.$disable.toggleAttribute("disabled",t)),this}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(t){const i=this.parent.add(this.object,this.property,t);return i.name(this._name),this.destroy(),i}min(t){return this}max(t){return this}step(t){return this}decimals(t){return this}listen(t=!0){return this._listening=t,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const t=this.save();t!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=t}getValue(){return this.object[this.property]}setValue(t){return this.object[this.property]=t,this._callOnChange(),this.updateDisplay(),this}updateDisplay(){return this}load(t){return this.setValue(t),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class i extends t{constructor(t,i,e){super(t,i,e,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",()=>{this.setValue(this.$input.checked),this._callOnFinishChange()}),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function e(t){let i,e;return(i=t.match(/(#|0x)?([a-f0-9]{6})/i))?e=i[2]:(i=t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?e=parseInt(i[1]).toString(16).padStart(2,0)+parseInt(i[2]).toString(16).padStart(2,0)+parseInt(i[3]).toString(16).padStart(2,0):(i=t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(e=i[1]+i[1]+i[2]+i[2]+i[3]+i[3]),!!e&&"#"+e}const s={isPrimitive:!0,match:t=>"string"==typeof t,fromHexString:e,toHexString:e},n={isPrimitive:!0,match:t=>"number"==typeof t,fromHexString:t=>parseInt(t.substring(1),16),toHexString:t=>"#"+t.toString(16).padStart(6,0)},l={isPrimitive:!1,match:Array.isArray,fromHexString(t,i,e=1){const s=n.fromHexString(t);i[0]=(s>>16&255)/255*e,i[1]=(s>>8&255)/255*e,i[2]=(255&s)/255*e},toHexString:([t,i,e],s=1)=>n.toHexString(t*(s=255/s)<<16^i*s<<8^e*s<<0)},r={isPrimitive:!1,match:t=>Object(t)===t,fromHexString(t,i,e=1){const s=n.fromHexString(t);i.r=(s>>16&255)/255*e,i.g=(s>>8&255)/255*e,i.b=(255&s)/255*e},toHexString:({r:t,g:i,b:e},s=1)=>n.toHexString(t*(s=255/s)<<16^i*s<<8^e*s<<0)},o=[s,n,l,r];class a extends t{constructor(t,i,s,n){var l;super(t,i,s,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(l=this.initialValue,o.find(t=>t.match(l))),this._rgbScale=n,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",()=>{this._setValueFromHexString(this.$input.value)}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$text.addEventListener("input",()=>{const t=e(this.$text.value);t&&this._setValueFromHexString(t)}),this.$text.addEventListener("focus",()=>{this._textFocused=!0,this.$text.select()}),this.$text.addEventListener("blur",()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()}),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(t){if(this._format.isPrimitive){const i=this._format.fromHexString(t);this.setValue(i)}else this._format.fromHexString(t,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(t){return this._setValueFromHexString(t),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class h extends t{constructor(t,i,e){super(t,i,e,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",t=>{t.preventDefault(),this.getValue().call(this.object)}),this.$button.addEventListener("touchstart",()=>{},{passive:!0}),this.$disable=this.$button}}class d extends t{constructor(t,i,e,s,n,l){super(t,i,e,"number"),this._initInput(),this.min(s),this.max(n);const r=void 0!==l;this.step(r?l:this._getImplicitStep(),r),this.updateDisplay()}decimals(t){return this._decimals=t,this.updateDisplay(),this}min(t){return this._min=t,this._onUpdateMinMax(),this}max(t){return this._max=t,this._onUpdateMinMax(),this}step(t,i=!0){return this._step=t,this._stepExplicit=i,this}updateDisplay(){const t=this.getValue();if(this._hasSlider){let i=(t-this._min)/(this._max-this._min);i=Math.max(0,Math.min(i,1)),this.$fill.style.width=100*i+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?t:t.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$disable=this.$input;const t=t=>{const i=parseFloat(this.$input.value);isNaN(i)||(this._snapClampSetValue(i+t),this.$input.value=this.getValue())};let i,e,s,n,l,r=!1;const o=t=>{if(r){const s=t.clientX-i,n=t.clientY-e;Math.abs(n)>5?(t.preventDefault(),this.$input.blur(),r=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(s)>5&&a()}if(!r){const i=t.clientY-s;l-=i*this._step*this._arrowKeyMultiplier(t),n+l>this._max?l=this._max-n:n+l<this._min&&(l=this._min-n),this._snapClampSetValue(n+l)}s=t.clientY},a=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",o),window.removeEventListener("mouseup",a)};this.$input.addEventListener("input",()=>{let t=parseFloat(this.$input.value);isNaN(t)||(this._stepExplicit&&(t=this._snap(t)),this.setValue(this._clamp(t)))}),this.$input.addEventListener("keydown",i=>{"Enter"===i.code&&this.$input.blur(),"ArrowUp"===i.code&&(i.preventDefault(),t(this._step*this._arrowKeyMultiplier(i))),"ArrowDown"===i.code&&(i.preventDefault(),t(this._step*this._arrowKeyMultiplier(i)*-1))}),this.$input.addEventListener("wheel",i=>{this._inputFocused&&(i.preventDefault(),t(this._step*this._normalizeMouseWheel(i)))},{passive:!1}),this.$input.addEventListener("mousedown",t=>{i=t.clientX,e=s=t.clientY,r=!0,n=this.getValue(),l=0,window.addEventListener("mousemove",o),window.addEventListener("mouseup",a)}),this.$input.addEventListener("focus",()=>{this._inputFocused=!0}),this.$input.addEventListener("blur",()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()})}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const t=t=>{const i=this.$slider.getBoundingClientRect();let e=(s=t,n=i.left,l=i.right,r=this._min,o=this._max,(s-n)/(l-n)*(o-r)+r);var s,n,l,r,o;this._snapClampSetValue(e)},i=i=>{t(i.clientX)},e=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",i),window.removeEventListener("mouseup",e)};let s,n,l=!1;const r=i=>{i.preventDefault(),this._setDraggingStyle(!0),t(i.touches[0].clientX),l=!1},o=i=>{if(l){const t=i.touches[0].clientX-s,e=i.touches[0].clientY-n;Math.abs(t)>Math.abs(e)?r(i):(window.removeEventListener("touchmove",o),window.removeEventListener("touchend",a))}else i.preventDefault(),t(i.touches[0].clientX)},a=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",o),window.removeEventListener("touchend",a)},h=this._callOnFinishChange.bind(this);let d;this.$slider.addEventListener("mousedown",s=>{this._setDraggingStyle(!0),t(s.clientX),window.addEventListener("mousemove",i),window.addEventListener("mouseup",e)}),this.$slider.addEventListener("touchstart",t=>{t.touches.length>1||(this._hasScrollBar?(s=t.touches[0].clientX,n=t.touches[0].clientY,l=!0):r(t),window.addEventListener("touchmove",o,{passive:!1}),window.addEventListener("touchend",a))},{passive:!1}),this.$slider.addEventListener("wheel",t=>{if(Math.abs(t.deltaX)<Math.abs(t.deltaY)&&this._hasScrollBar)return;t.preventDefault();const i=this._normalizeMouseWheel(t)*this._step;this._snapClampSetValue(this.getValue()+i),this.$input.value=this.getValue(),clearTimeout(d),d=setTimeout(h,400)},{passive:!1})}_setDraggingStyle(t,i="horizontal"){this.$slider&&this.$slider.classList.toggle("active",t),document.body.classList.toggle("lil-gui-dragging",t),document.body.classList.toggle("lil-gui-"+i,t)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(t){let{deltaX:i,deltaY:e}=t;Math.floor(t.deltaY)!==t.deltaY&&t.wheelDelta&&(i=0,e=-t.wheelDelta/120,e*=this._stepExplicit?1:10);return i+-e}_arrowKeyMultiplier(t){let i=this._stepExplicit?1:10;return t.shiftKey?i*=10:t.altKey&&(i/=10),i}_snap(t){const i=Math.round(t/this._step)*this._step;return parseFloat(i.toPrecision(15))}_clamp(t){return t<this._min&&(t=this._min),t>this._max&&(t=this._max),t}_snapClampSetValue(t){this.setValue(this._clamp(this._snap(t)))}get _hasScrollBar(){const t=this.parent.root.$children;return t.scrollHeight>t.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class c extends t{constructor(t,i,e,s){super(t,i,e,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this._values=Array.isArray(s)?s:Object.values(s),this._names=Array.isArray(s)?s:Object.keys(s),this._names.forEach(t=>{const i=document.createElement("option");i.innerHTML=t,this.$select.appendChild(i)}),this.$select.addEventListener("change",()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()}),this.$select.addEventListener("focus",()=>{this.$display.classList.add("focus")}),this.$select.addEventListener("blur",()=>{this.$display.classList.remove("focus")}),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.updateDisplay()}updateDisplay(){const t=this.getValue(),i=this._values.indexOf(t);return this.$select.selectedIndex=i,this.$display.innerHTML=-1===i?t:this._names[i],this}}class u extends t{constructor(t,i,e){super(t,i,e,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",()=>{this.setValue(this.$input.value)}),this.$input.addEventListener("keydown",t=>{"Enter"===t.code&&this.$input.blur()}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let p=!1;class g{constructor({parent:t,autoPlace:i=void 0===t,container:e,width:s,title:n="Controls",injectStyles:l=!0,touchStyles:r=!0}={}){if(this.parent=t,this.root=t?t.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",()=>this.openAnimated(this._closed)),this.$title.addEventListener("keydown",t=>{"Enter"!==t.code&&"Space"!==t.code||(t.preventDefault(),this.$title.click())}),this.$title.addEventListener("touchstart",()=>{},{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(n),r&&this.domElement.classList.add("allow-touch-styles"),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),!p&&l&&(!function(t){const i=document.createElement("style");i.innerHTML=t;const e=document.querySelector("head link[rel=stylesheet], head style");e?document.head.insertBefore(i,e):document.head.appendChild(i)}('.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"â";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"â¾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"â¸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"â";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}'),p=!0),e?e.appendChild(this.domElement):i&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),s&&this.domElement.style.setProperty("--width",s+"px"),this.domElement.addEventListener("keydown",t=>t.stopPropagation()),this.domElement.addEventListener("keyup",t=>t.stopPropagation())}add(t,e,s,n,l){if(Object(s)===s)return new c(this,t,e,s);const r=t[e];switch(typeof r){case"number":return new d(this,t,e,s,n,l);case"boolean":return new i(this,t,e);case"string":return new u(this,t,e);case"function":return new h(this,t,e)}console.error("gui.add failed\n\tproperty:",e,"\n\tobject:",t,"\n\tvalue:",r)}addColor(t,i,e=1){return new a(this,t,i,e)}addFolder(t){return new g({parent:this,title:t})}load(t,i=!0){return t.controllers&&this.controllers.forEach(i=>{i instanceof h||i._name in t.controllers&&i.load(t.controllers[i._name])}),i&&t.folders&&this.folders.forEach(i=>{i._title in t.folders&&i.load(t.folders[i._title])}),this}save(t=!0){const i={controllers:{},folders:{}};return this.controllers.forEach(t=>{if(!(t instanceof h)){if(t._name in i.controllers)throw new Error(`Cannot save GUI with duplicate property "${t._name}"`);i.controllers[t._name]=t.save()}}),t&&this.folders.forEach(t=>{if(t._title in i.folders)throw new Error(`Cannot save GUI with duplicate folder "${t._title}"`);i.folders[t._title]=t.save()}),i}open(t=!0){return this._closed=!t,this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(t=!0){return this._closed=!t,this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame(()=>{const i=this.$children.clientHeight;this.$children.style.height=i+"px",this.domElement.classList.add("transition");const e=t=>{t.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",e))};this.$children.addEventListener("transitionend",e);const s=t?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!t),requestAnimationFrame(()=>{this.$children.style.height=s+"px"})}),this}title(t){return this._title=t,this.$title.innerHTML=t,this}reset(t=!0){return(t?this.controllersRecursive():this.controllers).forEach(t=>t.reset()),this}onChange(t){return this._onChange=t,this}_callOnChange(t){this.parent&&this.parent._callOnChange(t),void 0!==this._onChange&&this._onChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(t){this.parent&&this.parent._callOnFinishChange(t),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach(t=>t.destroy())}controllersRecursive(){let t=Array.from(this.controllers);return this.folders.forEach(i=>{t=t.concat(i.controllersRecursive())}),t}foldersRecursive(){let t=Array.from(this.folders);return this.folders.forEach(i=>{t=t.concat(i.foldersRecursive())}),t}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (g);


/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/FontLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/FontLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Font: () => (/* binding */ Font),
/* harmony export */   FontLoader: () => (/* binding */ FontLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


class FontLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			const font = scope.parse( JSON.parse( text ) );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new Font( json );

	}

}

//

class Font {

	constructor( data ) {

		this.isFont = true;

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			shapes.push( ...paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/utils/TextureUtils.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/utils/TextureUtils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decompress: () => (/* binding */ decompress)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


let _renderer;
let fullscreenQuadGeometry;
let fullscreenQuadMaterial;
let fullscreenQuad;

function decompress( texture, maxTextureSize = Infinity, renderer = null ) {

	if ( ! fullscreenQuadGeometry ) fullscreenQuadGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 2, 2, 1, 1 );
	if ( ! fullscreenQuadMaterial ) fullscreenQuadMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial( {
		uniforms: { blitTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform( texture ) },
		vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
		fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
	} );

	fullscreenQuadMaterial.uniforms.blitTexture.value = texture;
	fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;
	fullscreenQuadMaterial.needsUpdate = true;

	if ( ! fullscreenQuad ) {

		fullscreenQuad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( fullscreenQuadGeometry, fullscreenQuadMaterial );
		fullscreenQuad.frustumCulled = false;

	}

	const _camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera();
	const _scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();
	_scene.add( fullscreenQuad );

	if ( renderer === null ) {

		renderer = _renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer( { antialias: false } );

	}

	const width = Math.min( texture.image.width, maxTextureSize );
	const height = Math.min( texture.image.height, maxTextureSize );

	renderer.setSize( width, height );
	renderer.clear();
	renderer.render( _scene, _camera );

	const canvas = document.createElement( 'canvas' );
	const context = canvas.getContext( '2d' );

	canvas.width = width;
	canvas.height = height;

	context.drawImage( renderer.domElement, 0, 0, width, height );

	const readableTexture = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture( canvas );

	readableTexture.minFilter = texture.minFilter;
	readableTexture.magFilter = texture.magFilter;
	readableTexture.wrapS = texture.wrapS;
	readableTexture.wrapT = texture.wrapT;
	readableTexture.name = texture.name;

	if ( _renderer ) {

		_renderer.forceContextLoss();
		_renderer.dispose();
		_renderer = null;

	}

	return readableTexture;

}


/***/ }),

/***/ "./src/modal/modal-interop.js":
/*!************************************!*\
  !*** ./src/modal/modal-interop.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   focusElement: () => (/* binding */ focusElement),
/* harmony export */   getModalDialogRect: () => (/* binding */ getModalDialogRect),
/* harmony export */   setModalPosition: () => (/* binding */ setModalPosition),
/* harmony export */   startModalDrag: () => (/* binding */ startModalDrag),
/* harmony export */   stopModalDrag: () => (/* binding */ stopModalDrag)
/* harmony export */ });
var currentDotNetHelper;
var currentModalDialogElement; // Store the element reference passed from Blazor

// We don't need setupDraggableModal anymore, as positioning is done via drag.
// If you want initial centering, it's better done in CSS or after rendering using modalDialogElementRef.

var getModalDialogRect = function getModalDialogRect(element) {
  // Now accepts an ElementReference
  if (element) {
    return element.getBoundingClientRect();
  }
  return null;
};
var startModalDrag = function startModalDrag(dotNetHelper, element) {
  // Now accepts ElementReference
  currentDotNetHelper = dotNetHelper;
  currentModalDialogElement = element; // Store the passed element

  if (currentModalDialogElement) {
    // Ensure the modal dialog is position: absolute for dragging
    currentModalDialogElement.style.position = 'absolute';
    currentModalDialogElement.style.margin = '0'; // Remove default margin (if Bootstrap is applying it)

    // Set initial position if it hasn't been set by CSS transform
    // Or if you want it centered initially, you can set it here based on window size
    // This is more complex to do reliably in JS without knowing viewport,
    // so rely on initial CSS transform if possible.

    document.onmousemove = function (e) {
      currentDotNetHelper.invokeMethodAsync('HandleMouseMove', e.clientX, e.clientY);
    };
    document.onmouseup = function () {
      currentDotNetHelper.invokeMethodAsync('HandleMouseUp');
      stopModalDrag();
    };
  }
};
var stopModalDrag = function stopModalDrag() {
  document.onmousemove = null;
  document.onmouseup = null;
  currentDotNetHelper = null;
  currentModalDialogElement = null; // Clear the stored element
};

// getModalDialogElement is now removed as it's no longer needed

var setModalPosition = function setModalPosition(x, y) {
  // No longer accepts element, uses stored one
  if (currentModalDialogElement) {
    currentModalDialogElement.style.left = "".concat(x, "px");
    currentModalDialogElement.style.top = "".concat(y, "px");
  }
};
var focusElement = function focusElement(element) {
  if (element) {
    element.focus();
  }
};

/***/ }),

/***/ "./src/mySLD.js":
/*!**********************!*\
  !*** ./src/mySLD.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawSLD: () => (/* binding */ drawSLD),
/* harmony export */   updateSLD: () => (/* binding */ updateSLD),
/* harmony export */   updateSLDItem: () => (/* binding */ updateSLDItem),
/* harmony export */   updateSLDWithStudyResults: () => (/* binding */ updateSLDWithStudyResults)
/* harmony export */ });
/* harmony import */ var _joint_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @joint/core */ "./node_modules/@joint/core/dist/joint.js");
/* harmony import */ var _joint_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_joint_core__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


var dotNetObjDraw;
var dotNetObjSLD;
var graph, paper;
var sldComponentsJS = [];
var sldComponentsString1;
var propertyButton = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.elementTools.Button({
  focusOpacity: 0.5,
  // slightly right corner
  x: '0%',
  y: '50%',
  offset: {
    x: 10,
    y: 0
  },
  action: function action(evt) {
    if (dotNetObjSLD) dotNetObjSLD.invokeMethodAsync('PropertyUpdate', this.model.tag, this.model.type);
  },
  markup: [{
    tagName: 'circle',
    selector: 'button',
    attributes: {
      'r': 7,
      'fill': '#001DFF',
      'cursor': 'pointer'
    }
  }, {
    tagName: 'path',
    selector: 'icon',
    attributes: {
      'd': 'M -2 4 2 4 M 0 3 0 0 M -2 -1 1 -1 M -1 -4 1 -4',
      'fill': 'none',
      'stroke': '#FFFFFF',
      'stroke-width': 2,
      'pointer-events': 'none'
    }
  }]
});
var infoButton = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Button({
  markup: [{
    tagName: 'circle',
    selector: 'button',
    attributes: {
      'r': 7,
      'fill': '#001DFF',
      'cursor': 'pointer'
    }
  }, {
    tagName: 'path',
    selector: 'icon',
    attributes: {
      'd': 'M -2 4 2 4 M 0 3 0 0 M -2 -1 1 -1 M -1 -4 1 -4',
      'fill': 'none',
      'stroke': '#FFFFFF',
      'stroke-width': 2,
      'pointer-events': 'none'
    }
  }],
  distance: '50%',
  offset: 0,
  action: function action(evt) {
    console.log('View id: ' + this.id + '\n' + 'Model id: ' + this.model.id);
  }
});
var removeButton = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Button({
  markup: [{
    tagName: 'circle',
    selector: 'button',
    attributes: {
      'r': 7,
      'fill': 'red',
      'cursor': 'pointer'
    }
  }, {
    tagName: 'path',
    selector: 'icon',
    attributes: {
      'd': 'M -4 4 L 4 -4 M 4 4 L -4 -4',
      'fill': 'none',
      'stroke': '#FFFFFF',
      'stroke-width': 2,
      'pointer-events': 'none'
    }
  }],
  distance: '25%',
  offset: 0,
  action: function action(evt) {
    // Get the link by its ID
    var link = graph.getCell(this.model.id);
    if (link && link.isLink()) {
      removeLink(link);
    } else {
      console.log("Link id '".concat(this.id, "' of link model '").concat(this.model.id, "' not available."));
    }
  }
});
var validateButton = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Button({
  markup: [{
    tagName: 'circle',
    selector: 'button',
    attributes: {
      'r': 7,
      'fill': 'green',
      'cursor': 'pointer'
    }
  }, {
    tagName: 'path',
    selector: 'icon',
    attributes: {
      'd': 'M -2.5 -0.2 l 0.23 -0.24 c 0.34 0.1 1 0.35 1.7 0.72 c 0.6 -0.8 2 -1.9 2.7 -2.4 l 0.2 0.2 l -2.8 3.78 l -2 -2 z',
      'fill': 'none',
      'stroke': '#FFFFFF',
      'stroke-width': 2,
      'pointer-events': 'none'
    }
  }],
  distance: '75%',
  offset: 0,
  action: function action(evt) {
    // Get the link by its ID
    var link = graph.getCell(this.model.id);
    if (link && link.isLink()) {
      validateLinkFromServer(link);
    } else {
      console.log("Link id '".concat(this.id, "' of link model '").concat(this.model.id, "' not available."));
    }
  }
});
function updateSLD() {
  console.log("Client side Update SLD");
  var allChildren = graph.getElements();
  console.log("Graph has ".concat(allChildren.length, " children. sldComponents has ").concat(sldComponentsJS.length, " items."));
  for (var i = 0; i < sldComponentsJS.length; i += 10) {
    var sldComponentsString = JSON.stringify(sldComponentsJS.slice(i, Math.min(sldComponentsJS.length, i + 9)));
    //sldComponentsString = "";
    if (dotNetObjSLD) dotNetObjSLD.invokeMethodAsync('SLDComponentUpdate', sldComponentsString);
  }
  sldComponentsJS = [];
}
function updateSLDItem(itemJSON, modalType, originalTag, branchesString) {
  console.log("Client side Update SLDItem", modalType, itemJSON);
  var item = JSON.parse(itemJSON);
  var branches = JSON.parse(branchesString);
  var itemModel = graph.getElements().find(function (el) {
    return el.tag === originalTag;
  });
  switch (modalType) {
    case "Bus":
      itemModel = updateBus(itemModel, item, branches);
      break;
    case "Transformer":
      itemModel = updateTransformer(itemModel, item, branches);
      break;
    case "CableBranch":
      itemModel = updateCable(itemModel, item, branches);
      break;
    case "BusDuct":
      itemModel = updateBusDuct(itemModel, item, branches);
      break;
    case "Switch":
      itemModel = updateSwitch(itemModel, item, branches);
      break;
    case "Capacitor":
      itemModel = updateCapacitor(itemModel, item, branches);
      break;
    case "Motor":
      itemModel = updateMotor(itemModel, item, branches);
      break;
    case "Heater":
      itemModel = updateHeater(itemModel, item, branches);
      break;
    case "LumpLoad":
      itemModel = updateLumpLoad(itemModel, item, branches);
      break;
    default:
      //itemModel = updateBus(itemModel, item, branches);
      break;
  }

  // check if there is any change in the tag of the item
  // then the link tag connecting to the item should be updated
  var itemModels = graph.getLinks().filter(function (el) {
    return el.source && el.source.hasOwnProperty('tag') && el.source.tag === originalTag || el.target && el.target.hasOwnProperty('tag') && el.target.tag === originalTag;
  });
  var itemModels1 = graph.getLinks().filter(function (el) {
    return el.source && el.source.hasOwnProperty('tag') && el.source.tag === item.Tag || el.target && el.target.hasOwnProperty('tag') && el.target.tag === item.Tag;
  });

  // Retrieve all link models in the graph
  var links = graph.getLinks(); // or graph.getElements() if you want all elements

  // Filter links based on the property value
  var filteredLinks = links.filter(function (link) {
    return link.attr('source/tag') === originalTag;
  });
  itemModels.forEach(function (itemModel) {
    return itemModel = getLinkTag(itemModel);
  });
}
function updateSLDWithStudyResults(busesString, switchboardString, switchString, branchesString, loadsString, transformersString, cableBranchesString, busDuctsString) {
  var buses = JSON.parse(busesString);
  var switchboards = JSON.parse(switchboardString);
  var switches = JSON.parse(switchString);
  var branches = JSON.parse(branchesString);
  var loads = JSON.parse(loadsString);
  var transformers = JSON.parse(transformersString);
  var cableBranches = JSON.parse(cableBranchesString);
  var busDucts = JSON.parse(busDuctsString);
  buses.forEach(function (item) {
    var itemModel = graph.getElements().find(function (el) {
      return el.tag && el.tag === item.Tag;
    });
    if (itemModel) itemModel = updateBus(itemModel, item);
  });
  transformers.forEach(function (item) {
    if (!branches.find(function (br) {
      return br.Tag === item.Tag;
    })) return;
    var itemModel = graph.getElements().find(function (el) {
      return el.tag && el.tag === item.Tag;
    });
    if (itemModel) itemModel = updateTransformer(itemModel, item, branches);
  });
  cableBranches.forEach(function (item) {
    if (!branches.find(function (br) {
      return br.Tag === item.Tag;
    })) return;
    var itemModel = graph.getElements().find(function (el) {
      return el.tag && el.tag === item.Tag;
    });
    if (itemModel) itemModel = updateCable(itemModel, item, branches);
  });
  busDucts.forEach(function (item) {
    if (!branches.find(function (br) {
      return br.Tag === item.Tag;
    })) return;
    var itemModel = graph.getElements().find(function (el) {
      return el.tag && el.tag === item.Tag;
    });
    if (itemModel) itemModel = updateBusDuct(itemModel, item, branches);
  });
  loads.forEach(function (item) {
    var itemModel = graph.getElements().find(function (el) {
      return el.tag && el.tag === item.Tag;
    });
    if (itemModel) {
      if (item.Category === "Motor") {
        itemModel = updateMotor(itemModel, item, branches);
      } else if (item.Category === "Heater") {
        itemModel = updateHeater(itemModel, item, branches);
      } else if (item.Category === "LumpLoad") {
        itemModel = updateLumpLoad(itemModel, item, branches);
      }
    }
  });
  switches.forEach(function (item) {
    var itemModel = graph.getElements().find(function (el) {
      return el.tag === item.Tag;
    });
    if (itemModel) itemModel = updateSwitch(itemModel, item, branches);
  });
}
function drawSLD(divString, xGridSize, yGridSize, leftSpacing, topSpacing, xGridSpacing, yGridSpacing, busesString, switchboardString, branchesString, loadsString, transformersString, cablesString, busDuctsString, xyString, sldComponentsString, dotNetObjRef, dotNetObjSLDRef) {
  // Define the custom drawing elements
  // grid   
  var GridElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('CustomGridElement', {
    attrs: {
      // size 40 x 40
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '50%',
        refY: '10%'
      },
      // textAnchor: middle: Align text to the middle horizontally
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'middle',
        fontSize: 10,
        refX: '50%',
        refY: -45
      },
      // textAnchor end: Right align text// Adjust horizontal position relative to refX
      ratedSC: {
        fill: 'black',
        textAnchor: 'end',
        fontSize: 10,
        refX: '50%',
        refY: -35,
        dx: -2
      },
      ratedVoltage: {
        fill: 'black',
        textAnchor: 'start',
        fontSize: 10,
        refX: '50%',
        refY: -35,
        dx: 2
      },
      busFaultkA: {
        fill: 'red',
        fontWeight: 'bold',
        textAnchor: 'end',
        fontSize: 10,
        refX: '50%',
        refY: 5,
        dx: -10
      },
      operatingVoltage: {
        fill: 'blue',
        textAnchor: 'start',
        fontSize: 10,
        refX: '50%',
        refY: 5,
        dx: 10
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '50%',
              y: 10
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10,
                y: -5
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: '1',
        group: 'in'
      }] // bus can have muliple ports
    }
  }, {
    markup: [{
      //https://yqnn.github.io/svg-path-editor/
      tagName: 'path',
      selector: 'body',
      attributes: {
        d: 'M 0 0 v -6 h -9 v -18 h 18 v 18 h -9 m -3 0 l -6 -6 l 12 -12 l 6 6 l -12 12 m 6 0 l -12 -12 l 6 -6 l 12 12 l -6 6 m 6 0 l -18 -18 m 18 0 l -18 18 z',
        stroke: 'blue',
        strokeWidth: 1,
        fill: 'none'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'ratedSC'
    }, {
      tagName: 'text',
      selector: 'ratedVoltage'
    }, {
      tagName: 'text',
      selector: 'busFaultkA'
    }, {
      tagName: 'text',
      selector: 'operatingVoltage'
    }]
  });

  // switchboard    
  var SwitchboardElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('SwitchboardElement', {
    attrs: {
      root: {
        magnet: false
      },
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refCx: '0%',
        refCy: '100%',
        strokeWidth: 1,
        strokeDasharray: '5,5',
        stroke: 'brown',
        fill: 'none',
        refX: '0%',
        refY: '0%',
        alphaValue: 0.4
      },
      tag: {
        ref: 'body',
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'start',
        fontSize: 8,
        refX: 5,
        refY: 5
      },
      '.': {
        'pointer-events': 'none'
      }
    }
  }, {
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, {
      tagName: 'text',
      selector: 'tag'
    }]
  });

  // node 
  var NodeElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('CustomNodeElement', {
    attrs: {
      root: {
        magnet: false
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'start',
        fontSize: 8,
        refX: '0%',
        refY: -12
      },
      ratedSC: {
        textAnchor: 'start',
        fontSize: 8,
        fill: 'brown',
        refX: '0%',
        refY: 5
      },
      ratedVoltage: {
        textAnchor: 'start',
        fontSize: 8,
        fill: 'blue',
        refX: 25,
        refY: 5
      },
      busFault: {
        textAnchor: 'end',
        fontSize: 8,
        fill: 'red',
        refX: '100%',
        refY: -12
      },
      operatingVoltage: {
        textAnchor: 'end',
        fontSize: 8,
        fill: 'blue',
        refX: '100%',
        refY: 5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            name: 'absolute',
            args: {
              x: '50%',
              y: 0
            }
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: '1',
        group: 'in'
      }] // node has only one port
    }
  }, {
    markup: [{
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'ratedSC'
    }, {
      tagName: 'text',
      selector: 'ratedVoltage'
    }, {
      tagName: 'text',
      selector: 'busFault'
    }, {
      tagName: 'text',
      selector: 'operatingVoltage'
    }]
  });

  // bus
  var BusElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('CustomBusElement', {
    attrs: {
      root: {
        magnet: false
      },
      body: {
        stroke: 'blue',
        strokeWidth: 5,
        fill: 'transparent'
      },
      label: {
        ref: 'body',
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'start',
        fontSize: 8,
        refX: '0%',
        refY: -12
      },
      ratedSC: {
        ref: 'body',
        textAnchor: 'start',
        fontSize: 8,
        fill: 'brown',
        refX: '0%',
        refY: 5
      },
      ratedVoltage: {
        ref: 'body',
        textAnchor: 'start',
        fontSize: 8,
        fill: 'blue',
        refX: 25,
        refY: 5
      },
      busFault: {
        ref: 'body',
        textAnchor: 'end',
        fontSize: 8,
        fill: 'red',
        refX: '100%',
        refY: -12
      },
      operatingVoltage: {
        ref: 'body',
        textAnchor: 'end',
        fontSize: 8,
        fill: 'blue',
        refX: '100%',
        refY: 5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '50%',
              y: 0
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10,
                y: -5
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
        //'out': {
        //    position: { name: 'absolute', args: { x: '50%', y: 2 } },
        //    label: { position: { name: 'right', args: { x: 10, y: 5 } }, markup: [{ tagName: 'text', selector: 'label' }] },
        //    attrs: { portBody: { magnet: true, r: 3, fill: '#E6A502', stroke: '#023047' }, label: { text: 'to', fontSize: 8, } },
        //    markup: [{ tagName: 'circle', selector: 'portBody' }],
        //}
      },
      items: [{
        id: '1',
        group: 'in'
      }] // bus can have muliple ports
    }
  }, {
    markup: [{
      tagName: 'line',
      selector: 'body'
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'ratedSC'
    }, {
      tagName: 'text',
      selector: 'ratedVoltage'
    }, {
      tagName: 'text',
      selector: 'busFault'
    }, {
      tagName: 'text',
      selector: 'operatingVoltage'
    }]
  });

  // node 
  var BusNodeElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('BusNodeElement', {
    attrs: {
      body: {
        r: 14,
        // Radius of the circle
        cx: '50%',
        // Center x-coordinate (relative to the element's width)
        cy: '50%',
        // Center y-coordinate (relative to the element's height)
        strokeWidth: 1,
        stroke: '#000000',
        fill: 'yellow'
      }
    }
  }, {
    markup: [{
      tagName: 'circle',
      selector: 'body'
    }]
  });

  // load
  var LoadElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('LoadElement', {
    attrs: {
      body: {
        refWidth: '100%',
        // Full width of the element
        refHeight: '100%',
        // Full height of the element
        strokeWidth: 1,
        stroke: '#000000',
        fill: 'pink'
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'middle',
        // Center-align text
        fontSize: 8,
        refX: 0,
        // Center alignment horizontally
        refY: 35 // Adjust as needed
      },
      operatingPower: {
        fill: 'blue',
        textAnchor: 'middle',
        // Center-align text
        fontSize: 8,
        refX: 0,
        // Center alignment horizontally
        refY: 45 // Adjust as needed
      },
      rating: {
        fill: 'black',
        textAnchor: 'middle',
        // Center-align text
        fontSize: 8,
        refX: 0,
        // Center alignment horizontally
        refY: 55 // Adjust as needed
      }
    }
  }, {
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'operatingPower'
    },
    // Adjusted order
    {
      tagName: 'text',
      selector: 'rating'
    } // Adjusted order
    ]
  });

  // lump load 
  var LumpLoadElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('LumpLoadElement', {
    attrs: {
      root: {
        magnet: false
      },
      body1: {
        refRCircumscribed: '25%',
        refCx: '0%',
        refCy: '50%',
        strokeWidth: 1,
        stroke: 'black',
        fill: 'cyan',
        refX: '0%',
        refY: '-15%',
        alphaValue: 0.4
      },
      body2: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '0%',
        refY: '0%',
        stroke: 'black',
        strokeWidth: 1,
        fill: 'none'
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -25
      },
      operatingPower: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -15
      },
      rating: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '0%',
              y: -10
            }
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }]
    }
  }, {
    markup: [{
      tagName: 'circle',
      selector: 'body1'
    }, {
      tagName: 'path',
      selector: 'body2',
      attributes: {
        d: 'm 0 15 L -15 15 L 0 38 L 15 15 L 0 15 m 0 0 v -20 Z'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'operatingPower'
    }, {
      tagName: 'text',
      selector: 'rating'
    }]
  });

  // capacitor 
  var CapacitorElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('CapacitorElement', {
    attrs: {
      root: {
        magnet: false
      },
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '0%',
        refY: '0%',
        stroke: 'black',
        strokeWidth: 2
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -25
      },
      operatingPower: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -15
      },
      rating: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '0%',
              y: -10
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10,
                y: -5
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }]
    }
  }, {
    markup: [{
      tagName: 'path',
      selector: 'body',
      attributes: {
        d: 'M -20 15 L 20 15 L -20 15 Z M -21 30 C -10 16 10 16 20 30 m 0 0 C 10 16 -10 16 -21 30 M 0 20 L 0 37 M 0 15 L 0 0 Z'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'operatingPower'
    }, {
      tagName: 'text',
      selector: 'rating'
    }]
  });

  // transformer element   
  var TransformerElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('TransformerElement', {
    attrs: {
      root: {
        magnet: false
      },
      // primary: 100%/sqrt(2), i.e., radious is 100% of the width/heght of the element size width
      primary: {
        refRCircumscribed: '71%',
        refCx: '0%',
        refCy: '50%',
        strokeWidth: 1,
        stroke: 'black',
        fill: 'aquamarine',
        refX: '0%',
        refY: '-75%',
        alphaValue: 0.4
      },
      secondary: {
        refRCircumscribed: '71%',
        refCx: '0%',
        refCy: '50%',
        strokeWidth: 1,
        stroke: 'black',
        fill: 'aquamarine',
        refX: '%',
        refY: '75%'
      },
      tag: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: '150%',
        refY: -15
      },
      voltage: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: '150%',
        refY: -5
      },
      kVArating: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: '150%',
        refY: 5
      },
      impedance: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: '150%',
        refY: 15
      },
      loading: {
        fill: 'blue',
        textAnchor: 'right',
        fontSize: 8,
        refX: '150%',
        refY: 25
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            name: 'left',
            args: {
              y: -22
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: 'black'
            },
            label: {
              text: 'from',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        },
        'out': {
          position: {
            name: 'left',
            args: {
              y: 37
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: 'black'
            },
            label: {
              text: 'to',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }, {
        id: 'portOut',
        group: 'out'
      }]
    }
  }, {
    markup: [{
      tagName: 'circle',
      selector: 'primary'
    }, {
      tagName: 'circle',
      selector: 'secondary'
    }, {
      tagName: 'text',
      selector: 'tag'
    }, {
      tagName: 'text',
      selector: 'voltage'
    }, {
      tagName: 'text',
      selector: 'kVArating'
    }, {
      tagName: 'text',
      selector: 'impedance'
    }, {
      tagName: 'text',
      selector: 'loading'
    }]
  });

  // bus duct
  var BusDuctElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('BusDuctElement', {
    attrs: {
      root: {
        magnet: false
      },
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '0%',
        refY: '0%',
        stroke: 'black',
        strokeWidth: 1
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -25
      },
      size: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -15
      },
      length: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -5
      },
      impedance: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: 5
      },
      operatingCurrent: {
        fill: 'blue',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: 15
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            name: 'left',
            args: {
              y: '-50%'
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'white',
              stroke: 'black'
            },
            label: {
              text: 'from',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        },
        'out': {
          position: {
            name: 'left',
            args: {
              y: '50%'
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'white',
              stroke: 'black'
            },
            label: {
              text: 'to',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }, {
        id: 'portOut',
        group: 'out'
      }]
    }
  }, {
    markup: [{
      //https://yqnn.github.io/svg-path-editor/
      tagName: 'path',
      selector: 'body',
      attributes: {
        d: 'M -3 15 L -5 25 L -3 15 L -3 -15 L -5 -25 L -3 -15 M 0 -25 L 0 25 M 3 15 L 5 25 L 3 15 L 3 -15 L 5 -25 L 3 -15'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'size'
    }, {
      tagName: 'text',
      selector: 'length'
    }, {
      tagName: 'text',
      selector: 'impedance'
    }, {
      tagName: 'text',
      selector: 'operatingCurrent'
    }]
  });

  // cable 
  var CableElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('CableElement', {
    attrs: {
      root: {
        magnet: false
      },
      //body: { refWidth: '100%', refHeight: '100%', strokeWidth: 1, stroke: '#A00000', fill: 'orange', refX: 0, refY: -25 },
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '50%',
        refY: '10%'
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 25,
        refY: -20
      },
      size: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 25,
        refY: -10
      },
      length: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 25,
        refY: 0
      },
      impedance: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 25,
        refY: 10
      },
      operatingCurrent: {
        fill: 'blue',
        textAnchor: 'right',
        fontSize: 8,
        refX: 25,
        refY: 20
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            name: 'left',
            args: {
              x: 5,
              y: -25
            }
          },
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: 'from',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        },
        'out': {
          position: {
            name: 'left',
            args: {
              x: 5,
              y: 32
            }
          },
          // size 10x60
          label: {
            position: {
              name: 'right',
              args: {
                x: 10
              }
            },
            markup: [{
              tagName: 'text',
              selector: 'label'
            }]
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: '#E6A502',
              stroke: '#023047'
            },
            label: {
              text: 'to',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }, {
        id: 'portOut',
        group: 'out'
      }]
    }
  }, {
    markup: [{
      //https://yqnn.github.io/svg-path-editor/
      tagName: 'path',
      selector: 'body',
      attributes: {
        d: 'M 5 -25 C 3 -20 -3 -20 -5 -25 L -5 20 C -3 15 3 15 5 20 L 5 -25 C 3 -30 -3 -30 -5 -25 M -5 20 C -3 25 3 25 5 20',
        stroke: 'black',
        strokeWidth: 1,
        fill: 'orange'
      }
    },
    //{ tagName: 'rect', selector: 'body' },
    {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'size'
    }, {
      tagName: 'text',
      selector: 'length'
    }, {
      tagName: 'text',
      selector: 'impedance'
    }, {
      tagName: 'text',
      selector: 'operatingCurrent'
    }]
  });

  // motor
  var MotorElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('MotorElement', {
    attrs: {
      root: {
        magnet: false
      },
      body1: {
        refRCircumscribed: '25%',
        refCx: '0%',
        refCy: '50%',
        strokeWidth: 1,
        stroke: 'black',
        fill: 'azure',
        refX: '0%',
        refY: '-15%',
        alphaValue: 0.4
      },
      body2: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '0%',
        refY: '0%',
        stroke: 'black',
        strokeWidth: 1,
        fill: 'none'
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -25
      },
      operatingPower: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -15
      },
      rating: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '0%',
              y: -10
            }
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }]
    }
  }, {
    markup: [{
      tagName: 'circle',
      selector: 'body1'
    }, {
      tagName: 'path',
      selector: 'body2',
      attributes: {
        d: 'm -8 30 L -8 15 L 0 25 L 8 15 L 8 30 L 8 15 L 0 25 L -8 15 L -8 30  m 8 -25 v -13 Z'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'operatingPower'
    }, {
      tagName: 'text',
      selector: 'rating'
    }]
  });

  // heater
  var HeaterElement = _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Element.define('Heaterlement', {
    attrs: {
      root: {
        magnet: false
      },
      body: {
        refWidth: '100%',
        refHeight: '100%',
        refX: '0%',
        refY: '0%',
        stroke: 'black',
        strokeWidth: 1,
        fill: 'cornsilk'
      },
      label: {
        fill: 'blue',
        fontWeight: 'bold',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -25
      },
      operatingPower: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -15
      },
      rating: {
        fill: 'black',
        textAnchor: 'right',
        fontSize: 8,
        refX: 15,
        refY: -5
      }
    },
    ports: {
      groups: {
        'in': {
          position: {
            ref: 'body',
            name: 'absolute',
            args: {
              x: '0%',
              y: -10
            }
          },
          attrs: {
            portBody: {
              magnet: true,
              r: 3,
              fill: 'orange',
              stroke: '#023047'
            },
            label: {
              text: '1',
              fontSize: 8
            }
          },
          markup: [{
            tagName: 'circle',
            selector: 'portBody'
          }]
        }
      },
      items: [{
        id: 'portIn',
        group: 'in'
      }]
    }
  }, {
    markup: [{
      tagName: 'path',
      selector: 'body',
      attributes: {
        d: 'm -15 5 L 15 5 L 15 55 L -15 55 L -15 5 m 0 10 L 15 15 M 15 25 L -15 25 M -15 35 L 15 35 M 15 45 L -15 45 m 15 -40 v -14 Z'
      }
    }, {
      tagName: 'text',
      selector: 'label'
    }, {
      tagName: 'text',
      selector: 'operatingPower'
    }, {
      tagName: 'text',
      selector: 'rating'
    }]
  });

  // link
  var branchLink = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Link({
    router: {
      name: 'manhattan'
    },
    connector: {
      name: 'rounded',
      args: {
        radius: 2
      },
      jumpover: {
        size: 6
      }
    },
    attrs: {
      line: {
        stroke: '#333333',
        strokeWidth: 2,
        sourceMarker: {
          type: 'circle',
          r: 2,
          fill: 'none'
        },
        targetMarker: {
          type: 'circle',
          r: 2,
          fill: 'none'
        }
      }
    }
  });
  dotNetObjDraw = dotNetObjRef;
  dotNetObjSLD = dotNetObjSLDRef;
  var buses = JSON.parse(busesString);
  var branches = JSON.parse(branchesString);
  var loads = JSON.parse(loadsString);
  var transformers = JSON.parse(transformersString);
  var cables = JSON.parse(cablesString);
  var busDucts = JSON.parse(busDuctsString);
  var sldComponents = JSON.parse(sldComponentsString);
  sldComponentsString1 = sldComponentsString;
  var switchboards = JSON.parse(switchboardString);

  //var xy = JSON.parse(xyString);
  //console.log("hello" + JSON.stringify(buses));

  // define namespace, includes default imported joint standrad namespace 'shapes'
  // and other shapes (e.g.,RectangleTwoLabels) under 'custom' namespace
  var namespace = {
    shapes: _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes,
    BusElement: BusElement,
    SwitchboardElement: SwitchboardElement,
    CableElement: CableElement,
    TransformerElement: TransformerElement,
    LoadElement: LoadElement,
    BusNodeElement: BusNodeElement,
    BusDuctElement: BusDuctElement,
    GridElement: GridElement,
    LumpLoadElement: LumpLoadElement,
    CapacitorElement: CapacitorElement,
    NodeElement: NodeElement
  };
  var defaultGrid = buses.filter(function (item) {
    return item.Category === "Swing";
  })[0];
  var defaultBus = buses.filter(function (item) {
    return item.Category !== "Swing";
  })[0];
  var defaultCable = cables[0];
  var defaultTransformer = transformers[0];
  var defaultBusduct = busDucts[0];
  graph = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Graph({}, {
    cellNamespace: namespace
  });
  paper = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.Paper({
    el: document.getElementById(divString),
    model: graph,
    width: xGridSize,
    height: yGridSize,
    gridSize: 5,
    drawGrid: true,
    background: {
      color: '#F5F5F5'
    },
    cellViewNamespace: namespace,
    interactive: function interactive(cellView) {
      if (cellView.model.isElement()) {
        return {
          elementMove: interaction
        };
      }
      return true;
    },
    defaultLink: function defaultLink() {
      return new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Link({
        router: {
          name: 'manhattan'
        },
        connector: {
          name: 'rounded',
          args: {
            radius: 3
          },
          jumpover: {
            size: 6
          }
        },
        attrs: {
          line: {
            stroke: '#000000',
            // Ensure the line is visible with a color
            strokeWidth: 2,
            // Adjust stroke width as needed
            sourceMarker: {
              type: 'circle',
              r: 3,
              fill: 'yellow'
            },
            targetMarker: {
              type: 'circle',
              r: 3,
              fill: 'green'
            }
          },
          label: {
            textAnchor: 'middle',
            // Center the text horizontally
            refX: 0.5,
            // Adjust as needed
            refY: -10,
            // Position label above the line
            fontSize: 12,
            // Adjust font size as needed
            fill: '#000000' // Color for the label text
          }
        }
      }, {
        markup: [{
          tagName: 'path',
          selector: 'line'
        }, {
          tagName: 'text',
          selector: 'label'
        }]
      });
    },
    linkPinning: false,
    validateConnection: function validateConnection(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
      // Prevent loop linking
      if (magnetS === magnetT) return false;
      // Prevent the link to self
      if (cellViewS === cellViewT) return false;

      // Prevent linking more than one link
      var sourcePortId = linkView.model.prop('source/port');
      var targetPortId = linkView.model.prop('target/port');
      var allLinksSource = graph.getConnectedLinks(cellViewS.model);
      var sourcePortLinks = allLinksSource.filter(function (link) {
        return link.prop('source/port') == sourcePortId;
      });
      var allLinksTarget = graph.getConnectedLinks(cellViewT.model);
      var targetPortLinks = allLinksTarget.filter(function (link) {
        return link.prop('target/port') == targetPortId;
      });
      console.log("Source Element '".concat(cellViewS.model.tag, "' at port '").concat(sourcePortId, "' has ").concat(sourcePortLinks.length, " connections and ") + "Target Element '".concat(cellViewT.model.tag, "' at port '").concat(targetPortId, "' has ").concat(targetPortLinks.length, " connections."));
      if (sourcePortLinks.length > 3) return false;
      if (targetPortLinks && targetPortLinks.length > 3) return false;
      linkView.model.on('change', function () {
        console.log('link changed');
      });

      // Prevent linking from input ports
      //if (magnetS && magnetS.getAttribute('port-group') === 'in') return false;
      // Prevent linking from output ports to input ports within one element
      //if (cellViewS === cellViewT) return false;
      // Prevent linking to output ports
      //return magnetT && magnetT.getAttribute('port-group') === 'in';

      // end of linking
      var sM, tM, sPort, tPort, linkM;
      sM = cellViewS.model;
      tM = cellViewT.model;
      linkM = linkView.model;
      sPort = linkM.prop('source/port');
      tPort = linkM.prop('target/port');
      return true;
    },
    validateMagnet: function validateMagnet(cellView, magnet, _evt) {
      // Note that this is the default behaviour. It is shown for reference purposes.
      // Disable linking interaction for magnets marked as passive
      return magnet.getAttribute('magnet') !== 'passive';
    },
    // Enable link snapping within 20px lookup radius
    snapLinks: {
      radius: 20
    }
  });
  paper.el.style.border = '1px solid #2E2E2E';

  // Function to check if a port has links
  function hasLink(element, portName) {
    // Get all links (edges) connected to the element
    var links = graph.getLinks();

    // Check if any link uses the specified port as source or target
    return links.some(function (link) {
      return link.get('source').id === element.id && link.get('source').port === portName || link.get('target').id === element.id && link.get('target').port === portName;
    });
  }

  // Function to get the port ID from an element and a magnet
  function getPortId(element, magnet) {
    // Iterate over all ports of the element
    for (var portName in element.getPorts()) {
      var _port = element.getPort(portName);
      // Check if the magnet matches the port element
      if (_port && _port.attrs.body.el === magnet) {
        return portName; // Return the port ID (name)
      }
    }
    return null; // Port not found
  }

  //const rect11 = new Rectangle();
  //rect11.addTo(graph);

  //var Container = shapes.container.Parent;
  //var Child = shapes.container.Child;
  //var Link = shapes.container.Link;
  //var BusElement = shapes.standard.Rectangle;
  var saveDataButton = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Rectangle();
  saveDataButton.resize(100, 30);
  saveDataButton.position(50, 30);
  saveDataButton.attr('root/title', 'joint.shapes.standard.Rectangle');
  saveDataButton.attr('label/text', 'Save Data');
  saveDataButton.attr('label/text/fill', 'white');
  saveDataButton.attr('body/fill', 'blue');
  saveDataButton.tag = "saveData";
  saveDataButton.addTo(graph);

  // create template custom shapes
  var templateGridElement = new GridElement();
  templateGridElement.type = "grid";
  templateGridElement.tag = "templateGridElement";
  templateGridElement.clicked = false;
  templateGridElement.position(50, 100);
  templateGridElement.resize(20, 80);
  templateGridElement.addTo(graph);
  var newGridElement = templateGridElement.clone();
  newGridElement.type = "grid";
  newGridElement.tag = "templateGridElement";
  newGridElement.addTo(graph);
  //
  var templateBusElement = new BusElement({
    position: {
      x: 25,
      y: 200
    },
    size: {
      width: 50,
      height: 0
    },
    attrs: {
      body: {
        x1: 0,
        y1: 0,
        x2: 50,
        y2: 0
      }
    }
  });
  templateBusElement.type = "bus";
  templateBusElement.tag = "templateBusElement";
  templateBusElement.clicked = false;
  templateBusElement.addTo(graph);
  var newBusElement = templateBusElement.clone();
  newBusElement.type = "bus";
  newBusElement.tag = "templateBusElement";
  newBusElement.addTo(graph);
  var templateCableElement = new CableElement();
  templateCableElement.type = "cable";
  templateCableElement.tag = "templateCableElement";
  templateCableElement.clicked = false;
  templateCableElement.position(50, 300);
  templateCableElement.resize(10, 60);
  templateCableElement.addTo(graph);
  var newCableElement = templateCableElement.clone();
  newCableElement.type = "cable";
  newCableElement.tag = "templateCableElement";
  newCableElement.addTo(graph);
  var templateTransformerElement = new TransformerElement();
  templateTransformerElement.type = "transformer";
  templateTransformerElement.tag = "templateTransformerElement";
  templateTransformerElement.clicked = false;
  templateTransformerElement.position(50, 400);
  templateTransformerElement.resize(15, 15);
  templateTransformerElement.addTo(graph);
  var newTransformerElement = templateTransformerElement.clone();
  newTransformerElement.type = "transformer";
  newTransformerElement.tag = "templateTransformerElement";
  newTransformerElement.addTo(graph);
  var templateBusDuctElement = new BusDuctElement();
  templateBusDuctElement.type = "busduct";
  templateBusDuctElement.tag = "templateBusDuctElement";
  templateBusDuctElement.clicked = false;
  templateBusDuctElement.position(50, 500);
  templateBusDuctElement.resize(10, 60);
  templateBusDuctElement.addTo(graph);
  var newBusDuctElement = templateBusDuctElement.clone();
  newBusDuctElement.type = "busduct";
  newBusDuctElement.tag = "templateBusDuctElement";
  newBusDuctElement.addTo(graph);
  var templateCapacitorElement = new CapacitorElement();
  templateCapacitorElement.type = "capacitor";
  templateCapacitorElement.tag = "templateCapacitorElement";
  templateCapacitorElement.clicked = false;
  templateCapacitorElement.position(50, 600);
  templateCapacitorElement.resize(30, 60);
  templateCapacitorElement.addTo(graph);
  var newCapacitorElement = templateCapacitorElement.clone();
  newCapacitorElement.type = "capacitor";
  newCapacitorElement.tag = "templateCapacitorElement";
  newCapacitorElement.addTo(graph);
  var templateMotorElement = new MotorElement();
  templateMotorElement.type = "motor";
  templateMotorElement.tag = "templateMotorElement";
  templateMotorElement.clicked = false;
  templateMotorElement.position(50, 700);
  templateMotorElement.resize(30, 60);
  templateMotorElement.addTo(graph);
  var newMotorElement = templateMotorElement.clone();
  newMotorElement.type = "motor";
  newMotorElement.tag = "templateMotorElement";
  newMotorElement.addTo(graph);
  var templateHeaterElement = new HeaterElement();
  templateHeaterElement.type = "heater";
  templateHeaterElement.tag = "templateHeaterElement";
  templateHeaterElement.clicked = false;
  templateHeaterElement.position(50, 800);
  templateHeaterElement.resize(30, 60);
  templateHeaterElement.addTo(graph);
  var newHeaterElement = templateHeaterElement.clone();
  newHeaterElement.type = "heater";
  newHeaterElement.tag = "templateHeaterElement";
  newHeaterElement.addTo(graph);
  var templateLumpLoadElement = new LumpLoadElement();
  templateLumpLoadElement.type = "lumpload";
  templateLumpLoadElement.tag = "templateLumpLoadElement";
  templateLumpLoadElement.clicked = false;
  templateLumpLoadElement.position(50, 900);
  templateLumpLoadElement.resize(30, 60);
  templateLumpLoadElement.addTo(graph);
  var newLumpLoadElement = templateLumpLoadElement.clone();
  newLumpLoadElement.type = "lumpload";
  newLumpLoadElement.tag = "templateLumpLoadElement";
  newLumpLoadElement.addTo(graph);
  var container = [];
  var child = [];
  var link = [];
  var linkCount = 0;
  var branchElement = [];
  var busesDone = [];
  var busesElement = [];
  var swbdElement = [];
  var busesNodeElement = []; // dots on bus
  var loadElement = [];

  // new items - drag from template
  paper.on('element:pointerup', function (elementView, event, x, y) {
    if (!elementView.model.tag.includes('template')) return;
    console.log('Template Element ' + elementView.model.tag + 'moved to ' + x + ',' + y);
    if (isOverlapping(elementView.model, graph)) {
      // Move the element to the nearest empty position
      var newPosition = findNearestEmptyPosition(elementView.model, graph, 50);
      elementView.model.set('position', newPosition);
    }
    if (elementView.model.tag == 'templateGridElement') {
      busesElement.push(elementView.model);
      busesElement.at(-1).tag = "Grid-".concat(busesElement.filter(function (br) {
        return br.type = "grid";
      }).length.toString().padStart(3, '0'));
      busesElement.at(-1).attr({
        label: {
          text: busesElement.at(-1).tag
        },
        ratedSC: {
          text: "0kA"
        },
        ratedVoltage: {
          text: "0kV"
        },
        busFaultkA: {
          text: "0kA"
        },
        operatingVoltage: {
          text: "0% â 0Â°"
        }
      });
      var _newGridElement = templateGridElement.clone();
      _newGridElement.type = "gid";
      _newGridElement.tag = "templateGridElement";
      _newGridElement.addTo(graph);
    } else if (elementView.model.tag == 'templateBusElement') {
      busesElement.push(elementView.model);
      busesElement.at(-1).tag = "Bus-".concat(busesElement.filter(function (br) {
        return br.type = "bus";
      }).length.toString().padStart(3, '0'));
      busesElement.at(-1).attr({
        label: {
          text: busesElement.at(-1).tag
        },
        ratedSC: {
          text: "0kA"
        },
        ratedVoltage: {
          text: "0kV"
        },
        busFaultkA: {
          text: "0kA"
        },
        operatingVoltage: {
          text: "0% â 0Â°"
        }
      });
      var _newBusElement = templateBusElement.clone();
      _newBusElement.type = "gid";
      _newBusElement.tag = "templateBusElement";
      _newBusElement.addTo(graph);
    } else if (elementView.model.tag == 'templateCableElement') {
      branchElement.push(elementView.model);
      branchElement.at(-1).tag = "Cablebranch-".concat(branchElement.filter(function (br) {
        return br.type = "cable";
      }).length.toString().padStart(3, '0'));
      branchElement.at(-1).attr({
        label: {
          text: branchElement.at(-1).tag
        },
        size: {
          text: '3Cx16'
        },
        length: {
          text: "300m, .04l-j.07\u03A9/km"
        },
        impedance: {
          text: "R:.2, X:.3"
        },
        operatingCurrent: {
          text: "0A \u22200\xB0"
        }
      });
      var _newCableElement = templateCableElement.clone();
      _newCableElement.type = "cable";
      _newCableElement.tag = "templateCableElement";
      _newCableElement.addTo(graph);
    } else if (elementView.model.tag == 'templateTransformerElement') {
      branchElement.push(elementView.model);
      branchElement.at(-1).tag = "Transformer-".concat(branchElement.filter(function (br) {
        return br.type = "transformer";
      }).length.toString().padStart(3, '0'));
      branchElement.at(-1).attr({
        label: {
          text: branchElement.at(-1).tag
        },
        voltage: {
          text: "0kV"
        },
        kVArating: {
          text: "0kVA"
        },
        impedance: {
          text: "0%"
        },
        loading: {
          text: "0kW 0kVAR"
        }
      });
      var _newTransformerElement = templateTransformerElement.clone();
      _newTransformerElement.type = "lumpload";
      _newTransformerElement.tag = "templateTransformerElement";
      _newTransformerElement.addTo(graph);
    } else if (elementView.model.tag == 'templateBusDuctElement') {
      branchElement.push(elementView.model);
      branchElement.at(-1).tag = "BusDuct-".concat(branchElement.filter(function (br) {
        return br.type = "transformer";
      }).length.toString().padStart(3, '0'));
      branchElement.at(-1).attr({
        label: {
          text: branchElement.at(-1).tag
        },
        voltage: {
          text: "0kV"
        },
        kVArating: {
          text: "0kVA"
        },
        impedance: {
          text: "0%"
        },
        loading: {
          text: "0kW 0kVAR"
        }
      });
      var _newBusDuctElement = templateBusDuctElement.clone();
      _newBusDuctElement.type = "busduct";
      _newBusDuctElement.tag = "templateBusDuctElement";
      _newBusDuctElement.addTo(graph);
    } else if (elementView.model.tag == 'templateCapacitorElement') {
      loadElement.push(elementView.model);
      loadElement.at(-1).tag = "Capacitor-".concat(capacitorElement.length.toString().padStart(3, '0'));
      loadElement.at(-1).attr({
        label: {
          text: capacitorElement.at(-1).tag
        },
        operatingPower: {
          text: "0kVAR"
        },
        rating: {
          text: "0kVAR"
        }
      });
      var _newCapacitorElement = templateCapacitorElement.clone();
      _newCapacitorElement.type = "capacitor";
      _newCapacitorElement.tag = "templateCapacitorElement";
      _newCapacitorElement.addTo(graph);
    } else if (elementView.model.tag == 'templateMotorElement') {
      loadElement.push(elementView.model);
      loadElement.at(-1).tag = "Motor-".concat(loadElement.filter(function (br) {
        return br.type = "motor";
      }).length.toString().padStart(3, '0'));
      loadElement.at(-1).attr({
        label: {
          text: loadElement.at(-1).tag
        }
      });
      var _newMotorElement = templateMotorElement.clone();
      _newMotorElement.type = "motor";
      _newMotorElement.tag = "templateMotorElement";
      _newMotorElement.addTo(graph);
    } else if (elementView.model.tag == 'templateHeaterlement') {
      loadElement.push(elementView.model);
      loadElement.at(-1).tag = "Heater-".concat(loadElement.filter(function (br) {
        return br.type = "heater";
      }).length.toString().padStart(3, '0'));
      loadElement.at(-1).attr({
        label: {
          text: loadElement.at(-1).tag
        }
      });
      var _newHeaterElement = templateHeaterElement.clone();
      _newHeaterElement.type = "heater";
      _newHeaterElement.tag = "templateHeaterElement";
      _newHeaterElement.addTo(graph);
    } else if (elementView.model.tag == 'templateLumpLoadElement') {
      loadElement.push(elementView.model);
      loadElement.at(-1).tag = "LumpLoad-".concat(loadElement.filter(function (br) {
        return br.type = "lumpload";
      }).length.toString().padStart(3, '0'));
      loadElement.at(-1).attr({
        label: {
          text: loadElement.at(-1).tag
        },
        operatingPower: {
          text: "".concat(4, "kW ", 3, "kVAR")
        },
        rating: {
          text: "".concat(5, "kVA")
        }
      });
      newLumpLoadElement = templateLumpLoadElement.clone();
      newLumpLoadElement.type = "lumpload";
      newLumpLoadElement.tag = "templateLumpLoadElement";
      newLumpLoadElement.addTo(graph);
    } else if (elementView.model.tag == 'templateOtherElement') {}
  });

  // delete items

  buses.forEach(function (bus, index) {
    if (bus.Category === "Swing") {
      // grid            
      busesElement[index] = new GridElement();
      busesElement[index].type = "swing";
      busesElement[index].tag = bus.Tag;
      busesElement[index].clicked = false;
      busesElement[index].position(bus.CordX, bus.CordY);
      busesElement[index].resize(40, 40);

      //busesElement[index] = updateBus(busesElement[index], bus);

      busesElement[index].attr({
        label: {
          text: "Grid" + bus.Tag
        },
        ratedSC: {
          text: Math.round(10 * bus.ISC) / 10 + "kA"
        },
        ratedVoltage: {
          text: bus.VR / 1000 + "kV"
        },
        busFaultkA: {
          text: Math.round(10 * bus.SCkAaMax) / 10 + "kA"
        },
        operatingVoltage: {
          text: Math.round(10000 * bus.Vo.Magnitude) / 100 + "% â " + Math.round(bus.Vo.Phase * 1800 / Math.PI) / 10 + "Â°"
        }
      });
      busesElement[index].addTo(graph);
    } else {
      // for node, the bus line and parameter display is off
      // other bus
      // one way to draw the bus by "Expanding parent area to cover its children"
      // where children are at both ends
      // another was is to draw two edge and draw a link as the bus
      // in this way all the links can be perpendicular to the bus bar (link)

      busesElement.push(new BusElement({
        position: {
          x: bus.CordX - bus.Length / 2,
          y: bus.CordY
        },
        // Width represents the length of the line
        size: {
          width: bus.Length,
          height: 0
        },
        attrs: {
          body: {
            x1: 0,
            y1: 0,
            x2: bus.Length,
            y2: 0
          },
          label: {
            text: bus.Tag
          },
          ratedSC: {
            text: Math.round(10 * bus.ISC) / 10 + "kA"
          },
          ratedVoltage: {
            text: bus.VR / 1000 + "kV"
          },
          busFault: {
            text: Math.round(10 * bus.SCkAaMax) / 10 + "kA"
          },
          operatingVoltage: {
            text: Math.round(10000 * bus.Vo.Magnitude) / 100 + "% â " + Math.round(bus.Vo.Phase * 1800 / Math.PI) / 10 + "Â°"
          }
        }
      }));

      //busesElement.at(-1) = updateBus(busesElement.at(-1), bus);

      busesElement.at(-1).type = "bus";
      busesElement.at(-1).tag = bus.Tag;
      busesElement.at(-1).clicked = false;
      busesElement.at(-1).addTo(graph);
    }

    // check if exising server data has customised bus position and length for this bus
    busesElement[index] = updatePositionLength(busesElement[index], sldComponents);
  });

  // toggle bus and node by double clicking
  paper.on('element:pointerdblclick', function (elementView) {
    if (elementView.model.type != "bus") return;
    var ports = elementView.model.getGroupPorts('in');

    // if this bus has more than two ports or
    if (ports.length > 2) return;

    // two ports are not catering to the top or bottom links
    // (i.e., their positions are different, then this shall remain as bus)
    if (ports.length == 2) {
      var b = elementView.model.getPortsPositions('in');
      if (b[1].x != b[2].x) return;
    }

    // also no node if the bus is part of a switchboard whihc has more than one buses
    var swbd = switchboards.find(function (item) {
      return JSON.parse(item[1]).includes(elementView.model.tag);
    });
    if (swbd) {
      var busTags = JSON.parse(swbd[1]);
      if (busTags.length > 1) return;
    }
    if (elementView.model.node) {
      // already a node, change to bus
      elementView.model.node = false;
    } else {
      // its bus, change to a node
      elementView.model.node = true;
    }
    elementView.model = updateNodeOrBus(elementView.model);
    // update SLDComponent for sending updated Bus data to server
    // remove existing sldComponentStrings with this bus tag, if exists
    sldComponentsJS = sldComponentsJS.filter(function (item) {
      return item.Tag != elementView.model.tag || item.Type != "bus" || item.SLD != "key";
    });
    var props = {
      'node': elementView.model.node,
      'position': elementView.model.attributes.position,
      'length': cwidth
    };
    sldComponentsJS.push({
      'Type': "bus",
      'Tag': elementView.model.tag,
      'SLD': "key",
      'PropertyJSON': JSON.stringify(props)
    });
  });

  //
  // by default element interaction is enabled for all items
  var interaction = true;
  // original x and y
  var ox;
  var oy;
  var clickedBusTag;
  var end;
  var x1;
  var x2;
  var oposx;
  var owidth;
  var cposx;
  var cwidth;
  // bus ends drag
  paper.on('element:pointerdown', function (elementView, event, x, y) {
    if (elementView.model.type != "bus") return;
    // disable element movement for template items
    if (elementView.model.type && elementView.model.tag.includes("template")) {
      interaction = false;
    }
    // check if its a bus
    // if the clicked point is either left or right end, then prevent element movement
    else if (elementView.model.type && elementView.model.type == "bus") {
      // check the location of the click
      var pos = elementView.model.prop('position');
      var width = elementView.model.prop('size/width');
      oposx = elementView.model.prop('position/x');
      owidth = elementView.model.prop('size/width');
      end = x - pos.x < 10 ? "left" : pos.x + width - x < 10 ? "right" : "middle";
      x1 = elementView.model.prop('attrs/body/x1');
      x2 = elementView.model.prop('attrs/body/x2');
      // prevent bus element movement only if the position is not middle
      if (end != "middle") {
        interaction = false;
      } else {
        interaction = true;
      }
      clickedBusTag = elementView.model.tag;
      console.log("Bus '".concat(clickedBusTag, "', position: (").concat(pos.x, ",").concat(pos.y, "), width:").concat(width, ", x1-x2:").concat(x2 - x1, " ") + "clicked at (".concat(x, ",").concat(y, "), '").concat(end, "' end, (ox,oy): (").concat(ox, ",").concat(oy, "), x1: ").concat(x1, ", x2: ").concat(x2, "), interaction: ").concat(interaction));
    } else {
      // if clicked on any ther than bus element, restore interaction
      interaction = true;
    }
  });
  var toWrite = true;
  paper.on('element:pointermove', function (elementView, event, x, y) {
    if (elementView.model.type != "bus") return;
    // bus left/right end movement
    if (elementView.model.type && elementView.model.type == "bus" && elementView.model.tag == clickedBusTag) {
      if (toWrite) {
        toWrite = false;
        setTimeout(function () {
          if (end == "left") {
            cposx = Math.min(x, oposx + owidth - 50);
            cwidth = oposx + owidth - cposx;
          }
          if (end == "right") {
            cposx = oposx;
            cwidth = Math.max(x, oposx + 50) - oposx;
          }
          if (end == "right" || end == "left") {
            console.log("Bus '".concat(clickedBusTag, "', ").concat(end, " end changing ") + "pos: ".concat(oposx, "-> ").concat(cposx, ", width: ").concat(owidth, " -> ").concat(cwidth));
            elementView.model.prop('position/x', cposx);
            elementView.model.prop('size/width', cwidth);
            elementView.model.prop('attrs/body/x2', cwidth);
            // X1 is always = 0;
            // Y1 and Y2 are not changed for a hirizontally oriented bus

            // update SLDComponent for sending updated Bus data to server
            // remove existing sldComponentStrings with this bus tag, if exists
            sldComponentsJS = sldComponentsJS.filter(function (item) {
              return item.Tag != elementView.model.tag || item.Type != "bus" || item.SLD != "key";
            });
            var props = {
              'node': elementView.model.node,
              'position': elementView.model.attributes.position,
              'length': cwidth
            };
            sldComponentsJS.push({
              'Type': "bus",
              'Tag': elementView.model.tag,
              'SLD': "key",
              'PropertyJSON': JSON.stringify(props)
            });
          }
          toWrite = true;

          // update switchboard, if any, for this bus
          var swbd = switchboards.find(function (item) {
            return JSON.parse(item[1]).includes(elementView.model.tag);
          });
          if (swbd) {
            var swbdModel = swbdElement.find(function (item) {
              return item.tag == swbd[0];
            });
            swbdModel = updateSwbdPositionSizeByBus(elementView.model.tag, busesElement, switchboards, swbdElement, 30, 20, 30, 20);
          }
        }, 10);
      }
    }
  });

  // switchboards

  switchboards.forEach(function (swbd, index) {
    swbdElement[index] = new SwitchboardElement();
    swbdElement[index].type = "swbd";
    swbdElement[index].tag = swbd[0];
    var anyBusTagOfThisBoard = JSON.parse(swbd[1])[0];
    swbdElement[index] = updateSwbdPositionSizeByBus(anyBusTagOfThisBoard, busesElement, switchboards, swbdElement, 30, 20, 30, 20);
    swbdElement[index].attr({
      tag: {
        text: swbd[0]
      }
    });
    swbdElement[index].addTo(graph);
  });
  function updateSwbdPositionSizeByBus(busTag, busesElement, switchboards, swbdElement, dx1, dx2, dy1, dy2) {
    var swbd = switchboards.find(function (item) {
      return JSON.parse(item[1]).includes(busTag);
    });
    var swbdModel = swbdElement.find(function (item) {
      return item.tag == swbd[0];
    });
    var busTags = JSON.parse(swbd[1]);
    // var busSections = JSON.parse(swbd[2]); not used
    // find the enclosing area
    var x1 = Number.MAX_SAFE_INTEGER;
    var y1 = Number.MAX_SAFE_INTEGER;
    var x2 = 0;
    var y2 = 0;
    busTags.forEach(function (bustag) {
      var bbox = busesElement.find(function (item) {
        return item.tag == bustag;
      }).getBBox();
      x1 = Math.min(x1, bbox.x);
      y1 = Math.min(y1, bbox.y);
      x2 = Math.max(x2, bbox.x + bbox.width);
      y2 = Math.max(y2, bbox.y + bbox.height);
    });
    x2 += dx2;
    y2 += dy2;
    x1 -= dx1;
    y1 -= dy1;
    swbdModel.position(x1, y1);
    swbdModel.resize(x2 - x1, y2 - y1);
    return swbdModel;
  }
  branches.forEach(function (branch, index) {
    var sourceBus = buses.find(function (bus) {
      return bus.Tag == branch.BfT;
    });
    var targetBus = buses.find(function (bus) {
      return bus.Tag == branch.BtT;
    });
    var sourceBusNode = busesNodeElement.find(function (item) {
      return item.tag == "".concat(sourceBus.Tag, "_").concat(branch.Tag);
    });
    var targetBusNode = busesNodeElement.find(function (item) {
      return item.tag == "".concat(targetBus.Tag, "_").concat(branch.Tag);
    });

    // Handle branch elements based on type
    if (branch.Category === "Cable") {
      var cable = cables.find(function (cbl) {
        return cbl.Tag == branch.Tag;
      });
      branchElement[index] = new CableElement();
      branchElement[index].type = "cable";
      branchElement[index].tag = cable.Tag;
      branchElement[index].clicked = false;
      branchElement[index].position(targetBus.CordX - 5, targetBus.CordY - yGridSpacing / 2 - 20);
      branchElement[index].resize(10, 60);
      branchElement[index] = updateCable(branchElement[index], cable, branches);
      //branchElement[index].attr({
      //    label: { text: cable.Tag },
      //    size: { text: cable.CblDesc },
      //    length: { text: `${cable.L}m, ${cable.Rl}-j${cable.Xl}Î©/km` },
      //    impedance: { text: `R:${cable.R}, X:${cable.X}` },
      //    operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A â ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}Â°` }
      //});
    } else if (branch.Category === "Transformer") {
      var transformer = transformers.find(function (tr) {
        return tr.Tag === branch.Tag;
      });
      branchElement[index] = new TransformerElement();
      branchElement[index].type = "transformer";
      branchElement[index].tag = transformer.Tag;
      branchElement[index].clicked = false;
      branchElement[index].position((targetBus.CordX + sourceBus.CordX) / 2, (targetBus.CordY + sourceBus.CordY) / 2);
      branchElement[index].resize(15, 15);
      branchElement[index] = updateTransformer(branchElement[index], transformer, branches);

      //branchElement[index].attr({
      //    tag: { text: transformer.Tag },
      //    voltage: { text: `${transformer.V1}/${transformer.V2}kV` },
      //    kVArating: { text: `${transformer.KVA}kVA` },
      //    impedance: { text: `Z:${transformer.Z}%` },
      //    loading: { text: `${Math.round(10 * branch.KW) / 10}KW ${Math.round(10 * branch.KVAR) / 10}kVAR` }
      //});
    } else if (branch.Category === "BusDuct") {
      var busDuct = busDucts.find(function (busDuct) {
        return busDuct.Tag == branch.Tag;
      });
      branchElement[index] = new BusDuctElement();
      branchElement[index].type = "busduct";
      branchElement[index].tag = busDuct.Tag;
      branchElement[index].clicked = false;
      branchElement[index].position(targetBus.CordX - 5, targetBus.CordY - yGridSpacing / 2 - 20);
      branchElement[index].resize(10, 60);
      branchElement[index] = updateBusDuct(branchElement[index], busDuct, branches);
    } else {

      // Handle other branch types
      //
      //
    }

    // check if exising server data has customized position data for this branch cell
    branchElement[index] = updateItemPosition(branchElement[index], sldComponents);
    branchElement[index].addTo(graph);

    // Create top and bottom links for every branch connection
    // once this branch element is created
    // time to create the links dynamically
    // Create top and bottom links for this branch connections

    var fromLink = branchLink.clone();
    var toLink = branchLink.clone();
    // bus-side port index shall be the default 0
    // later it shall be distributed as per total connection

    var sourceBusElement = busesElement.find(function (item) {
      return item.tag == branch.BfT;
    });
    var targetBusElement = busesElement.find(function (item) {
      return item.tag == branch.BtT;
    });
    var thisbranchElement = branchElement.find(function (item) {
      return item.tag == branch.Tag;
    });
    fromLink.set({
      source: {
        id: sourceBusElement.id,
        port: sourceBusElement.getPorts()[0].id
      },
      target: {
        id: thisbranchElement.id,
        port: thisbranchElement.getPorts()[0].id
      }
    });
    toLink.set({
      source: {
        id: targetBusElement.id,
        port: targetBusElement.getPorts()[0].id
      },
      target: {
        id: thisbranchElement.id,
        port: thisbranchElement.getPorts()[1].id
      }
    });
    fromLink.attr({
      target: {
        magnet: false
      }
    });
    toLink.attr({
      target: {
        magnet: false
      }
    });
    fromLink.tag = getLinkTag(fromLink);
    toLink.tag = getLinkTag(toLink);

    // check if exising server data has customised vertices for this link
    fromLink = updateLinkVertices(fromLink, sldComponents);
    toLink = updateLinkVertices(toLink, sldComponents);
    fromLink.type = "link";
    toLink.type = "link";
    // Add the link to the graph
    graph.addCell(fromLink);
    graph.addCell(toLink);
  });

  // once all the links are created, time to create required no of ports as per the connections
  // and distribute the port along the length of the bus
  busesElement.forEach(function (busElement, index) {
    busPortDistribution(busElement.id);
    console.log("Distributing ports for bus '".concat(busElement.tag, "'."));
  });
  function updateLinkVertices(link, sldComponents) {
    // check if exising server data has customised vertices for this link
    var existingLinkData = sldComponents.find(function (item) {
      return item.Tag == link.tag && item.Type == "link";
    });
    if (existingLinkData) {
      //var verticesText = existingData.propertyJSON.replace(/'/g, '"');
      var newVerticesText = existingLinkData.PropertyJSON;
      var newVertices = JSON.parse(newVerticesText);
      if (newVertices) link.vertices(newVertices);
      //console.log(`'${bottomLink.tag}' are updated with vertices ${newVerticesText} from DB.`);
    }
    return link;
  }
  function updateItemPosition(cell, sldComponents) {
    // check if exising server data has customised position for this cell
    var serverData = sldComponents.find(function (item) {
      return cell && cell.hasOwnProperty('tag') && item.Tag === cell.tag;
    });
    if (serverData) {
      var newPositionText = serverData.PropertyJSON;
      var newPosition = JSON.parse(newPositionText);
      if (newPosition) cell.prop('position', newPosition);
    }
    return cell;
  }
  function updatePositionLength(busModel, sldComponents) {
    // check if exising server data has customised node?, position and length for this bus
    var serverData = sldComponents.find(function (item) {
      return busModel && busModel.hasOwnProperty('tag') && item.Tag === busModel.tag;
    });
    if (serverData) {
      if (busModel.hasOwnProperty('type') && busModel.type === "swing") {
        busModel.prop('position', JSON.parse(serverData.PropertyJSON));
      } else {
        var newPositionLengthText = serverData.PropertyJSON;
        var newPositionLength = JSON.parse(newPositionLengthText);
        if (newPositionLength.position) {
          busModel.prop('position', newPositionLength.position);
        }
        if (newPositionLength.length && busModel.type == "bus") {
          busModel.prop('size/width', newPositionLength.length);
          busModel.prop('attrs/body/x2', newPositionLength.length);
        }

        // check if its node or not
        if (newPositionLength.node && busModel.type == "bus") {
          if (newPositionLength.node) {
            //busModel.prop('node', true);
            busModel.node = true;
          } else {
            //busModel.prop('node', false);
            busModel.node = false;
          }
          busModel = updateNodeOrBus(busModel);
        }
      }
    }
    return busModel;
  }
  function updateNodeOrBus(busModel) {
    // update node status by either doubleclick or by server data
    if (busModel.node) {
      busModel.attr('label/textAnchor', 'end');
      busModel.attr('label/refX', '50%');
      busModel.attr('label/dx', -10);
      busModel.attr('label/refY', 0);
      busModel.attr('body/visibility', 'hidden');
      busModel.attr('ratedSC/visibility', 'hidden');
      busModel.attr('ratedVoltage/visibility', 'hidden');
      busModel.attr('busFault/visibility', 'hidden');
      busModel.attr('operatingVoltage/visibility', 'hidden');
    } else {
      //label: { ref: 'body', fill: 'blue', fontWeight: 'bold', textAnchor: 'start', fontSize: 8, refX: '0%', refY: -12 },
      busModel.attr('label/textAnchor', 'start');
      busModel.attr('label/refY', -12);
      busModel.attr('body/visibility', 'visible');
      busModel.attr('ratedSC/visibility', 'visible');
      busModel.attr('ratedVoltage/visibility', 'visible');
      busModel.attr('busFault/visibility', 'visible');
      busModel.attr('operatingVoltage/visibility', 'visible');
    }
    return busModel;
  }
  paper.on('element:mouseenter', function (elementView) {
    var tools = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.ToolsView({
      tools: [propertyButton]
    });
    if (elementView.model.tag && !elementView.model.tag.includes('template')) elementView.addTools(tools);
  });
  paper.on('element:mouseleave', function (elementView) {
    if (elementView.hasTools) elementView.removeTools();
  });

  //https://www.jointjs.com/demos/smart-routing
  //https://github.com/clientIO/joint/blob/master/packages/joint-core/demo/routing/src/routing.js
  paper.on('link:mouseenter', function (linkView) {
    var tools = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.ToolsView({
      tools: [new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Vertices(), new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Segments(),
      //new linkTools.Boundary(),
      // custom buttons complement the pre-made Remove button tool;
      //new linkTools.Remove(),
      infoButton, removeButton, validateButton]
    });
    var toolsR = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.dia.ToolsView({
      tools: [new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Vertices(), new _joint_core__WEBPACK_IMPORTED_MODULE_0__.linkTools.Segments(),
      //new linkTools.Boundary(),
      // custom buttons complement the pre-made Remove button tool;
      //new linkTools.Remove(),
      infoButton, removeButton]
    });
    if (linkView.model.prop('validated')) {
      linkView.addTools(toolsR);
    } else {
      linkView.addTools(tools);
    }
  });
  paper.on('link:mouseleave', function (linkView) {
    linkView.removeTools();
    var link = linkView.model;
    var vertices = link.vertices();
    //console.log(`${link.tag} has ${vertices.length} vertices and they are ${JSON.stringify(vertices)}.`);

    // remove existing sldComponentStrings with this link tag, if exists
    sldComponentsJS = sldComponentsJS.filter(function (sldComponent) {
      return sldComponent.Tag != link.tag || sldComponent.Type != "link" || sldComponent.SLD != "key";
    });

    // Creating an object using the sldComponentData constructor function
    // add this new json string to the list
    //if (vertices.length > 0) sldComponentsJS.push(new sldComponentData(link.tag, "link", "key", JSON.stringify(vertices)));
    if (vertices.length > 0) sldComponentsJS.push({
      'Type': "link",
      'Tag': link.tag,
      'SLD': "key",
      'PropertyJSON': JSON.stringify(vertices)
    });
    //console.log(`Total ${sldComponentsJS.length} sldComponents, tag '${link.tag}' ${(vertices.length > 0 ? "" : "not")} added.`);
  });
  toWrite = true;
  graph.on('change:position', function (cell) {
    if (cell.tag == "selectbox") return;
    if (cell.type == "link") return;
    //if (cell.isLink) return;
    // remove existing sldComponentStrings with this cell tag, if exists
    sldComponentsJS = sldComponentsJS.filter(function (sldComponent) {
      return sldComponent.Tag != cell.tag || sldComponent.Type != cell.type || sldComponent.SLD != "key";
    });

    // Creating an object using the sldComponentData constructor function
    // add this new json string to the list
    //sldComponentsJS.push(new sldComponentData(cell.tag, cell.type, "key", JSON.stringify(cell.attributes.position)));
    if (cell.type == "bus") {
      // save position and length
      var props = {
        'position': cell.attributes.position,
        'length': cell.attributes.size.width
      };
      sldComponentsJS.push({
        'Type': cell.type,
        'Tag': cell.tag,
        'SLD': "key",
        'PropertyJSON': JSON.stringify(props)
      });
    } else {
      sldComponentsJS.push({
        'Type': cell.type,
        'Tag': cell.tag,
        'SLD': "key",
        'PropertyJSON': JSON.stringify(cell.attributes.position)
      });
    }
    //console.log(`Total ${sldComponentsJS.length} sldComponents, tag '${link.tag}' ${(vertices.length > 0 ? "" : "not")} added.`);

    if (toWrite) {
      toWrite = false;
      setTimeout(function () {
        try {
          console.log("Change position function @ 500ms : Tag '".concat(cell.tag, "' of type '").concat(cell.type, "' moved to (").concat(cell.attributes.position.x, ",").concat(cell.attributes.position.y, ")"));
          dotNetObjDraw.invokeMethodAsync('TagMoveUpdate', cell.type, cell.tag, cell.attributes.position.x, cell.attributes.position.y);
          toWrite = true;
        } catch (err) {
          console.log(err.message);
        }
      }, 500);
    }

    // if any bus changes its position, update the switchboard accordingly

    // update switchboard, if any, for this bus
    if (cell.type == "bus") {
      var swbd = switchboards.find(function (item) {
        return JSON.parse(item[1]).includes(cell.tag);
      });
      if (swbd) {
        var swbdModel = swbdElement.find(function (item) {
          return item.tag == swbd[0];
        });
        swbdModel = updateSwbdPositionSizeByBus(cell.tag, busesElement, switchboards, swbdElement, 30, 20, 30, 20);
      }
    }
  });

  // Create a text element for coordinates display
  var textBlock = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.TextBlock();
  textBlock.resize(1000, 20);
  textBlock.position(100, 10);
  textBlock.attr('body/fill', 'none');
  textBlock.attr('body/stroke', 'none');
  textBlock.attr('label/text', '');
  textBlock.attr('label/fontSize', 8);
  // Styling of the label via `style` presentation attribute (i.e. CSS).
  textBlock.attr('label/style/color', 'red');
  textBlock.addTo(graph);

  // Update coordinates display on mouse move
  paper.on('blank:pointerclick', function (evt, x, y) {
    textBlock.attr('label/text', "X: ".concat(x, ", Y: ").concat(y, " "));
  });
  paper.on('cell:pointerclick', function (cell, evt, x, y) {
    textBlock.attr('label/text', "X: ".concat(x, ", Y: ").concat(y, " x:  ").concat(cell.getBBox().x, " y: ").concat(cell.getBBox().y, " height:  ").concat(cell.getBBox().height, " width: ").concat(cell.getBBox().width, " shift: ").concat(cell.getBBox().height / 3.5));
    if (cell.model.tag && cell.model.tag.includes("template")) {
      console.log(cell.model.tag);
    }
  });

  //loads.forEach(load => {
  //    var i = loads.indexOf(load);
  //    var connectedBus = buses.filter(bus => bus.T == load.BT)[0];
  //    var connectedBranchList = branches.filter(br => br.BtT == connectedBus.T || br.BfT == connectedBus.T);
  //    var connectedBranch = connectedBranchList[0];
  //    var operatingPowerText = "";
  //    if (connectedBranchList.length > 0) { operatingPowerText = Math.round(10 * connectedBranch.KW) / 10 + "KW " + Math.round(10 * connectedBranch.KVAR) / 10 + "kVAR"; }
  //    var connectedBusNodeList = busesNodeElement.filter(item => item.tag == connectedBus.T + "_" + load.T);
  //    if (connectedBusNodeList.length > 0) {
  //        // do not draw load and link for loads not having connected bus
  //        loadElement[i] = new LoadElement;
  //        loadElement[i].position(connectedBus.CordX, connectedBus.CordY + yGridSpacing / 2);
  //        loadElement[i].type = "load";
  //        loadElement[i].tag = load.T;
  //        loadElement[i].clicked = false;
  //        loadElement[i].resize(20, 30);
  //        var rating = (load.T.includes("-Lump")) ? "(combined)" : "(" + Math.round(10000000 * load.P) / 10 + "kW " + Math.round(10000 * load.PF) / 100 + "% PF)";
  //        operatingPowerText = (load.T.includes("-Lump")) ? Math.round(10 * load.P) / 10 + "KW " + Math.round(10 * load.Q) / 10 + "kVAR" : operatingPowerText;
  //        loadElement[i].attr({
  //            label: { text: load.T },
  //            operatingPower: { text: operatingPowerText },
  //            rating: { text: rating },
  //        });
  //        link[linkCount] = new branchLink();  // load link
  //        link[linkCount].addTo(graph);
  //        linkCount++;
  //        link[link.length - 1].source(connectedBusNodeList[0], {
  //            anchor: { name: 'modelCenter', args: { rotate: true, dx: 0, } },
  //            connectionPoint: {
  //                name: 'bbox', args: { offset: 0, selector: 'body', }
  //            }
  //        });
  //        link[link.length - 1].target(loadElement[i], {
  //            anchor: { name: 'modelCenter', args: { rotate: true, dx: 0, } }
  //        });
  //        link[link.length - 1].router('orthogonal');
  //        link[link.length - 1].connector('jumpover', { size: 5 });
  //        link[link.length - 1].attr({
  //            line: {
  //                sourceMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', },
  //                targetMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', }
  //            }
  //        });
  //        loadElement[i].addTo(graph);
  //    }
  //});

  //// assigning preset postion to all elements
  ////busesElement.forEach(element => {
  ////    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);
  ////    if (xypos.length > 0) {
  ////        element.position(xypos[0].CordX, xypos[0].CordY);
  ////    }
  ////});
  //branchElement.forEach(element => {
  //    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);
  //    if (xypos.length > 0) {
  //        element.position(xypos[0].CordX, xypos[0].CordY);
  //    }
  //});
  //loadElement.forEach(element => {
  //    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);
  //    if (xypos.length > 0) {
  //        element.position(xypos[0].CordX, xypos[0].CordY);
  //    }
  //});
  ////
  //function busBFS(prntBusT, thisBusT, parentContainer) {
  //    var parentBus = buses.filter(b => b.T == prntBusT)[0];
  //    var bus = buses.filter(b => b.T == thisBusT)[0];
  //    var busStr = bus.T + " (" + (bus.SCkAa).toString() + "kA)";
  //    // create a container
  //    container[buses.indexOf(bus)] = new Container({
  //        z: 1,
  //        attrs: { headerText: { text: busStr } }
  //    });
  //    graph.addCells([container[buses.indexOf(bus)]]);
  //    container[buses.indexOf(bus)].toggle(false);

  //    createChildLink(container[buses.indexOf(bus)], bus.T);

  //    buses.filter(b => b.T == thisBusT)[0].SLDL = buses.filter(b => b.T == thisBusT)[0].SLDL + 1; // bus bar length
  //    buses.filter(b => b.T == prntBusT)[0].SLDL = buses.filter(b => b.T == prntBusT)[0].SLDL + 1; // bus bar length

  //    // for all connected loads on to this bus
  //    if (loads.filter(l => l.BT == bus.T).length > 0) {
  //        loads.filter(l => l.BT == bus.T).forEach(load => {
  //            createChildLink(container[buses.indexOf(bus)], load.T);
  //        })
  //        busesDone.push(bus.T);
  //        buses.filter(b => b.T == thisBusT)[0].SLDL = buses.filter(b => b.T == thisBusT)[0].SLDL + 1; // bus bar length
  //        buses.filter(b => b.T == prntBusT)[0].SLDL = buses.filter(b => b.T == prntBusT)[0].SLDL + 1; // bus bar length

  //    }
  //    if (bus.Cn.length > 1) {
  //        // this bus has further connected bus
  //        // create a container for all downstream bus except the parentBus
  //        (bus.Cn).filter(bT => busesDone.includes(bT) != true && bT != prntBusT).forEach(bT => {
  //            var newChildBus = buses.filter(b => b.T == bT)[0];
  //            //prntBusT = bus.T
  //            //thisBusT = bT
  //            busBFS(bus.T, bT, container[buses.indexOf(bus)]);
  //        });
  //        // as this bus is completely done
  //        busesDone.push(bus.T);
  //    }

  //    paper.fitToContent();

  //    function createChildLink(mycontainer, childtText) {
  //        var ck = child.length;
  //        var lk = link.length;
  //        var posx = buses.filter(b => b.T == prntBusT)[0].CordX + 50 * buses.filter(b => b.T == prntBusT)[0].SLDL;
  //        var posy = 150 + buses.filter(b => b.T == prntBusT)[0].CordY;
  //        child[ck] = new Child({
  //            z: 2,
  //            position: { x: posx, y: posy },
  //            attrs: { label: { text: childtText } }
  //        });
  //        //
  //        link[lk] = new Link({
  //            z: 4,
  //            source: { id: mycontainer.id },
  //            target: { id: child[ck].id }
  //        });
  //        graph.addCells([child[ck], link[lk]]);

  //        mycontainer.embed(child[ck]);
  //        link[lk].reparent();
  //    }

  //}

  //----example------

  //var portsIn = {
  //    position: { name: 'top' },
  //    attrs: { portBody: { magnet: true, r: 3, fill: '#023047', stroke: '#023047' } },
  //    label: { position: { name: 'top', args: { y: 2 } }, markup: [{ tagName: 'text', selector: 'label', className: 'label-text' }] },
  //    markup: [{ tagName: 'circle', selector: 'portBody' }]
  //};

  //var portsOut = {
  //    position: { name: 'bottom' },
  //    attrs: { portBody: { magnet: true, r: 3, fill: '#E6A502', stroke: '#023047' } },
  //    label: { position: { name: 'bottom', args: { y: 2 } }, markup: [{ tagName: 'text', selector: 'label', className: 'label-text' }] },
  //    markup: [{ tagName: 'circle', selector: 'portBody' }]
  //};

  //const rect1 = new shapes.standard.Rectangle({
  //    size: { width: 40, height: 40 }, position: { x: 50, y: 1100 }, attrs: { body: { fill: '#8ECAE6' } },
  //    ports: {
  //        groups: { 'in': portsIn, 'out': portsOut }
  //    }
  //});

  //rect1.addPorts([
  //    { group: 'in', id: '1', attrs: { label: { text: '1' } } },
  //    { group: 'in', id: '2', attrs: { label: { text: '2' } } },
  //    { group: 'out', id: '3', attrs: { label: { text: '3' } } }
  //]);
  //const rect2 = rect1.clone().position(50, 1300);

  //var link35 = new dia.Link({
  //    source: { id: rect1.id, port: '3' },
  //    target: { id: rect2.id, port: '2' }
  //});

  //link35.router('orthogonal');
  //link35.connector('jumpover', { size: 10 });
  //link35.attr({
  //    line: {
  //        sourceMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', },
  //        targetMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', }
  //    }
  //});

  //graph.addCells([rect1, rect2, link35]);

  //var port = {
  //    label: {
  //        position: {
  //            name: 'left'
  //        },
  //        markup: [{
  //            tagName: 'text',
  //            selector: 'label'
  //        }]
  //    },
  //    attrs: {
  //        portBody: { magnet: true, r: 5, x: 5, y: 5, fill: '#E6A502', stroke: '#023047' },
  //        label: {
  //            text: 'port'
  //        }
  //    },
  //    markup: [{
  //        tagName: 'rect',
  //        selector: 'portBody'
  //    }]
  //};

  //var model = new shapes.standard.Rectangle({ size: { width: 200, height: 10 }, attrs: { body: { fill: '#8ECAE6' } }, ports: { groups: { 'in': portsOut } } });

  //model.addPorts([{ group: 'in', attrs: { label: { text: 'in1' } } }, { group: 'in', attrs: { label: { text: 'in2' } } }, { group: 'in', attrs: { label: { text: 'out' } } }]);

  //model.addPort(port); // add a port using Port API

  //const portId = model.getPorts()[0].id;

  //model.portProp(portId, 'attrs/portBody', { r: 3, fill: 'darkslateblue' });
  //model.portProp(portId, 'custom', { testAttribute: true });
  //console.log(model.portProp(portId, 'custom'));

  //const rect11 = new shapes.standard.Rectangle({ size: { width: 20, height: 20 }, attrs: { body: { fill: '#8ECAE6' } } });
  //const rect12 = new shapes.standard.Rectangle({ size: { width: 20, height: 20 }, attrs: { body: { fill: '#8ECAE6' } } });

  //var link11 = new branchLink();
  //link11.source(rect11, { anchor: { name: 'bottom', args: { rotate: true, dx: 50, dy: 10 } } });
  //link11.target(rect12, { anchor: { name: 'modelCenter', args: { rotate: true } } });

  //link11.router('orthogonal');
  //link11.connector('jumpover', { size: 5 });
  //link11.vertex(0, {
  //    x: 160,
  //    y: 1450
  //});

  //graph.addCells([rect11, rect12, link11]);

  //paper.on('element:button:pointerdown', function (elementView) {
  //    var element = elementView.model;
  //    element.toggle();
  //    fitAncestors(element);
  //});

  //paper.on('element:pointermove', function (elementView) {
  //    var element = elementView.model;
  //    fitAncestors(element);
  //});

  //function fitAncestors(element) {
  //    element.getAncestors().forEach(function (container) {
  //        container.fitChildren();
  //    });
  //}

  function dragStart(evt, x, y) {
    //const data = (evt.data = {
    //    tool,
    //    ox: x,
    //    oy: y
    //});
    ox = x;
    oy = y;
    // remove previously created selectboxes
    var existingSelectBox = graph.getElements().find(function (el) {
      return el.tag && el.tag == "selectbox";
    });
    if (existingSelectBox) {
      // unembed elements before removing this selectbox
      var allChildren = graph.getElements();
      //console.log(existingSelectBox.id);
      //allChildren.forEach(child => console.log(child.id, " - ", child.parent(), " ."));
      var children = allChildren.filter(function (el) {
        return el.get('parent') && graph.getCell(el.get('parent')).tag == "selectbox";
      });
      if (children && children.length > 0) {
        children.forEach(function (child) {
          // remove from the selection boundary
          //console.log(`DragStart: ${child.tag} was earlier embedded in parent '${child.get('parent')}', to be un-embedded.`);
          existingSelectBox.unembed(child);
          //console.log(`DragStart: ${child.tag} is un-embedded now and hence has parent '${child.get('parent')}' post un-embedding.`);
          // unhighlight the child element
          //var childView = paper.findView(child);
          //highlighters.mask.remove(childView);
        });
      }
      //console.log(`DragStart: Earlier Select box '${existingSelectBox.id}' removed`);
      existingSelectBox.remove();
    }
    //console.log(`Select box '${existingSelectBox.id}' removed`);
    var selectBox = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Rectangle({
      position: {
        x: x,
        y: y
      },
      size: {
        width: 1,
        height: 1
      },
      attrs: {
        body: {
          fill: 'rgba(100, 100, 0, 0.25)',
          stroke: 'red',
          strokeWidth: 1,
          strokeDasharray: '5,5'
        }
      }
    });
    selectBox.tag = "selectbox";
    selectBox.type = "selectbox";
    selectBox.addTo(graph);
  }
  function drag(evt, x, y) {
    var selectBoxElement = graph.getElements().find(function (el) {
      return el.tag == "selectbox";
    });
    var selectBox = paper.findViewByModel(selectBoxElement);
    if (selectBox) {
      selectBox.model.prop('size/width', Math.abs(ox - x));
      selectBox.model.prop('size/height', Math.abs(oy - y));
      selectBox.model.prop('position/x', Math.min(ox, x));
      selectBox.model.prop('position/y', Math.min(oy, y));
    }
  }
  function dragEnd(evt) {
    var selectBoxElement = graph.getElements().find(function (el) {
      return el.tag == "selectbox";
    });
    if (selectBoxElement) {
      // if it is just a click without substantial drag, then the created selectBox to be removed
      var selectBox = paper.findViewByModel(selectBoxElement);
      var dx = selectBox.model.prop('size/width');
      var dy = selectBox.model.prop('size/height');
      if (dx < 5 && dy < 5) {
        // unembed elements, if any, before removing this selectbox
        var allChildren = graph.getElements();
        var children = allChildren.filter(function (el) {
          return el.get('parent') && graph.getCell(el.get('parent')).tag == "selectbox";
        });
        if (children && children.length > 0) {
          children.forEach(function (child) {
            // remove from the selection boundary
            //console.log(`DragEnd: Insufficient drag : ${child.tag} was embedded in parent '${child.get('parent')}' , to be un-embedded.`);
            selectBoxElement.unembed(child);
            //console.log(`DragEnd: Insufficient drag : ${child.tag} is un-embedded now and hence has parent '${child.get('parent')}' post un-embedding.`);
          });
        }
        selectBoxElement.remove();
        //console.log(`DragEnd: Insufficient drag : ${selectBoxElement.tag} is  removed as its not substatially dragged.`)
      } else {
        // retain the select box and embed all the elements inside
        var selectedElements = graph.getElements().filter(function (el) {
          return el.tag && el.tag != selectBoxElement.tag && el.getBBox().intersect(selectBoxElement.getBBox());
        });
        if (selectedElements.length > 0) {
          //console.log(`DragEnd: Total ${selectedElements.length} intersected items.`);
          selectedElements.forEach(function (el) {
            if (!el.get('parent')) {
              selectBoxElement.embed(el);
              //console.log(`DragEnd: Tag '${el.tag}' is embedded to '${el.get('parent')}'.`);
            } else {
              //console.log(`DragEnd: Tag '${el.tag}' has parent '${el.get('parent')}', hence embedding skipped.`);
            }
          });
        }
      }
    }
  }
  paper.on("blank:pointerdown", function (evt, x, y) {
    return dragStart(evt, x, y);
  });
  //paper.on("element:pointerdown", (_, evt, x, y) => dragStart(evt, x, y));

  paper.on("blank:pointermove", function (evt, x, y) {
    return drag(evt, x, y);
  });
  //paper.on("element:pointermove", (_, evt, x, y) => drag(evt, x, y));

  paper.on("blank:pointerup", function (evt) {
    return dragEnd(evt);
  });
  //paper.on("element:pointerup", (_, evt) => dragEnd(evt));

  graph.on('change:source change:target', /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(link) {
      var source, target, validatedLink, sourcePortId, targetPortId;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            console.log("Checking link ....");
            if (!(!link instanceof _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Link)) {
              _context.n = 1;
              break;
            }
            return _context.a(2);
          case 1:
            if (!(link.get('source').id && link.get('target').id)) {
              _context.n = 3;
              break;
            }
            // both ends of the link are connected.
            source = graph.getCell(link.get('source'));
            target = graph.getCell(link.get('target'));
            link.attr("linestroke", '#999999');
            console.log("Checking link between '".concat(source.tag, "' and ").concat(target.tag, "...."));
            // validate the link at server side based on the business cases
            _context.n = 2;
            return validateLinkFromServer(link);
          case 2:
            validatedLink = _context.v;
            if (validatedLink.prop('valid')) {
              // if the validation is successsfull, update the source/target (bus/port) data
              // assign tag to this link
              sourcePortId = link.prop('source/port');
              targetPortId = link.prop('target/port');
              link.tag = getLinkTag(link);
              // if the source/targer are not bus, then make the magnet passive
              // so that no further connection from the same port is possible
              if (source.type !== "bus") {
                //source.getPort(sourcePortId).getAttribute('magnet') = 'passive';
                source.attr("ports/".concat(sourcePortId, "/magnet"), 'passive');
              }
              if (target.type !== "bus") {
                //target.getPort(targetPortId).getAttribute('magnet') = 'passive';
                target.attr("ports/".concat(targetPortId, "/magnet"), 'passive');
              }

              // if source/targets are bus, distribute the ports
              // along the bus length as per no of links connected to this bus
              if (source.type == "bus") busPortDistribution(source.id);
              if (target.type == "bus") busPortDistribution(target.id);
            } else {
              // else remove the created link
              removeLink(link);
              if (source.type == "bus") busPortDistribution(source.id);
              if (target.type == "bus") busPortDistribution(target.id);
              console.log("Created link between '".concat(source.tag, "' and ").concat(target.tag, " not valid, hence removed"));
            }
          case 3:
            return _context.a(2);
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());

  // additional code for testing purpose

  // Define the port configuration
  var port = {
    position: {
      name: 'right',
      args: {
        y: '0%'
      }
    },
    label: {
      position: {
        name: 'top',
        args: {
          x: 6
        }
      },
      markup: [{
        tagName: 'text',
        selector: 'label'
      }]
    },
    attrs: {
      portBody: {
        magnet: true,
        r: 3,
        fill: 'orange',
        stroke: 'blue',
        strokeWidth: 1
      },
      label: {
        text: 'port'
      }
    },
    markup: [{
      tagName: 'circle',
      selector: 'portBody'
    }]
  };
  var portsIn = {
    position: {
      name: 'left',
      args: {
        y: -10
      } // Adjust as needed
    },
    label: {
      position: {
        name: 'top',
        args: {
          y: -6
        }
      },
      markup: [{
        tagName: 'text',
        selector: 'label',
        className: 'label-text'
      }]
    },
    attrs: {
      portBody: {
        magnet: true,
        r: 3,
        fill: 'orange',
        stroke: '#023047'
      },
      label: {
        text: 'in'
      }
    },
    markup: [{
      tagName: 'circle',
      selector: 'portBody'
    }]
  };
  var portsOut = {
    position: {
      name: 'left',
      args: {
        y: '100%'
      }
    },
    label: {
      position: {
        name: 'right',
        args: {
          y: 6
        }
      },
      markup: [{
        tagName: 'text',
        selector: 'label',
        className: 'label-text'
      }]
    },
    attrs: {
      portBody: {
        magnet: true,
        r: 3,
        fill: '#E6A502',
        stroke: '#023047'
      },
      label: {
        text: 'out'
      }
    },
    markup: [{
      tagName: 'circle',
      selector: 'portBody'
    }]
  };
  var rect = new _joint_core__WEBPACK_IMPORTED_MODULE_0__.shapes.standard.Rectangle({
    position: {
      x: 50,
      y: 1250
    },
    size: {
      width: 100,
      height: 120
    },
    attrs: {
      root: {
        title: 'Port Example'
      },
      body: {
        fill: 'lightblue'
      },
      label: {
        text: 'Port \nRectangle',
        fontSize: 12
      }
    },
    ports: {
      groups: {
        'in': portsIn,
        'out': portsOut,
        'any': port
      }
    }
  });
  rect.addPorts([
  //{ group: 'in', attrs: { label: { text: 'in0' } } },
  {
    id: 'in1',
    group: 'in',
    attrs: {
      label: {
        text: 'in'
      }
    }
  }, {
    id: 'out1',
    group: 'out',
    attrs: {
      label: {
        text: 'out'
      }
    }
  }, {
    id: 'anyPort1',
    group: 'any',
    attrs: {
      label: {
        text: 'anyPort'
      }
    }
  }]);
  rect.tag = "Port-Rectangle";
  // ....
  // add another port to group 'a'.
  //rect.addPort(port);
  rect.addTo(graph);

  // get position of the port
  var portId = 'anyPort1';
  var portIndex = rect.getPortIndex(portId);
  // set args on newly added
  rect.addPort({
    group: 'anyPort',
    args: {
      y: '60%'
    }
  });
  // update existing
  rect.portProp(portId, 'args/y', '30%');
  rect.portProp(portId, 'attrs/label/text', 'just chill'); // { name: 'right', args: { y: '60%' } });
  //rect.prop('ports/items/' + portIndex + '/position', { name: 'right', args: { y: '60%' } });
}

//function linkTag(source, target, sourcePortIndex, targetPortIndex) {
//    return (source.tag > target.tag) ?
//        `${source.tag}:${sourcePortIndex} - ${target.tag}:${targetPortIndex}` :
//        `${target.tag}:${targetPortIndex} - ${source.tag}:${sourcePortIndex}`;
//}

function getLinkTag(link) {
  var source = graph.getCell(link.get('source'));
  var target = graph.getCell(link.get('target'));
  var sourcePortId = link.prop('source/port');
  var targetPortId = link.prop('target/port');
  var sourcePortIndex = source.getPortIndex(sourcePortId);
  var targetPortIndex = target.getPortIndex(targetPortId);
  return source.tag > target.tag ? "".concat(source.tag, ":").concat(sourcePortIndex, " - ").concat(target.tag, ":").concat(targetPortIndex) : "".concat(target.tag, ":").concat(targetPortIndex, " - ").concat(source.tag, ":").concat(sourcePortIndex);
}
function getLinkData(link) {
  var sPort = link.prop('source/port');
  var tPort = link.prop('target/port');
  //var sM = graph.getCell(link.prop('source').id);
  var sM = graph.getElements().find(function (el) {
    return el.id === link.prop('source').id;
  });
  var tM = graph.getElements().find(function (el) {
    return el.id === link.prop('target').id;
  });
  return {
    'sourceTag': sM.tag,
    'targetTag': tM.tag,
    'sourcePort': sPort ? sPort : "",
    'targetPort': tPort ? tPort : ""
  };
}
function busPortDistribution(busId) {
  // function to distribute the ports along the bus length
  // as per no of links connected to this bus

  // pick the bus from graph and update there, does not return any
  var bus = graph.getCell(busId);
  // all busses have only one port group 'in' and default one port
  // ports are numbered with 1, 2, 3...
  // default port 1 cannot be deleted

  // check all the links connected to this bus
  var allLinks = graph.getConnectedLinks(bus);

  // check existing ports 
  var ports = bus.getGroupPorts('in');
  var busWidth = bus.prop('size/width'); // busWidth not required as the positions are refX in percentage

  // check up-side and down-side connection requirement
  var upLinks = [];
  var downLinks = [];

  // assign other end position (x,y) fpr filter purpose
  allLinks.forEach(function (link) {
    var source = graph.getCell(link.prop('source').id);
    var target = graph.getCell(link.prop('target').id);
    var otherEnd = source.id === bus.id ? target : source;
    link.otherEndX = otherEnd.prop('position/x');
    link.otherEndY = otherEnd.prop('position/y');
  });

  // arrange links as per the X value of the other end of the links
  allLinks.sort(function (a, b) {
    return a.otherEndX - b.otherEndX;
  });
  allLinks.forEach(function (link) {
    if (link.otherEndY < bus.prop('position/y')) {
      upLinks.push(link);
    } else {
      downLinks.push(link);
    }

    // below code is to compare based on the absolute position of the ports, not just element position
    //var otherEndPortTag = source.id === bus.id ? link.prop('target/port') : link.prop('source/port');
    //var otherEndPortPosition = otherEnd.getPortsPositions(otherEndPortTag);
    //var otherEndPortPositionAbsoluteY = otherend.prop('position/y') + otherEndPortPosition.y;
  });

  // total no of ports is equal to total no of connections
  var reqPorts = upLinks.length + downLinks.length;
  console.log("Bus port postion distribution for bus tag '".concat(bus.tag, "' having total ").concat(allLinks.length, " connections : ") + "Upside links : ".concat(upLinks.length, " and Downside links ").concat(downLinks.length, ", total available ports ").concat(ports.length, " and required ports ").concat(reqPorts, "."));

  // Remove ports if the required no. of ports are less than the existing ports (however retain minimum 1)
  if (reqPorts < ports.length && ports.length > 1) {
    for (var i = ports.length; i > upLinks.length; i--) {
      bus.removePort("{i}");
    }
  }

  // Add ports if the required no. of ports are more than the existing ports
  if (reqPorts > ports.length) {
    // Define new ports
    var newPorts = [];
    for (var _i = ports.length; _i < reqPorts; _i++) {
      newPorts.push({
        id: "".concat(_i + 1),
        group: 'in',
        position: {
          name: 'absolute',
          args: {
            x: "0%",
            y: 0
          }
        }
      });
    }

    // Add new ports to the element
    newPorts.forEach(function (port) {
      bus.addPort(_objectSpread(_objectSpread({}, port), {}, {
        attrs: {
          portBody: {
            magnet: true,
            r: 3,
            fill: 'orange',
            stroke: '#023047'
          },
          label: {
            text: port.id,
            fontSize: 8
          }
        },
        markup: [{
          tagName: 'circle',
          selector: 'portBody'
        }]
      }));
    });
  }

  // Define new positions to the arranged ports as per final port nos
  // and Update the ports' positions
  for (var _i2 = 0; _i2 < upLinks.length; _i2++) {
    // position for up-side ports
    var pos = "".concat(Math.round((_i2 + 0.5) * 100 / upLinks.length), "%");
    console.log("Bus tag '".concat(bus.tag, "' postion for Port #'").concat(_i2 + 1, "' (up-link # ").concat(_i2 + 1, ") '").concat(pos));
    bus.portProp("".concat(_i2 + 1), 'args/x', pos);
    bus.portProp("".concat(_i2 + 1), 'attrs/label/refX', 3);
    bus.portProp("".concat(_i2 + 1), 'attrs/label/refY', -10);
    // reassign the corresponding port for up-side links
    var end = upLinks[_i2].prop('source').id == bus.id ? 'source' : 'target';
    var portId = bus.getPorts()[_i2].id;
    if (end == 'source') upLinks[_i2].set({
      source: {
        id: busId,
        port: portId
      }
    });
    if (end == 'target') upLinks[_i2].set({
      target: {
        id: busId,
        port: portId
      }
    });
    var end = upLinks[_i2].prop('source') == bus.id ? 'source' : 'target';
    upLinks[_i2].prop("".concat(end, "'/port"), "".concat(_i2 + 1));
  }
  for (var _i3 = 0; _i3 < downLinks.length; _i3++) {
    // position for down-side ports
    var pos = "".concat(Math.round((_i3 + 0.5) * 100 / downLinks.length), "%");
    console.log("Bus tag '".concat(bus.tag, "' postion for Port #'").concat(upLinks.length + _i3 + 1, "' (down-link # ").concat(_i3 + 1, ") '").concat(pos));
    bus.portProp("".concat(upLinks.length + _i3 + 1), 'args/x', pos);
    bus.portProp("".concat(upLinks.length + _i3 + 1), 'attrs/label/refX', 3);
    bus.portProp("".concat(upLinks.length + _i3 + 1), 'attrs/label/refY', 10);
    // reassign the corresponding port for down-side links
    var end = downLinks[_i3].prop('source').id == bus.id ? 'source' : 'target';
    var portId = bus.getPorts()[upLinks.length + _i3].id;
    if (end == 'source') downLinks[_i3].set({
      source: {
        id: busId,
        port: portId
      }
    });
    if (end == 'target') downLinks[_i3].set({
      target: {
        id: busId,
        port: portId
      }
    });
  }
  // later : if up and down are same or both are odd or in LCM, there are common ports
}
function validateLinkFromServer(_x2) {
  return _validateLinkFromServer.apply(this, arguments);
}
function _validateLinkFromServer() {
  _validateLinkFromServer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(link) {
    var linkData, success, _t;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          linkData = getLinkData(link);
          success = false;
          _context2.p = 1;
          if (!dotNetObjSLD) {
            _context2.n = 3;
            break;
          }
          _context2.n = 2;
          return dotNetObjSLD.invokeMethodAsync('SLDValidateLink', JSON.stringify(linkData));
        case 2:
          success = _context2.v;
          console.log("Validation success of the Link between '".concat(linkData.sourceTag, " and ").concat(linkData.targetTag, "' from server side: ").concat(success, "."));
          if (success) {
            link.set('valid', true);
          } else {
            link.set('valid', false);
          }
        case 3:
          _context2.n = 5;
          break;
        case 4:
          _context2.p = 4;
          _t = _context2.v;
          console.log("Validation process for link between'".concat(linkData.sourceTag, " and ").concat(linkData.targetTag, "' from server side failed due to error: ").concat(_t.message, "."));
        case 5:
          return _context2.a(2, link);
      }
    }, _callee2, null, [[1, 4]]);
  }));
  return _validateLinkFromServer.apply(this, arguments);
}
function removeLink(_x3) {
  return _removeLink.apply(this, arguments);
}
function _removeLink() {
  _removeLink = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(link) {
    var linkData, success;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          linkData = getLinkData(link);
          if (!dotNetObjSLD) {
            _context3.n = 2;
            break;
          }
          _context3.n = 1;
          return dotNetObjSLD.invokeMethodAsync('SLDRemoveLink', JSON.stringify(linkData));
        case 1:
          success = _context3.v;
          if (success) {
            link.remove(); // Remove the link from the graph
          }
          console.log("Removal success of the Link between '".concat(linkData.sourceTag, " and ").concat(linkData.targetTag, "' : ").concat(success, "."));
        case 2:
          return _context3.a(2);
      }
    }, _callee3);
  }));
  return _removeLink.apply(this, arguments);
}
function isOverlapping(element, graph) {
  // Function to check if an element overlaps with any other elements
  var bbox = element.getBBox();
  return graph.getCells().some(function (cell) {
    if (cell === element) return false;
    var cellBBox = cell.getBBox();
    return bbox.intersect(cellBBox);
  });
}
function findNearestEmptyPosition(element, graph) {
  var spacing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
  // Function to find the nearest empty position
  // Adjust spacing as needed
  var position = element.get('position');
  var newPosition = _objectSpread({}, position);
  while (isOverlapping(element, graph)) {
    // Move the element to a new position
    newPosition.x += spacing;
    if (newPosition.x > paper.options.width) {
      newPosition.x = 0;
      newPosition.y += spacing;
    }

    // Ensure newPosition is within paper bounds
    // and away from template (x>100) and top margin 50
    newPosition.x = Math.max(100, Math.min(newPosition.x, paper.options.width - element.getBBox().width));
    newPosition.y = Math.max(50, Math.min(newPosition.y, paper.options.height - element.getBBox().height));
    element.set('position', newPosition);
  }
  return newPosition;
}
function updateBus(busModel, busInfo) {
  if (busInfo.Category === "Swing") {
    // grid            
    busModel.attr({
      label: {
        text: "Grid" + busInfo.Tag
      },
      ratedSC: {
        text: Math.round(10 * busInfo.ISC) / 10 + "kA"
      },
      ratedVoltage: {
        text: busInfo.VR / 1000 + "kV"
      },
      busFaultkA: {
        text: Math.round(10 * busInfo.SCkAaMax) / 10 + "kA"
      },
      operatingVoltage: {
        text: Math.round(10000 * busInfo.Vo.Magnitude) / 100 + "% â " + Math.round(busInfo.Vo.Phase * 1800 / Math.PI) / 10 + "Â°"
      }
    });
  } else {
    // the other bus
    busModel.attr({
      label: {
        text: busInfo.Tag
      },
      ratedSC: {
        text: Math.round(10 * busInfo.ISC) / 10 + "kA"
      },
      ratedVoltage: {
        text: busInfo.VR / 1000 + "kV"
      },
      busFault: {
        text: Math.round(10 * busInfo.SCkAaMax) / 10 + "kA"
      },
      operatingVoltage: {
        text: Math.round(10000 * busInfo.Vo.Magnitude) / 100 + "% â " + Math.round(busInfo.Vo.Phase * 1800 / Math.PI) / 10 + "Â°"
      }
    });
  }
  return busModel;
}
function updateTransformer(trafoModel, trafoInfo, branches) {
  var branch = branches.find(function (br) {
    return br.Tag === trafoInfo.Tag;
  });
  trafoModel.attr({
    tag: {
      text: trafoInfo.Tag
    },
    voltage: {
      text: "".concat(trafoInfo.V1 / 1000, "/").concat(trafoInfo.V2 / 1000, "kV")
    },
    kVArating: {
      text: "".concat(trafoInfo.KVA, "kVA")
    },
    impedance: {
      text: "Z:".concat(trafoInfo.Z, "%")
    },
    loading: {
      text: "".concat(Math.round(10 * (branch === null || branch === void 0 ? void 0 : branch.KW)) / 10, "KW ").concat(Math.round(10 * (branch === null || branch === void 0 ? void 0 : branch.KVAR)) / 10, "kVAR")
    }
  });
  return trafoModel;
}
function updateCable(cableModel, cabledata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag === cabledata.Tag;
  });
  cableModel.attr({
    label: {
      text: cabledata.Tag
    },
    size: {
      text: cabledata.CblDesc
    },
    length: {
      text: "".concat(cabledata.L, "m, ").concat(cabledata.Rl, "-j").concat(cabledata.Xl, "\u03A9/km")
    },
    impedance: {
      text: "R:".concat(cabledata.R, ", X:").concat(cabledata.X)
    },
    operatingCurrent: {
      text: "".concat(Math.round(10 * (branch === null || branch === void 0 ? void 0 : branch.Io.Magnitude)) / 10, "A \u2220").concat(Math.round((branch === null || branch === void 0 ? void 0 : branch.Io.Phase) * 1800 / Math.PI) / 10, "\xB0")
    }
  });
  return cableModel;
}
function updateBusDuct(busDuctModel, busDuctdata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag == busDuctdata.Tag;
  });
  busDuctModel.attr({
    label: {
      text: busDuctdata.Tag
    },
    size: {
      text: "".concat(busDuctdata.IR, "A")
    },
    length: {
      text: "".concat(busDuctdata.L, "m, ").concat(Math.round(1000 * busDuctdata.Rl) / 1000, "-j").concat(Math.round(1000 * busDuctdata.Xl) / 1000, "\u03A9/km")
    },
    impedance: {
      text: "R:".concat(Math.round(10000 * busDuctdata.R) / 10000, ", X:").concat(Math.round(10000 * busDuctdata.X) / 10000)
    },
    operatingCurrent: {
      text: "".concat(Math.round(10 * branch.Io.Magnitude) / 10, "A \u2220").concat(Math.round(branch.Io.Phase * 1800 / Math.PI) / 10, "\xB0")
    }
  });
  return busDuctModel;
}
function updateMotor(motorModel, motordata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag == motordata.Tag;
  });
  motorModel.attr({
    // label: { text: busDuctdata.Tag },
    // size: { text: `${busDuctdata.IR}A` },
    // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}Î©/km` },
    // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },
    // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A â ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}Â°` }
  });
  return motorModel;
}
function updateHeater(heaterModel, heaterdata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag == heaterdata.Tag;
  });
  heaterModel.attr({
    // label: { text: busDuctdata.Tag },
    // size: { text: `${busDuctdata.IR}A` },
    // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}Î©/km` },
    // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },
    // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A â ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}Â°` }
  });
  return heaterModel;
}
function updateCapacitor(capacitorModel, capacitordata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag == capacitordata.Tag;
  });
  capacitorModel.attr({
    // label: { text: busDuctdata.Tag },
    // size: { text: `${busDuctdata.IR}A` },
    // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}Î©/km` },
    // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },
    // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A â ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}Â°` }
  });
  return capacitorModel;
}
function updateLumpLoad(lumpLoadModel, lumpLoaddata, branches) {
  var branch = branches.find(function (br) {
    return br.Tag == lumpLoaddata.Tag;
  });
  lumploadModel.attr({
    //label: { text: busDuctdata.Tag },
    //size: { text: `${busDuctdata.IR}A` },
    //length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}Î©/km` },
    //impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },
    //operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A â ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}Â°` }
  });
  return lumploadModel;
}

/***/ }),

/***/ "./src/myThree.js":
/*!************************!*\
  !*** ./src/myThree.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   centrePlan3Js: () => (/* binding */ centrePlan3Js),
/* harmony export */   clearScene3Js: () => (/* binding */ clearScene3Js),
/* harmony export */   drawBend3Js: () => (/* binding */ drawBend3Js),
/* harmony export */   drawCross3Js: () => (/* binding */ drawCross3Js),
/* harmony export */   drawCube3Js: () => (/* binding */ drawCube3Js),
/* harmony export */   drawEquipment3Js: () => (/* binding */ drawEquipment3Js),
/* harmony export */   drawLadder3Js: () => (/* binding */ drawLadder3Js),
/* harmony export */   drawLadderChunk3Js: () => (/* binding */ drawLadderChunk3Js),
/* harmony export */   drawNode3Js: () => (/* binding */ drawNode3Js),
/* harmony export */   drawPlane3Js: () => (/* binding */ drawPlane3Js),
/* harmony export */   drawScene3Js: () => (/* binding */ drawScene3Js),
/* harmony export */   drawSleeve3Js: () => (/* binding */ drawSleeve3Js),
/* harmony export */   drawTee3Js: () => (/* binding */ drawTee3Js),
/* harmony export */   hide3D3Js: () => (/* binding */ hide3D3Js),
/* harmony export */   rotatePlaneJs: () => (/* binding */ rotatePlaneJs),
/* harmony export */   scalePlane3Js: () => (/* binding */ scalePlane3Js)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ "./node_modules/three/examples/jsm/controls/OrbitControls.js");
/* harmony import */ var three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/loaders/FontLoader */ "./node_modules/three/examples/jsm/loaders/FontLoader.js");
/* harmony import */ var three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/geometries/TextGeometry */ "./node_modules/three/examples/jsm/geometries/TextGeometry.js");
/* harmony import */ var three_examples_jsm_exporters_GLTFExporter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/exporters/GLTFExporter */ "./node_modules/three/examples/jsm/exporters/GLTFExporter.js");
/* harmony import */ var three_examples_jsm_libs_lil_gui_module_min__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/libs/lil-gui.module.min */ "./node_modules/three/examples/jsm/libs/lil-gui.module.min.js");
/* harmony import */ var _src_threejs_objects_plane_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/threejs/objects/plane.js */ "./src/threejs/objects/plane.js");
/* harmony import */ var _src_threejs_objects_ladder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/threejs/objects/ladder */ "./src/threejs/objects/ladder.js");
/* harmony import */ var _src_threejs_objects_bend_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/threejs/objects/bend.js */ "./src/threejs/objects/bend.js");
/* harmony import */ var _src_threejs_objects_tee_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/threejs/objects/tee.js */ "./src/threejs/objects/tee.js");
/* harmony import */ var _src_threejs_objects_cross_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/threejs/objects/cross.js */ "./src/threejs/objects/cross.js");
/* harmony import */ var _threejs_objects_node__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./threejs/objects/node */ "./src/threejs/objects/node.js");
/* harmony import */ var _src_threejs_objects_sleeve_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/threejs/objects/sleeve */ "./src/threejs/objects/sleeve.js");
/* harmony import */ var _src_threejs_objects_equipment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/threejs/objects/equipment */ "./src/threejs/objects/equipment.js");
/* harmony import */ var _src_threejs_objects_refPoint__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/threejs/objects/refPoint */ "./src/threejs/objects/refPoint.js");
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }





 //dat-gui
//import {Stats} from 'three/examples/jsm/libs/stats.module';










var dotNetObj;
var scene, camera, renderer;
var canvas, controls, currentPlane;
var rendererWidth = window.innerWidth;
var rendererHeight = window.innerHeight;
var raycaster;
var posx = 0,
  posy = 0,
  posz = 0,
  eventclientX = 0,
  eventclientY = 0,
  eventpageX = 0,
  eventpageY = 0,
  eventoffsetX = 0,
  eventoffsetY = 0,
  eventlayerX = 0,
  eventlayerY = 0,
  eventx = 0,
  eventy = 0,
  mousex = 0,
  mousey = 0,
  linePositionx = 0,
  linePositiony = 0,
  linePositionz = 0;
//const stats = new Stats();

// materials
var defaultOpacity = 0.9,
  defaultColor = 0xc8c8c8,
  defaultColorLadder = 0xc80000,
  defaultColorEq = 0x7f868a,
  defaultColorTrench = 0x77ff88;
var defaultColorSSFloor = 0x424242,
  defaultColorSleeve = 0x7f868a,
  defaultColorMCT = 0xc8c8c8,
  defaultColorConcrete = 0xc8c8c8;
var substationFloorMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
  color: defaultColorSSFloor,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var ladderMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorLadder,
  shininess: 100,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var equipmentMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorEq,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var sleeveMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorSleeve,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var trenchMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorTrench,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var concreteMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorConcrete,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var mctMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorMCT,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({
  color: 0x0080ff,
  size: 0.02,
  alphaTest: 0.5
});
var redRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
  color: 0xff0000,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
});
var yellowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
  color: 0xffff00,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
});
var selectedObjectMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: 0xffff00,
  transparent: true,
  opacity: 0.8,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var savedObject, savedObjectMaterial; // storing previously selecyed object and its meterials properties
var selectItemColor = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: 'yellow',
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true
});
var ctrlKeyPressed = false;
var shiftKeyPressed = false;
var shadowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
  color: 0xcccccc,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
});
var intervalId = window.setInterval(function () {
  if (camera != undefined) {
    var sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);
    dotNetObj.invokeMethodAsync("SaveSceneInfo", sceneInfo);
  }
}, 10000);
var eventListenersAdded = false;

//clearInterval(intervalId)
function drawScene3Js(divId) {
  var sceneInfoJson = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var dotNetObjRef = arguments.length > 2 ? arguments[2] : undefined;
  if (eventListenersAdded) return; // Prevent adding listeners multiple times
  dotNetObj = dotNetObjRef;
  canvas = document.getElementById(divId);
  canvas.setAttribute('tabindex', '0'); // Make canvas focusable
  //canvas.focus(); // Optionally set focus programmatically
  scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();
  scene.Name = "name";
  camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 400);
  //light
  scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight(0xffffff, 0.9));
  scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.HemisphereLight(0x9f9f9b, 0x080820, 1));
  var pointLight = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 1, 100);
  pointLight.position.set(rendererWidth / 2, rendererHeight / 2, 100);
  scene.add(pointLight);
  var axesHelper = new three__WEBPACK_IMPORTED_MODULE_0__.AxesHelper(500);
  scene.add(axesHelper);
  //shadowRing(0, 0, plotElevtn + 0.01); // to shadow mouse movement when ctrl key is pressed    
  var shadowRing = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.2, 0.21, 20), shadowRingMaterial);
  shadowRing.name = 'shadowRing';
  shadowRing.position.set(0, 0, 0.01);
  scene.add(shadowRing);
  raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();
  renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  canvas.appendChild(renderer.domElement);
  controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__.OrbitControls(camera, renderer.domElement);
  controls.autoRotate = true;
  controls.autoRotateSpeed = 6;
  controls.screenSpacePanning = true;
  controls.minDistance = 5;
  controls.maxDistance = 10000;
  if (sceneInfoJson != "") {
    var sceneInfo = JSON.parse(sceneInfoJson);
    rendererWidth = sceneInfo[0];
    rendererHeight = sceneInfo[1];
    camera.position.x = sceneInfo[2];
    camera.position.y = sceneInfo[3];
    camera.position.z = sceneInfo[4];
    camera.rotation.x = sceneInfo[5];
    camera.rotation.y = sceneInfo[6];
    camera.rotation.z = sceneInfo[7];
  }
  controls.addEventListener('change', function () {
    var distance = camera.position.distanceTo(shadowRing.position);
    var scale = distance * .1;
    shadowRing.scale.set(scale, scale, scale);

    // Updated scaling logic
    var refObjects = getObjectsByName(scene, 'refPoint');
    if (refObjects && refObjects.length > 0) {
      refObjects.forEach(function (obj) {
        var d = camera.position.distanceTo(obj.position); // Use obj's position (group or individual)
        var sc = d * 0.1;
        if (obj instanceof three__WEBPACK_IMPORTED_MODULE_0__.Group) {
          // Scale the group itself: this scales all children and their relative positions
          obj.scale.set(sc, sc, sc);
        } else {
          // For non-groups, scale the object directly (as before)
          obj.scale.set(sc, sc, sc);
        }
      });
    }
  });
  var sceneInfo1 = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);
  dotNetObj.invokeMethodAsync("SaveSceneInfo", sceneInfo1);
  controls.update();
  camera.position.z = 5;

  // Add event listeners
  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('keydown', onKeyDown, false);
  window.addEventListener('keyup', onKeyUp, false);
  renderer.domElement.addEventListener('mousemove', onMouseMove, false);
  renderer.domElement.addEventListener('wheel', mouseWheel, false);
  renderer.domElement.addEventListener('mousedown', mouseDownListener, false);
  renderer.domElement.addEventListener('mousemove', mouseMoveListener, false);
  renderer.domElement.addEventListener('mouseup', mouseUpListener, false);

  // Add double-click event listener
  renderer.domElement.addEventListener('dblclick', autoZoomToFit);

  // Prevent context menu on Ctrl+click or right-click
  renderer.domElement.addEventListener('contextmenu', function (event) {
    event.preventDefault();
  });
  eventListenersAdded = true;

  // onWindowResize (unchanged)
  function onWindowResize() {
    console.log('Window resize event triggered');
    rendererWidth = window.innerWidth;
    rendererHeight = window.innerHeight;
    camera.aspect = rendererWidth / rendererHeight;
    var sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);
    dotNetObj.invokeMethodAsync("SaveSceneInfo", sceneInfo);
    camera.updateProjectionMatrix();
    scene.updateMatrixWorld(true);
    renderer.setSize(rendererWidth, rendererHeight);
    render();
  }

  // onKeyDown (unchanged, as it works correctly)
  function onKeyDown(event) {
    console.log("Key down event triggered: ".concat(event.key, ", Key code: ").concat(event.code));
    if (event.key === 'Control') {
      ctrlKeyPressed = true;
    }
    if (event.key === 'Shift') {
      shiftKeyPressed = true;
    }
    if (event.key === 'Escape') {
      // clear all the clicked reference points to start afres
      clearRefPoints();
    }
    showHideShadowRingNPosinLines();
    console.log("Key pressed event after: ".concat(event.key, ", Key code: ").concat(event.code, ", \n        Ctrl key pressed status: ").concat(ctrlKeyPressed, ", Shift key pressed status: ").concat(shiftKeyPressed));
  }

  // onKeyUp (unchanged, as it works correctly)
  function onKeyUp(event) {
    console.log("Key released event triggered: ".concat(event.key, ", Key code: ").concat(event.code));
    if (event.key === 'Control') {
      ctrlKeyPressed = false;
    }
    if (event.key === 'Shift') {
      shiftKeyPressed = false;
    }
    showHideShadowRingNPosinLines();
    console.log("Key released event after: ".concat(event.key, ", Key code: ").concat(event.code, ", \n        Ctrl key pressed status: ").concat(ctrlKeyPressed, ", Shift key pressed status: ").concat(shiftKeyPressed));
  }

  // onMouseMove (unchanged, as it works with global ctrlKeyPressed)
  function onMouseMove(event) {
    if (ctrlKeyPressed) {
      var _findCoordinate = findCoordinate(event);
      var _findCoordinate2 = _slicedToArray(_findCoordinate, 2);
      mouse = _findCoordinate2[0];
      pos = _findCoordinate2[1];
      console.log("Control Key pressed and mouse move ", pos);
      scene.getObjectByName('shadowRing').position.set(pos.x, pos.y, plotElevtn + 0.01);
      var linePosition = topPlotPlanIntersectPosition(event);
      scene.remove(scene.getObjectByName('positionlinex'));
      var pointsx = [];
      pointsx.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x + 100, linePosition.y, linePosition.z));
      pointsx.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x - 100, linePosition.y, linePosition.z));
      var geometry1 = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(pointsx);
      var material1 = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
        color: 0xff0000
      });
      linex = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry1, material1);
      linex.name = 'positionlinex';
      scene.add(linex);
      scene.remove(scene.getObjectByName('positionliney'));
      var pointsy = [];
      pointsy.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x, linePosition.y + 100, linePosition.z));
      pointsy.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x, linePosition.y - 100, linePosition.z));
      var geometry2 = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(pointsy);
      var material2 = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
        color: 0x0000ff
      });
      liney = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry2, material2);
      liney.name = 'positionliney';
      scene.add(liney);
      render();
    }
  }
  var drag = false;
  function mouseDownListener(event) {
    drag = false;
  }
  function mouseMoveListener(event) {
    drag = true;
  }
  function mouseUpListener(event) {
    if (drag) {
      console.log('Drag Detected');
    } else {
      console.log('Click Detected');
      // Only handle left-clicks
      if (event.button === 0) {
        console.log('Left-click detected');
        // Use event.ctrlKey and event.shiftKey for reliability
        console.log("Click event: Ctrl key pressed status: ".concat(event.ctrlKey, ", Shift key pressed status: ").concat(event.shiftKey));

        // Moved from raycast and onClick
        var _findCoordinate3 = findCoordinate(event);
        var _findCoordinate4 = _slicedToArray(_findCoordinate3, 2);
        mouse = _findCoordinate4[0];
        pos = _findCoordinate4[1];
        var linePosition = topPlotPlanIntersectPosition(event);
        var objectPosition = topObjectIntersectPosition(event);
        console.log("Mouse position: Mouse:[".concat(mouse.x, ", ").concat(mouse.y, "],  ") + "Position:[".concat(pos.x, ", ").concat(pos.y, "],  Client:[").concat(event.clientX, ", ").concat(event.clientY, "],  ") + "Screen:[".concat(event.screenX, ", ").concat(event.screenY, "],  Page:[").concat(event.pageX, ", ").concat(event.pageY, "],  ") + "Offset:[".concat(event.offsetX, ", ").concat(event.offsetY, "],  Layer:[").concat(event.layerX, ", ").concat(event.layerY, "],  ") + "EvenXY:[".concat(event.x, ", ").concat(event.y, "],  LinePosition :[").concat(linePosition.x, ", ").concat(linePosition.y, ", ").concat(linePosition.z, "],  ") + "Render Width Height:[".concat(rendererWidth, ", ").concat(rendererHeight, "]"));
        dotNetObj.invokeMethodAsync("MouseClick", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
        if (!event.ctrlKey) {
          console.log("Select Object");
          // castObject(event); // Uncomment if needed
        }
        if (!event.ctrlKey && event.shiftKey) {
          console.log("De-select Object");
          // castObject(event); // Uncomment if needed
        }
        if (event.ctrlKey) {
          console.log("Clicked while Ctrl key is pressed");
          var point = intersectPoint(currentPlane.Tag);
          point.z += 0.01;
          refPoints.push([point.x, point.y, mouse.x, mouse.y]);
          var refPointText = "";
          if (scalePlaneDoneStatus === false) {
            refPointText = refPointTexts[refPoints.length - 1];
          } else {
            // centre
            refPointText = refPointTexts[-1];
          }
          scene.add((0,_src_threejs_objects_refPoint__WEBPACK_IMPORTED_MODULE_14__.drawRefPointMesh)(refPointText, point, .5));
          render();
          if (refPoints.length === 4 || scalePlaneDoneStatus === true && refPoints.length === 1) {
            console.log("Draw UpdateRefPoints ".concat(refPoints.toString()));
            dotNetObj.invokeMethodAsync("UpdateRefPoints", refPoints.toString());
          }
        }
      } else if (event.button === 1) {
        console.log('Middle-click detected');
        // Add middle-click behavior if needed
      } else if (event.button === 2) {
        console.log('Right-click detected');
        // Add right-click behavior if needed
      }
    }
  }
  function findCoordinate(event) {
    // calculate mouse position in normalized device coordinates (-1 to +1) for both components
    var rect = event.target.getBoundingClientRect();
    var mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
    var x = event.clientX - rect.left; //x position within the element.
    var y = event.clientY - rect.top; //y position within the element.
    mouse.x = x / rendererWidth * 2 - 1;
    mouse.y = -(y / rendererHeight) * 2 + 1;
    //
    var vec = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // create once and reuse
    var pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // create once and reuse
    //
    vec.set((event.clientX - rect.left) / rendererWidth * 2 - 1, -((event.clientY - rect.top) / rendererHeight) * 2 + 1, 0);
    vec.unproject(camera);
    vec.sub(camera.position).normalize();
    var distance = -camera.position.z / vec.z;
    pos.copy(camera.position).add(vec.multiplyScalar(distance));
    // rounding to two decimal
    pos.x = Math.round(pos.x * 100) / 100;
    pos.y = Math.round(pos.y * 100) / 100;
    return [mouse, pos];
  }
  function animate() {
    requestAnimationFrame(animate);

    //cube.rotation.x += 0.01;
    //cube.rotation.y += 0.01;

    renderer.render(scene, camera);
  }
  function GetSceneInfo(scene, camera) {
    var sceneInfo = {
      "sceneName": scene.Name,
      "cameraPosition": {
        "x": camera.position.x,
        "y": camera.position.y,
        "z": camera.position.z
      },
      "cameraRotation": {
        "x": camera.rotation.x,
        "y": camera.rotation.y,
        "z": camera.rotation.z
      },
      "rendererWidth": rendererWidth,
      "rendererHeight": rendererHeight

      //"getWorlDirection": JSON.stringify(cameraTargetVector),
    };
    return JSON.stringify(sceneInfo);
  }
  animate();
}
function drawCube3Js() {
  var side = Math.random() * 1;
  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(side, side, side);
  var color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
  color.setHex("0x".concat(parseInt(Math.random() * 255)).concat(parseInt(Math.random() * 255)).concat(parseInt(Math.random() * 255)));
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
    color: color
  });
  var cube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
  cube.position.x = Math.random() * 50;
  cube.position.y = Math.random() * 50;
  cube.position.z = Math.random() * 10;
  scene.add(cube);
  animate();
}

// Utility function (as above)
function getObjectsByName(scene, name) {
  var objects = [];
  scene.traverse(function (obj) {
    if (obj.name === name) {
      objects.push(obj);
    }
  });
  return objects;
}
function clearScene3Js() {
  scene.children.forEach(function (obj) {
    if (obj.isMesh) {
      scene.remove(obj);
    }
  });
  renderer.render(scene, camera);
}
function hide3D3Js(hidePP) {
  scene.children.forEach(function (child) {
    if (child !== undefined) {
      if (child.Tag !== undefined) {
        if (child.Tag.includes("plotplan")) {
          child.visible = hidePP;
        }
      }
    }
  });
  renderer.render(scene, camera);
}
function drawPlane3Js(planeName, planeTag, imageString, scaleX, scaleY, centreX, centreY, elevation, opacity) {
  //console.log("Step 3: Drawing Plane from three.js drawPlane : ", planeTag);
  scene.add((0,_src_threejs_objects_plane_js__WEBPACK_IMPORTED_MODULE_6__.drawPlaneMesh)(rendererWidth, rendererHeight, planeName, planeTag, imageString, scaleX, scaleY, centreX, centreY, elevation, opacity));
  currentPlane = scene.children[scene.children.length - 1];
  scalePlaneDoneStatus = false;
}
function rotatePlaneJs(angle) {
  if (currentPlane) {
    if (angle !== undefined) {
      currentPlane.rotateZ(angle);
      renderer.render(scene, camera);
    }
  }
}
var scalePlaneDoneStatus = false;
function scalePlane3Js(scaleX, scaleY) {
  if (currentPlane) {
    if (scaleX !== undefined && scaleY !== undefined) {
      if (scaleX !== 0 && scaleY !== 0) {
        currentPlane.scale.set(scaleX, scaleY, 1);
        currentPlane.updateMatrixWorld();
        clearRefPoints();
        orthoCamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);
        renderer.render(scene, orthoCamera);
        scalePlaneDoneStatus = true;
      }
    }
  }
}
function centrePlan3Js(centreX, centreY, elevation) {
  console.log("centrePlan3Js", centreX, centreY, elevation);
  // align to centre
  if (currentPlane) {
    if (centreX !== undefined && centreY !== undefined) {
      currentPlane.position.set(-centreX, -centreY, elevation);
      currentPlane.updateMatrixWorld();
      clearRefPoints();
      // orthoCamera = new THREE.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);
      renderer.render(scene, orthoCamera);
    }
  }
}
function drawLadder3Js(tag, jsonPoints, color, opacity) {
  scene.add((0,_src_threejs_objects_ladder__WEBPACK_IMPORTED_MODULE_7__.drawLadderMesh)(tag, jsonPoints, ladderMaterial, color, opacity));
}
function drawLadderChunk3Js(jsonDataList, opacity) {
  var dataList = JSON.parse(jsonDataList);
  dataList.forEach(function (item, index) {
    scene.add((0,_src_threejs_objects_ladder__WEBPACK_IMPORTED_MODULE_7__.drawLadderMesh)(item.Tag, item.JsonPoints, ladderMaterial, item.Color, opacity));
  });
}
function drawBend3Js(tag, jsonFacePoints, color, opacity) {
  scene.add((0,_src_threejs_objects_bend_js__WEBPACK_IMPORTED_MODULE_8__.drawBendMesh)(tag, jsonFacePoints, ladderMaterial, color, opacity));
}
function drawTee3Js(tag, jsonFacePoints, color, opacity) {
  scene.add((0,_src_threejs_objects_tee_js__WEBPACK_IMPORTED_MODULE_9__.drawTeeMesh)(tag, jsonFacePoints, ladderMaterial, color, opacity));
}
function drawCross3Js(tag, jsonFacePoints, color, opacity) {
  scene.add((0,_src_threejs_objects_cross_js__WEBPACK_IMPORTED_MODULE_10__.drawCrossMesh)(tag, jsonFacePoints, ladderMaterial, color, opacity));
}
function drawNode3Js(tag, jsonPoint, color, opacity) {
  scene.add((0,_threejs_objects_node__WEBPACK_IMPORTED_MODULE_11__.drawNodeMesh)(tag, jsonPoint, pointsMaterial, color, opacity));
}
function drawSleeve3Js(tag, jsonPoints, radious, segment, radialSegments, color, opacity) {
  scene.add((0,_src_threejs_objects_sleeve_js__WEBPACK_IMPORTED_MODULE_12__.drawSleeveMesh)(tag, jsonPoints, radious, segment, radialSegments, sleeveMaterial, color, opacity));
  renderer.render(scene, camera);
}
function drawEquipment3Js(tag, x, y, z, w, d, h, a, color, opacity, colortext) {
  scene.add((0,_src_threejs_objects_equipment__WEBPACK_IMPORTED_MODULE_13__.drawEquipmentMesh)(tag, x, y, z, w, d, h, a, equipmentMaterial, color, opacity, colortext));
}
function getRandomColor() {
  new three__WEBPACK_IMPORTED_MODULE_0__.Color();
  color.setHex("0x".concat(parseInt(Math.random() * 255)).concat(parseInt(Math.random() * 255)).concat(parseInt(Math.random() * 255)));
  return color;
}

window.Layout3d = {
  load: function load(state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference) {
    loadScene3d(state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference);
  },
  scalePlotPlan: function (_scalePlotPlan) {
    function scalePlotPlan(_x, _x2) {
      return _scalePlotPlan.apply(this, arguments);
    }
    scalePlotPlan.toString = function () {
      return _scalePlotPlan.toString();
    };
    return scalePlotPlan;
  }(function (scaleX, scaleY) {
    scalePlotPlan(scaleX, scaleY);
  }),
  centrePlotPlan: function (_centrePlotPlan) {
    function centrePlotPlan(_x3, _x4, _x5) {
      return _centrePlotPlan.apply(this, arguments);
    }
    centrePlotPlan.toString = function () {
      return _centrePlotPlan.toString();
    };
    return centrePlotPlan;
  }(function (centreX, centreY, elevation) {
    centrePlotPlan(centreX, centreY, elevation);
  }),
  //drawLadder: (tag, type, jsonPoints, opacity, color, animationText, progress) => { drawLadder(tag, type, jsonPoints, opacity, color, animationText, progress); },
  //drawBend: (tag, jsonPoints, opacity, color) => { drawBend(tag, jsonPoints, opacity, color); },
  //drawTee: (tag, jsonPoints, opacity, color) => { drawTee(tag, jsonPoints, opacity, color); },
  //drawCross: (tag, jsonPoints, opacity, color) => { drawCross(tag, jsonPoints, opacity, color); },
  drawCable: function drawCable(tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option) {
    _drawCable(tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option);
  },
  //drawNode: (tag, jsonPoint, color) => { drawNode(tag, jsonPoint, color); },
  //drawSleeve: (tag, radious, jsonPoints, opacity, color) => { drawSleeve(tag, radious, jsonPoints, opacity, color); },
  drawBoard: function drawBoard(tagName, jsonPoint, v, w, d, h, angle, color, opacity) {
    _drawBoard(tagName, jsonPoint, v, w, d, h, angle, color, opacity);
  },
  equipment: function (_equipment) {
    function equipment(_x6, _x7, _x8, _x9, _x0, _x1, _x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17) {
      return _equipment.apply(this, arguments);
    }
    equipment.toString = function () {
      return _equipment.toString();
    };
    return equipment;
  }(function (tag, x1, y1, z1, x2, y2, z2, w, d, h, a, color, opacity, colortext) {
    equipment(tag, x1, y1, z1, x2, y2, z2, w, d, h, a, color, opacity, colortext);
  }),
  saveSceneGLTF: function saveSceneGLTF() {
    _saveSceneGLTF();
  },
  removeItem: function removeItem(tag) {
    _removeItem(tag);
  },
  searchItem: function searchItem(tag) {
    _searchItem(tag);
  },
  toggleFunction: function toggleFunction() {
    _toggleFunction();
  },
  hidePlotPlan: function hidePlotPlan(hidePP) {
    _hidePlotPlan(hidePP);
  },
  orthoView: function orthoView(ortho, xp, yp, zp) {
    _orthoView(ortho, xp, yp, zp);
  },
  clearClickedPoints: function (_clearClickedPoints) {
    function clearClickedPoints() {
      return _clearClickedPoints.apply(this, arguments);
    }
    clearClickedPoints.toString = function () {
      return _clearClickedPoints.toString();
    };
    return clearClickedPoints;
  }(function () {
    clearClickedPoints();
  }),
  selectObjectHighlight: function (_selectObjectHighlight) {
    function selectObjectHighlight(_x18) {
      return _selectObjectHighlight.apply(this, arguments);
    }
    selectObjectHighlight.toString = function () {
      return _selectObjectHighlight.toString();
    };
    return selectObjectHighlight;
  }(function (tag) {
    selectObjectHighlight(tag);
  }),
  copyText: function copyText(text) {
    navigator.clipboard.writeText(text).then(function () {
      alert(text, " copied to clipboard!");
    })["catch"](function (error) {
      alert(error);
    });
  }
};
var projectName = "BlazorNPM";
var caller;
var clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();
var mixer, cameraPerspective, orthoCamera;
var xscalefactor = 1.00,
  yscalefactor = 1.00,
  lxcentreworld = -110.62,
  lycentreworld = -72.08; // without scalling to match ladder coordinates
var planeMesh, lxmin, lxmax, lymin, lymax, xxmin, xxmax, yymin, yymax; // global variable for plot plan scale
var plotElevtn = 0;
//var rendererWidth = window.innerWidth - 60;
//var rendererHeight = Math.min(window.innerHeight - 100, rendererWidth * 0.6);

var selectedObject = [],
  selectedInputTab,
  clickCoordinate = [],
  clickedPointSeq = [];
var refPoints = [],
  refPointTexts = ['X-Left', 'X-Right', 'Y-Bottom', 'Y-Top', 'Centre (0,0)'];
var mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
var pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var raycaster;

// ***** Clipping planes: *****
//const localPlane = new THREE.Plane(new THREE.Vector3(0, - 1, 0), 0.8);
//const xPlane = new THREE.Plane(new THREE.Vector3(- 1, 0, 0), 0.1);
//const yPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.1);
//const zPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0.1);
var startTime;

// ***** Clipping planes: *****

var localPlane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0), 400);
var globalPlane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0), 20);
var globalPlane1 = new three__WEBPACK_IMPORTED_MODULE_0__.Plane(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0), 0.1);
var localPlane1 = new three__WEBPACK_IMPORTED_MODULE_0__.Plane(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), 0.1);

// ***** Clipping setup (renderer): *****
var globalPlanes = [globalPlane],
  Empty = Object.freeze([]);
var globalPlanesz = [globalPlane1];

//const xPlanes = [xPlane], Empty = Object.freeze([]);
//const yPlanes = [yPlane], Empty = Object.freeze([]);
//const zPlane = [zPlanes], Empty = Object.freeze([]);

// ***** Clipping setup (renderer): *****
//const Empty = Object.freeze([]), xPlanes = [xPlane], yPlanes = [yPlane], zPlanes = [zPlane];

//materials
var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: 0x80ee10,
  shininess: 100,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var defaultOpacity = 0.9;
var defaultColor = 0xc8c8c8;
var defaultColorLadder = 0xc80000;
var defaultColorEq = 0x7f868a,
  defaultColorSSFloor = 0x424242;
var defaultColorSleeve = 0xc8c8b8;
var defaultColorConcrete = 0xc8c898;
var defaultColorTrench = 0xc8c878;
var defaultColorMCT = 0xc8c838;
var substationFloorMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
  color: defaultColorSSFloor,
  transparent: true,
  opacity: 0.5,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var laddermaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorLadder,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var equipmentmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorEq,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var sleevematerial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorSleeve,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var sleeveRadialSegments = 30; // no of radial segments for tubes as sleeves
var sleeveTubularSegments = 30; // no of tubular segments for tubes as sleeves
var trenchmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorTrench,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var concretematerial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorConcrete,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var mctmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: defaultColorMCT,
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({
  color: 0x0080ff,
  size: 0.02,
  alphaTest: 0.5
});
var redRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
  color: 0xff0000,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
});
var yellowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
  color: 0xffff00,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
});
var selectedObjectMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: 0xffff00,
  transparent: true,
  opacity: 0.8,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var savedObject, savedObjectMaterial; // storing previously selecyed object and its meterials properties
var selectItemColor = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
  color: 'yellow',
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var loader = new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_2__.FontLoader();
/*var textMesh, textGeometry;*/
var textMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
  color: 'brown',
  transparent: true,
  opacity: defaultOpacity,
  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
  flatShading: true,
  clippingPlanes: [localPlane],
  clipShadows: true
});
var linex, liney;
function animate1() {
  //requestID = requestAnimationFrame(animate);
  // need to update the orbitcontrols for autorotate camera to take effect
  //controls.update();
  requestAnimationFrame(animate);
  controls.update();
  arrowCamera.position.copy(camera.position);
  arrowCamera.position.sub(controls.target);
  arrowCamera.position.setLength(300);
  arrowCamera.lookAt(arrowScene.position);
  render();
}

// Function to auto-zoom to fit the scene
function autoZoomToFit() {
  console.log("double click to auto fit");
  // Create a Box3 to calculate the bounding box of the scene
  var box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
  scene.traverse(function (object) {
    if (object.isMesh) {
      box.expandByObject(object);
    }
  });

  // Get the size and center of the bounding box
  var size = box.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());
  var center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());

  // Set the camera to look at the center
  controls.target.copy(center);
  camera.lookAt(center);

  // Calculate the distance the camera needs to be from the scene
  var maxDim = Math.max(size.x, size.y, size.z);
  var fov = camera.fov * (Math.PI / 180); // Convert FOV to radians
  var cameraZ = maxDim / (2 * Math.tan(fov / 2));

  // Adjust camera position
  camera.position.copy(center);
  camera.position.z += cameraZ * 1.5; // Add some padding (adjust multiplier as needed)

  // Update the controls
  controls.update();
}
function render() {
  var a = clock.getDelta();
  var delta = clock.getDelta();
  if (mixer !== undefined) {
    mixer.update(delta);
  }
  //fitCameraToObject(camera, planeMesh, 50);

  if (resizeRendererToDisplaySize(renderer)) {
    var _canvas = renderer.domElement;
    camera.aspect = _canvas.clientWidth / _canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  //console.log('Render:', renderer.info.render.calls);
  renderer.render(scene, camera);
}

// var docDiv1 = document.getElementById(div1)
// docDiv1.body.appendChild(stats.dom)
// function animate() {
//     stats.begin();
//     renderer.render(scene, camera);
//     stats.end();
//     requestAnimationFrame(animate);
// }

// glf exporter
function _saveSceneGLTF() {
  //https://github.com/mrdoob/three.js/blob/master/examples/misc_exporter_gltf.html#L46
  var gltfExporter = new three_examples_jsm_exporters_GLTFExporter__WEBPACK_IMPORTED_MODULE_4__.GLTFExporter();
  //
  var hideObjectTypesForExport = ["rawladder", "ladder", "bend", "tee", "cross", "node", "sleeve", "equipment"];
  scene.traverse(function (child) {
    if (child instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {
      if (hideObjectTypesForExport.includes(child.type)) {
        child.visible = false;
      }
    }
  });
  //
  var options = {
    trs: false,
    onlyVisible: true,
    binary: false,
    maxTextureSize: 4096
  };
  gltfExporter.parse(scene, function (result) {
    if (result instanceof ArrayBuffer) {
      saveArrayBuffer(result, 'scene.glb');
    } else {
      var output = JSON.stringify(result, null, 2);
      saveString(output, 'scene.gltf');
    }
  }, function (error) {
    console.log('An error happened during parsing', error);
  }, options);
  //
  scene.traverse(function (child) {
    if (child instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {
      child.visible = false;
    }
  });
}
function save(blob, filename) {
  var link = document.createElement('a');
  link.style.display = 'none';
  document.body.appendChild(link); // Firefox workaround, see #6594
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  // URL.revokeObjectURL( url ); breaks Firefox...
}
function saveString(text, filename) {
  save(new Blob([text], {
    type: 'text/plain'
  }), filename);
}
function saveArrayBuffer(buffer, filename) {
  save(new Blob([buffer], {
    type: 'application/octet-stream'
  }), filename);
}
function loadScene3d(state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference) {
  console.log("State : ", state);
  //update widow size to server
  var sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);
  dotNetObj.invokeMethodAsync("SaveSceneInfo", sceneInfo);

  //DotNet.invokeMethodAsync(projectName, "UpdateOnWindowResize", rendererWidth, rendererHeight);

  dotNetObj = reference;
  caller = reference;
  //function draw3d(file, scaleX, scaleY, centreX, centreY) {
  //var div = 'layoutPage3d'
  //var div = "layoutPage3d1"
  canvas = document.getElementById(div1);
  if (!canvas) {
    return;
  }
  if (!arrowScene) {
    //https://jsfiddle.net/b97zd1a3/16/
    //var CANVAS_WIDTH = 200;
    //var CANVAS_HEIGHT = 200;
    //var arrowRenderer = new THREE.WebGLRenderer({ alpha: true }); // clear
    //arrowRenderer.setClearColor(0x000000, 0);
    //arrowRenderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);

    //var arrowCanvas = document.body.appendChild(arrowRenderer.domElement);
    //arrowCanvas.setAttribute('id', 'arrowCanvas');
    //arrowCanvas.style.width = CANVAS_WIDTH;
    //arrowCanvas.style.height = CANVAS_HEIGHT;

    //var arrowScene = new THREE.Scene();

    //var arrowCamera = new THREE.PerspectiveCamera(50, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);
    //arrowCamera.up = camera.up; // important!

    //var arrowPos = new THREE.Vector3(0, 0, 0);
    //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), arrowPos, 60, 0x7F2020, 20, 10));
    //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), arrowPos, 60, 0x207F20, 20, 10));
    //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), arrowPos, 60, 0x20207F, 20, 10));
  }
  if (!scene) {
    //create the scene and other initialiasations
    console.log("No scene found XXXXXXXXXXXXXXXXXXXXXX");
    scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();
    scene.background = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);

    //renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer({
      antialias: true,
      preserveDrawingBuffer: true,
      premultipliedAlpha: false
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(rendererWidth, rendererHeight);
    renderer.shadowMap.enabled = true; // Enable shadow mapping
    renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;
    canvas.appendChild(renderer.domElement);
    renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
    renderer.localClippingEnabled = false;

    //
    //https://threejs.org/examples/webgl_clipping.html
    //// GUI
    var gui = new three_examples_jsm_libs_lil_gui_module_min__WEBPACK_IMPORTED_MODULE_5__.GUI({
        autoPlace: false
      }),
      folderLocal = gui.addFolder('Local Clipping'),
      propsLocal = {
        get 'Enabled'() {
          return renderer.localClippingEnabled;
        },
        set 'Enabled'(v) {
          renderer.localClippingEnabled = v;
        },
        get 'Plane'() {
          return localPlane.constant;
        },
        set 'Plane'(v) {
          localPlane.constant = v;
        }
      },
      folderLocal1 = gui.addFolder('Z-axis Clipping'),
      propsLocal1 = {
        get 'Enabled'() {
          return renderer.localClippingEnabled;
        },
        set 'Enabled'(v) {
          renderer.localClippingEnabled = v;
        },
        get 'Plane'() {
          return localPlane1.constant;
        },
        set 'Plane'(v) {
          localPlane1.constant = v;
        }
      },
      folderY = gui.addFolder('Y-axis Clipping'),
      propsY = {
        get 'Enabled'() {
          return renderer.clippingPlanes !== Empty;
        },
        set 'Enabled'(v) {
          renderer.clippingPlanes = v ? globalPlanes1 : Empty;
        },
        get 'Plane'() {
          return globalPlane1.constant;
        },
        set 'Plane'(v) {
          globalPlane1.constant = v;
        }
      },
      folderX = gui.addFolder('X-axis Clipping'),
      propsX = {
        get 'Enabled'() {
          return renderer.clippingPlanes !== Empty;
        },
        set 'Enabled'(v) {
          renderer.clippingPlanes = v ? globalPlanes : Empty;
        },
        get 'Plane'() {
          return globalPlane.constant;
        },
        set 'Plane'(v) {
          globalPlane.constant = v;
        }
      };
    var customContainer = document.getElementById(div1);
    //customContainer.appendChild(gui.domElement);
    gui.domElement.id = 'gui';
    var guiContainer = document.getElementById(guiDiv);
    //gui_container.appendChild(gui.domElement);
    guiContainer.appendChild(gui.domElement);

    // Start

    //startTime = Date.now();
    folderLocal.open();
    folderLocal.add(propsLocal, 'Enabled');
    folderLocal.add(propsLocal, 'Plane', -50, 500);
    folderLocal1.open();
    folderLocal1.add(propsLocal1, 'Enabled');
    folderLocal1.add(propsLocal1, 'Plane', -5, 50);
    folderX.open();
    folderX.add(propsX, 'Enabled');
    folderX.add(propsX, 'Plane', -50, 500);
    folderY.open();
    folderY.add(propsY, 'Enabled');
    folderY.add(propsY, 'Plane', -50, 300);
    var frameWidth = canvas.clientWidth;
    var frameHeight = canvas.clientHeight;

    //camera
    var fov = 20;
    var aspectRatio = rendererWidth / rendererHeight;
    var frustumSize = 1000;
    var near = 0.001;
    var far = 4000;
    cameraPerspective = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(fov, aspectRatio, near, far);
    //camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
    cameraPerspective.position.set(0, 0, 400);
    //camera.up = new THREE.Vector3(0,0,1);
    cameraPerspective.lookAt(scene.position);
    cameraPerspective.add(new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 1));
    camera = cameraPerspective;
    scene.add(camera);
    orthoCamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);
    orthoCamera.add(new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 1));
    // helper
    //var arrowHelper = new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 400, 0xff0000 );
    var axis = new three__WEBPACK_IMPORTED_MODULE_0__.AxesHelper(300);
    scene.add(axis);
    createWheelStopListener(renderer.domElement, function () {
      doAfterEndScrol();
    });
    raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();

    //-----------------------

    var segments = [];
    var maxCount = 1000;
    var count = 0;
    var thisgroup,
      segType = "LV",
      opacity = 0.8;
    var w = .1,
      t = 0.02,
      deg = 0;
    var Option = 'JS';
    Option = 'CS';
    var t0 = performance.now();

    //window.getElementById("randomNumberSpan").innerText = count;	

    //var geometry = new THREE.PlaneBufferGeometry(30, 30);
    //var plane = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide }));
    //scene.add(plane);

    //light
    scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight(0xffffff, 0.9));
    scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.HemisphereLight(0xffffff, 0x080820, 1));
    var pointLight = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 1, 100);
    pointLight.position.set(rendererWidth / 2, rendererHeight / 2, 100);
    scene.add(pointLight);

    //   renderer = new THREE.WebGLRenderer({ antialias: true });
    //   renderer.setPixelRatio(window.devicePixelRatio);
    //renderer.setSize(frameWidth, frameHeight);

    while (canvas.lastElementChild) {
      canvas.removeChild(canvas.lastElementChild);
    }
    canvas.appendChild(renderer.domElement);
    controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_1__.OrbitControls(camera, renderer.domElement);
    controls.screenSpacePanning = true;
    controls.minDistance = 5;
    controls.maxDistance = 10000;
    //controls.target.set(1, 0, 0);
    //controls.maxPolarAngle = Math.PI;
    //controls.enableDamping = true;
    //controls.dampingFactor = 0.05;
    //controls.autoRotate = true;
    //controls.listenToKeyEvents(window); // optional
    //controls.addEventListener('change', render);
    controls.update();

    // draw mouse position lines (visible while ctrl key is pressed)
    var linePosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(10, 10, .1);
    if (linex == undefined) {
      // create new position line parallel to x-axis
      var pointsx = [];
      pointsx.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x + 100, linePosition.y, linePosition.z));
      pointsx.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x - 100, linePosition.y, linePosition.z));
      var geometry2 = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(pointsx);
      var material2 = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
        color: 0xff0000
      });
      linex = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry2, material2);
      linex.name = 'positionlinex';
      scene.add(linex);
      linex.visible = false;
    }
    if (liney == undefined) {
      // create new position line parallel to y-axis
      var pointsy = [];
      pointsy.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x, linePosition.y + 100, linePosition.z));
      pointsy.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(linePosition.x, linePosition.y - 100, linePosition.z));
      var geometry1 = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(pointsy);
      var material1 = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
        color: 0x0000ff
      });
      var _liney = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry1, material1);
      _liney.name = 'positionliney';
      scene.add(_liney);
      _liney.visible = false;
    }
  }
  if (file !== null) {
    loadPlotPlan(file, scaleX, scaleY, centreX, centreY, elevation, opacity);
  }
  animate();
}
function fitCameraToObject(camera, object, offset) {
  offset = offset || 1.5;
  var boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
  boundingBox.setFromObject(object);
  var center = boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());
  var size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());
  var startDistance = center.distanceTo(camera.position);
  // here we must check if the screen is horizontal or vertical, because camera.fov is
  // based on the vertical direction.
  var endDistance = camera.aspect > 1 ? (size.y / 2 + offset) / Math.abs(Math.tan(camera.fov / 2)) : (size.y / 2 + offset) / Math.abs(Math.tan(camera.fov / 2)) / camera.aspect;
  camera.position.set(camera.position.x * endDistance / startDistance, camera.position.y * endDistance / startDistance, camera.position.z * endDistance / startDistance);
  camera.lookAt(center);
}
function resizeRendererToDisplaySize(renderer) {
  var canvas = renderer.domElement;
  var width = canvas.clientWidth;
  var height = canvas.clientHeight;
  var needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
function intersectPoint(planeTag) {
  try {
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length !== 0) {
      intersects = intersects.filter(function (item) {
        return item.object.Tag !== undefined && item.object.Tag === planeTag;
      });
    }
    if (intersects.length !== 0) {
      return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.round(intersects[0].point.x * 1000) / 1000, Math.round(intersects[0].point.y * 1000) / 1000, Math.round(intersects[0].point.z * 1000) / 1000);
    } else {
      return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);
    }
  } catch (e) {
    console.log(e);
  }
  return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
}
function topPlotPlanIntersectPosition(event) {
  try {
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length != 0) {
      // filter intersect of plotplans
      intersects = intersects.filter(function (item) {
        return item.object.Tag != undefined && item.object.Tag.includes("plotplan");
      });
      // if intersect is plot plan choose the next non plotplan item
      if (intersects.length > 0) {
        //console.log(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);
        return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.round(intersects[0].point.x * 1000) / 1000, Math.round(intersects[0].point.y * 1000) / 1000, Math.round(intersects[0].point.z * 1000) / 1000);
      }
    }
  } catch (e) {
    console.log(e);
  }
  return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
}
function topObjectIntersectPosition(event) {
  try {
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length != 0) {
      if (intersects.length > 0) {
        return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.round(intersects[0].point.x * 1000) / 1000, Math.round(intersects[0].point.y * 1000) / 1000, Math.round(intersects[0].point.z * 1000) / 1000);
      }
    }
  } catch (e) {
    console.log(e);
  }
}
function loadPlotPlanNotUsed(userImageFile, scaleX, scaleY, centreX, centreY, elevation, opacity) {
  //online pdf to png converter: https://pdf2png.com
  //online image editor: https://www.online-image-editor.com
  // remove if there is any existing plot
  //

  if (userImageFile === undefined) {
    alert("Select the plot plan background image.");
    light;
    return;
  }
  // Create an image
  var image = new Image(); // or document.createElement('img' );
  // Set image source
  image.src = userImageFile;
  image.onload = function () {
    texture.needsUpdate = true;
  };
  var texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(image);
  var plotPlanOpacity = opacity;
  var planeMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    map: texture,
    color: 0xa0a0a0,
    transparent: true,
    opacity: plotPlanOpacity,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
    flatShading: true
  });

  // plane geometry
  var planeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(rendererWidth, rendererHeight);
  planeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(planeGeometry, planeMaterial);
  planeMesh.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), elevation);
  scene.add(planeMesh);
  planeMesh.name = "plotplan"; // main background any additional plane to be added to this main background
  var planeMeshCount = getObjectByNameArray(scene, 'plotplan').length;
  planeMesh.Tag = "plotplan" + planeMeshCount; //toString();

  scalePlotPlan(scaleX, scaleY);
  centrePlotPlan(centreX, centreY, elevation);
  shadowRing(0, 0, plotElevtn + 0.01); // to shadow mouse movement when ctrl key is pressed

  renderer.render(scene, camera);
  return false;
}
function getObjectByNameArray(parentObject, childObjectName) {
  var match = [];
  parentObject.traverse(function (child) {
    if (child.name === childObjectName) {
      match.push(child);
    }
  });
  return match;
}
function scalePlotPlanNotUsed(scaleX, scaleY) {
  // scale the plane
  if (scaleX !== undefined && scaleY !== undefined) {
    if (scaleX !== 0 && scaleY !== 0) {
      planeMesh.scale.set(scaleX, scaleY, 1);
      planeMesh.updateMatrixWorld();
      scene.getObjectByName('shadowRing');
      while (scene.getObjectByName('clickedPoints')) {
        scene.remove(scene.getObjectByName('clickedPoints'));
      }
      orthoCamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);
      renderer.render(scene, orthoCamera);
    }
  }
}
function clearRefPoints() {
  while (scene.getObjectByName('refPoint')) {
    scene.remove(scene.getObjectByName('refPoint'));
  }
  renderer.render(scene, camera);
  refPoints = [];
}
function showHideShadowRingNPosinLines() {
  if (scene.getObjectByName('shadowRing') && scene.getObjectByName('positionlinex') && scene.getObjectByName('positionliney')) {
    if (ctrlKeyPressed) {
      scene.getObjectByName('shadowRing').visible = true;
      scene.getObjectByName('positionlinex').visible = true;
      scene.getObjectByName('positionliney').visible = true;
    } else {
      scene.getObjectByName('shadowRing').visible = false;
      scene.getObjectByName('positionlinex').visible = false;
      scene.getObjectByName('positionliney').visible = false;
    }
    render();
  }
}
function shadowRing(x, y, z) {
  var shadowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    color: 0xc3c383,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
  });
  var shadowRing = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.4, 0.5, 20), shadowRingMaterial);

  //shadowRing.name = str == "" ? 'shadowRing' : str;
  shadowRing.name = 'shadowRing';
  shadowRing.position.set(y, x, z + 0.01);
  //scene.getObjectByName('plotplan').add(shadowRing)
  scene.add(shadowRing);
  render();
}
function hideObject() {
  selectedObject.forEach(function (el) {
    el.visible = false;
  });
  render();
}
function resetObject() {
  selectedObject.forEach(function (el) {
    el.visible = true;
    el.material.color = el.OriginalColor;
  });
  //clear selectedObject array
  selectedObject.length = 0;
  render();
}
function commonAction(event) {
  if (window.event.shiftKey && (window.event.key == 'h' || window.event.key == 'H')) {
    hideObject();
  }
  if (window.event.key === "Escape") {
    resetObject();
  }
}
var mouseWheelStatus = false;
var hideObjectTypesOnScrolling = ["rawladder", "ladder", "bend", "tee", "cross", "node", "sleeve", "equipment"];
var raycastObjectTypes = ["rawladder", "ladder", "bend", "tee", "cross", "node", "sleeve", "board", "cable"];
function mouseWheel() {
  if (!mouseWheelStatus) {
    scene.traverse(function (child) {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {
        if (hideObjectTypesOnScrolling.includes(child.type)) {
          child.visible = false;
        }
      }
    });
    //console.log("mouseWheel");
    mouseWheelStatus = true;
  }
}
function createWheelStopListener(element, callback, timeout) {
  var handle = null;
  var onScroll = function onScroll() {
    if (handle) {
      clearTimeout(handle);
    }
    handle = setTimeout(callback, timeout || 200); // default 200 ms
  };
  element.addEventListener('wheel', onScroll);
  return function () {
    element.removeEventListener('wheel', onScroll);
  };
}
function doAfterEndScrol() {
  if (mouseWheelStatus) {
    scene.traverse(function (child) {
      if (child instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {
        if (hideObjectTypesOnScrolling.includes(child.type)) {
          child.visible = true;
        }
      }
    });
    //console.log("scroll end");
    mouseWheelStatus = false;
  }
}

//let isClicked = false;
//function mouseClick() {
//    console.log('click');
//    isClicked = true;
//}
//function mouseMove(e) {
//    if (isClicked) {
//        console.log('clicked and draged')
//    } else {
//        console.log('drag');
//        isClicked = false;
//    }
//}

function raycastNotUsed(event) {
  // clicked event
  var _findCoordinate5 = findCoordinate(event);
  var _findCoordinate6 = _slicedToArray(_findCoordinate5, 2);
  mouse = _findCoordinate6[0];
  pos = _findCoordinate6[1];
  var linePosition = topPlotPlanIntersectPosition(event);
  var objectPosition = topObjectIntersectPosition(event);
  if (linePosition == undefined) {
    linePosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  }
  console.log("MouseClick2", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
  //DotNet.invokeMethodAsync(projectName, "UpdateLayout3DMousePosition", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
  dotNetObj.invokeMethodAsync("MouseClick2", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
  if (!event.ctrlKey && !event.shiftKey) {
    castObject(event);
  }
  //
  try {
    if (event.ctrlKey && !event.shiftKey) {
      // if ctrl key is not pressed, the raycast selects a point

      drawRefPoint(planeName);
      console.log();
      console.log("Mouse posion : " + "Mouse: [" + mouse.x + ", " + mouse.y + "] " + "Position:[" + pos.x + "," + pos.y + "] " + "Client: [" + event.clientX + "," + event.clientY + "] " + "Screen:[" + event.screenX + "," + event.screenY + "] " + "Page:[" + event.pageX + "," + event.pageY + "] " + "Offset:[" + event.offsetX + "," + event.offsetY + "] " + "Layer:[" + event.layerX + "," + event.layerY + "] " + "EvenXY:[" + event.x + "," + event.y + "] " + "LinePosition :[" + linePosition.x, linePosition.y, linePosition.z + "] ");
      pos.z = plotElevtn + 0.01; // plotplan elevation as default clicked coordinate elevation, .01 to make visible
      //
      var groupredRing = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
      var redRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
        color: 0xff0000,
        side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
      });
      var yellowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
        color: 0xffff00,
        side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
      });
      var redCircleGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.CircleGeometry(0.1, 10);
      var redCircle = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redCircleGeometry, redRingMaterial);
      groupredRing.add(redCircle);
      var redRingGeometryIn = new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.1, 0.3, 20);
      var redRingMeshIn = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redRingGeometryIn, yellowRingMaterial);
      groupredRing.add(redRingMeshIn);
      var redRingGeometryOut = new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.3, 0.35, 20);
      var redRingMeshOut = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redRingGeometryOut, redRingMaterial);
      groupredRing.add(redRingMeshOut);
      //groupredRing.scale(0.5, 0.5, 0.5);
      clickedPointSeq.push("clickedPoint" + clickedPointSeq.length);
      groupredRing.name = clickedPointSeq[clickedPointSeq.length - 1];
      groupredRing.name = 'clickedPoints';
      groupredRing.position.set(linePosition.x, linePosition.y, linePosition.z);
      //clickedPointsGroup.add(groupredRing);
      scene.add(groupredRing);
      // storing clicked coordinates for adding segment
      clickCoordinate.push([linePosition.x, linePosition.y, linePosition.z]);
      //DotNet.invokeMethodAsync(projectName, "UpdateLayout3DScale", pos.x, pos.y, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
      dotNetObj.invokeMethodAsync("MouseClick", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);
      render();
    }
  } catch (e) {
    console.log(e);
  }
  //
}

//

function findCoordinate(event) {
  // calculate mouse position in normalized device coordinates (-1 to +1) for both components
  var rect = event.target.getBoundingClientRect();
  var mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
  var x = event.clientX - rect.left; //x position within the element.
  var y = event.clientY - rect.top; //y position within the element.
  mouse.x = x / rendererWidth * 2 - 1;
  mouse.y = -(y / rendererHeight) * 2 + 1;
  //
  var vec = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // create once and reuse
  var pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // create once and reuse
  //
  vec.set((event.clientX - rect.left) / rendererWidth * 2 - 1, -((event.clientY - rect.top) / rendererHeight) * 2 + 1, 0);
  vec.unproject(camera);
  vec.sub(camera.position).normalize();
  var distance = -camera.position.z / vec.z;
  pos.copy(camera.position).add(vec.multiplyScalar(distance));
  // rounding to two decimal
  pos.x = Math.round(pos.x * 100) / 100;
  pos.y = Math.round(pos.y * 100) / 100;
  return [mouse, pos];
}
window.invokeDotnetStaticFunction = window.invokeDotnetStaticFunction || function () {
  DotNet.invokeMethodAsync('BlazorJSDemoUI', 'CalculateLadderPoints').then(function (data) {
    return data;
  });
};
window.giveMerandomInt = window.giveMerandomInt || function (n) {
  DotNet.invokeMethodAsync(projectName, 'GenerateRandomInt', n).then(function (result) {
    document.getElementById('randomNumberSpan').innerText = result;
  });
};

//

// window.drawLadder = function (tag, type, jsonPoints, opacity, color) {
//     let start = Date.now();
//     if (!canvas) {
//         return;
//     }
//     try {
//         var clr = JSON.parse(color);
//         var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
//         var points = JSON.parse(jsonPoints);
//         var vertices1 = [];
//         var pushorder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];
//         pushorder.forEach(i => {
//             vertices1.push(new THREE.Vector3(points[i].X, points[i].Y, points[i].Z));
//         });
//         var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);
//
//         //for wireframe
//         const wireframe = new THREE.WireframeGeometry(pointsGeometry);
//         const line = new THREE.LineSegments(wireframe);
//         line.material.depthTest = false;
//         line.material.opacity = 0.5;
//         line.material.transparent = true;
//         var wireFrameColor = new THREE.Color(0, 0, 1);
//         line.material.color = setColor;
//         //scene.add(line);
//
//         //for solid display
//         var material = new THREE.MeshPhongMaterial({
//             color: setColor,
//             transparent: true,
//             opacity: opacity,
//             side: THREE.DoubleSide,
//             flatShading: true,
//             clippingPlanes: [localPlane],
//             clipShadows: true
//         });
//         laddermaterial.color = setColor;
//         var ladderMesh = new THREE.Mesh(pointsGeometry, material);
//         ladderMesh.type = type; // "ladder" or "rawladder"
//         //mesh.material.color.set(setColor);
//         //mesh.material.opacity = opacity;
//         //var cx = (points[1].X + points[6].X) / 2;
//         //var cy = (points[1].Y + points[6].Y) / 2;
//         //var cz = (points[1].Z + points[6].Z) / 2;
//         ladderMesh.Tag = tag;
//         ladderMesh.Clicked = false;
//         ladderMesh.OriginalColor = ladderMesh.material.color;
//         //let box = new THREE.Box3().setFromObject(ladderMesh);
//         //let sphere = box.getBoundingSphere();
//         //let centerPoint = box.getCenter();
//         //let centerPoint = sphere.center;
//         //ladderMesh.updateMatrixWorld();
//         //ladderMesh.position.set(cx, cy, cz);
//         var mesh = ladderMesh;
//         var center = new THREE.Vector3();
//         mesh.geometry.computeBoundingBox();
//         mesh.geometry.boundingBox.getCenter(center);
//         mesh.geometry.center();
//         mesh.position.copy(center);
//         //doAddScene(ladderMesh, animationText, progress, start, drawLadderCallback);
//         scene.add(ladderMesh);
//         //render();
//         pointsGeometry.dispose();
//     } catch (e) {
//         console.log(tag + e);
//     }
//     //
//     //if (animationText != "") {
//     //    var progress = parseInt(animationText);
//     //    DotNet.invokeMethodAsync('WslEncompass', "SegmentPageUpdateLadderProgress", progress);
//     //}
//     //DotNet.invokeMethodAsync(projectName, "ItemDrawn", tag);
//     return tag;
// }
var requestID;
function doAddScene(meshObject, animationText, progress, start, callback) {
  scene.add(meshObject);
  var timeTaken = Date.now() - start;
  console.log("Total time taken for " + meshObject.Tag + " : " + timeTaken + " milliseconds");
  callback(animationText, progress);
}

//function drawLadderCallback(animationText, progress) {

//    if (animationText == "first") {
//        cancelAnimationFrame(requestID);
//        console.log("cancelleing animation");
//    } else if (animationText == "last") {
//        animate();
//        console.log("reverting animation");
//    } else if (animationText == "progress") {
//        DotNet.invokeMethodAsync('WslEncompass', 'UpdateProgressLayoutComponent', progress);
//        console.log("show progress animation : " + progress);
//    };
//}

window.drawBendNotUsed = function (tag, jsonFacePoints, opacity, color) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var faces = JSON.parse(jsonFacePoints);
  var vertices1 = [];
  faces.forEach(function (face) {
    face.forEach(function (pt) {
      vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
    });
  });
  try {
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    pointsGeometry.computeBoundingSphere();
    if (isNaN(pointsGeometry.boundingSphere.radius)) {
      geometry.boundingSphere.radius = 1; // Set a default value or any suitable value
    }
    var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
      color: setColor,
      transparent: true,
      opacity: opacity,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      flatShading: true,
      clippingPlanes: [localPlane],
      clipShadows: true
    });
    var bendMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    bendMesh.Tag = tag;
    bendMesh.Clicked = false;
    bendMesh.OriginalColor = bendMesh.material.color;
    bendMesh.Type = "bend";
    var mesh = bendMesh;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    mesh.geometry.computeBoundingBox();
    mesh.geometry.boundingBox.getCenter(center);
    mesh.geometry.center();
    mesh.position.copy(center);
    scene.add(bendMesh);
    pointsGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  //
  return tag;
};
window.drawTeeNotUsed = function (tag, jsonFacePoints, opacity, color) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var faces = JSON.parse(jsonFacePoints);
  var vertices1 = [];
  faces.forEach(function (face) {
    face.forEach(function (pt) {
      vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
    });
  });
  try {
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
      color: setColor,
      transparent: true,
      opacity: opacity,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      flatShading: true,
      clippingPlanes: [localPlane],
      clipShadows: true
    });
    var teeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    teeMesh.Tag = tag;
    teeMesh.Clicked = false;
    teeMesh.OriginalColor = teeMesh.material.color;
    teeMesh.Type = "tee";
    var mesh = teeMesh;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    mesh.geometry.computeBoundingBox();
    mesh.geometry.boundingBox.getCenter(center);
    mesh.geometry.center();
    mesh.position.copy(center);
    scene.add(teeMesh);
    pointsGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  //
  //DotNet.invokeMethodAsync(projectName, "ItemDrawn", tag);
  return tag;
};
window.drawCrossNotUsed = function (tag, jsonFacePoints, opacity, color) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var faces = JSON.parse(jsonFacePoints);
  var vertices1 = [];
  faces.forEach(function (face) {
    face.forEach(function (pt) {
      vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
    });
  });
  try {
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
      color: setColor,
      transparent: true,
      opacity: opacity,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      flatShading: true,
      clippingPlanes: [localPlane],
      clipShadows: true
    });
    var crossMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    crossMesh.Tag = tag;
    crossMesh.Clicked = false;
    crossMesh.OriginalColor = crossMesh.material.color;
    crossMesh.Type = "cross";
    var mesh = crossMesh;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    mesh.geometry.computeBoundingBox();
    mesh.geometry.boundingBox.getCenter(center);
    mesh.geometry.center();
    mesh.position.copy(center);
    scene.add(crossMesh);
    pointsGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  //
  return tag;
};
window.drawSleeveNotUsed = function (tag, radious, jsonPoints, opacity, color) {
  opacity = 1;
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var rawPoints = JSON.parse(jsonPoints);
  //const segment = 20;
  //const radialSegments = 8;
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
    color: 0x00ff00
  });
  var points = [];
  rawPoints.forEach(function (p) {
    points.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(p.X, p.Y, p.Z));
  });
  try {
    var curve = new three__WEBPACK_IMPORTED_MODULE_0__.CatmullRomCurve3(points);
    var tubeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.TubeGeometry(curve, 20, radious, 8, false);
    var tube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(tubeGeometry, material);
    tube.Type = "sleeve";
    tube.Tag = tag;
    tube.Clicked = false;
    tube.OriginalColor = tube.material.color;
    //tube.name = "CB" + icable;
    //cableData[icable][11] = cableData[icable][11] + curve.getLength();//cable total length
    //cableLaid.add( tube );
    scene.add(tube);
  } catch (e) {
    console.log(tag + e);
  }
  var pp = curve.getPoints(20);
  var pps = [];
  pp.forEach(function (p) {
    pps.push([p.x, p.y, p.z]);
  });
  return [tag, pps.toString()];
};
function _drawCable(tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option, percent) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var pointSetSegments = JSON.parse(jsonPointSetSegments);
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    color: setColor,
    transparent: true,
    opacity: opacity,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
    flatShading: true,
    clippingPlanes: [localPlane],
    clipShadows: true
  });
  for (var i = 0; i < pointSetSegments.length; i = i + 4) {
    var ptFrom = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pointSetSegments[i].X, pointSetSegments[i].Y, pointSetSegments[i].Z);
    var v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pointSetSegments[i + 1].X, pointSetSegments[i + 1].Y, pointSetSegments[i + 1].Z);
    var v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pointSetSegments[i + 2].X, pointSetSegments[i + 2].Y, pointSetSegments[i + 2].Z);
    var ptTo = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pointSetSegments[i + 3].X, pointSetSegments[i + 3].Y, pointSetSegments[i + 3].Z);
    if (v1.x == 0 & v1.y == 0 && v1.z == 0 && v2.x == 0 & v2.y == 0 && v2.z == 0 || option != "curve") {
      // case straight section
      var curve = new three__WEBPACK_IMPORTED_MODULE_0__.LineCurve(ptFrom, ptTo);
    } else {
      //case bend
      var curve = new three__WEBPACK_IMPORTED_MODULE_0__.CubicBezierCurve3(ptFrom, v1, v2, ptTo);
    }
    var tubeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.TubeGeometry(curve, tubeTubularSegments, dia / 2, tubeRadialSegments, false);
    var tube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(tubeGeometry, material);
    //const wireframe = new THREE.WireframeGeometry(tubeGeometry);
    //const tube = new THREE.LineSegments(wireframe)
    tube.Tag = tag;
    tube.Type = "cable";
    scene.add(tube);
    tubeGeometry.dispose();
    if (percent == 1) {
      tube.onAfterRender = function () {
        console.log("last cable drawn");
      };
    }
  }

  // return curve.getLength();//cable total length
  //
}
window.drawCableFromRoute = function (tag, jsonPoints, tubeTubularSegments, dia, tubeRadialSegments, opacity, color) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var pts = JSON.parse(jsonPoints);
  if (pts.length == 0) {
    return;
  }
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    color: setColor,
    transparent: true,
    opacity: opacity,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
    flatShading: true,
    clippingPlanes: [localPlane],
    clipShadows: true
  });
  try {
    // Create an array of points
    var points = [];
    pts.forEach(function (pt) {
      return points.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
    });

    // Create a Catmull-Rom curve
    //var spline = new THREE.Curve3(points);

    // Define the radius of the tube
    var radius = dia / 2;

    // Define the number of radial segments
    var radialSegments = tubeTubularSegments;

    //// Define the number of tubular segments
    //var tubularSegments = tubeTubularSegments;

    //// Set closed to true if you want the tube to be closed
    //var closed = false;

    //// Create the tube geometry
    //var geometry = new THREE.TubeGeometry(spline, points.length, radius, radialSegments, closed);

    //// Create a material
    ////var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

    //// Create the tube mesh
    //var tubeMesh = new THREE.Mesh(geometry, material);

    //// Add the tube to the scene
    //tubeMesh.Tag = tag;
    //tubeMesh.type = "cable";
    //scene.add(tubeMesh);
    //geometry.dispose();

    // Create an array to hold vertices and faces
    var vertices = [];
    var indices = [];

    // Iterate over each pair of consecutive points
    for (var i = 0; i < points.length - 1; i++) {
      var start = points[i];
      var end = points[i + 1];

      // Compute the direction vector between the points
      var direction = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(end, start).normalize();

      // Compute the tangent vector (perpendicular to the direction)
      var tangent = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(direction, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)).normalize();

      // Compute the binormal vector (perpendicular to both direction and tangent)
      var binormal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(direction, tangent).normalize();

      // Compute vertices for the pipe section
      var theta = Math.PI * 2 / radialSegments;
      for (var j = 0; j <= radialSegments; j++) {
        var segment = tangent.clone().multiplyScalar(Math.cos(theta * j) * radius).add(binormal.clone().multiplyScalar(Math.sin(theta * j) * radius));
        vertices.push(start.clone().add(segment));
      }
    }

    // Generate indices for faces
    for (var i = 0; i < points.length - 1; i++) {
      for (var j = 0; j < radialSegments; j++) {
        var v0 = i * (radialSegments + 1) + j;
        var v1 = v0 + 1;
        var v2 = (i + 1) * (radialSegments + 1) + j;
        var v3 = v2 + 1;
        indices.push(v0, v1, v2);
        indices.push(v1, v3, v2);
      }
    }

    // Create a geometry
    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.setFromPoints(vertices);
    geometry.setIndex(indices);

    // Create a material
    var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
      color: 0xff0000
    });

    // Create the pipe mesh
    var pipeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
    pipeMesh.Tag = tag;
    pipeMesh.Type = "cable";
    // Add the pipe to the scene
    scene.add(pipeMesh);
  } catch (e) {
    console.log(tag + e);
  }

  //
  return tag;
};
window.drawNodeNotUsed = function (tag, jsonPoint, color) {
  if (!canvas) {
    return;
  }
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var nodePoint = JSON.parse(jsonPoint);
  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.03, 5, 5); // radious, widthsegment, heightsegments
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    color: setColor,
    transparent: true,
    opacity: 0.5,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
    flatShading: true,
    clippingPlanes: [localPlane],
    clipShadows: true
  });
  var sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
  sphere.position.set(nodePoint.X, nodePoint.Y, nodePoint.Z);
  //sphere.translate(new THREE.Vector3(nodePoint.X, nodePoint.Y, nodePoint.Z));
  sphere.Type = "node";
  scene.add(sphere);
  sphere.Tag = tag;
  sphere.Clicked = false;
  sphere.OriginalColor = sphere.material.color;
  geometry.dispose();
  //
  return tag;
};
function equipmentNotUsed(tag, x, y, z, w, d, h, a, color, opacity, colortext) {
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  var clrT = JSON.parse(colortext);
  var textColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clrT[0] / 255, clrT[1] / 255, clrT[2] / 255);
  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(w, d, h); // l along x-axis, w along y axis, d along z axis
  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
    color: setColor,
    transparent: true,
    opacity: opacity,
    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
    flatShading: true,
    clippingPlanes: [localPlane],
    clipShadows: true
  });
  var cube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
  //
  // Point P -> x1, y1, z1
  // Point Q -> x2, y2, z2
  // Vector  PQ' is the projection of vector PQ on x-y plane
  // vector along the width PW = cross of Z axis vector and PQ'
  // vector along depth PD = PW cross PQ'
  //
  //var tempv1 = new THREE.Vector3(0, 0, 0);
  //var tempv2 = new THREE.Vector3(0, 0, 0);
  //var tempv3 = new THREE.Vector3(0, 0, 0);
  //var tempv4 = new THREE.Vector3(0, 0, 0);
  //tempv1.set(x2 - x1, y2 - y1, z2 - z1); // pQ
  //tempv2.set(x2 - x1, y2 - y1, 0); //PQ'
  //tempv3.set(0, 0, 1); // Z axis
  //tempv4 = tempv2.clone().cross(tempv3); // PW
  //cube.rotateOnAxis(tempv3, Math.atan((y2 - y1) / (x2 - x1)));  // rotate cube at x-y plane , own axis and world axis is same
  //cube.rotateOnWorldAxis(tempv4.normalize(), tempv1.angleTo(tempv2));  // rotate along width world axis
  //cube.position.x = (x1 + x2) / 2; cube.position.y = (y1 + y2) / 2; cube.position.z = (z1 + z2) / 2; // position
  //const fontSize = 0.8 * Math.min(1, Math.max(w, d) / tag.length);

  var fontSize = 0.3 * Math.min(w, d, 1);
  if (tag.length * fontSize > Math.max(w, d)) {
    fontSize = Math.max(w, d) / tag.length;
  }
  var fontHeight = fontSize / 5; // Thickness to extrude text
  //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }
  //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }
  loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
    // Create the text geometry
    var textGeometry = new three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__.TextGeometry(tag, {
      font: font,
      height: fontHeight,
      size: fontSize,
      color: '#5C4033'
      //, curveSegments: 32,
      //bevelEnabled: true,
      //bevelThickness: 0.5,
      //bevelSize: 0.5,
      //bevelSegments: 8,
    });
    // Geometries are attached to meshes so that they get rendered
    var textMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(textGeometry, textMaterial);
    textMesh.geometry.center();
    // Update positioning of the text
    textMesh.position.set(0, 0, h / 2);
    textMesh.rotateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), Math.PI * (-1 + w < d ? 1 / 2 : 0));
    cube.add(textMesh);
  });
  cube.rotateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), a);
  cube.position.set(x, y, z);
  cube.updateMatrixWorld();
  cube.OriginalColor = cube.material.color;
  cube.Tag = tag;
  cube.Type = "equipment";
  cube.Clicked = false;
  scene.add(cube);
  geometry.dispose();
  //
}
function _drawBoard(tagName, jsonPoint, v, w, d, h, angle, color, opacity) {
  if (!canvas) {
    return;
  }
  //tagName, jsonPoints, v, w, d, h, angle, JsonConvert.SerializeObject(color), opacity
  var Point = JSON.parse(jsonPoint);
  var clr = JSON.parse(color);
  var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
  // text label orientation
  // label on 'front' means, the text on 'xz' plane along x axis. 
  // label on 'top' means xy plane along y axis
  var writePlane = 'xz'; // default 'front'
  var textcolor = 0x1000000 - defaultColorEq; // tag label of the equipment with invert colour
  //draw each vertical
  for (var i = 0; i < v; i++) {
    //ith vertical
    var x = -w / 2 + (i + 1 / 2) * w / v;
    var y = d / 2;
    var z = h / 2;
    var drawEdge = true;
    var drawMesh = true;
    // draw each verticals
    functionVertical(x, y, z, w / v, d, h, defaultColorEq, opacity, drawEdge, drawMesh);
    // add label for each verticals on front
    if (v != 1 && writeLabelText) {
      // writing the label
      var labelText = 'PNL#' + (i + 1).toString();
      var textSize = 0.1;
      // coordinate of the text
      // text width is assumed as 40% of text height
      var labelCoordinate = [x - textSize * labelText.length * 0.4, y - d / 2 - 0.001, z];
      //
      //writeLabel(labelText, textSize, labelCoordinate, textcolor, groupEq);
      //
    }
  }
  var writeLabelText = true;
  //adding tag label of the equipment
  if (writeLabelText) {
    var textSize = 0.2;
    // if switchgears (multiple verticals) write in front, else for pumps, compressors, etc., write on top
    if (v != 1) {
      // switchgear
      var textCoordinate = [-w / 2 + textSize, -0.001, z + h / 2 - 2 * textSize];
    } else {
      // other equipment like pump, etc.
      writePlane = 'xy';
      var textCoordinate = [textSize / 2, d / 2 - textSize * tagName.length * 0.4, h + 0.005];
    }
    //writeLabel(tagName, textSize, textCoordinate, textcolor);
  }
  //
  // rotating the equipment as per the face direction
  // and positioning the panel at the required coordinates
  //tempv1.set(Point.X, Point.Y, Point.Z);
  //tempv1.sub((tempv2.normalize()).multiplyScalar(d / 2));
  //groupEq.rotateZ(angle * Math.PI / 180);
  //groupEq.position.set(tempv1.x, tempv1.y, tempv1.z);
  //groupEq.lookAt(tempv2); // not used
  //
  //cube.Clicked = false;
  //cube.OriginalColor = cube.material.color;
  //crossMesh.type = "board";
}

//

// function for Single Vertical Panel
function functionVertical(x, y, z, w, d, h, colr, opec, drawEdge, drawMesh) {
  // equipment is drawn facing -y axis, i.e., from South
  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(w, d, h);
  // drawing mesh
  if (drawMesh) {
    var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();
    material.clone(equipmentmaterial);
    var cube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
    cube.position.x = x;
    cube.position.y = y;
    cube.position.z = z;
    cube.material.color.setHex(colr);
    cube.material.opacity = opec;
    //scene.add(cube);
  }
  //
  //drawing outerline/edge
  if (drawEdge) {
    var edges = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(geometry);
    var line = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(edges);
    line.material.depthTest = false;
    line.material.opacity = 0.1;
    line.material.transparent = true;
    line.position.set(x, y, z);
    var color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0x000ff);
    line.material.color = color;
    scene.add(line);
  }
  geometry.dispose();
}
function _searchItem(tag) {
  var selectedObject = scene.children.filter(function (child) {
    return child.Tag && child.Tag.includes(tag);
  });
  if (selectedObject[0] != undefined) {
    for (var i = 0; i < selectedObject.length; i++) {
      selectedObject[i].material.color = selectItemColor.color;
    }
    camera.lookAt(selectedObject[0].position);
    controls.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(selectedObject[0].position.x, selectedObject[0].position.y, selectedObject[0].position.z);
    //controls.minDistance = 5;
    //controls.maxDistance = 20;
    //controls.update();
    //camera.zoom = 100;
    animate();
  }
}
function _hidePlotPlan(hidePP) {
  //var selectedObject = scene.children.filter(child => child.Tag.includes("plotplan"));
  scene.children.forEach(function (child) {
    if (child != undefined) {
      if (child.Tag != undefined) {
        if (child.Tag.includes("plotplan")) {
          child.visible = hidePP;
        }
      }
    }
  });
  animate();
}
function _orthoView(ortho, xp, yp, zp) {
  //orthographic camera view;
  //https://stackoverflow.com/questions/48758959/what-is-required-to-convert-threejs-perspective-camera-to-orthographic
  //https://www.google.ae/search?q=threejs+camera&sca_esv=562123659&tbm=vid&sxsrf=AB5stBih_AvvkPKwAIYnui6TpwA4RL21aA:1693635801552&source=lnms&sa=X&ved=2ahUKEwjtgdKCpYuBAxVhRKQEHQ7fAMwQ_AUoA3oECAEQBQ&biw=1727&bih=1076&dpr=1.5#fpstate=ive&vld=cid:af7537a2,vid:FwcXultcBl4
  //https://sbcode.net/view_source/section.html
  //
  if (ortho == true) {
    var v3_object = scene.children.filter(function (child) {
      return child.hasOwnProperty('Tag') && child.Tag.includes("plotplan");
    })[0];
    if (v3_object == undefined) return;
    var v3_camera = cameraPerspective.position;
    var line_of_sight = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    cameraPerspective.getWorldDirection(line_of_sight);
    //var v3_object_position = v3_object.position;
    var v3_object_position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(v3_object.position.x, v3_object.position.y, v3_object.position.z);
    var v3_distance = v3_object_position.sub(v3_camera);
    //var v3_distance = (v3_object.clone()).sub(v3_camera);
    var depth = v3_distance.dot(line_of_sight);
    var fov_y = cameraPerspective.fov;
    var height_ortho = depth * 2 * Math.atan(fov_y * (Math.PI / 180) / 2);
    //var aspect = width / height;
    var width_ortho = height_ortho * cameraPerspective.aspect;
    //var width_ortho = height_ortho * aspect;

    var neworthoCamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(width_ortho / -2, width_ortho / 2, height_ortho / 2, height_ortho / -2, cameraPerspective.near, cameraPerspective.far);
    neworthoCamera.name = 'orthoCamera';
    neworthoCamera.lookAt(v3_object_position);
    neworthoCamera.position.set(xp, yp, zp);
    neworthoCamera.updateProjectionMatrix();
    //neworthoCamera.quaternion.copy(cameraPerspective.quaternion);
    camera = neworthoCamera;
  } else {
    camera = cameraPerspective;
    scene.remove(scene.getObjectByName('orthoCamera'));
    renderer.render(scene, camera);
  }
  //animate(); // animate includes render
  renderer.render(scene, camera);
}
function _removeItem(tag) {
  var selectedObject = scene.children.filter(function (child) {
    return child.Tag == tag;
  });
  if (selectedObject != undefined) {
    scene.remove(selectedObject);
    animate();
  }
}
function writeLabel(labelText, textSize, labelCoordinate, textcolor) {
  // write label facing -y axis at the given coordinate
  var loader = new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_2__.FontLoader();
  //loader.load('..fonts/helvetiker_regular.typeface.json', function (font) {
  //    //helvetiker_regular
  //    //gentilis_regular.typeface
  //    //const color = 0xffff00;
  //    const textMaterial = new THREE.MeshBasicMaterial({
  //        color: textcolor,
  //        transparent: true,
  //        opacity: 0.9,
  //        side: THREE.DoubleSide
  //    });
  //    const shapes = font.generateShapes(labelText, textSize);
  //    const textGeometry = new THREE.ShapeBufferGeometry(shapes);
  //    const text = new THREE.Mesh(textGeometry, textMaterial);
  //    text.position.set(labelCoordinate[0], labelCoordinate[1], labelCoordinate[2]);
  //    scene.add(text);
  //    textGeometry.dispose();
  //    render();
  //});
}
function castObject(event) {
  // select an object by clicking it 
  // if ctrl key is not pressed, the raycast selects or deselects the object (cable, ladeder, etc.)
  // find intersections
  //2. set the picking ray from the camera position and mouse coordinates

  try {
    raycaster.setFromCamera(mouse, camera);
    //
    //3. compute intersections (no 2nd parameter true anymore)
    var intersects = raycaster.intersectObjects(scene.children);
    // remove hidden items from intersects if raycasted: not required as its covered in below while loop
    //var intersects = intersectstemp.filter(function (val) {
    //        return selectedObject.indexOf(val) == -1;
    //    });
    if (intersects.length == 0) return;
    if (!(intersects[0].object.Tag == undefined)) {
      var intersectItemIndex = 0;
      // if intersect is plot plan choose the next non plotplan item
      intersects = intersects.filter(function (item) {
        return !item.object.Tag.includes("plotplan");
      });
      if (intersects.length == 0) return; // no object other than plotplan
      while (intersects[intersectItemIndex].object.visible == false && intersectItemIndex < intersects.length) {
        intersectItemIndex++;
      }
      var castObjectTags = [];
      var castObjectUIDs = [];
      if (intersects.length > 0) {
        controls.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(intersects[0].object.position.x, intersects[0].object.position.y, intersects[0].object.position.z);
        if (selectedObject.includes(intersects[intersectItemIndex].object)) {
          var indx = selectedObject.indexOf(intersects[intersectItemIndex].object);
          selectedObject.splice(indx, 1);
        } else {
          selectedObject.push(intersects[intersectItemIndex].object);
        }
        intersects.forEach(function (el) {
          if (el.object.Tag != undefined) {
            castObjectTags.push(el.object.Tag);
            castObjectUIDs.push(el.object.UID == undefined ? newGuid() : el.object.UID);
          }
        });
        if (intersects[intersectItemIndex].object.Clicked) {
          intersects[intersectItemIndex].object.material.color = intersects[intersectItemIndex].object.OriginalColor;
        } else {
          intersects[intersectItemIndex].object.material.color = selectItemColor.color;
        }
        intersects[intersectItemIndex].object.Clicked = !intersects[intersectItemIndex].object.Clicked;
        //
        var castObjects = intersects.filter(function (item) {
          return item.object.visible == true;
        });
        var castObjectHidden = intersects[0];
        var casObjectTag = "";
        //
        var x = 0,
          y = 0,
          z = 0,
          xh = castObjectHidden.object.position.x,
          yh = castObjectHidden.object.position.y,
          zh = castObjectHidden.object.position.z;
        if (castObjects.length > 0) {
          casObjectTag = castObjects[0].object.Tag;
          x = castObjects[0].object.position.x;
          y = castObjects[0].object.position.y;
          z = castObjects[0].object.position.z;
        }
        DotNet.invokeMethodAsync(projectName, "UpdateCastObject", JSON.stringify(castObjectUIDs), JSON.stringify(castObjectTags), casObjectTag, x, y, z, castObjectHidden.object.Tag, xh, yh, zh);
      }
    }
  } catch (e) {
    console.log(e);
  }
}
window.selectObjectHighlight = function (tag) {
  var selectObject = scene.children.filter(function (child) {
    return child.Tag == tag;
  });
  var returnColour = selectObject.mesh.color;
  return returnColour;
};
function _toggleFunction() {
  var toggle = document.getElementById("layoutPage3dSegment");
  if (toggle.style.display === "none") {
    toggle.style.display = "block";
  } else {
    toggle.style.display = "none";
  }
}
function newGuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var uuid = Math.random() * 16 | 0,
      v = c == 'x' ? uuid : uuid & 0x3 | 0x8;
    return uuid.toString(16);
  });
}

/***/ }),

/***/ "./src/threejs/fonts/helvetiker_regular.typeface.json":
/*!************************************************************!*\
  !*** ./src/threejs/fonts/helvetiker_regular.typeface.json ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"glyphs":{"0":{"x_min":73,"x_max":715,"ha":792,"o":"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"1":{"x_min":215.671875,"x_max":574,"ha":792,"o":"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"2":{"x_min":59,"x_max":731,"ha":792,"o":"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"3":{"x_min":54,"x_max":737,"ha":792,"o":"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"4":{"x_min":48,"x_max":742.453125,"ha":792,"o":"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"5":{"x_min":54.171875,"x_max":738,"ha":792,"o":"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"6":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"7":{"x_min":58.71875,"x_max":730.953125,"ha":792,"o":"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"8":{"x_min":55,"x_max":736,"ha":792,"o":"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"9":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"ÃÂ¿":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},"S":{"x_min":0,"x_max":788,"ha":890,"o":"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"ÃÂ¦":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{"x_min":183.25,"x_max":608.328125,"ha":792,"o":"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"ÃÂ¤":{"x_min":-0.4375,"x_max":777.453125,"ha":839,"o":"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},"y":{"x_min":0,"x_max":684.78125,"ha":771,"o":"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"Ã ":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"ÃÂ":{"x_min":-111,"x_max":339,"ha":361,"o":"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},"g":{"x_min":0,"x_max":686,"ha":838,"o":"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"ÃÂ²":{"x_min":0,"x_max":442,"ha":539,"o":"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"Ã¢â¬â":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"ÃÅ¡":{"x_min":0,"x_max":819.5625,"ha":893,"o":"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"Ãâ":{"x_min":-46.265625,"x_max":392,"ha":513,"o":"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},"e":{"x_min":0,"x_max":714,"ha":813,"o":"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"ÃÅ":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},"J":{"x_min":0,"x_max":588,"ha":699,"o":"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"ÃÂ»":{"x_min":-1,"x_max":503,"ha":601,"o":"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"ÃÂ©":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"ÃÅ½":{"x_min":0,"x_max":922,"ha":1030,"o":"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{"x_min":193.0625,"x_max":598.609375,"ha":792,"o":"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"ÃÂ«":{"x_min":0,"x_max":507.203125,"ha":604,"o":"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},"D":{"x_min":0,"x_max":828,"ha":935,"o":"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"Ã¢Ëâ¢":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"ÃÂ¿":{"x_min":0,"x_max":47,"ha":125,"o":"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},"w":{"x_min":0,"x_max":1009.71875,"ha":1100,"o":"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},"$":{"x_min":0,"x_max":700,"ha":793,"o":"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\\\":{"x_min":-0.015625,"x_max":425.0625,"ha":522,"o":"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"ÃÂµ":{"x_min":0,"x_max":697.21875,"ha":747,"o":"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"Ãâ¢":{"x_min":42,"x_max":181,"ha":297,"o":"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"ÃÅ½":{"x_min":0,"x_max":1144.5,"ha":1214,"o":"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ã¢â¬â¢":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"ÃÂ":{"x_min":0,"x_max":801,"ha":915,"o":"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{"x_min":8.71875,"x_max":350.390625,"ha":478,"o":"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},"Q":{"x_min":0,"x_max":968,"ha":1072,"o":"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"Ãâ":{"x_min":1,"x_max":676.28125,"ha":740,"o":"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},"M":{"x_min":0,"x_max":954,"ha":1067,"o":"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"ÃÂ¨":{"x_min":0,"x_max":1006,"ha":1094,"o":"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},"C":{"x_min":0,"x_max":886,"ha":944,"o":"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{"x_min":0,"x_max":138,"ha":236,"o":"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{"x_min":0,"x_max":480.5625,"ha":578,"o":"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},"X":{"x_min":-0.015625,"x_max":854.15625,"ha":940,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{"x_min":0,"x_max":963.890625,"ha":1061,"o":"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"ÃÂ¹":{"x_min":42,"x_max":284,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"Ãâ ":{"x_min":0,"x_max":906.953125,"ha":982,"o":"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{"x_min":0,"x_max":318,"ha":415,"o":"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"ÃÂµ":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"Ãâ":{"x_min":0,"x_max":952.78125,"ha":1028,"o":"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{"x_min":0,"x_max":481,"ha":578,"o":"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"Ã¢â¬Â°":{"x_min":-3,"x_max":1672,"ha":1821,"o":"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},"a":{"x_min":0,"x_max":698.609375,"ha":794,"o":"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"Ã¢â¬â":{"x_min":0,"x_max":941.671875,"ha":1039,"o":"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{"x_min":8.71875,"x_max":780.953125,"ha":792,"o":"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},"N":{"x_min":0,"x_max":801,"ha":914,"o":"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"ÃÂ":{"x_min":0,"x_max":712,"ha":797,"o":"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"ÃÂ¯":{"x_min":0,"x_max":941.671875,"ha":938,"o":"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},"Z":{"x_min":0,"x_max":779,"ha":849,"o":"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},"u":{"x_min":0,"x_max":617,"ha":729,"o":"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},"k":{"x_min":0,"x_max":612.484375,"ha":697,"o":"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"Ãâ":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"Ãâ":{"x_min":0,"x_max":906.953125,"ha":985,"o":"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},"s":{"x_min":0,"x_max":604,"ha":697,"o":"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},"B":{"x_min":0,"x_max":778,"ha":876,"o":"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"Ã¢â¬Â¦":{"x_min":0,"x_max":614,"ha":708,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{"x_min":0,"x_max":607,"ha":704,"o":"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},"H":{"x_min":0,"x_max":803,"ha":915,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"ÃÂ½":{"x_min":0,"x_max":675,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},"c":{"x_min":1,"x_max":701.390625,"ha":775,"o":"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"ÃÂ¶":{"x_min":0,"x_max":566.671875,"ha":678,"o":"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"ÃÂ²":{"x_min":0,"x_max":660,"ha":745,"o":"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"ÃÅ":{"x_min":0,"x_max":954,"ha":1068,"o":"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"ÃÅ":{"x_min":0.109375,"x_max":1120,"ha":1217,"o":"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ãâ°":{"x_min":0,"x_max":1158,"ha":1275,"o":"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ã¢â¬Â¢":{"x_min":0,"x_max":663.890625,"ha":775,"o":"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"ÃÂ¥":{"x_min":0.1875,"x_max":819.546875,"ha":886,"o":"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{"x_min":0,"x_max":318.0625,"ha":415,"o":"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},"U":{"x_min":0,"x_max":796,"ha":904,"o":"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"ÃÂ³":{"x_min":0.5,"x_max":744.953125,"ha":822,"o":"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"ÃÂ±":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},"F":{"x_min":0,"x_max":683.328125,"ha":717,"o":"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"ÃÂ­":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"ÃÂ§":{"x_min":0,"x_max":854.171875,"ha":935,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{"x_min":116,"x_max":674,"ha":792,"o":"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"Ã¢â¬ ":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"ÃÂ°":{"x_min":0,"x_max":347,"ha":444,"o":"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},"V":{"x_min":0,"x_max":862.71875,"ha":940,"o":"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"ÃÅ¾":{"x_min":0,"x_max":734.71875,"ha":763,"o":"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "},"Ã ":{"x_min":0,"x_max":0,"ha":853},"ÃÂ«":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"Ã¢â¬Â":{"x_min":0,"x_max":347,"ha":454,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{"x_min":0,"x_max":1260,"ha":1357,"o":"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"ÃÅ ":{"x_min":0,"x_max":499,"ha":613,"o":"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},"i":{"x_min":14,"x_max":136,"ha":275,"o":"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"Ãâ":{"x_min":0,"x_max":778,"ha":877,"o":"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"Ãâ¦":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{"x_min":0,"x_max":275,"ha":372,"o":"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},"m":{"x_min":0,"x_max":1019,"ha":1128,"o":"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"Ãâ¡":{"x_min":8.328125,"x_max":780.5625,"ha":815,"o":"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"ÃÂ¯":{"x_min":42,"x_max":326.71875,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"Ãâ":{"x_min":0,"x_max":779.171875,"ha":850,"o":"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},"R":{"x_min":0,"x_max":781.953125,"ha":907,"o":"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},"o":{"x_min":0,"x_max":713,"ha":821,"o":"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},"K":{"x_min":0,"x_max":819.46875,"ha":906,"o":"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},"d":{"x_min":0,"x_max":683,"ha":796,"o":"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"ÃÂ¨":{"x_min":-109,"x_max":247,"ha":232,"o":"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},"E":{"x_min":0,"x_max":736.109375,"ha":789,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"Y":{"x_min":0,"x_max":820,"ha":886,"o":"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\\"":{"x_min":0,"x_max":299,"ha":396,"o":"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"Ã¢â¬Â¹":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"Ã¢â¬Å¾":{"x_min":0,"x_max":364,"ha":467,"o":"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"ÃÂ´":{"x_min":1,"x_max":710,"ha":810,"o":"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"ÃÂ­":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"Ãâ°":{"x_min":0,"x_max":922,"ha":1031,"o":"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"ÃÂ´":{"x_min":0,"x_max":96,"ha":251,"o":"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"ÃÂ±":{"x_min":11,"x_max":781,"ha":792,"o":"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"Ãâ¹":{"x_min":0,"x_max":617,"ha":725,"o":"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"ÃÂ§":{"x_min":0,"x_max":593,"ha":690,"o":"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},"b":{"x_min":0,"x_max":685,"ha":783,"o":"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},"q":{"x_min":0,"x_max":683,"ha":876,"o":"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"ÃÂ©":{"x_min":-0.171875,"x_max":969.5625,"ha":1068,"o":"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"ÃÂ":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},"z":{"x_min":-0.015625,"x_max":613.890625,"ha":697,"o":"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"Ã¢âÂ¢":{"x_min":0,"x_max":894,"ha":1000,"o":"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"ÃÂ®":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"ÃË":{"x_min":0,"x_max":960,"ha":1056,"o":"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"ÃÂ®":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{"x_min":0,"x_max":833,"ha":931,"o":"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"Ãâ¢":{"x_min":0,"x_max":736.21875,"ha":778,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"ÃÂ³":{"x_min":0,"x_max":450,"ha":547,"o":"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{"x_min":0,"x_max":273.609375,"ha":371,"o":"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},"L":{"x_min":0,"x_max":645.828125,"ha":696,"o":"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"ÃÆ":{"x_min":0,"x_max":803.390625,"ha":894,"o":"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"ÃÂ¶":{"x_min":0,"x_max":573,"ha":642,"o":"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"ÃÂ¸":{"x_min":0,"x_max":674,"ha":778,"o":"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"ÃÅ¸":{"x_min":0,"x_max":958,"ha":1054,"o":"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"Ãâ":{"x_min":0,"x_max":705.28125,"ha":749,"o":"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":-3,"x_max":1089,"ha":1186,"o":"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},"P":{"x_min":0,"x_max":726,"ha":806,"o":"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"ÃË":{"x_min":0,"x_max":1078.21875,"ha":1118,"o":"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"ÃÂ":{"x_min":0.125,"x_max":1136.546875,"ha":1235,"o":"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},"_":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"ÃÂª":{"x_min":-110,"x_max":246,"ha":275,"o":"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{"x_min":23,"x_max":768,"ha":792,"o":"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"ÃÂ½":{"x_min":0,"x_max":1050,"ha":1149,"o":"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"ÃÂ¡":{"x_min":0,"x_max":720,"ha":783,"o":"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"\'":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"ÃÂª":{"x_min":0,"x_max":350,"ha":397,"o":"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"Ãâ¦":{"x_min":0,"x_max":450,"ha":553,"o":"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},"T":{"x_min":0,"x_max":777,"ha":835,"o":"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"ÃÂ¦":{"x_min":0,"x_max":915,"ha":997,"o":"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"Ã¢Ââ¹":{"x_min":0,"x_max":0,"ha":694},"j":{"x_min":-77.78125,"x_max":167,"ha":349,"o":"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"ÃÂ£":{"x_min":0,"x_max":756.953125,"ha":819,"o":"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"Ã¢â¬Âº":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"ÃÂ£":{"x_min":0,"x_max":704.484375,"ha":801,"o":"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},"t":{"x_min":0,"x_max":367,"ha":458,"o":"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"ÃÂ¬":{"x_min":0,"x_max":706,"ha":803,"o":"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"ÃÂ»":{"x_min":0,"x_max":750,"ha":803,"o":"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},"W":{"x_min":0,"x_max":1263.890625,"ha":1351,"o":"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"v":{"x_min":0,"x_max":675.15625,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"Ãâ":{"x_min":0.28125,"x_max":644.5,"ha":703,"o":"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"ÃÂ¾":{"x_min":0,"x_max":624.9375,"ha":699,"o":"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{"x_min":-3,"x_max":894.25,"ha":992,"o":"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"Ãâº":{"x_min":0,"x_max":862.5,"ha":942,"o":"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},"I":{"x_min":41,"x_max":180,"ha":293,"o":"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},"G":{"x_min":0,"x_max":921,"ha":1011,"o":"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"ÃÂ°":{"x_min":0,"x_max":617,"ha":725,"o":"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{"x_min":0,"x_max":138.890625,"ha":236,"o":"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"ÃÂ·":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"ÃÂ¥":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},"r":{"x_min":0,"x_max":355.5625,"ha":432,"o":"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},"x":{"x_min":0,"x_max":675,"ha":764,"o":"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"ÃÂ¼":{"x_min":0,"x_max":696.609375,"ha":747,"o":"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},"h":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"Ãâ ":{"x_min":-2,"x_max":878,"ha":974,"o":"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},"f":{"x_min":0,"x_max":378,"ha":472,"o":"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"Ã¢â¬Å":{"x_min":1,"x_max":348.21875,"ha":454,"o":"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},"A":{"x_min":0.03125,"x_max":906.953125,"ha":1008,"o":"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"Ã¢â¬Ë":{"x_min":1,"x_max":139.890625,"ha":236,"o":"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"ÃÅ ":{"x_min":-70,"x_max":283,"ha":361,"o":"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"Ãâ¬":{"x_min":-0.21875,"x_max":773.21875,"ha":857,"o":"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"ÃÂ¬":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},"O":{"x_min":0,"x_max":958,"ha":1057,"o":"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},"n":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},"l":{"x_min":41,"x_max":166,"ha":279,"o":"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"ÃÂ¤":{"x_min":40.09375,"x_max":728.796875,"ha":825,"o":"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"ÃÂº":{"x_min":0,"x_max":632.328125,"ha":679,"o":"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},"p":{"x_min":0,"x_max":685,"ha":786,"o":"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"Ã¢â¬Â¡":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"ÃË":{"x_min":0,"x_max":808,"ha":907,"o":"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"ÃÂ·":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}},"cssFontWeight":"normal","ascender":1189,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-334,"xMin":-111,"yMax":1189,"xMax":1672},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Helvetiker","font_family_name":"Helvetiker","copyright":"Copyright (c) ÃÅagenta ltd, 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"ÃÅagenta ltd:Helvetiker:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\"Fonts\\") and associated documentation files (the \\"Font Software\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\"MgOpen\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\"MgOpen\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"ÃÅagenta ltd","font_sub_family_name":"Regular"},"descender":-334,"familyName":"Helvetiker","lineHeight":1522,"underlineThickness":50}');

/***/ }),

/***/ "./src/threejs/objects/bend.js":
/*!*************************************!*\
  !*** ./src/threejs/objects/bend.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawBendMesh: () => (/* binding */ drawBendMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawBendMesh(tag, jsonFacePoints, material, color, opacity) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;
    var faces = JSON.parse(jsonFacePoints);
    var vertices1 = [];
    faces.forEach(function (face) {
      face.forEach(function (pt) {
        vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
      });
    });
    if (jsonFacePoints.includes("NaN")) {
      console.log("NanN :", tag, jsonFacePoints);
    }
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    pointsGeometry.computeBoundingSphere();
    if (isNaN(pointsGeometry.boundingSphere.radius)) {
      geometry.boundingSphere.radius = 1; // Set a default value or any suitable value
    }
    var bendMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    bendMesh.Tag = tag;
    bendMesh.Type = "bend";
    bendMesh.Clicked = false;
    bendMesh.OriginalColor = bendMesh.material.color;
    bendMesh.material.opacity = opacity;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    bendMesh.geometry.computeBoundingBox();
    bendMesh.geometry.boundingBox.getCenter(center);
    bendMesh.geometry.center();
    bendMesh.position.copy(center);
    pointsGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  return bendMesh;
}


/***/ }),

/***/ "./src/threejs/objects/cross.js":
/*!**************************************!*\
  !*** ./src/threejs/objects/cross.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawCrossMesh: () => (/* binding */ drawCrossMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawCrossMesh(tag, jsonFacePoints, material, color, opacity) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;
    var faces = JSON.parse(jsonFacePoints);
    var vertices1 = [];
    faces.forEach(function (face) {
      face.forEach(function (pt) {
        vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
      });
    });
    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    var crossMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
    crossMesh.Tag = tag;
    crossMesh.Type = "cross";
    crossMesh.Clicked = false;
    crossMesh.OriginalColor = crossMesh.material.color;
    crossMesh.material.opacity = opacity;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    crossMesh.geometry.computeBoundingBox();
    crossMesh.geometry.boundingBox.getCenter(center);
    crossMesh.geometry.center();
    crossMesh.position.copy(center);
    geometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  return crossMesh;
}


/***/ }),

/***/ "./src/threejs/objects/equipment.js":
/*!******************************************!*\
  !*** ./src/threejs/objects/equipment.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawEquipmentMesh),
/* harmony export */   drawEquipmentMesh: () => (/* binding */ drawEquipmentMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawEquipmentMesh(tag, x, y, z, w, d, h, a, material, color, opacity, colortext) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;
    var clrT = JSON.parse(colortext);
    var textColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clrT[0] / 255, clrT[1] / 255, clrT[2] / 255);
    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(w, d, h); // l along x-axis, w along y axis, d along z axis
    var equipmentMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
    //
    var fontSize = 0.3 * Math.min(w, d, 1);
    if (tag.length * fontSize > Math.max(w, d)) {
      fontSize = Math.max(w, d) / tag.length;
    }
    var fontHeight = fontSize / 5; // Thickness to extrude text
    //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }
    //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }
    loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
      // Create the text geometry
      var textGeometry = new TextGeometry(tag, {
        font: font,
        height: fontHeight,
        size: fontSize,
        color: '#5C4033'
        //, curveSegments: 32,
        //bevelEnabled: true,
        //bevelThickness: 0.5,
        //bevelSize: 0.5,
        //bevelSegments: 8,
      });
      // Geometries are attached to meshes so that they get rendered
      var textMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(textGeometry, textMaterial);
      textMesh.geometry.center();
      // Update positioning of the text
      textMesh.position.set(0, 0, h / 2);
      textMesh.rotateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), Math.PI * (-1 + w < d ? 1 / 2 : 0));
      equipmentMesh.add(textMesh);
    });
    equipmentMesh.rotateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), a);
    equipmentMesh.position.set(x, y, z);
    equipmentMesh.updateMatrixWorld();
    equipmentMesh.Tag = tag;
    equipmentMesh.Type = "equipment";
    equipmentMesh.Clicked = false;
    equipmentMesh.OriginalColor = equipmentMesh.material.color;
    equipmentMesh.material.opacity = opacity;
    geometry.dispose();
    //
  } catch (e) {
    console.log(tag + e);
  }
  return equipmentMesh;
}


/***/ }),

/***/ "./src/threejs/objects/ladder.js":
/*!***************************************!*\
  !*** ./src/threejs/objects/ladder.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawLadderMesh: () => (/* binding */ drawLadderMesh),
/* harmony export */   drawLadderMeshBatch: () => (/* binding */ drawLadderMeshBatch)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function drawLadderMesh(tag, jsonPoints, material, color, opacity) {
  try {
    // Parse color only once and handle potential errors
    var clr;
    try {
      clr = JSON.parse(color);
    } catch (colorParseError) {
      console.error("Error parsing color for tag ".concat(tag, ": ").concat(colorParseError));
      return null; // Exit if color parsing fails
    }
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;

    // Parse points only once and handle errors
    var points;
    try {
      points = JSON.parse(jsonPoints);
    } catch (pointsParseError) {
      console.error("Error parsing points for tag ".concat(tag, ": ").concat(pointsParseError));
      return null; // Exit if points parsing fails
    }
    var vertices1 = [];
    var pushOrder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];

    // Pre-allocate array for better performance
    vertices1.length = pushOrder.length;

    // Use a for loop for better performance than forEach
    for (var _i = 0; _i < pushOrder.length; _i++) {
      var pointIndex = pushOrder[_i];
      vertices1[_i] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(points[pointIndex].X, points[pointIndex].Y, points[pointIndex].Z);
    }
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1);
    var ladderMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    ladderMesh.Tag = tag;
    ladderMesh.Type = "ladder";
    ladderMesh.Clicked = false;
    ladderMesh.OriginalColor = ladderMesh.material.color.clone(); // Clone the color

    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    pointsGeometry.computeBoundingBox();
    pointsGeometry.boundingBox.getCenter(center);
    ladderMesh.geometry.center();
    ladderMesh.position.copy(center);
    ladderMesh.material.opacity = opacity;

    // Dispose of geometry after use
    //pointsGeometry.dispose(); // Moved to be handled outside of this function.

    return ladderMesh;
  } catch (e) {
    console.error("".concat(tag, " - Unexpected error: ").concat(e));
    return null;
  }
}
function drawLadderMeshBatch(tags, jsonPointsArray, material, colors, opacities) {
  console.log("Step 4: Drawing from ladder.js : drawLadderMeshBatch for " + tags.length + " trays with " + jsonPointsArray.length);
  // Validate inputs
  if (!Array.isArray(jsonPointsArray) || !Array.isArray(tags) || !Array.isArray(colors) || !Array.isArray(opacities)) {
    console.error('Invalid input arrays:', {
      tags: tags,
      jsonPointsArray: jsonPointsArray,
      colors: colors,
      opacities: opacities
    });
    return null;
  }
  if (jsonPointsArray.length !== tags.length || jsonPointsArray.length !== colors.length || jsonPointsArray.length !== opacities.length) {
    console.error('Array lengths mismatch:', {
      tags: tags.length,
      points: jsonPointsArray.length,
      colors: colors.length,
      opacities: opacities.length
    });
    return null;
  }
  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
  var vertices = [];
  var pushOrder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];

  // Parse and validate points
  var points = [];
  for (var _i2 = 0; _i2 < jsonPointsArray.length; _i2++) {
    try {
      var parsed = JSON.parse(jsonPointsArray[_i2]);
      if (!Array.isArray(parsed) || parsed.length < 8) {
        console.error("Tray ".concat(_i2, " : Invalid points array for tag ").concat(tags[_i2], ": Expected at least 8 vertices, got"), parsed);
        continue;
      }
      if (!parsed.every(function (p) {
        return p && typeof p.X === 'number' && typeof p.Y === 'number' && typeof p.Z === 'number';
      })) {
        console.error("Tray ".concat(_i2, " : Invalid point structure for tag ").concat(tags[_i2], ": Missing or invalid X, Y, Z"), parsed);
        continue;
      }
      points.push(parsed);
    } catch (e) {
      console.error("Tray ".concat(_i2, " : Error parsing JSON for tag ").concat(tags[_i2], ":"), e);
    }
  }
  if (points.length === 0) {
    console.error('No valid points to render');
    return null;
  }

  // Create vertices for valid ladders
  for (var _i3 = 0; _i3 < points.length; _i3++) {
    for (var j = 0; j < pushOrder.length; j++) {
      var idx = pushOrder[j];
      vertices.push(points[_i3][idx].X, points[_i3][idx].Y, points[_i3][idx].Z);
    }
  }
  geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertices, 3));

  // Material cache
  var materialCache = {};
  function getMaterial(color, opacity) {
    var key = "".concat(color, "_").concat(opacity);
    if (!materialCache[key]) {
      var colorArray;
      try {
        // Handle case where color is a JSON string
        if (typeof color === 'string') {
          colorArray = JSON.parse(color);
        } else if (Array.isArray(color)) {
          // Handle case where color is already an array
          colorArray = color;
        } else {
          throw new Error('Tray ' + i + ' : Invalid color format');
        }
        // Validate color array
        if (!Array.isArray(colorArray) || colorArray.length !== 3 || !colorArray.every(function (c) {
          return typeof c === 'number' && c >= 0 && c <= 255;
        })) {
          throw new Error('Tray ' + i + ' : Invalid color array');
        }
        materialCache[key] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
          color: _construct(three__WEBPACK_IMPORTED_MODULE_0__.Color, _toConsumableArray(colorArray.map(function (c) {
            return c / 255;
          }))),
          opacity: opacity,
          transparent: true
        });
      } catch (e) {
        console.error("Error processing color for key ".concat(key, ":"), e, 'Color value:', color);
        // Fallback to default color (white)
        materialCache[key] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
          color: 0xffffff,
          opacity: opacity,
          transparent: true
        });
      }
    }
    return materialCache[key];
  }
  var count = points.length;
  var instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(geometry, getMaterial(colors[0], opacities[0]), count);

  // Store tags for valid ladders only
  instancedMesh.instanceTags = points.map(function (_, i) {
    return tags[i];
  });
  instancedMesh.Type = "ladder";
  instancedMesh.castShadow = true; // Cast shadows
  instancedMesh.receiveShadow = true; // Receive shadows (optional, for ladders shadowing each other)

  // Set instance matrices and colors
  var _loop = function _loop(_i4) {
    var matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    var tempGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(pushOrder.map(function (idx) {
      return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(points[_i4][idx].X, points[_i4][idx].Y, points[_i4][idx].Z);
    }));
    tempGeometry.computeBoundingBox();
    tempGeometry.boundingBox.getCenter(center);
    matrix.setPosition(center);
    instancedMesh.setMatrixAt(_i4, matrix);
    try {
      var colorArray;
      if (typeof colors[_i4] === 'string') {
        colorArray = JSON.parse(colors[_i4]);
      } else if (Array.isArray(colors[_i4])) {
        colorArray = colors[_i4];
      } else {
        throw new Error('Tray ' + _i4 + ' : Invalid color format');
      }
      if (!Array.isArray(colorArray) || colorArray.length !== 3 || !colorArray.every(function (c) {
        return typeof c === 'number' && c >= 0 && c <= 255;
      })) {
        throw new Error('Tray ' + _i4 + ' : Invalid color array');
      }
      instancedMesh.setColorAt(_i4, _construct(three__WEBPACK_IMPORTED_MODULE_0__.Color, _toConsumableArray(colorArray.map(function (c) {
        return c / 255;
      }))));
    } catch (e) {
      console.error("Tray ".concat(_i4, " : Error setting color for tag ").concat(tags[_i4], ":"), e, 'Color value:', colors[_i4]);
      instancedMesh.setColorAt(_i4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 11));
    }
    tempGeometry.dispose();
  };
  for (var _i4 = 0; _i4 < count; _i4++) {
    _loop(_i4);
  }
  instancedMesh.instanceMatrix.needsUpdate = true;
  instancedMesh.instanceColor.needsUpdate = true;
  return instancedMesh;
}


/***/ }),

/***/ "./src/threejs/objects/node.js":
/*!*************************************!*\
  !*** ./src/threejs/objects/node.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawNodeMesh: () => (/* binding */ drawNodeMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawNodeMesh(tag, jsonPoint, material, color, opacity) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;
    var nodePoint = JSON.parse(jsonPoint);
    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.03, 5, 5); // radious, widthsegment, heightsegments
    var _sphereMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
    _sphereMesh.position.set(nodePoint.X, nodePoint.Y, nodePoint.Z);
    _sphereMesh.Tag = tag;
    _sphereMesh.Type = "node";
    _sphereMesh.Clicked = false;
    _sphereMesh.OriginalColor = _sphereMesh.material.color;
    _sphereMesh.material.opacity = opacity;
    geometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  return sphereMesh;
}


/***/ }),

/***/ "./src/threejs/objects/plane.js":
/*!**************************************!*\
  !*** ./src/threejs/objects/plane.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawPlaneMesh: () => (/* binding */ drawPlaneMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawPlaneMesh(rendererWidth, rendererHeight, planeName, planeTag, imageString, scaleX, scaleY, centreX, centreY, elevation, opacity) {
  try {
    // Create an image
    var image = new Image(); // or document.createElement('img' );
    // Set image source
    image.src = imageString;
    //console.log("Step 4: Drawing planeMesh plane.js", planeName, planeTag)
    var texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(image);
    var planeMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial({
      map: texture,
      color: 0xffffff,
      transparent: true,
      opacity: opacity,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      flatShading: true
    });
    image.onload = function () {
      texture.needsUpdate = true;
    };
    //
    // plane geometry
    var planeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(rendererWidth, rendererHeight);
    var planeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(planeGeometry, planeMaterial);
    planeMesh.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), elevation);
    planeMesh.Name = planeName; // "plotplan"; // main background any additional plane to be added to this main background
    //var planeMeshCount = getObjectByNameArray(scene, 'plotplan').length;
    planeMesh.Tag = planeTag; // "plotplan" + planeMeshCount; //toString();
    planeMesh.Type = 'plotplan';
    planeMesh.material.opacity = opacity;
    // scale the plane
    if (scaleX !== undefined && scaleY !== undefined) {
      if (scaleX !== 0 && scaleY !== 0) {
        planeMesh.scale.set(scaleX, scaleY, 1);
        planeMesh.updateMatrixWorld();
      }
    }
    //
    // align to centre
    if (centreX !== undefined && centreY !== undefined) {
      planeMesh.position.set(-centreX, -centreY, elevation);
      planeMesh.updateMatrixWorld();
    }
    //
  } catch (e) {
    console.log(planeTag + e);
  }
  return planeMesh;
}


/***/ }),

/***/ "./src/threejs/objects/refPoint.js":
/*!*****************************************!*\
  !*** ./src/threejs/objects/refPoint.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawRefPointMesh: () => (/* binding */ drawRefPointMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_geometries_TextGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/geometries/TextGeometry.js */ "./node_modules/three/examples/jsm/geometries/TextGeometry.js");
/* harmony import */ var _fonts_helvetiker_regular_typeface_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fonts/helvetiker_regular.typeface.json */ "./src/threejs/fonts/helvetiker_regular.typeface.json");
/* harmony import */ var three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/loaders/FontLoader */ "./node_modules/three/examples/jsm/loaders/FontLoader.js");




function drawRefPointMesh(tag, point, opacity) {
  var refPoint;
  try {
    refPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Group();

    // Create materials with transparency and opacity
    var redRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
      color: 0xff0000,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      transparent: false,
      opacity: opacity
    });
    var yellowRingMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
      color: 0xffff00,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,
      transparent: false,
      opacity: opacity
    });
    var textMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
      color: 0xffff00,
      transparent: false,
      opacity: 1,
      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
    });

    // Create geometries and meshes for circle and rings
    var redCircleGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.CircleGeometry(0.1, 10);
    var redCircle = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redCircleGeometry, redRingMaterial);
    refPoint.add(redCircle);
    var redRingGeometryIn = new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.1, 0.3, 20);
    var redRingMeshIn = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redRingGeometryIn, yellowRingMaterial);
    refPoint.add(redRingMeshIn);
    var redRingGeometryOut = new three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry(0.3, 0.35, 20);
    var redRingMeshOut = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(redRingGeometryOut, redRingMaterial);
    refPoint.add(redRingMeshOut);

    // Load font and create text mesh
    var fontSize = .3;
    var fontHeight = fontSize / 5; // Thickness to extrude text
    var loader = new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_3__.FontLoader();
    loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
      // Create the text geometry
      var textGeometry = new three_examples_jsm_geometries_TextGeometry_js__WEBPACK_IMPORTED_MODULE_1__.TextGeometry(tag, {
        font: font,
        depth: fontHeight,
        size: fontSize,
        color: '#0000ff',
        //, curveSegments: 32,
        bevelEnabled: false
        //bevelThickness: 0.5,
        //bevelSize: 0.5,
        //bevelSegments: 8,
      });
      // Geometries are attached to meshes so that they get rendered
      var textMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(textGeometry, textMaterial);
      textMesh.geometry.center();
      // Update positioning of the text
      textMesh.position.set(.5, .5, 0);
      refPoint.add(textMesh);
    });

    // Set group position
    refPoint.position.set(point.x, point.y, point.z);

    // Set custom properties
    refPoint.Tag = tag;
    refPoint.Type = "refPoint";
    refPoint.Clicked = false;
    refPoint.name = 'refPoint';

    // Dispose geometries
    redCircleGeometry.dispose();
    redRingGeometryIn.dispose();
    redRingGeometryOut.dispose();
  } catch (e) {
    console.log(tag + ' Error: ' + e);
  }
  return refPoint;
}


/***/ }),

/***/ "./src/threejs/objects/sleeve.js":
/*!***************************************!*\
  !*** ./src/threejs/objects/sleeve.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawSleeveMesh: () => (/* binding */ drawSleeveMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawSleeveMesh(tag, jsonPoints, radious, segment, radialSegments, material, color, opacity) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;

    // var rawPoints = JSON.parse(jsonPoints);
    // var points = [];
    // rawPoints.forEach(p => {
    //     points.push(new THREE.Vector3(p.X, p.Y, p.Z));
    // });
    //
    // //var pp = curve.getPoints(segment);
    // var pps = [];
    // points.forEach(p => { pps.push([p.x, p.y, p.z]); });
    //
    // var geometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);
    // var curve = new THREE.CatmullRomCurve3(points);
    // var tubeGeometry = new THREE.TubeBufferGeometry(curve, segment, radious, radialSegments, false);
    // var tubeMesh = new THREE.Mesh(tubeGeometry, material);

    // Parse and create points
    var rawPoints = JSON.parse(jsonPoints);
    var points = rawPoints.map(function (p) {
      return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(p.X, p.Y, p.Z);
    });

    // Create curve from points
    var curve = new three__WEBPACK_IMPORTED_MODULE_0__.CatmullRomCurve3(points);

    // Create tube geometry
    var tubeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.TubeGeometry(curve, segment, radious, radialSegments, false);

    // Create mesh
    var tubeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(tubeGeometry, material);
    tubeMesh.Tag = tag;
    tubeMesh.Type = "sleeve";
    tubeMesh.Clicked = false;
    tubeMesh.OriginalColor = color;
    tubeMesh.material.opacity = opacity;
    //console.log("drawing sleeve sleeve.js tubeJeometry done for ", tag);
    tubeGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  return tubeMesh;
}


/***/ }),

/***/ "./src/threejs/objects/tee.js":
/*!************************************!*\
  !*** ./src/threejs/objects/tee.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawTeeMesh: () => (/* binding */ drawTeeMesh)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");

function drawTeeMesh(tag, jsonFacePoints, material, color, opacity) {
  try {
    var clr = JSON.parse(color);
    var setColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);
    material.color = setColor;
    var faces = JSON.parse(jsonFacePoints);
    var vertices1 = [];
    faces.forEach(function (face) {
      face.forEach(function (pt) {
        vertices1.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(pt.X, pt.Y, pt.Z));
      });
    });
    var pointsGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints(vertices1, 3);
    var teeMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(pointsGeometry, material);
    teeMesh.Tag = tag;
    teeMesh.Type = "tee";
    teeMesh.Clicked = false;
    teeMesh.OriginalColor = teeMesh.material.color;
    teeMesh.material.opacity = opacity;
    var center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    teeMesh.geometry.computeBoundingBox();
    teeMesh.geometry.boundingBox.getCenter(center);
    teeMesh.geometry.center();
    teeMesh.position.copy(center);
    pointsGeometry.dispose();
  } catch (e) {
    console.log(tag + e);
  }
  return teeMesh;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/* harmony import */ var _myThree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./myThree */ "./src/myThree.js");
/* harmony import */ var _mySLD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mySLD */ "./src/mySLD.js");
/* harmony import */ var _src_modal_modal_interop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/modal/modal-interop */ "./src/modal/modal-interop.js");
//// Module Manager for registering the modules of the chart
//import { ModuleManager } from 'igniteui-webcomponents-core';
//// Radial Gauge Module
//import { IgcRadialGaugeModule } from 'igniteui-webcomponents-gauges';

//// register the modules
//ModuleManager.register(
//    IgcRadialGaugeModule
//);





window.consoleLog = function (logString) {
  console.log(logString);
};

//drawBend, drawTee, drawCross, drawCable
window.drawScene = function (divId) {
  var sceneJSON = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var dotNetObjRef = arguments.length > 2 ? arguments[2] : undefined;
  (0,_myThree__WEBPACK_IMPORTED_MODULE_1__.drawScene3Js)(divId, sceneJSON, dotNetObjRef);
};
window.drawCube = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawCube3Js;
window.hide3D = _myThree__WEBPACK_IMPORTED_MODULE_1__.hide3D3Js;
window.clearScene = function () {
  clearScene();
};
window.drawPlane = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawPlane3Js;
window.rotatePlane = _myThree__WEBPACK_IMPORTED_MODULE_1__.rotatePlaneJs;
window.scalePlane = _myThree__WEBPACK_IMPORTED_MODULE_1__.scalePlane3Js;
window.centrePlane = _myThree__WEBPACK_IMPORTED_MODULE_1__.centrePlan3Js;
window.updateValue = function (value) {
  var rg = document.getElementById("rg");
  rg.value = value;
};
window.drawLadder = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawLadder3Js;
window.drawLadderChunk = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawLadderChunk3Js;
window.drawBend = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawBend3Js;
window.drawTee = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawTee3Js;
window.drawCross = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawCross3Js;
window.drawNode = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawNode3Js;
window.drawSleeveZ = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawSleeve3Js;
window.drawEquipment = _myThree__WEBPACK_IMPORTED_MODULE_1__.drawEquipment3Js;
var dotNetObj;
window.initialiseObjectRef = function (dotNetObjRef) {
  dotNetObj = dotNetObjRef;
};
// eventlisteners
window.addEventListener('resize', onWindowResize, false);
function onWindowResize() {
  var windowWidth = parseInt(window.innerWidth);
  var windowHeight = parseInt(window.innerHeight);
  //dotNetObj.invokeMethodAsync("WindowSize", windowWidth, windowHeight);
}
window.saveAsFile = function (fileName, bytesBase64) {
  var link = document.createElement('a');
  link.download = fileName;
  link.href = "data:application/octet-stream;base64," + bytesBase64;
  document.body.appendChild(link); // Needed for Firefox
  link.click();
  document.body.removeChild(link);
};
window.drawSLD = _mySLD__WEBPACK_IMPORTED_MODULE_2__.drawSLD;
window.updateSLD = _mySLD__WEBPACK_IMPORTED_MODULE_2__.updateSLD;
window.updateSLDItem = _mySLD__WEBPACK_IMPORTED_MODULE_2__.updateSLDItem;
window.updateSLDWithStudyResults = _mySLD__WEBPACK_IMPORTED_MODULE_2__.updateSLDWithStudyResults;

//window.setupDraggableModal = setupDraggableModal;
window.startModalDrag = _src_modal_modal_interop__WEBPACK_IMPORTED_MODULE_3__.startModalDrag;
window.stopModalDrag = _src_modal_modal_interop__WEBPACK_IMPORTED_MODULE_3__.stopModalDrag;
window.getModalDialogRect = _src_modal_modal_interop__WEBPACK_IMPORTED_MODULE_3__.getModalDialogRect;
//window.getModalDialogElement = getModalDialogElement;
window.setModalPosition = _src_modal_modal_interop__WEBPACK_IMPORTED_MODULE_3__.setModalPosition;
//window.focusElement = focusElement;
})();

/******/ })()
;
//# sourceMappingURL=main.bundle.js.map