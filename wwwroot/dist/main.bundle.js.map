{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,KAA4D;AAC7D,CAAC,CACsG;AACvG,CAAC,8BAA8B;;AAE/B,uHAAuH,qBAAM,mBAAmB,qBAAM;;AAEtJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,aAAa;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;;AAEhC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO,mBAAmB,aAAa;AACzE,EAAE;;AAEF;AACA,oCAAoC;AACpC;;AAEA;AACA,oFAAoF,MAAM;;AAE1F;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,IAAI;AACJ,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,uDAAuD;;AAEvD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,kFAAkF;AAClF,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,WAAW,gBAAgB;AAClC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sDAAsD;AACtD,KAAK;AACL,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf,6CAA6C,gCAAgC;AAC7E;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;;;;AAIA,6DAA6D,uBAAuB;;AAEpF;AACA;AACA,WAAW,yDAAyD;AACpE;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,uBAAuB,+DAA+D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C,WAAW;AACX,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA,8CAA8C,wBAAwB;;AAEtE;AACA;AACA,WAAW,0EAA0E;AACrF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;AAQA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;;AAEA;;AAEA;AACA;;;;;;AAMA,kCAAkC;;AAElC;AACA;AACA,uEAAuE,yCAAyC;AAChH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,+CAA+C;AAC/C,iDAAiD;AACjD,OAAO,qBAAqB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe,oFAAoF;AAC1G;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,YAAY;AACZ,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kDAAkD,mBAAmB;;AAErE;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,GAAG,gBAAgB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,WAAW,0DAA0D;AACrE;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA,0DAA0D,sBAAsB;;AAEhF;AACA;AACA,WAAW,sEAAsE;AACjF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,KAAuB,aAAa,CAAI,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,EAAE;;AAEF;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,8BAA8B,IAAI,0BAA0B;;AAEvE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,iBAAiB;AACxB,KAAK;AACL;;AAEA;;;;;;AAMA;AACA;AACA,WAAW,0EAA0E;AACrF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;AAOA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,WAAW,sFAAsF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,OAAO;AACtB;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,QAAQ;AACvB;AACA;AACA,IAAI;AACJ,eAAe,OAAO;AACtB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,SAAS;AACxB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA,gFAAgF;;AAEhF;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,cAAc,SAAS;AACvB,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,SAAS;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,SAAS;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,MAAM;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI;AACJ,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,MAAM,0BAA0B,MAAM;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,eAAe,MAAM;AACrB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,0CAA0C;AAC1C;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mCAAmC;;AAEnC;AACA,iCAAiC;;AAEjC;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;;AAEA;AACA,qCAAqC;AACrC,uBAAuB;AACvB;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD,qBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC;AACvC,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC;AACvC,oDAAoD;;AAEpD;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,IAAI;AACJ,+BAA+B;AAC/B;AACA,yCAAyC;;AAEzC;;AAEA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;;AAEvC;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA,wBAAwB;AACxB,gBAAgB;AAChB;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,gCAAgC;AAChC;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA,wBAAwB;AACxB,sBAAsB;AACtB,sBAAsB;AACtB,qBAAqB;AACrB;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA,SAAS;AACT;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,6GAA6G;AAC7G;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wFAAwF;AACxF;AACA;AACA,mFAAmF;AACnF;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,gGAAgG;AAChG;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wGAAwG;AACxG;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,IAAI;AACJ,yGAAyG;AACzG;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,0EAA0E;;AAE1E;AACA,IAAI;AACJ,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA,qBAAqB;AACrB,0BAA0B;AAC1B,qCAAqC;AACrC,mCAAmC;AACnC,gBAAgB;AAChB;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA,SAAS;AACT;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kGAAkG;AAClG;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ,0FAA0F;AAC1F;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,IAAI,4CAA4C,IAAI;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,IAAI,cAAc,IAAI,gBAAgB,YAAY,6BAA6B;AAC/G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,wEAAwE;AACxE,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,2DAA2D;;AAE3D;AACA,iBAAiB,OAAO;AACxB;AACA,yEAAyE;AACzE;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA,iCAAiC;;AAEjC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,iHAAiH;AACjH;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,4GAA4G;AAC5G;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;;AAEA,gBAAgB;AAChB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;;AAE7D,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,IAAI;AACJ,wFAAwF;AACxF;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA,mFAAmF;AACnF;AACA;AACA,MAAM;AACN;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,gHAAgH;AAChH;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iGAAiG;AACjG;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,gBAAgB;AAChB,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA,qEAAqE;AACrE,qEAAqE;;AAErE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA,kDAAkD;;AAElD,4FAA4F;AAC5F,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,wDAAwD;AACxD;AACA,8FAA8F;AAC9F;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,gBAAgB;AAChB,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uHAAuH;AACvH;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wGAAwG;AACxG;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,2BAA2B;AAC3B,gBAAgB;AAChB,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,IAAI;AACJ;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oDAAoD;AACpD;AACA;AACA,+FAA+F;AAC/F,gDAAgD;;AAEhD;AACA,sCAAsC;AACtC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gIAAgI;AAChI;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,+CAA+C;AAC/C,0EAA0E;AAC1E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF,iEAAiE;;AAEjE;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+IAA+I;AAC/I;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,MAAM,QAAQ;AACnE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA,oDAAoD;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA,8DAA8D;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC;AACA,uBAAuB,eAAe;AACtC,qBAAqB,aAAa;AAClC,qBAAqB,cAAc,EAAE,sEAAsE;AAC3G;AACA,0BAA0B,QAAQ,GAAG,OAAO;AAC5C,0BAA0B,cAAc;AACxC,kDAAkD,EAAE;AACpD;AACA,qBAAqB,aAAa;AAClC;;AAEA;AACA,2BAA2B,QAAQ,GAAG,OAAO;AAC7C,2BAA2B,QAAQ,GAAG,OAAO;AAC7C,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,qBAAqB,WAAW;AAChC,sBAAsB,WAAW;AACjC,yBAAyB,MAAM,KAAK,gDAAgD,GAAG,oBAAoB;AAC3G;AACA;AACA;AACA,uBAAuB,8CAA8C,GAAG,MAAM;;AAE9E;AACA,mCAAmC,QAAQ,GAAG,QAAQ,GAAG,gBAAgB,KAAK,kCAAkC,OAAO,YAAY,GAAG,gBAAgB,KAAK,gDAAgD,OAAO,QAAQ,GAAG,YAAY,GAAG,gBAAgB,MAAM,QAAQ,GAAG,gBAAgB,8BAA8B,QAAQ;AACnU;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,cAAc;;AAEpC;AACA,6BAA6B,YAAY,EAAE,QAAQ;AACnD,wBAAwB,wEAAwE;;AAEhG;AACA;AACA,6BAA6B,OAAO,KAAK,OAAO,IAAI,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,EAAE;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wEAAwE,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC,cAAc;AACd;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,YAAY,oBAAoB;AAChC,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,KAAK;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC,cAAc;AACd;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;AAC/C;;AAEA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,SAAS;AACvB,gBAAgB,sBAAsB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qGAAqG;AACrG,wIAAwI;AACxI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,MAAM,iBAAiB,MAAM,aAAa,YAAY,IAAI,QAAQ;AAC1G;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,cAAc,QAAQ;AACtB,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;;AAEA,iEAAiE;AACjE,oBAAoB,6BAA6B;AACjD;AACA;AACA,sCAAsC;AACtC,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,SAAS,2IAA2I;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB,sBAAsB;;AAEtB;AACA,uBAAuB,QAAQ;AAC/B,qCAAqC;;AAErC;AACA;AACA,8BAA8B;AAC9B,2CAA2C;AAC3C;AACA,gDAAgD;;AAEhD,iEAAiE;AACjE;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,SAAS;AACT,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C,2DAA2D,yBAAyB;AACpF,yDAAyD,OAAO;;AAEhE;AACA;AACA;AACA;AACA,iCAAiC;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA,IAAI,GAAG;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe,QAAQ,iBAAiB,OAAO,QAAQ,OAAO,WAAW;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,qBAAqB,eAAe,QAAQ;AAC5C,qBAAqB,SAAS,QAAQ;AACtC,qBAAqB,yBAAyB,QAAQ;AACtD,qBAAqB,wBAAwB,QAAQ;AACrD;AACA;AACA;AACA,kBAAkB;AAClB,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,gDAAgD;AAChD,mDAAmD;AACnD,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,mBAAmB,QAAQ,qGAAqG,YAAY,qFAAqF,YAAY;AACnS;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,mBAAmB,QAAQ,kGAAkG,MAAM,0IAA0I,KAAK;AACxU;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,KAAK,QAAQ,GAAG,QAAQ,GAAG,iBAAiB,MAAM,mBAAmB,QAAQ,0EAA0E,KAAK,mBAAmB,GAAG,QAAQ,GAAG,+CAA+C,MAAM,qGAAqG,QAAQ;AAC1b;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,qEAAqE,GAAG,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,qEAAqE,GAAG,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,wFAAwF,QAAQ,EAAE,QAAQ,wCAAwC,QAAQ,EAAE,QAAQ,wCAAwC,QAAQ,EAAE,QAAQ;AAC9N;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,mFAAmF,OAAO,mCAAmC,OAAO,mCAAmC,OAAO;AAC9K;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,mFAAmF,OAAO,eAAe,QAAQ,mCAAmC,OAAO,eAAe,QAAQ,mCAAmC,OAAO,eAAe,QAAQ;AACnP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,OAAO,GAAG,EAAE,MAAM,KAAK,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,KAAK;AACL;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA,KAAK;AACL;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,IAAI;AACJ;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,YAAY;AACzC,qCAAqC;AACrC;AACA;;AAEA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,6BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6BAA6B,WAAW;AACxC;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc,SAAS,UAAU,MAAM,cAAc,QAAQ,IAAI,EAAE,cAAc;AAC7H;AACA,iDAAiD,WAAW;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,SAAS;AACT;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,kBAAkB,4BAA4B,EAAE,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,IAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA,IAAI;AACJ,6BAA6B;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,qFAAqF,YAAY;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,iBAAiB;AAC5C;AACA;AACA,mBAAmB,YAAY,UAAU,aAAa,IAAI,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sFAAsF,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,4CAA4C;AAC5C;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA,2CAA2C;AAC3C;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,KAAK,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB;AACpB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB;AACpB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2BAA2B,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB;AACpB;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,oBAAoB;AACpB;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC;AAChC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,IAAI;AACJ;AACA;AACA,qBAAqB;AACrB;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,oBAAoB,sBAAsB;AAC1C;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB,gBAAgB,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,aAAa;AAC3B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,oBAAoB;AAClC,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,cAAc,gBAAgB;AAC9B,cAAc,IAAI;AAClB,cAAc,SAAS;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc,gBAAgB,sDAAsD,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,QAAQ;AACxB;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,MAAM;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA,cAAc,YAAY;AAC1B,eAAe,yEAAyE;AACxF,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,cAAc,MAAM;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,QAAQ;;AAER;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,oCAAoC;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,gCAAgC;AAChC;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,8BAA8B;AAC9B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,eAAe;AACf;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,eAAe;AACf;AACA;AACA,sEAAsE;AACtE,MAAM;AACN;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,WAAW;AACvB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,WAAW;AACvB,YAAY,QAAQ;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,WAAW;AACvB,YAAY,QAAQ;AACpB,eAAe,QAAQ;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,0EAA0E;AAC1E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,8HAA8H;AAC5N,8FAA8F,8HAA8H;AAC5N;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yDAAyD;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uEAAuE;AACvE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sEAAsE;AACtE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,+CAA+C;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C,2CAA2C;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,YAAY;AAC3B,eAAe,iBAAiB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,EAAE;AACF,aAAa;AACb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,8BAA8B,SAAS;AACvC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,OAAO,wBAAwB,OAAO;AAC9G;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE,IAAI,EAAE;AAChD;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB,gCAAgC;AAChC,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,IAAI;AACJ;AACA,qCAAqC;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,iDAAiD;;AAEjD;AACA,iIAAiI;AACjI,wFAAwF;AACxF,qHAAqH;AACrH,2CAA2C;;AAE3C;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,IAAI;AACJ,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,gFAAgF,KAAK;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,MAAM;AACN,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,iFAAiF,KAAK;AACtF;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,cAAc;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4DAA4D;AAC5D;AACA;AACA,0DAA0D;AAC1D;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,6BAA6B;AAC7B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB;AACpB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,IAAI;;AAEV;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C,cAAc,QAAQ,kCAAkC,2BAA2B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iEAAiE;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C,cAAc,GAAG;AACjB,cAAc,eAAe;AAC7B;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,GAAG;AACjB,cAAc,eAAe;AAC7B;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,GAAG;AACjB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,IAAI;AACJ,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,eAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW;AACjB;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW;AACjB;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,mDAAmD;AACnD;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA,+CAA+C;AAC/C;AACA,IAAI;AACJ,4CAA4C;AAC5C;AACA,IAAI;AACJ,4CAA4C;AAC5C;AACA,IAAI;AACJ,iDAAiD;AACjD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,+DAA+D;AAC/D;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,0CAA0C;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,iDAAiD;AACjD;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,gDAAgD;AAChD;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sDAAsD;AACtD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,sCAAsC;AACtC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA,6CAA6C;AAC7C,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,aAAa;AACb,6CAA6C;AAC7C;AACA;AACA;AACA,SAAS;AACT,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA,sCAAsC;AACtC;AACA;AACA,IAAI;AACJ,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,mDAAmD;AACnD,6DAA6D;AAC7D,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,iDAAiD;AACjD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP,yBAAyB,EAAE,GAAG,EAAE;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,MAAM,GAAG,UAAU,GAAG,WAAW;AACvD,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,yCAAyC;AACzC,oBAAoB;AACpB,IAAI;AACJ;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,0EAA0E;AAC1E,sDAAsD;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,6DAA6D,qBAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wEAAwE;AACxE,wGAAwG;AACxG,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8FAA8F;AAC9F,4GAA4G;AAC5G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,eAAe;AACnG;AACA;AACA;AACA,cAAc;AACd;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,IAAI;AACJ,4CAA4C;AAC5C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP,kCAAkC,GAAG;AACrC,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP,mCAAmC,GAAG;AACtC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,4BAA4B;AAC5B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,oDAAoD;AACpD,oDAAoD;AACpD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,uBAAuB;AACvB;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,4BAA4B;AAC5B,iCAAiC;AACjC,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,uBAAuB,eAAe,GAAG,MAAM;AAC/C,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yBAAyB;AACzB,QAAQ;AACR;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,QAAQ;AACR,oFAAoF;AACpF;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,yBAAyB,aAAa;AACrD;AACA;AACA,MAAM;AACN;AACA,eAAe,yBAAyB,eAAe;AACvD;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,gCAAgC;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sBAAsB,IAAI,IAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,cAAc,uBAAuB;AACrC;AACA,uCAAuC;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,QAAQ;AACtB,cAAc,gBAAgB;AAC9B,cAAc,QAAQ;AACtB;AACA,uCAAuC;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,GAAG;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6BAA6B;AAC7B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,qCAAqC,4BAA4B,EAAE;AACnE;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oDAAoD;AACpD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,6BAA6B,cAAc;AAC3C,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA,6BAA6B;AAC7B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ,6DAA6D;AAC7D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,iEAAiE;AACjE,wCAAwC;AACxC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,2CAA2C;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA,uBAAuB;AACvB;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA,IAAI;AACJ;AACA;AACA,yCAAyC,OAAO;AAChD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,GAAG,WAAW;AACjE;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,mCAAmC;AACnC,yCAAyC;AACzC;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,GAAG,YAAY;AACnE;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS,GAAG,SAAS,WAAW,MAAM;AAC7F,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,oCAAoC;;;;;;;;;;;;;;;;;;;;;;;;;;;AChxtC2B;AACN;AACQ;AACJ;AACN;AACZ;AACM;AACM;AACD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE,aAAa;AACnF;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,uBAAuB;AACvB;AACA;AACA;AACA,OAAO;AACP,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,qBAAqB,mEAAS,cAAc,2EAAiB,yCAAyC,2EAAiB;AACvH,kBAAkB,2EAAiB;AACnC,WAAW;AACX;;AAEA,+BAA+B,oEAAc,CAAC,iEAAW,yDAAyD;;AAElH;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA,qBAAqB,0EAAgB,YAAY,yEAAe;AAChE,kBAAkB,uEAAa;AAC/B,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA,6CAA6C,KAAK;;AAElD;AACA,sEAAsE;AACtE,SAAS;;AAET,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA,cAAc,8DAAQ;AACtB;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACO,mDAAmD;;;;;;;;;;;;;;;;;;ACpMX;AAChC;AACf,2DAA2D;;AAE3D;AACA;AACA,IAAI;AACJ,uBAAuB,4DAAY;AACnC;;AAEA;AACA;AACA;AACA,UAAU;;;AAGV;AACA,QAAQ;AACR,MAAM;;;AAGN;AACA,C;;;;;;;;;;;;;;;;;;;ACtB2D;AAClB;AACF;AACc;AACtC;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,6DAAa;AA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;AACA;;AAEA;AACA,C;;;;;;;;;;;;;;;;ACT2C;AAC5B;AACf,uCAAuC,2DAAW;AAClD,C;;;;;;;;;;;;;;;;;;;ACHmD;AACJ;AACR;AACU;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;;AAEA;AACA;AACA;;AAEA,qBAAqB,+DAAe;AACpC;AACA,YAAY,yDAAS;AACrB,+DAA+D,8DAAc;AAC7E;AACA;AACA,uCAAuC,6DAAa;AACpD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA,CAAC;AACM;AACP;AACA,CAAC,OAAO;;AAED;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,gH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BoB;AACU,CAAC;;AAEgE,CAAC;;AAE5D,CAAC;;;;;;;;;;;;;;;;;;;ACLU;AACK,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC,SAAS,uEAAa,cAAc,qEAAW;AAC/C;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uHAAuH;;AAEvH;AACA;AACA;AACA,OAAO,IAAI,GAAG;;AAEd,WAAW,uEAAa,cAAc,qEAAW;AACjD;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;;;;;ACnF2D;AACF;AACV;AACc;AACc;AAChC;AACoB;AACN;AACa,CAAC;;AAExE;AACA,oEAAoE;AACpE;AACA,GAAG;AACH,SAAS,wEAAkB,yCAAyC,qEAAe,UAAU,qDAAc;AAC3G;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAgB;AACtC,aAAa,8EAAwB;AACrC,oBAAoB,2CAAI,EAAE,4CAAK;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,uEAAa;AAC/B,+BAA+B,0CAAG,GAAG,2CAAI;AACzC,+BAA+B,6CAAM,GAAG,4CAAK;AAC7C;AACA;AACA,0BAA0B,yEAAe;AACzC;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,eAAe,wDAAM,oBAAoB;;AAEzC;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,kEAAQ;AACf;AACA;;AAEA;AACA,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;;;;;ACzF2D;AACE;AACZ;AACkB;AACJ;AACJ;AACR;AACX,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,qDAAK;AACZ,OAAO,qDAAK;AACZ;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,2CAAI;AAClB,cAAc,0CAAG;AACjB;;AAEA;AACA,uBAAuB,yEAAe;AACtC;AACA;;AAEA,yBAAyB,mEAAS;AAClC,qBAAqB,4EAAkB;;AAEvC,UAAU,0EAAgB;AAC1B;AACA;AACA;AACA,MAAM;;;AAGN;;AAEA,sBAAsB,0CAAG,mBAAmB,2CAAI,kBAAkB,4CAAK,mBAAmB,0CAAG;AAC7F,cAAc,6CAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,2CAAI,mBAAmB,0CAAG,kBAAkB,6CAAM,mBAAmB,0CAAG;AAC9F,cAAc,4CAAK;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG,EAAE,mEAAS;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,oCAAoC;AAC/D;;AAEA,yBAAyB,qCAAqC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAgB;AAC/B,eAAe,kEAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,mDAAmD;AAC7F;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yCAAyC,kDAAkD;AAC3F;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,4CAA4C;AAC5C;AACA,GAAG;AACH,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;ACxKiD,CAAC;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAS;AACxB;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;;;AChDmE;AACR;AAC0B;AAC9B;AACY;AACA;AAChB,CAAC;;AAErD;AACA,MAAM,sEAAgB,gBAAgB,2CAAI;AAC1C;AACA;;AAEA,0BAA0B,0EAAoB;AAC9C,UAAU,mFAA6B,gCAAgC,mFAA6B;AACpG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAgB;AACtC;AACA,iGAAiG,0EAAoB;AACrH;AACA,sBAAsB,sEAAgB,gBAAgB,2CAAI,GAAG,0EAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA,yBAAyB,sEAAgB;;AAEzC,2BAA2B,kEAAY,gBAAgB,4CAAK;AAC5D,sBAAsB,0CAAG,EAAE,6CAAM;AACjC;AACA,mBAAmB,oEAAc;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,4CAAK,GAAG,2CAAI,sBAAsB,6CAAM,GAAG,0CAAG;;AAE1G;AACA,0BAA0B,0EAAoB;AAC9C;;AAEA,2BAA2B,0EAAoB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;AClJsD;AACC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,0CAAG,EAAE,4CAAK,EAAE,6CAAM,EAAE,2CAAI;AAClC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAc;AACxC;AACA,GAAG;AACH,0BAA0B,oEAAc;AACxC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,GAAG;AACH,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DyD;AACZ;AACgB;AACE;AACpB;AACA;AACI;AACc;;;;;;;;;;;;;;;;;;;ACPF;AACD,CAAC;;AAErD;AACP,sBAAsB,sEAAgB;AACtC,wBAAwB,2CAAI,EAAE,0CAAG;;AAEjC,mEAAmE;AACnE;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,UAAU,2CAAI,EAAE,4CAAK;AACrB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAU;AACvB;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;ACrDuD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAc;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;;;;;;;ACxB6D;AACF;AACgB;AAC5B;AACY;AACF;AACI;AACN;AACJ;AACY;AACE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAc;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB,sEAAgB;AACtC,kBAAkB,kEAAY;AAC9B;AACA,iBAAiB,8EAAwB;AACzC,gBAAgB,gEAAU;AAC1B;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,0CAAG,GAAG,2CAAI;AAChD,qCAAqC,6CAAM,GAAG,4CAAK;AACnD;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAAK;AACpC,+BAA+B,4CAAK,2CAA2C;AAC/E;;AAEA;AACA,6CAA6C,uEAAa;AAC1D;AACA;AACA;AACA,yHAAyH,wEAAkB;AAC3I;AACA,uDAAuD;AACvD;AACA;AACA;AACA;;AAE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P,C;;;;;;;;;;;;;;;ACLe;AACf;AACA,C;;;;;;;;;;;;;;;ACFmC;AACpB;AACf;AACA,C;;;;;;;;;;;;;;;ACHe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACPe;AACf;AACA,C;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;;;;ACRe;AACf;AACA,C;;;;;;;;;;;;;;;;;ACFO;AACA;AACA,uB;;;;;;;;;;;;;;;ACFQ;AACf;AACA;AACA,sDAAsD;AACtD,+BAA+B;AAC/B,4BAA4B;AAC5B,KAAK;AACL;AACA,GAAG,IAAI,GAAG;;AAEV;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;;;;;ACbyD;AAC1C;AACf,yBAAyB,EAAE,kEAAkB;AAC7C,C;;;;;;;;;;;;;;;;ACH6C,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEe;AACf;AACA,2CAA2C;;AAE3C,SAAS,qDAAc;AACvB;AACA;AACA,KAAK;AACL,GAAG;AACH,C;;;;;;;;;;;;;;;AC3Ce;AACf,yBAAyB;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;;;;ACPe;AACf;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,C;;;;;;;;;;;;;;;;;ACV2D;AACpD;AACP,SAAS,6CAAO,MAAM,6CAAO;AAC7B;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mGAAmG,kCAAkC;AACrI;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,IAAI,IAAI,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D,GAAG;AACH;AACA,uCAAuC,sBAAsB;AAC7D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD,sBAAsB;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG;;AAElG;AACA;AACA,0DAA0D;AAC1D,0EAA0E;AAC1E,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oCAAoC,YAAY,SAAS,mBAAmB,UAAU,uBAAuB,cAAc;AAC1J;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA,cAAc,KAAK,EAAE,eAAe;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8IAA8I,SAAS;AACvJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,oBAAoB;AACzD;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,KAAK;AACxF;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,uCAAuC,YAAY,EAAE,eAAe;;AAEpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,YAAY;AAClD,oCAAoC,YAAY;AAChD,kCAAkC,YAAY;AAC9C,wCAAwC,YAAY;AACpD,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,0BAA0B,YAAY;AACtC,kCAAkC,YAAY;AAC9C,wCAAwC,YAAY;AACpD,wCAAwC,YAAY;AACpD,qCAAqC,YAAY;AACjD,qCAAqC,YAAY,EAAE,eAAe;AAClE,uCAAuC,YAAY,EAAE,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,MAAM;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C,4BAA4B,YAAY;AACxC,gCAAgC,YAAY;AAC5C,uCAAuC,YAAY,EAAE,eAAe;AACpE;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB,GAAG,oBAAoB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAiD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,4BAA4B,YAAY;AACxC,gCAAgC,YAAY;AAC5C,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C,uCAAuC,YAAY,EAAE,eAAe;AACpE,yCAAyC,YAAY,EAAE,eAAe;AACtE,qCAAqC,YAAY,EAAE,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB,GAAG,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,mBAAmB,wDAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC,kCAAkC,YAAY;AAC9C,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6CAA6C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,4BAA4B,YAAY;AACxC,+CAA+C,YAAY;AAC3D,gCAAgC,YAAY;AAC5C,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C,gCAAgC,YAAY;AAC5C,4CAA4C,YAAY;AACxD,oDAAoD,YAAY;AAChE,kDAAkD,YAAY;AAC9D,uCAAuC,YAAY,EAAE,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,qCAAqC,YAAY,EAAE,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C,4BAA4B,YAAY;AACxC,6CAA6C,YAAY;AACzD,gCAAgC,YAAY;AAC5C,8BAA8B,YAAY;AAC1C,uCAAuC,YAAY,EAAE,eAAe;AACpE,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wDAAmB;AAC9B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,kCAAkC,YAAY;AAC9C,4BAA4B,YAAY;AACxC,qCAAqC,YAAY,EAAE,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB,IAAI,oBAAoB,IAAI,mBAAmB,IAAI,oBAAoB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,qBAAqB;AACxF;;AAEA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB,GAAG,oBAAoB;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,YAAY;AACxC,gCAAgC,YAAY;AAC5C,4BAA4B,YAAY;AACxC,8BAA8B,YAAY;AAC1C,qCAAqC,YAAY;AACjD,gCAAgC,YAAY;AAC5C,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA,mCAAmC,6BAA6B,oBAAoB,6BAA6B,gBAAgB,6BAA6B;AAC9J,yGAAyG;AACzG,+BAA+B,eAAe,IAAI,qBAAqB;AACvE,wCAAwC,kBAAkB,2BAA2B,kBAAkB,4BAA4B,kBAAkB;;AAErJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB,yBAAyB,oBAAoB;AAChG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,SAAS;AAC/B,oCAAoC,UAAU;AAC9C,kCAAkC,UAAU;AAC5C,gCAAgC,UAAU;AAC1C,kCAAkC,UAAU;AAC5C,0BAA0B,UAAU;AACpC,8BAA8B,UAAU;AACxC,0BAA0B,UAAU;AACpC,4BAA4B,UAAU;AACtC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEkH;AAClH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC91IA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,sCAAsC,OAAO;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA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AEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA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AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;A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CA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,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EA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AA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;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,OAAO;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,OAAO;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA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;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;;AAE7D;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gEAAgE;;AAEhE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;A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H;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,OAAO;;AAEtB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAyC,QAAQ;;AAEjD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;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A;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,OAAO;;AAE7C;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;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EA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAC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EjE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ,wCAAwC;;AAExC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,cAAc;;AAE/B;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;A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AEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AA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A;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;AACJ;;AAEA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC;AACtC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB;;AAEnB;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC;;AAEtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB;;AAEnB;;AAEA,sCAAsC;;AAEtC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA,mBAAmB;;AAEnB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,4BAA4B;;AAE5B;;AAEA,6CAA6C;;AAE7C;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAkB,SAAS;;AAE3B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,iCAAiC,uBAAuB;;AAExD;;AAEA,mBAAmB,cAAc;;AAEjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC;;AAElC;AACA,oCAAoC;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;AACA,wCAAwC;;AAExC;;AAEA;;AAEA,IAAI;;AAEJ,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,wBAAwB;;AAE1C;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA,oBAAoB,eAAe;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,wBAAwB;;AAE1C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,wBAAwB;;AAE1C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,eAAe;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;;AAEjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA,qBAAqB,cAAc;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,qCAAqC;;AAErC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe;AACf;;AAEA;;AAEA;;AAEA,qCAAqC;;AAErC;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC;;AAErC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;;AAEjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,cAAc;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,cAAc;;AAEjC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mCAAmC;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN,iCAAiC;;AAEjC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,sCAAsC,SAAS;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,sCAAsC,SAAS;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,aAAa;;AAEhC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,SAAS;;AAEjD;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,eAAe;;AAElC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAsB,cAAc;;AAEpC;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,sBAAsB,cAAc;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wFAAwF,cAAc;;AAEtG;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,mCAAmC,gBAAgB;;AAEnD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;;AAEnD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;;AAEnD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,qBAAqB;;AAExC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,sBAAsB;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ;;AAErD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,4BAA4B;;AAE/C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,0BAA0B;;AAE3C;;AAEA,uBAAuB,4CAA4C;;AAEnE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,8CAA8C;;AAEpE;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,sCAAsC,SAAS;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,yCAAyC,OAAO;;AAEhD;AACA;;AAEA,6CAA6C;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,gCAAgC,cAAc;;AAE9C;;AAEA;;AAEA,WAAW;;AAEX;;AAEA,yDAAyD,kCAAkC;AAC3F,kDAAkD,QAAQ;;AAE1D;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA,OAAO;;AAEP;;AAEA,MAAM;;AAEN,wCAAwC,aAAa,mBAAmB,gBAAgB,IAAI,oBAAoB;;AAEhH;;AAEA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,QAAQ;;AAER;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,QAAQ;;AAEpD;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;AACA;;AAEA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,mBAAmB,iBAAiB;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB,WAAW;;AAEjC,sBAAsB;;AAEtB,uBAAuB,0BAA0B;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,mBAAmB,iBAAiB;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;;AAGH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;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AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6CAA6C,OAAO;;AAEpD;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6CAA6C,OAAO;;AAEpD;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,cAAc;;AAElC;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6CAA6C,SAAS;;AAEtD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,iDAAiD,SAAS;;AAE1D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B,cAAc;;AAE1C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,oBAAoB;;AAEvC;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,oBAAoB,cAAc;;AAElC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,cAAc;;AAEjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,cAAc;;AAEjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,GAAG;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,eAAe;;AAEf;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,wEAAwE,SAAS;;AAEjF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wEAAwE,SAAS;;AAEjF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wEAAwE,SAAS;;AAEjF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;;AAE1C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,SAAS;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,sBAAsB,yBAAyB;;AAE/C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,kDAAkD;;AAElD;;AAEA,IAAI,gEAAgE;;AAEpE;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA,iCAAiC;;AAEjC,yCAAyC,SAAS;;AAElD;;AAEA;;AAEA,oBAAoB;AACpB,0BAA0B,aAAa;AACvC,uBAAuB;AACvB,oCAAoC;;AAEpC;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;;AAElD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;;AAEA,KAAK;;AAEL,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;;AAElD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oCAAoC,SAAS;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,SAAS;;AAElD;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;;AAE9C;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN,KAAK;;AAEL,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,oDAAoD,SAAS;;AAE7D;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;;AAElC;AACA;AACA;;AAEA;;AAEA;;AAEA,qCAAqC;;AAErC;AACA;;AAEA,2BAA2B;AAC3B,iCAAiC;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B;;AAE/B,uBAAuB;AACvB,uBAAuB;;AAEvB,iCAAiC;;AAEjC,+BAA+B;AAC/B,6BAA6B;;AAE7B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB;AACjB,wBAAwB;AACxB,yBAAyB;;AAEzB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;;AAGL,4BAA4B;AAC5B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,+CAA+C,SAAS;;AAExD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;;AAExD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,OAAO;;AAEP;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,IAAI,OAAO;;AAEX;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qDAAqD;AACrD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,eAAe;;AAElC;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAyC,SAAS;;AAElD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAyC,SAAS;;AAElD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,uBAAuB;AACvB;;AAEA,oCAAoC;;;AAGpC,kCAAkC;AAClC;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,SAAS;;AAEjD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B,QAAQ;;AAEtC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,gBAAgB;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB;AACjB,mBAAmB,0BAA0B;;AAE7C,gCAAgC;;AAEhC;;AAEA,uCAAuC;;AAEvC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,gDAAgD,SAAS;;AAEzD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,gBAAgB;;AAEvD;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wBAAwB,kBAAkB;;AAE1C;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,8CAA8C,OAAO;;AAErD;;AAEA,oBAAoB,qBAAqB;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,WAAW,cAAc;AACzB,UAAU;AACV,aAAa,cAAc;AAC3B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ,+HAA+H;AAC/H;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,OAAO;;AAE9C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,OAAO;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB,sBAAsB;;AAEtB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB;AACxB,sBAAsB;AACtB,cAAc;;AAEd;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,gCAAgC;;AAE5E;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;;AAErC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,4CAA4C,gGAAgG;;AAE5I;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,0BAA0B,kBAAkB;;AAE5C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,4BAA4B;;AAE9C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,4CAA4C,iDAAiD;;AAE7F;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,yDAAyD,gFAAgF;;AAEzI;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,2CAA2C,iDAAiD;AAC5F;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA,sCAAsC,OAAO;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;;AAE1D;AACA;;AAEA;;AAEA,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;;AAE/B;;AAEA;AACA;AACA;;AAEA,4CAA4C,wCAAwC;;AAEpF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,aAAa;;AAEjC;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,WAAW;;AAE9B;;AAEA;;AAEA,oBAAoB,eAAe;;AAEnC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,4CAA4C,wCAAwC;;AAEpF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,gCAAgC;;AAE5E;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,4CAA4C,yDAAyD;;AAErG;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,+DAA+D,6DAA6D;AAC5H,+DAA+D,6DAA6D;AAC5H,+DAA+D,6DAA6D;AAC5H,+DAA+D,6DAA6D;;AAE5H;;AAEA,+DAA+D,6DAA6D;AAC5H,gEAAgE,8DAA8D;AAC9H,gEAAgE,8DAA8D;AAC9H,gEAAgE,8DAA8D;;AAE9H;;AAEA,gEAAgE,8DAA8D;AAC9H,gEAAgE,8DAA8D;AAC9H,gEAAgE,8DAA8D;AAC9H,gEAAgE,8DAA8D;;AAE9H;;AAEA,uDAAuD,qDAAqD;AAC5G,uDAAuD,qDAAqD;AAC5G,uDAAuD,qDAAqD;AAC5G,uDAAuD,qDAAqD;;AAE5G;;AAEA,iDAAiD,+CAA+C;AAChG,iDAAiD,+CAA+C;AAChG,iDAAiD,+CAA+C;;AAEhG;;AAEA,6DAA6D,2DAA2D;AACxH,0DAA0D,wDAAwD;;AAElH;;AAEA,0DAA0D,wDAAwD;AAClH,0DAA0D,wDAAwD;;AAElH,0DAA0D,wDAAwD;AAClH,0DAA0D,wDAAwD;;AAElH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,OAAO;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,kCAAkC;;AAE9E;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C,sBAAsB,oBAAoB;AAC1C,sBAAsB,oBAAoB;AAC1C,sBAAsB,qBAAqB;AAC3C,uBAAuB,qBAAqB;AAC5C,uBAAuB,qBAAqB;AAC5C,uBAAuB,qBAAqB;AAC5C,uBAAuB,qBAAqB;;AAE5C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,4CAA4C,kCAAkC;;AAE9E;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,4CAA4C,kCAAkC;;AAE9E;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,0DAA0D,sFAAsF;;AAEhJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,gEAAgE,kCAAkC;AAClG;AACA;;AAEA,gEAAgE,kCAAkC;AAClG;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,wCAAwC;;AAEpF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,2CAA2C,OAAO;;AAElD;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;;AAElD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,kCAAkC;AAClC,mCAAmC;;AAEnC;;AAEA;;AAEA;;AAEA,mDAAmD;AACnD,sBAAsB;;AAEtB,OAAO;;AAEP;AACA,6CAA6C;AAC7C;AACA,0BAA0B;;AAE1B;;AAEA,MAAM;;AAEN;AACA,iDAAiD;AACjD;AACA;AACA,mFAAmF;AACnF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;;AAE/C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL,qCAAqC,gCAAgC;;AAErE;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA,gDAAgD,aAAa;;AAE7D;;AAEA;;AAEA,gDAAgD,aAAa;;AAE7D;;AAEA,wBAAwB,mBAAmB;;AAE3C;AACA;;AAEA,0BAA0B,0BAA0B;;AAEpD;;AAEA;;AAEA;;AAEA;AACA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;AACA;;AAEA,0CAA0C,QAAQ;;AAElD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6DAA6D;;AAE7D,6DAA6D;;AAE7D;;AAEA,0BAA0B,oBAAoB;;AAE9C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kEAAkE;AAClE;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEs4N;;;;;;;;;;;;;;;;;AC5xnDv3N;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,sBAAsB;AACtB,oBAAoB;AACpB,iBAAiB,sCAAG;AACpB,mBAAmB,wCAAK;AACxB,kCAAkC,4CAAS;;AAE3C,4BAA4B,kDAAe;;AAE3C;;AAEA;;AAEA;AACA;AACA,8CAA8C;;AAE9C;AACA;;AAEA;AACA,oBAAoB,0CAAO;;AAE3B;AACA,oBAAoB,0CAAO;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,gCAAgC;;AAEhC;AACA;AACA,qCAAqC;AACrC,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA,gBAAgB;;AAEhB;AACA,wBAAwB,MAAM,wCAAK,iBAAiB,wCAAK,eAAe,wCAAK;;AAE7E;AACA,mBAAmB,KAAK,wCAAK,cAAc,wCAAK;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,sBAAsB,0CAAO;;AAE7B;AACA,oBAAoB,6CAAU,sCAAsC,0CAAO;AAC3E;;AAEA,4BAA4B,0CAAO;AACnC,8BAA8B,6CAAU;AACxC,kCAAkC,0CAAO;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C;;AAE1C,0CAA0C;;AAE1C;;AAEA;;AAEA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,8BAA8B,0CAAO;AACrC;;AAEA;AACA;AACA;;AAEA;;AAEA,6BAA6B,0CAAO;AACpC;;AAEA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD;;AAEpD,oEAAoE,gBAAgB;;AAEpF;;AAEA;AACA;;AAEA;;AAEA,4BAA4B,kBAAkB,GAAG;;AAEjD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,wBAAwB,4CAAS;AACjC,6BAA6B,4CAAS;;AAEtC;AACA,wBAAwB,0CAAO;;AAE/B,0BAA0B,0CAAO;AACjC,wBAAwB,0CAAO;AAC/B,0BAA0B,0CAAO;;AAEjC,uBAAuB,0CAAO;AAC9B,qBAAqB,0CAAO;AAC5B,uBAAuB,0CAAO;;AAE9B,yBAAyB,0CAAO;AAChC,uBAAuB,0CAAO;AAC9B,yBAAyB,0CAAO;;AAEhC,6BAA6B,0CAAO;AACpC,oBAAoB,0CAAO;AAC3B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,0CAAO;;AAExB;;AAEA,8CAA8C;AAC9C;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,iBAAiB,0CAAO;;AAExB;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH,sCAAsC;AACtC;;AAEA,sBAAsB,0CAAO;;AAE7B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qEAAqE;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qEAAqE;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB,6DAA6D;;AAElF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SAAS,wCAAK;;AAEd;;AAEA;;AAEA;;AAEA;;AAEA,SAAS,wCAAK;;AAEd;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SAAS,wCAAK;;AAEd;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA,qDAAqD;;AAErD,8DAA8D,+BAA+B;;AAE7F;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA,qDAAqD;;AAErD,iEAAiE,+BAA+B;;AAEhG;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,WAAW,wCAAK;;AAEhB;;AAEA;;AAEA;;AAEA;;AAEA,WAAW,wCAAK;;AAEhB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,WAAW,wCAAK;;AAEhB;;AAEA;;AAEA;;AAEA;;AAEA,WAAW,wCAAK;;AAEhB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,qBAAqB;;AAEzC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,qBAAqB;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,0CAAO;AAC1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,8DAA8D,iBAAiB;;AAE/E,mDAAmD;;AAEnD,gEAAgE,+BAA+B;;AAE/F;;AAEA;;AAEA;;AAEA;;AAEyB;;;;;;;;;;;;;;;;;;ACh+CV;AACyC;;;AAGxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;;AAEA,qDAAqD,QAAQ;;AAE7D;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,gDAAa;AAC7B,gBAAgB,6DAA0B;AAC1C,gBAAgB,4DAAyB;AACzC,gBAAgB,+CAAY;AAC5B,gBAAgB,4DAAyB;AACzC,gBAAgB,2DAAwB;;AAExC,gBAAgB,sDAAmB;AACnC,gBAAgB,iDAAc;AAC9B,gBAAgB,yDAAsB;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,wCAAK;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,mBAAmB;;AAEzC,mBAAmB,wBAAwB;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,4CAAS;;AAEtB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa,aAAa;AAC1B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC,kBAAkB;;AAE3D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,2CAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,mCAAmC;;AAEvE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;;AAE5C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,0CAAO;;AAEvB,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB,0CAAO;;AAEvB,yCAAyC,QAAQ;;AAEjD;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,2BAA2B,iDAAc;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,+BAA+B,oDAAiB;;AAEhD,kBAAkB,kEAAU;;AAE5B;;AAEA,+BAA+B,oDAAiB;;AAEhD,kBAAkB,kEAAU;;AAE5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;;AAErC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;;AAErC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uBAAuB,yCAAM;AAC7B,uBAAuB,+CAAY;AACnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,2CAA2C,gBAAgB;;AAE3D;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;;AAE1C,oBAAoB,wBAAwB;;AAE5C;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,4CAAS;;AAEvB;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,sBAAsB;AACnC,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,cAAc;AAC3B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,aAAa;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE;;AAElE;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB;;AAEtB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC;;AAErC,oBAAoB,6CAAU;;AAE9B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAqB,iBAAiB;;AAEtC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ;;AAER;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,aAAa;AAC1B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,oDAAiB;;AAEvC,SAAS,kEAAU;;AAEnB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,wBAAwB;;AAExB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,yBAAyB,6CAAU;AACnC;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,8CAA8C,OAAO;;AAErD;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,kDAAe;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,uCAAuC;;AAE3D;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,6CAA6C,QAAQ;;AAErD,wBAAwB,wBAAwB;;AAEhD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6DAA6D,QAAQ;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yDAAyD,uDAAuD;;AAEhH,uCAAuC,QAAQ;;AAE/C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,uBAAuB;AACnC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA,UAAU,4CAAS;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,gBAAgB;AAC5B,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;;AAEtC;AACA,wBAAwB,kDAAe;AACvC,mBAAmB,kDAAe;AAClC;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK,uCAAuC,sDAAmB;;AAE/D;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA,qCAAqC,kDAAe;AACpD,sCAAsC,kDAAe;AACrD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;;AAEA;AACA,YAAY,gBAAgB;AAC5B,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,mCAAmC,0CAAO;;AAE1C,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kDAAkD,kDAAe;AACjE;AACA;AACA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gDAAgD,OAAO;;AAEvD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,8CAA8C,OAAO;;AAErD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA,oBAAoB,wCAAK;AACzB;;AAEA,mBAAmB,oBAAoB;;AAEvC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,YAAY,sCAAsC;AAClD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,mBAAmB,kBAAkB;;AAErC,8BAA8B,wCAAK;;AAEnC;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,uBAAuB;;AAE1C;;AAEA;;AAEA,mBAAmB,+BAA+B;;AAElD;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,6CAA6C,QAAQ;;AAErD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,oCAAoC;AACpC;;AAEA;;AAEA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,8BAA8B;AAC9B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAE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ACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;;EAGA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAGA;EACA;EACA;EACA;EACA;EACA;;EAGA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;;EAEA;;EAEA;;EAGA;;EAEA;EACA;EACA;;EAGA;EACA;;EAEA;EACA;EACA;;EAGA;EACA;EACA;EACA;EACA;EACA;;EAEA;;EAGA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;;EAGA,SAAS0W,SAASA,CAAC5W,GAAG,EAAE9E,CAAC,EAAEC,CAAC,EAAE;IAC1B;IACA;IACA;IACA;IACA;IACAoX,EAAE,GAAGrX,CAAC;IACNsX,EAAE,GAAGrX,CAAC;IACN;IACA,IAAI0b,iBAAiB,GAAGtX,KAAK,CAAC8B,WAAW,CAAC,CAAC,CAACe,IAAI,CAAC,UAAAC,EAAE;MAAA,OAAIA,EAAE,CAACnC,GAAG,IAAImC,EAAE,CAACnC,GAAG,IAAI,WAAW;IAAA,EAAC;IACvF,IAAI2W,iBAAiB,EAAE;MACnB;MACA,IAAIzV,WAAW,GAAG7B,KAAK,CAAC8B,WAAW,CAAC,CAAC;MACrC;MACA;MACA,IAAIyV,QAAQ,GAAG1V,WAAW,CAAC6B,MAAM,CAAC,UAAAZ,EAAE;QAAA,OAAIA,EAAE,CAACmL,GAAG,CAAC,QAAQ,CAAC,IAAIjO,KAAK,CAACwB,OAAO,CAACsB,EAAE,CAACmL,GAAG,CAAC,QAAQ,CAAC,CAAC,CAACtN,GAA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","sources":["webpack://npmjs/./node_modules/@joint/core/dist/joint.js","webpack://npmjs/./node_modules/@popperjs/core/lib/createPopper.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/contains.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js","webpack://npmjs/./node_modules/@popperjs/core/lib/enums.js","webpack://npmjs/./node_modules/@popperjs/core/lib/index.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/arrow.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/flip.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/hide.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/index.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/offset.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js","webpack://npmjs/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js","webpack://npmjs/./node_modules/@popperjs/core/lib/popper-lite.js","webpack://npmjs/./node_modules/@popperjs/core/lib/popper.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/computeOffsets.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/debounce.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/detectOverflow.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getAltAxis.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/getVariation.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/math.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/mergeByName.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/orderModifiers.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/userAgent.js","webpack://npmjs/./node_modules/@popperjs/core/lib/utils/within.js","webpack://npmjs/./node_modules/bootstrap/dist/js/bootstrap.esm.js","webpack://npmjs/./node_modules/three/build/three.module.js","webpack://npmjs/./node_modules/three/examples/jsm/controls/OrbitControls.js","webpack://npmjs/./node_modules/three/examples/jsm/exporters/GLTFExporter.js","webpack://npmjs/./node_modules/three/examples/jsm/geometries/TextGeometry.js","webpack://npmjs/./node_modules/three/examples/jsm/libs/lil-gui.module.min.js","webpack://npmjs/./node_modules/three/examples/jsm/loaders/FontLoader.js","webpack://npmjs/./node_modules/three/examples/jsm/utils/TextureUtils.js","webpack://npmjs/./src/modal/modal-interop.js","webpack://npmjs/./src/mySLD.js","webpack://npmjs/./src/myThree.js","webpack://npmjs/./src/threejs/objects/bend.js","webpack://npmjs/./src/threejs/objects/cross.js","webpack://npmjs/./src/threejs/objects/equipment.js","webpack://npmjs/./src/threejs/objects/ladder.js","webpack://npmjs/./src/threejs/objects/node.js","webpack://npmjs/./src/threejs/objects/plane.js","webpack://npmjs/./src/threejs/objects/refPoint.js","webpack://npmjs/./src/threejs/objects/sleeve.js","webpack://npmjs/./src/threejs/objects/tee.js","webpack://npmjs/webpack/bootstrap","webpack://npmjs/webpack/runtime/compat get default export","webpack://npmjs/webpack/runtime/define property getters","webpack://npmjs/webpack/runtime/global","webpack://npmjs/webpack/runtime/hasOwnProperty shorthand","webpack://npmjs/webpack/runtime/make namespace object","webpack://npmjs/./src/index.js"],"sourcesContent":["/*! JointJS v4.2.1 (2025-11-20) - JavaScript diagramming library\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.joint = {}));\n})(this, (function (exports) { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n['default'] || n;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  (function () { return this; })() || Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Detect IE8's incomplete defineProperty implementation\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n\t});\n\n\t'use strict';\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f$4 = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor$2(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f$4\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.es/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject$1 = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject$1(input)) return input;\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty$1 = {}.hasOwnProperty;\n\n\tvar has$2 = function (it, key) {\n\t  return hasOwnProperty$1.call(it, key);\n\t};\n\n\tvar document$2 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject$1(document$2) && isObject$1(document$2.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$2.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$3 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ }\n\t  if (has$2(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$3\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject$1(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    createNonEnumerableProperty(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store$1 = global_1[SHARED] || setGlobal(SHARED, {});\n\n\tvar sharedStore = store$1;\n\n\tvar functionToString = Function.toString;\n\n\t// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\tif (typeof sharedStore.inspectSource != 'function') {\n\t  sharedStore.inspectSource = function (it) {\n\t    return functionToString.call(it);\n\t  };\n\t}\n\n\tvar inspectSource = sharedStore.inspectSource;\n\n\tvar WeakMap$2 = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap$2 === 'function' && /native code/.test(inspectSource(WeakMap$2));\n\n\tvar isPure = false;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.8.3',\n\t  mode: isPure ? 'pure' : 'global',\n\t  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys$1 = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys$1[key] || (keys$1[key] = uid(key));\n\t};\n\n\tvar hiddenKeys$1 = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set$1, get$1, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get$1(it) : set$1(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject$1(it) || (state = get$1(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store = sharedStore.state || (sharedStore.state = new WeakMap$1());\n\t  var wmget = store.get;\n\t  var wmhas = store.has;\n\t  var wmset = store.set;\n\t  set$1 = function (it, metadata) {\n\t    metadata.facade = it;\n\t    wmset.call(store, it, metadata);\n\t    return metadata;\n\t  };\n\t  get$1 = function (it) {\n\t    return wmget.call(store, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys$1[STATE] = true;\n\t  set$1 = function (it, metadata) {\n\t    metadata.facade = it;\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get$1 = function (it) {\n\t    return has$2(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has$2(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set$1,\n\t  get: get$1,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\tvar internalState_1 = internalState.set;\n\tvar internalState_2 = internalState.get;\n\tvar internalState_3 = internalState.has;\n\tvar internalState_4 = internalState.enforce;\n\tvar internalState_5 = internalState.getterFor;\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(String).split('String');\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  var state;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has$2(value, 'name')) {\n\t      createNonEnumerableProperty(value, 'name', key);\n\t    }\n\t    state = enforceInternalState(value);\n\t    if (!state.source) {\n\t      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t    }\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) O[key] = value;\n\t    else setGlobal(key, value);\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) O[key] = value;\n\t  else createNonEnumerableProperty(O, key, value);\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction$1 = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor$1 = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.es/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);\n\t};\n\n\tvar min$6 = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.es/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min$6(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max$4 = Math.max;\n\tvar min$5 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max$4(integer + length, 0) : min$5(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod$2 = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod$2(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod$2(false)\n\t};\n\tvar arrayIncludes_1 = arrayIncludes.includes;\n\tvar arrayIncludes_2 = arrayIncludes.indexOf;\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) !has$2(hiddenKeys$1, key) && has$2(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (has$2(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertynames\n\tvar f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$1\n\t};\n\n\tvar f = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has$2(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data$1[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data$1 = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else targetProperty = target[key];\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) continue;\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  }\n\t};\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar useSymbolAsUid = nativeSymbol\n\t  // eslint-disable-next-line no-undef\n\t  && !Symbol.sham\n\t  // eslint-disable-next-line no-undef\n\t  && typeof Symbol.iterator == 'symbol';\n\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar Symbol$1 = global_1.Symbol;\n\tvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\n\tvar wellKnownSymbol = function (name) {\n\t  if (!has$2(WellKnownSymbolsStore, name)) {\n\t    if (nativeSymbol && has$2(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];\n\t    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n\t  } return WellKnownSymbolsStore[name];\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.es/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `Object.defineProperties` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\t  return O;\n\t};\n\n\tvar html$1 = getBuiltIn('document', 'documentElement');\n\n\tvar GT = '>';\n\tvar LT = '<';\n\tvar PROTOTYPE = 'prototype';\n\tvar SCRIPT = 'script';\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\n\tvar EmptyConstructor = function () { /* empty */ };\n\n\tvar scriptTag = function (content) {\n\t  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n\t};\n\n\t// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\tvar NullProtoObjectViaActiveX = function (activeXDocument) {\n\t  activeXDocument.write(scriptTag(''));\n\t  activeXDocument.close();\n\t  var temp = activeXDocument.parentWindow.Object;\n\t  activeXDocument = null; // avoid memory leak\n\t  return temp;\n\t};\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar NullProtoObjectViaIFrame = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var JS = 'java' + SCRIPT + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html$1.appendChild(iframe);\n\t  // https://github.com/zloirock/core-js/issues/475\n\t  iframe.src = String(JS);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(scriptTag('document.F=Object'));\n\t  iframeDocument.close();\n\t  return iframeDocument.F;\n\t};\n\n\t// Check for document.domain and active x support\n\t// No need to use active x approach when document.domain is not set\n\t// see https://github.com/es-shims/es5-shim/issues/150\n\t// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n\t// avoid IE GC bug\n\tvar activeXDocument;\n\tvar NullProtoObject = function () {\n\t  try {\n\t    /* global ActiveXObject */\n\t    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n\t  } catch (error) { /* ignore */ }\n\t  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n\t  var length = enumBugKeys.length;\n\t  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n\t  return NullProtoObject();\n\t};\n\n\thiddenKeys$1[IE_PROTO$1] = true;\n\n\t// `Object.create` method\n\t// https://tc39.es/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    EmptyConstructor[PROTOTYPE] = anObject(O);\n\t    result = new EmptyConstructor();\n\t    EmptyConstructor[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO$1] = O;\n\t  } else result = NullProtoObject();\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n\t  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {\n\t    configurable: true,\n\t    value: objectCreate(null)\n\t  });\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype$1[UNSCOPABLES][key] = true;\n\t};\n\n\tvar defineProperty$1 = Object.defineProperty;\n\tvar cache = {};\n\n\tvar thrower = function (it) { throw it; };\n\n\tvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n\t  if (has$2(cache, METHOD_NAME)) return cache[METHOD_NAME];\n\t  if (!options) options = {};\n\t  var method = [][METHOD_NAME];\n\t  var ACCESSORS = has$2(options, 'ACCESSORS') ? options.ACCESSORS : false;\n\t  var argument0 = has$2(options, 0) ? options[0] : thrower;\n\t  var argument1 = has$2(options, 1) ? options[1] : undefined;\n\n\t  return cache[METHOD_NAME] = !!method && !fails(function () {\n\t    if (ACCESSORS && !descriptors) return true;\n\t    var O = { length: -1 };\n\n\t    if (ACCESSORS) defineProperty$1(O, 1, { enumerable: true, get: thrower });\n\t    else O[1] = 1;\n\n\t    method.call(O, argument0, argument1);\n\t  });\n\t};\n\n\t'use strict';\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\n\tvar USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$2 }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\tvar es_array_includes = {\n\n\t};\n\n\tvar aFunction = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar functionBindContext = function (fn, that, length) {\n\t  aFunction(fn);\n\t  if (that === undefined) return fn;\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar call = Function.call;\n\n\tvar entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n\t  return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n\t};\n\n\tvar includes$3 = entryUnbind('Array', 'includes');\n\n\tvar includes$2 = includes$3;\n\n\t// `ToObject` abstract operation\n\t// https://tc39.es/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\t// `IsArray` abstract operation\n\t// https://tc39.es/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n\t    else if (isObject$1(C)) {\n\t      C = C[SPECIES];\n\t      if (C === null) C = undefined;\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\n\tvar createMethod$1 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var IS_FILTER_OUT = TYPE == 7;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = functionBindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) target[index] = result; // map\n\t        else if (result) switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } else switch (TYPE) {\n\t          case 4: return false;             // every\n\t          case 7: push.call(target, value); // filterOut\n\t        }\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$1(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.map\n\t  map: createMethod$1(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$1(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.some\n\t  some: createMethod$1(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.every\n\t  every: createMethod$1(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.find\n\t  find: createMethod$1(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$1(6),\n\t  // `Array.prototype.filterOut` method\n\t  // https://github.com/tc39/proposal-array-filtering\n\t  filterOut: createMethod$1(7)\n\t};\n\tvar arrayIteration_1 = arrayIteration.forEach;\n\tvar arrayIteration_2 = arrayIteration.map;\n\tvar arrayIteration_3 = arrayIteration.filter;\n\tvar arrayIteration_4 = arrayIteration.some;\n\tvar arrayIteration_5 = arrayIteration.every;\n\tvar arrayIteration_6 = arrayIteration.find;\n\tvar arrayIteration_7 = arrayIteration.findIndex;\n\tvar arrayIteration_8 = arrayIteration.filterOut;\n\n\t'use strict';\n\n\tvar $find = arrayIteration.find;\n\n\n\n\tvar FIND = 'find';\n\tvar SKIPS_HOLES$1 = true;\n\n\tvar USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);\n\n\t// Shouldn't skip holes\n\tif (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES$1 = false; });\n\n\t// `Array.prototype.find` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.find\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$1 }, {\n\t  find: function find(callbackfn /* , that = undefined */) {\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND);\n\n\tvar es_array_find = {\n\n\t};\n\n\tvar find$1 = entryUnbind('Array', 'find');\n\n\tvar find = find$1;\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod(true)\n\t};\n\tvar stringMultibyte_1 = stringMultibyte.codeAt;\n\tvar stringMultibyte_2 = stringMultibyte.charAt;\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\tvar ObjectPrototype = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has$2(O, IE_PROTO)) return O[IE_PROTO];\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype : null;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n\tvar returnThis$2 = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n\t  }\n\t}\n\n\tvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {\n\t  var test = {};\n\t  // FF44- legacy iterators case\n\t  return IteratorPrototype$2[ITERATOR$4].call(test) !== test;\n\t});\n\n\tif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has$2(IteratorPrototype$2, ITERATOR$4)) {\n\t  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$4, returnThis$2);\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype$2,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n\t};\n\tvar iteratorsCore_1 = iteratorsCore.IteratorPrototype;\n\tvar iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has$2(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {\n\t    defineProperty(it, TO_STRING_TAG$2, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar iterators = {};\n\n\t'use strict';\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject$1(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) setter.call(O, proto);\n\t    else O.__proto__ = proto;\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar IteratorPrototype = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n\t    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$3]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$3] != 'function') {\n\t          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$3, returnThis);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n\t      if (isPure) iterators[TO_STRING_TAG] = returnThis;\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ((!isPure || FORCED) && IterablePrototype[ITERATOR$3] !== defaultIterator) {\n\t    createNonEnumerableProperty(IterablePrototype, ITERATOR$3, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n\t  }\n\n\t  return methods;\n\t};\n\n\t'use strict';\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) return { value: undefined, done: true };\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\tvar es_string_iterator = {\n\n\t};\n\n\tvar iteratorClose = function (iterator) {\n\t  var returnMethod = iterator['return'];\n\t  if (returnMethod !== undefined) {\n\t    return anObject(returnMethod.call(iterator)).value;\n\t  }\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    iteratorClose(iterator);\n\t    throw error;\n\t  }\n\t};\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$2] === it);\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n\t  else object[propertyKey] = value;\n\t};\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$1] = 'z';\n\n\tvar toStringTagSupport = String(test) === '[object z]';\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = toStringTagSupport ? classofRaw : function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) return it[ITERATOR$1]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)];\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\t// `Array.from` method implementation\n\t// https://tc39.es/ecma262/#sec-array.from\n\tvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n\t  var O = toObject(arrayLike);\n\t  var C = typeof this == 'function' ? this : Array;\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var index = 0;\n\t  var length, result, step, iterator, next, value;\n\t  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n\t  // if the target is not iterable or it's an array with the default iterator - use a simple case\n\t  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n\t    iterator = iteratorMethod.call(O);\n\t    next = iterator.next;\n\t    result = new C();\n\t    for (;!(step = next.call(iterator)).done; index++) {\n\t      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n\t      createProperty(result, index, value);\n\t    }\n\t  } else {\n\t    length = toLength(O.length);\n\t    result = new C(length);\n\t    for (;length > index; index++) {\n\t      value = mapping ? mapfn(O[index], index) : O[index];\n\t      createProperty(result, index, value);\n\t    }\n\t  }\n\t  result.length = index;\n\t  return result;\n\t};\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\tvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n\t  Array.from(iterable);\n\t});\n\n\t// `Array.from` method\n\t// https://tc39.es/ecma262/#sec-array.from\n\t_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n\t  from: arrayFrom\n\t});\n\n\tvar es_array_from = {\n\n\t};\n\n\tvar from_1$1 = path.Array.from;\n\n\tvar from_1 = from_1$1;\n\n\t'use strict';\n\n\tvar $findIndex = arrayIteration.findIndex;\n\n\n\n\tvar FIND_INDEX = 'findIndex';\n\tvar SKIPS_HOLES = true;\n\n\tvar USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);\n\n\t// Shouldn't skip holes\n\tif (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });\n\n\t// `Array.prototype.findIndex` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.findindex\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {\n\t  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n\t    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND_INDEX);\n\n\tvar es_array_findIndex = {\n\n\t};\n\n\tvar findIndex$1 = entryUnbind('Array', 'findIndex');\n\n\tvar findIndex = findIndex$1;\n\n\tvar base64 = createCommonjsModule(function (module, exports) {\n\t  (function () {\n\t    /**\n\t     * version: 0.3.0\n\t     * git://github.com/davidchambers/Base64.js.git\n\t     */\n\n\t    var object = 'object' != 'undefined' ? exports : this; // #8: web workers\n\t    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t    function InvalidCharacterError(message) {\n\t      this.message = message;\n\t    }\n\t    InvalidCharacterError.prototype = new Error();\n\t    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\t    // encoder\n\t    // [https://gist.github.com/999166] by [https://github.com/nignag]\n\t    object.btoa || (object.btoa = function (input) {\n\t      var str = String(input);\n\t      for (\n\t      // initialize result and counter\n\t      var block, charCode, idx = 0, map = chars, output = '';\n\t      // if the next str index does not exist:\n\t      //   change the mapping table to \"=\"\n\t      //   check if d has no fractional digits\n\t      str.charAt(idx | 0) || (map = '=', idx % 1);\n\t      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n\t      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n\t        charCode = str.charCodeAt(idx += 3 / 4);\n\t        if (charCode > 0xFF) {\n\t          throw new InvalidCharacterError('\\'btoa\\' failed: The string to be encoded contains characters outside of the Latin1 range.');\n\t        }\n\t        block = block << 8 | charCode;\n\t      }\n\t      return output;\n\t    });\n\n\t    // decoder\n\t    // [https://gist.github.com/1020396] by [https://github.com/atk]\n\t    object.atob || (object.atob = function (input) {\n\t      var str = String(input).replace(/=+$/, '');\n\t      if (str.length % 4 == 1) {\n\t        throw new InvalidCharacterError('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n\t      }\n\t      for (\n\t      // initialize result and counters\n\t      var bc = 0, bs, buffer, idx = 0, output = '';\n\t      // get next character\n\t      // eslint-disable-next-line no-cond-assign\n\t      buffer = str.charAt(idx++);\n\t      // character found in table? initialize bit storage and add its ascii value;\n\t      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n\t      // and if not first of each 4 characters,\n\t      // convert the first 8 bits to one ascii character\n\t      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n\t        // try to find character in table (0-63, not found => -1)\n\t        buffer = chars.indexOf(buffer);\n\t      }\n\t      return output;\n\t    });\n\t  })();\n\t});\n\n\t// `Number.isNaN` method\n\t// https://tc39.es/ecma262/#sec-number.isnan\n\t_export({ target: 'Number', stat: true }, {\n\t  isNaN: function isNaN(number) {\n\t    // eslint-disable-next-line no-self-compare\n\t    return number != number;\n\t  }\n\t});\n\n\tvar es_number_isNan = {\n\n\t};\n\n\tvar isNan$1 = path.Number.isNaN;\n\n\tvar isNan = isNan$1;\n\n\tvar globalIsFinite = global_1.isFinite;\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\tvar numberIsFinite = Number.isFinite || function isFinite(it) {\n\t  return typeof it == 'number' && globalIsFinite(it);\n\t};\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\t_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\n\tvar es_number_isFinite = {\n\n\t};\n\n\tvar _isFinite$1 = path.Number.isFinite;\n\n\tvar _isFinite = _isFinite$1;\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.es/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject$1(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (error1) {\n\t    try {\n\t      regexp[MATCH] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (error2) { /* empty */ }\n\t  } return false;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\t// `String.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar es_string_includes = {\n\n\t};\n\n\tvar includes$1 = entryUnbind('String', 'includes');\n\n\tvar includes = includes$1;\n\n\t'use strict';\n\n\tvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\tvar nativeStartsWith = ''.startsWith;\n\tvar min$4 = Math.min;\n\n\tvar CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');\n\t// https://github.com/zloirock/core-js/pull/702\n\tvar MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n\t  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');\n\t  return descriptor && !descriptor.writable;\n\t}();\n\n\t// `String.prototype.startsWith` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.startswith\n\t_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n\t  startsWith: function startsWith(searchString /* , position = 0 */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));\n\t    var search = String(searchString);\n\t    return nativeStartsWith\n\t      ? nativeStartsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n\tvar es_string_startsWith = {\n\n\t};\n\n\tvar startsWith$1 = entryUnbind('String', 'startsWith');\n\n\tvar startsWith = startsWith$1;\n\n\t(function () {\n\t  if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {\n\t    return;\n\t  }\n\t  function subarray(start, end) {\n\t    return this.slice(start, end);\n\t  }\n\t  function set_(array, offset) {\n\t    if (arguments.length < 2) {\n\t      offset = 0;\n\t    }\n\t    for (var i = 0, n = array.length; i < n; ++i, ++offset) {\n\t      this[offset] = array[i] & 0xFF;\n\t    }\n\t  }\n\n\t  // we need typed arrays\n\t  function TypedArray(arg1) {\n\t    var result;\n\t    if (typeof arg1 === 'number') {\n\t      result = new Array(arg1);\n\t      for (var i = 0; i < arg1; ++i) {\n\t        result[i] = 0;\n\t      }\n\t    } else {\n\t      result = arg1.slice(0);\n\t    }\n\t    result.subarray = subarray;\n\t    result.buffer = result;\n\t    result.byteLength = result.length;\n\t    result.set = set_;\n\t    if (typeof arg1 === 'object' && arg1.buffer) {\n\t      result.buffer = arg1.buffer;\n\t    }\n\t    return result;\n\t  }\n\t  window.Uint8Array = TypedArray;\n\t  window.Uint32Array = TypedArray;\n\t  window.Int32Array = TypedArray;\n\t})();\n\n\t// Declare shorthands to the most used math functions.\n\tconst {\n\t  round: round$4,\n\t  floor,\n\t  PI: PI$1\n\t} = Math;\n\tconst scale = {\n\t  // Return the `value` from the `domain` interval scaled to the `range` interval.\n\t  linear: function (domain, range, value) {\n\t    var domainSpan = domain[1] - domain[0];\n\t    var rangeSpan = range[1] - range[0];\n\t    return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;\n\t  }\n\t};\n\tconst normalizeAngle = function (angle) {\n\t  return angle % 360 + (angle < 0 ? 360 : 0);\n\t};\n\tconst snapToGrid$1 = function (value, gridSize) {\n\t  return gridSize * round$4(value / gridSize);\n\t};\n\tconst toDeg = function (rad) {\n\t  return 180 * rad / PI$1 % 360;\n\t};\n\tconst toRad = function (deg, over360) {\n\t  over360 = over360 || false;\n\t  deg = over360 ? deg : deg % 360;\n\t  return deg * PI$1 / 180;\n\t};\n\n\t// Return a random integer from the interval [min,max], inclusive.\n\tconst random = function (min, max) {\n\t  if (max === undefined) {\n\t    // use first argument as max, min is 0\n\t    max = min === undefined ? 1 : min;\n\t    min = 0;\n\t  } else if (max < min) {\n\t    // switch max and min\n\t    const temp = min;\n\t    min = max;\n\t    max = temp;\n\t  }\n\t  return floor(Math.random() * (max - min + 1) + min);\n\t};\n\n\t// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\tconst {\n\t  cos: cos$2,\n\t  sin: sin$2,\n\t  atan2: atan2$1\n\t} = Math;\n\tconst bearing = function (p, q) {\n\t  var lat1 = toRad(p.y);\n\t  var lat2 = toRad(q.y);\n\t  var lon1 = p.x;\n\t  var lon2 = q.x;\n\t  var dLon = toRad(lon2 - lon1);\n\t  var y = sin$2(dLon) * cos$2(lat2);\n\t  var x = cos$2(lat1) * sin$2(lat2) - sin$2(lat1) * cos$2(lat2) * cos$2(dLon);\n\t  var brng = toDeg(atan2$1(y, x));\n\t  var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\t  var index = brng - 22.5;\n\t  if (index < 0) index += 360;\n\t  index = parseInt(index / 45);\n\t  return bearings[index];\n\t};\n\n\t// @return {integer} length without sqrt\n\t// @note for applications where the exact length is not necessary (e.g. compare only)\n\tconst squaredLength = function (start, end) {\n\t  var x0 = start.x;\n\t  var y0 = start.y;\n\t  var x1 = end.x;\n\t  var y1 = end.y;\n\t  return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n\t};\n\n\tconst length = function (start, end) {\n\t  return Math.sqrt(squaredLength(start, end));\n\t};\n\n\tconst types = {\n\t  Point: 1,\n\t  Line: 2,\n\t  Ellipse: 3,\n\t  Rect: 4,\n\t  Polyline: 5,\n\t  Polygon: 6,\n\t  Curve: 7,\n\t  Path: 8\n\t};\n\n\t/*\n\t    Point is the most basic object consisting of x/y coordinate.\n\n\t    Possible instantiations are:\n\t    * `Point(10, 20)`\n\t    * `new Point(10, 20)`\n\t    * `Point('10 20')`\n\t    * `Point(Point(10, 20))`\n\t*/\n\tconst {\n\t  abs: abs$2,\n\t  cos: cos$1,\n\t  sin: sin$1,\n\t  sqrt: sqrt$2,\n\t  min: min$3,\n\t  max: max$3,\n\t  atan2,\n\t  round: round$3,\n\t  pow: pow$3,\n\t  PI\n\t} = Math;\n\tconst Point = function (x, y) {\n\t  if (!(this instanceof Point)) {\n\t    return new Point(x, y);\n\t  }\n\t  if (typeof x === 'string') {\n\t    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n\t    x = parseFloat(xy[0]);\n\t    y = parseFloat(xy[1]);\n\t  } else if (Object(x) === x) {\n\t    y = x.y;\n\t    x = x.x;\n\t  }\n\t  this.x = x === undefined ? 0 : x;\n\t  this.y = y === undefined ? 0 : y;\n\t};\n\n\t// Alternative constructor, from polar coordinates.\n\t// @param {number} Distance.\n\t// @param {number} Angle in radians.\n\t// @param {point} [optional] Origin.\n\tPoint.fromPolar = function (distance, angle, origin) {\n\t  origin = new Point(origin);\n\t  var x = abs$2(distance * cos$1(angle));\n\t  var y = abs$2(distance * sin$1(angle));\n\t  var deg = normalizeAngle(toDeg(angle));\n\t  if (deg < 90) {\n\t    y = -y;\n\t  } else if (deg < 180) {\n\t    x = -x;\n\t    y = -y;\n\t  } else if (deg < 270) {\n\t    x = -x;\n\t  }\n\t  return new Point(origin.x + x, origin.y + y);\n\t};\n\n\t// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\tPoint.random = function (x1, x2, y1, y2) {\n\t  return new Point(random(x1, x2), random(y1, y2));\n\t};\n\tPoint.prototype = {\n\t  type: types.Point,\n\t  chooseClosest: function (points) {\n\t    var n = points.length;\n\t    if (n === 1) return new Point(points[0]);\n\t    var closest = null;\n\t    var minSqrDistance = Infinity;\n\t    for (var i = 0; i < n; i++) {\n\t      var p = new Point(points[i]);\n\t      var sqrDistance = this.squaredDistance(p);\n\t      if (sqrDistance < minSqrDistance) {\n\t        closest = p;\n\t        minSqrDistance = sqrDistance;\n\t      }\n\t    }\n\t    return closest;\n\t  },\n\t  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n\t  // otherwise return point itself.\n\t  // (see Squeak Smalltalk, Point>>adhereTo:)\n\t  adhereToRect: function (r) {\n\t    if (r.containsPoint(this)) {\n\t      return this;\n\t    }\n\t    this.x = min$3(max$3(this.x, r.x), r.x + r.width);\n\t    this.y = min$3(max$3(this.y, r.y), r.y + r.height);\n\t    return this;\n\t  },\n\t  // Compute the angle between vector from me to p1 and the vector from me to p2.\n\t  // ordering of points p1 and p2 is important!\n\t  // theta function's angle convention:\n\t  // returns angles between 0 and 180 when the angle is counterclockwise\n\t  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n\t  // returns NaN if any of the points p1, p2 is coincident with this point\n\t  angleBetween: function (p1, p2) {\n\t    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n\t    if (angleBetween < 0) {\n\t      angleBetween += 360; // correction to keep angleBetween between 0 and 360\n\t    }\n\t    return angleBetween;\n\t  },\n\t  // Return the bearing between me and the given point.\n\t  bearing: function (point) {\n\t    return bearing(this, point);\n\t  },\n\t  // Returns change in angle from my previous position (-dx, -dy) to my new position\n\t  // relative to ref point.\n\t  changeInAngle: function (dx, dy, ref) {\n\t    // Revert the translation and measure the change in angle around x-axis.\n\t    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n\t  },\n\t  clone: function () {\n\t    return new Point(this);\n\t  },\n\t  // Returns the cross product of this point relative to two other points\n\t  // this point is the common point\n\t  // point p1 lies on the first vector, point p2 lies on the second vector\n\t  // watch out for the ordering of points p1 and p2!\n\t  // positive result indicates a clockwise (\"right\") turn from first to second vector\n\t  // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n\t  // zero indicates that the first and second vector are collinear\n\t  // note that the above directions are reversed from the usual answer on the Internet\n\t  // that is because we are in a left-handed coord system (because the y-axis points downward)\n\t  cross: function (p1, p2) {\n\t    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n\t  },\n\t  difference: function (dx, dy) {\n\t    if (Object(dx) === dx) {\n\t      dy = dx.y;\n\t      dx = dx.x;\n\t    }\n\t    return new Point(this.x - (dx || 0), this.y - (dy || 0));\n\t  },\n\t  // Returns distance between me and point `p`.\n\t  distance: function (p) {\n\t    return length(this, p);\n\t  },\n\t  // Returns the dot product of this point with given other point\n\t  dot: function (p) {\n\t    return p ? this.x * p.x + this.y * p.y : NaN;\n\t  },\n\t  equals: function (p) {\n\t    return !!p && this.x === p.x && this.y === p.y;\n\t  },\n\t  // Linear interpolation\n\t  lerp: function (p, t) {\n\t    var x = this.x;\n\t    var y = this.y;\n\t    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n\t  },\n\t  magnitude: function () {\n\t    return sqrt$2(this.x * this.x + this.y * this.y) || 0.01;\n\t  },\n\t  // Returns a manhattan (taxi-cab) distance between me and point `p`.\n\t  manhattanDistance: function (p) {\n\t    return abs$2(p.x - this.x) + abs$2(p.y - this.y);\n\t  },\n\t  // Move point on line starting from ref ending at me by\n\t  // distance distance.\n\t  move: function (ref, distance) {\n\t    var theta = toRad(new Point(ref).theta(this));\n\t    var offset = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);\n\t    return offset;\n\t  },\n\t  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n\t  normalize: function (length) {\n\t    var scale = (length || 1) / this.magnitude();\n\t    return this.scale(scale, scale);\n\t  },\n\t  // Offset me by the specified amount.\n\t  offset: function (dx, dy) {\n\t    if (Object(dx) === dx) {\n\t      dy = dx.y;\n\t      dx = dx.x;\n\t    }\n\t    this.x += dx || 0;\n\t    this.y += dy || 0;\n\t    return this;\n\t  },\n\t  // Returns a point that is the reflection of me with\n\t  // the center of inversion in ref point.\n\t  reflection: function (ref) {\n\t    return new Point(ref).move(this, this.distance(ref));\n\t  },\n\t  // Rotate point by angle around origin.\n\t  // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n\t  rotate: function (origin, angle) {\n\t    if (angle === 0) return this;\n\t    origin = origin || new Point(0, 0);\n\t    angle = toRad(normalizeAngle(-angle));\n\t    var cosAngle = cos$1(angle);\n\t    var sinAngle = sin$1(angle);\n\t    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n\t    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n\t    this.x = x;\n\t    this.y = y;\n\t    return this;\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$3(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$3(this.x * f) / f;\n\t    this.y = round$3(this.y * f) / f;\n\t    return this;\n\t  },\n\t  // Scale point with origin.\n\t  scale: function (sx, sy, origin) {\n\t    origin = origin && new Point(origin) || new Point(0, 0);\n\t    this.x = origin.x + sx * (this.x - origin.x);\n\t    this.y = origin.y + sy * (this.y - origin.y);\n\t    return this;\n\t  },\n\t  snapToGrid: function (gx, gy) {\n\t    this.x = snapToGrid$1(this.x, gx);\n\t    this.y = snapToGrid$1(this.y, gy || gx);\n\t    return this;\n\t  },\n\t  squaredDistance: function (p) {\n\t    return squaredLength(this, p);\n\t  },\n\t  // Compute the angle between me and `p` and the x axis.\n\t  // (cartesian-to-polar coordinates conversion)\n\t  // Return theta angle in degrees.\n\t  theta: function (p) {\n\t    p = new Point(p);\n\n\t    // Invert the y-axis.\n\t    var y = -(p.y - this.y);\n\t    var x = p.x - this.x;\n\t    var rad = atan2(y, x); // defined for all 0 corner cases\n\n\t    // Correction for III. and IV. quadrant.\n\t    if (rad < 0) {\n\t      rad = 2 * PI + rad;\n\t    }\n\t    return 180 * rad / PI;\n\t  },\n\t  toJSON: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y\n\t    };\n\t  },\n\t  // Converts rectangular to polar coordinates.\n\t  // An origin can be specified, otherwise it's 0@0.\n\t  toPolar: function (o) {\n\t    o = o && new Point(o) || new Point(0, 0);\n\t    var x = this.x;\n\t    var y = this.y;\n\t    this.x = sqrt$2((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\t    this.y = toRad(o.theta(new Point(x, y)));\n\t    return this;\n\t  },\n\t  toString: function () {\n\t    return this.x + '@' + this.y;\n\t  },\n\t  serialize: function () {\n\t    return this.x + ',' + this.y;\n\t  },\n\t  update: function (x, y) {\n\t    if (Object(x) === x) {\n\t      y = x.y;\n\t      x = x.x;\n\t    }\n\t    this.x = x || 0;\n\t    this.y = y || 0;\n\t    return this;\n\t  },\n\t  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n\t  // Returns NaN if p is at 0,0.\n\t  vectorAngle: function (p) {\n\t    var zero = new Point(0, 0);\n\t    return zero.angleBetween(this, p);\n\t  }\n\t};\n\tPoint.prototype.translate = Point.prototype.offset;\n\n\t// For backwards compatibility:\n\tconst point = Point;\n\n\tconst {\n\t  max: max$2,\n\t  min: min$2\n\t} = Math;\n\tconst Line = function (p1, p2) {\n\t  if (!(this instanceof Line)) {\n\t    return new Line(p1, p2);\n\t  }\n\t  if (p1 instanceof Line) {\n\t    return new Line(p1.start, p1.end);\n\t  }\n\t  this.start = new Point(p1);\n\t  this.end = new Point(p2);\n\t};\n\tLine.prototype = {\n\t  type: types.Line,\n\t  // @returns the angle of incline of the line.\n\t  angle: function () {\n\t    var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n\t    return this.start.angleBetween(this.end, horizontalPoint);\n\t  },\n\t  bbox: function () {\n\t    var left = min$2(this.start.x, this.end.x);\n\t    var top = min$2(this.start.y, this.end.y);\n\t    var right = max$2(this.start.x, this.end.x);\n\t    var bottom = max$2(this.start.y, this.end.y);\n\t    return new Rect(left, top, right - left, bottom - top);\n\t  },\n\t  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\t  bearing: function () {\n\t    return bearing(this.start, this.end);\n\t  },\n\t  clone: function () {\n\t    return new Line(this.start, this.end);\n\t  },\n\t  // @return {point} the closest point on the line to point `p`\n\t  closestPoint: function (p) {\n\t    return this.pointAt(this.closestPointNormalizedLength(p));\n\t  },\n\t  closestPointLength: function (p) {\n\t    return this.closestPointNormalizedLength(p) * this.length();\n\t  },\n\t  // @return {number} the normalized length of the closest point on the line to point `p`\n\t  closestPointNormalizedLength: function (p) {\n\t    var product = this.vector().dot(new Line(this.start, p).vector());\n\t    var cpNormalizedLength = min$2(1, max$2(0, product / this.squaredLength()));\n\n\t    // cpNormalizedLength returns `NaN` if this line has zero length\n\t    // we can work with that - if `NaN`, return 0\n\t    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n\t    // (`NaN` is the only value that is not equal to itself)\n\n\t    return cpNormalizedLength;\n\t  },\n\t  closestPointTangent: function (p) {\n\t    return this.tangentAt(this.closestPointNormalizedLength(p));\n\t  },\n\t  // Returns `true` if the point lies on the line.\n\t  containsPoint: function (p) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    if (start.cross(p, end) !== 0) return false;\n\t    // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n\t    var length = this.length();\n\t    if (new Line(start, p).length() > length) return false;\n\t    if (new Line(p, end).length() > length) return false;\n\t    // else: `p` lies between start and end of the line\n\n\t    return true;\n\t  },\n\t  // Divides the line into two at requested `ratio` between 0 and 1.\n\t  divideAt: function (ratio) {\n\t    var dividerPoint = this.pointAt(ratio);\n\n\t    // return array with two lines\n\t    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n\t  },\n\t  // Divides the line into two at requested `length`.\n\t  divideAtLength: function (length) {\n\t    var dividerPoint = this.pointAtLength(length);\n\n\t    // return array with two new lines\n\t    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n\t  },\n\t  equals: function (l) {\n\t    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n\t  },\n\t  // @return {point} Point where I'm intersecting a line.\n\t  // @return [point] Points where I'm intersecting a rectangle.\n\t  // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n\t  intersect: function (shape, opt) {\n\t    if (shape && shape.intersectionWithLine) {\n\t      var intersection = shape.intersectionWithLine(this, opt);\n\n\t      // Backwards compatibility\n\t      if (intersection && shape instanceof Line) {\n\t        intersection = intersection[0];\n\t      }\n\t      return intersection;\n\t    }\n\t    return null;\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n\t    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n\t    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n\t    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n\t    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n\t    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n\t      // No intersection found.\n\t      return null;\n\t    }\n\t    if (det > 0) {\n\t      if (alpha > det || beta > det) {\n\t        return null;\n\t      }\n\t    } else {\n\t      if (alpha < det || beta < det) {\n\t        return null;\n\t      }\n\t    }\n\t    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];\n\t  },\n\t  isDifferentiable: function () {\n\t    return !this.start.equals(this.end);\n\t  },\n\t  // @return {double} length of the line\n\t  length: function () {\n\t    return length(this.start, this.end);\n\t  },\n\t  // @return {point} my midpoint\n\t  midpoint: function () {\n\t    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n\t  },\n\t  parallel: function (distance) {\n\t    const l = this.clone();\n\t    if (!this.isDifferentiable()) return l;\n\t    const {\n\t      start,\n\t      end\n\t    } = l;\n\t    const eRef = start.clone().rotate(end, 270);\n\t    const sRef = end.clone().rotate(start, 90);\n\t    start.move(sRef, distance);\n\t    end.move(eRef, distance);\n\t    return l;\n\t  },\n\t  // @return {point} my point at 't' <0,1>\n\t  pointAt: function (t) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    if (t <= 0) return start.clone();\n\t    if (t >= 1) return end.clone();\n\t    return start.lerp(end, t);\n\t  },\n\t  pointAtLength: function (length) {\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var lineLength = this.length();\n\t    if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n\t    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n\t  },\n\t  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n\t  pointOffset: function (p) {\n\t    // Find the sign of the determinant of vectors (start,end), where p is the query point.\n\t    p = new Point(p);\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n\t    return determinant / this.length();\n\t  },\n\t  rotate: function (origin, angle) {\n\t    this.start.rotate(origin, angle);\n\t    this.end.rotate(origin, angle);\n\t    return this;\n\t  },\n\t  round: function (precision) {\n\t    this.start.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.start.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  // @return {number} scale the line so that it has the requested length\n\t  setLength: function (length) {\n\t    var currentLength = this.length();\n\t    if (!currentLength) return this;\n\t    var scaleFactor = length / currentLength;\n\t    return this.scale(scaleFactor, scaleFactor, this.start);\n\t  },\n\t  // @return {integer} length without sqrt\n\t  // @note for applications where the exact length is not necessary (e.g. compare only)\n\t  squaredLength: function () {\n\t    return squaredLength(this.start, this.end);\n\t  },\n\t  tangentAt: function (t) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n\t    var tangentLine = new Line(start, end);\n\t    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  tangentAtLength: function (length) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var tangentStart = this.pointAtLength(length);\n\t    var tangentLine = new Line(start, end);\n\t    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  toString: function () {\n\t    return this.start.toString() + ' ' + this.end.toString();\n\t  },\n\t  serialize: function () {\n\t    return this.start.serialize() + ' ' + this.end.serialize();\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.start.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  },\n\t  // @return vector {point} of the line\n\t  vector: function () {\n\t    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t  }\n\t};\n\n\t// For backwards compatibility:\n\tLine.prototype.intersection = Line.prototype.intersect;\n\n\t// For backwards compatibility:\n\tconst line$1 = Line;\n\n\tconst {\n\t  sqrt: sqrt$1,\n\t  round: round$2,\n\t  pow: pow$2\n\t} = Math;\n\tconst Ellipse$1 = function (c, a, b) {\n\t  if (!(this instanceof Ellipse$1)) {\n\t    return new Ellipse$1(c, a, b);\n\t  }\n\t  if (c instanceof Ellipse$1) {\n\t    return new Ellipse$1(new Point(c.x, c.y), c.a, c.b);\n\t  }\n\t  c = new Point(c);\n\t  this.x = c.x;\n\t  this.y = c.y;\n\t  this.a = a;\n\t  this.b = b;\n\t};\n\tEllipse$1.fromRect = function (rect) {\n\t  rect = new Rect(rect);\n\t  return new Ellipse$1(rect.center(), rect.width / 2, rect.height / 2);\n\t};\n\tEllipse$1.prototype = {\n\t  type: types.Ellipse,\n\t  bbox: function () {\n\t    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n\t  },\n\t  /**\n\t   * @returns {g.Point}\n\t   */\n\t  center: function () {\n\t    return new Point(this.x, this.y);\n\t  },\n\t  clone: function () {\n\t    return new Ellipse$1(this);\n\t  },\n\t  /**\n\t   * @param {g.Point} p\n\t   * @returns {boolean}\n\t   */\n\t  containsPoint: function (p) {\n\t    return this.normalizedDistance(p) <= 1;\n\t  },\n\t  equals: function (ellipse) {\n\t    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n\t  },\n\t  // inflate by dx and dy\n\t  // @param dx {delta_x} representing additional size to x\n\t  // @param dy {delta_y} representing additional size to y -\n\t  // dy param is not required -> in that case y is sized by dx\n\t  inflate: function (dx, dy) {\n\t    if (dx === undefined) {\n\t      dx = 0;\n\t    }\n\t    if (dy === undefined) {\n\t      dy = dx;\n\t    }\n\t    this.a += 2 * dx;\n\t    this.b += 2 * dy;\n\t    return this;\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var intersections = [];\n\t    var a1 = line.start;\n\t    var a2 = line.end;\n\t    var rx = this.a;\n\t    var ry = this.b;\n\t    var dir = line.vector();\n\t    var diff = a1.difference(new Point(this));\n\t    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n\t    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\t    var a = dir.dot(mDir);\n\t    var b = dir.dot(mDiff);\n\t    var c = diff.dot(mDiff) - 1.0;\n\t    var d = b * b - a * c;\n\t    if (d < 0) {\n\t      return null;\n\t    } else if (d > 0) {\n\t      var root = sqrt$1(d);\n\t      var ta = (-b - root) / a;\n\t      var tb = (-b + root) / a;\n\t      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n\t        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n\t        return null;\n\t      } else {\n\t        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n\t        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n\t      }\n\t    } else {\n\t      var t = -b / a;\n\t      if (0 <= t && t <= 1) {\n\t        intersections.push(a1.lerp(a2, t));\n\t      } else {\n\t        // outside\n\t        return null;\n\t      }\n\t    }\n\t    return intersections;\n\t  },\n\t  // Find point on me where line from my center to\n\t  // point p intersects my boundary.\n\t  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n\t  intersectionWithLineFromCenterToPoint: function (p, angle) {\n\t    p = new Point(p);\n\t    if (angle) p.rotate(new Point(this.x, this.y), angle);\n\t    var dx = p.x - this.x;\n\t    var dy = p.y - this.y;\n\t    var result;\n\t    if (dx === 0) {\n\t      result = this.bbox().pointNearestToPoint(p);\n\t      if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n\t      return result;\n\t    }\n\t    var m = dy / dx;\n\t    var mSquared = m * m;\n\t    var aSquared = this.a * this.a;\n\t    var bSquared = this.b * this.b;\n\t    var x = sqrt$1(1 / (1 / aSquared + mSquared / bSquared));\n\t    x = dx < 0 ? -x : x;\n\t    var y = m * x;\n\t    result = new Point(this.x + x, this.y + y);\n\t    if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n\t    return result;\n\t  },\n\t  /**\n\t   * @param {g.Point} point\n\t   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n\t   */\n\t  normalizedDistance: function (point) {\n\t    var x0 = point.x;\n\t    var y0 = point.y;\n\t    var a = this.a;\n\t    var b = this.b;\n\t    var x = this.x;\n\t    var y = this.y;\n\t    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$2(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$2(this.x * f) / f;\n\t    this.y = round$2(this.y * f) / f;\n\t    this.a = round$2(this.a * f) / f;\n\t    this.b = round$2(this.b * f) / f;\n\t    return this;\n\t  },\n\t  /** Compute angle between tangent and x axis\n\t   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n\t   * @returns {number} angle between tangent and x axis\n\t   */\n\t  tangentTheta: function (p) {\n\t    var refPointDelta = 30;\n\t    var x0 = p.x;\n\t    var y0 = p.y;\n\t    var a = this.a;\n\t    var b = this.b;\n\t    var center = this.bbox().center();\n\t    var m = center.x;\n\t    var n = center.y;\n\t    var q1 = x0 > center.x + a / 2;\n\t    var q3 = x0 < center.x - a / 2;\n\t    var y, x;\n\t    if (q1 || q3) {\n\t      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n\t      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n\t    } else {\n\t      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n\t      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n\t    }\n\t    return new Point(x, y).theta(p);\n\t  },\n\t  toString: function () {\n\t    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\n\t  }\n\t};\n\n\t// For backwards compatibility:\n\tconst ellipse$1 = Ellipse$1;\n\n\tconst {\n\t  abs: abs$1,\n\t  cos,\n\t  sin,\n\t  min: min$1,\n\t  max: max$1,\n\t  round: round$1,\n\t  pow: pow$1\n\t} = Math;\n\tconst Rect = function (x, y, w, h) {\n\t  if (!(this instanceof Rect)) {\n\t    return new Rect(x, y, w, h);\n\t  }\n\t  if (Object(x) === x) {\n\t    y = x.y;\n\t    w = x.width;\n\t    h = x.height;\n\t    x = x.x;\n\t  }\n\t  this.x = x === undefined ? 0 : x;\n\t  this.y = y === undefined ? 0 : y;\n\t  this.width = w === undefined ? 0 : w;\n\t  this.height = h === undefined ? 0 : h;\n\t};\n\tRect.fromEllipse = function (e) {\n\t  e = new Ellipse$1(e);\n\t  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n\t};\n\tRect.fromPointUnion = function (...points) {\n\t  if (points.length === 0) return null;\n\t  const p = new Point();\n\t  let minX, minY, maxX, maxY;\n\t  minX = minY = Infinity;\n\t  maxX = maxY = -Infinity;\n\t  for (let i = 0; i < points.length; i++) {\n\t    p.update(points[i]);\n\t    const x = p.x;\n\t    const y = p.y;\n\t    if (x < minX) minX = x;\n\t    if (x > maxX) maxX = x;\n\t    if (y < minY) minY = y;\n\t    if (y > maxY) maxY = y;\n\t  }\n\t  return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\tRect.fromRectUnion = function (...rects) {\n\t  if (rects.length === 0) return null;\n\t  const r = new Rect();\n\t  let minX, minY, maxX, maxY;\n\t  minX = minY = Infinity;\n\t  maxX = maxY = -Infinity;\n\t  for (let i = 0; i < rects.length; i++) {\n\t    r.update(rects[i]);\n\t    const x = r.x;\n\t    const y = r.y;\n\t    const mX = x + r.width;\n\t    const mY = y + r.height;\n\t    if (x < minX) minX = x;\n\t    if (mX > maxX) maxX = mX;\n\t    if (y < minY) minY = y;\n\t    if (mY > maxY) maxY = mY;\n\t  }\n\t  return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\tRect.prototype = {\n\t  type: types.Rect,\n\t  // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n\t  // @return r {rectangle} representing a bounding box\n\t  bbox: function (angle) {\n\t    return this.clone().rotateAroundCenter(angle);\n\t  },\n\t  rotateAroundCenter: function (angle) {\n\t    if (!angle) return this;\n\t    const {\n\t      width,\n\t      height\n\t    } = this;\n\t    const theta = toRad(angle);\n\t    const st = abs$1(sin(theta));\n\t    const ct = abs$1(cos(theta));\n\t    const w = width * ct + height * st;\n\t    const h = width * st + height * ct;\n\t    this.x += (width - w) / 2;\n\t    this.y += (height - h) / 2;\n\t    this.width = w;\n\t    this.height = h;\n\t    return this;\n\t  },\n\t  bottomLeft: function () {\n\t    return new Point(this.x, this.y + this.height);\n\t  },\n\t  bottomLine: function () {\n\t    return new Line(this.bottomLeft(), this.bottomRight());\n\t  },\n\t  bottomMiddle: function () {\n\t    return new Point(this.x + this.width / 2, this.y + this.height);\n\t  },\n\t  center: function () {\n\t    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t  },\n\t  clone: function () {\n\t    return new Rect(this);\n\t  },\n\t  // @return {bool} true if point p is inside me.\n\t  // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n\t  containsPoint: function (p, opt) {\n\t    let x, y;\n\t    if (!p || typeof p === 'string') {\n\t      // Backwards compatibility: if the point is not provided,\n\t      // the point is considered to be the origin [0, 0].\n\t      ({\n\t        x,\n\t        y\n\t      } = new Point(p));\n\t    } else {\n\t      // Do not create a new Point object if the point is already a Point-like object.\n\t      ({\n\t        x = 0,\n\t        y = 0\n\t      } = p);\n\t    }\n\t    return opt && opt.strict ? x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n\t  },\n\t  // @return {bool} true if rectangle `r` is inside me.\n\t  containsRect: function (r) {\n\t    var r0 = new Rect(this).normalize();\n\t    var r1 = new Rect(r).normalize();\n\t    var w0 = r0.width;\n\t    var h0 = r0.height;\n\t    var w1 = r1.width;\n\t    var h1 = r1.height;\n\t    if (!w0 || !h0 || !w1 || !h1) {\n\t      // At least one of the dimensions is 0\n\t      return false;\n\t    }\n\t    var x0 = r0.x;\n\t    var y0 = r0.y;\n\t    var x1 = r1.x;\n\t    var y1 = r1.y;\n\t    w1 += x1;\n\t    w0 += x0;\n\t    h1 += y1;\n\t    h0 += y0;\n\t    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n\t  },\n\t  corner: function () {\n\t    return new Point(this.x + this.width, this.y + this.height);\n\t  },\n\t  // @return {boolean} true if rectangles are equal.\n\t  equals: function (r) {\n\t    var mr = new Rect(this).normalize();\n\t    var nr = new Rect(r).normalize();\n\t    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n\t  },\n\t  // inflate by dx and dy, recompute origin [x, y]\n\t  // @param dx {delta_x} representing additional size to x\n\t  // @param dy {delta_y} representing additional size to y -\n\t  // dy param is not required -> in that case y is sized by dx\n\t  inflate: function (dx, dy) {\n\t    if (dx === undefined) {\n\t      dx = 0;\n\t    }\n\t    if (dy === undefined) {\n\t      dy = dx;\n\t    }\n\t    this.x -= dx;\n\t    this.y -= dy;\n\t    this.width += 2 * dx;\n\t    this.height += 2 * dy;\n\t    return this;\n\t  },\n\t  // @return {rect} if rectangles intersect, {null} if not.\n\t  intersect: function (r) {\n\t    var myOrigin = this.origin();\n\t    var myCorner = this.corner();\n\t    var rOrigin = r.origin();\n\t    var rCorner = r.corner();\n\n\t    // No intersection found\n\t    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n\t    var x = max$1(myOrigin.x, rOrigin.x);\n\t    var y = max$1(myOrigin.y, rOrigin.y);\n\t    return new Rect(x, y, min$1(myCorner.x, rCorner.x) - x, min$1(myCorner.y, rCorner.y) - y);\n\t  },\n\t  intersectionWithLine: function (line) {\n\t    var r = this;\n\t    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n\t    var points = [];\n\t    var dedupeArr = [];\n\t    var pt, i;\n\t    var n = rectLines.length;\n\t    for (i = 0; i < n; i++) {\n\t      pt = line.intersect(rectLines[i]);\n\t      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n\t        points.push(pt);\n\t        dedupeArr.push(pt.toString());\n\t      }\n\t    }\n\t    return points.length > 0 ? points : null;\n\t  },\n\t  // Find point on my boundary where line starting\n\t  // from my center ending in point p intersects me.\n\t  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n\t  intersectionWithLineFromCenterToPoint: function (p, angle) {\n\t    p = new Point(p);\n\t    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t    var result;\n\t    if (angle) p.rotate(center, angle);\n\n\t    // (clockwise, starting from the top side)\n\t    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];\n\t    var connector = new Line(center, p);\n\t    for (var i = sides.length - 1; i >= 0; --i) {\n\t      var intersection = sides[i].intersection(connector);\n\t      if (intersection !== null) {\n\t        result = intersection;\n\t        break;\n\t      }\n\t    }\n\t    if (result && angle) result.rotate(center, -angle);\n\t    return result;\n\t  },\n\t  leftLine: function () {\n\t    return new Line(this.topLeft(), this.bottomLeft());\n\t  },\n\t  leftMiddle: function () {\n\t    return new Point(this.x, this.y + this.height / 2);\n\t  },\n\t  maxRectScaleToFit: function (rect, origin) {\n\t    rect = new Rect(rect);\n\t    origin || (origin = rect.center());\n\t    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n\t    var ox = origin.x;\n\t    var oy = origin.y;\n\n\t    // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n\t    // so when the scale is applied the point is still inside the rectangle.\n\n\t    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n\t    // Top Left\n\t    var p1 = rect.topLeft();\n\t    if (p1.x < ox) {\n\t      sx1 = (this.x - ox) / (p1.x - ox);\n\t    }\n\t    if (p1.y < oy) {\n\t      sy1 = (this.y - oy) / (p1.y - oy);\n\t    }\n\t    // Bottom Right\n\t    var p2 = rect.bottomRight();\n\t    if (p2.x > ox) {\n\t      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n\t    }\n\t    if (p2.y > oy) {\n\t      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n\t    }\n\t    // Top Right\n\t    var p3 = rect.topRight();\n\t    if (p3.x > ox) {\n\t      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n\t    }\n\t    if (p3.y < oy) {\n\t      sy3 = (this.y - oy) / (p3.y - oy);\n\t    }\n\t    // Bottom Left\n\t    var p4 = rect.bottomLeft();\n\t    if (p4.x < ox) {\n\t      sx4 = (this.x - ox) / (p4.x - ox);\n\t    }\n\t    if (p4.y > oy) {\n\t      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n\t    }\n\t    return {\n\t      sx: min$1(sx1, sx2, sx3, sx4),\n\t      sy: min$1(sy1, sy2, sy3, sy4)\n\t    };\n\t  },\n\t  maxRectUniformScaleToFit: function (rect, origin) {\n\t    var scale = this.maxRectScaleToFit(rect, origin);\n\t    return min$1(scale.sx, scale.sy);\n\t  },\n\t  // Move and expand me.\n\t  // @param r {rectangle} representing deltas\n\t  moveAndExpand: function (r) {\n\t    this.x += r.x || 0;\n\t    this.y += r.y || 0;\n\t    this.width += r.width || 0;\n\t    this.height += r.height || 0;\n\t    return this;\n\t  },\n\t  moveAroundPoint: function (origin, angle) {\n\t    const newCenter = this.center().rotate(origin, angle);\n\t    this.x = newCenter.x - this.width / 2;\n\t    this.y = newCenter.y - this.height / 2;\n\t    return this;\n\t  },\n\t  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n\t  // If width < 0 the function swaps the left and right corners,\n\t  // and it swaps the top and bottom corners if height < 0\n\t  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n\t  normalize: function () {\n\t    var newx = this.x;\n\t    var newy = this.y;\n\t    var newwidth = this.width;\n\t    var newheight = this.height;\n\t    if (this.width < 0) {\n\t      newx = this.x + this.width;\n\t      newwidth = -this.width;\n\t    }\n\t    if (this.height < 0) {\n\t      newy = this.y + this.height;\n\t      newheight = -this.height;\n\t    }\n\t    this.x = newx;\n\t    this.y = newy;\n\t    this.width = newwidth;\n\t    this.height = newheight;\n\t    return this;\n\t  },\n\t  // Offset me by the specified amount.\n\t  offset: function (dx, dy) {\n\t    // pretend that this is a point and call offset()\n\t    // rewrites x and y according to dx and dy\n\t    return Point.prototype.offset.call(this, dx, dy);\n\t  },\n\t  origin: function () {\n\t    return new Point(this.x, this.y);\n\t  },\n\t  // @return {point} a point on my boundary nearest to the given point.\n\t  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n\t  pointNearestToPoint: function (point) {\n\t    point = new Point(point);\n\t    if (this.containsPoint(point)) {\n\t      var side = this.sideNearestToPoint(point);\n\t      switch (side) {\n\t        case 'right':\n\t          return new Point(this.x + this.width, point.y);\n\t        case 'left':\n\t          return new Point(this.x, point.y);\n\t        case 'bottom':\n\t          return new Point(point.x, this.y + this.height);\n\t        case 'top':\n\t          return new Point(point.x, this.y);\n\t      }\n\t    }\n\t    return point.adhereToRect(this);\n\t  },\n\t  rightLine: function () {\n\t    return new Line(this.topRight(), this.bottomRight());\n\t  },\n\t  rightMiddle: function () {\n\t    return new Point(this.x + this.width, this.y + this.height / 2);\n\t  },\n\t  round: function (precision) {\n\t    let f = 1; // case 0\n\t    if (precision) {\n\t      switch (precision) {\n\t        case 1:\n\t          f = 10;\n\t          break;\n\t        case 2:\n\t          f = 100;\n\t          break;\n\t        case 3:\n\t          f = 1000;\n\t          break;\n\t        default:\n\t          f = pow$1(10, precision);\n\t          break;\n\t      }\n\t    }\n\t    this.x = round$1(this.x * f) / f;\n\t    this.y = round$1(this.y * f) / f;\n\t    this.width = round$1(this.width * f) / f;\n\t    this.height = round$1(this.height * f) / f;\n\t    return this;\n\t  },\n\t  // Scale rectangle with origin.\n\t  scale: function (sx, sy, origin) {\n\t    origin = this.origin().scale(sx, sy, origin);\n\t    this.x = origin.x;\n\t    this.y = origin.y;\n\t    this.width *= sx;\n\t    this.height *= sy;\n\t    return this;\n\t  },\n\t  // @return {string} (left|right|top|bottom) side which is nearest to point\n\t  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n\t  sideNearestToPoint: function (point) {\n\t    point = new Point(point);\n\t    var distToLeft = point.x - this.x;\n\t    var distToRight = this.x + this.width - point.x;\n\t    var distToTop = point.y - this.y;\n\t    var distToBottom = this.y + this.height - point.y;\n\t    var closest = distToLeft;\n\t    var side = 'left';\n\t    if (distToRight < closest) {\n\t      closest = distToRight;\n\t      side = 'right';\n\t    }\n\t    if (distToTop < closest) {\n\t      closest = distToTop;\n\t      side = 'top';\n\t    }\n\t    if (distToBottom < closest) {\n\t      // closest = distToBottom;\n\t      side = 'bottom';\n\t    }\n\t    return side;\n\t  },\n\t  snapToGrid: function (gx, gy) {\n\t    var origin = this.origin().snapToGrid(gx, gy);\n\t    var corner = this.corner().snapToGrid(gx, gy);\n\t    this.x = origin.x;\n\t    this.y = origin.y;\n\t    this.width = corner.x - origin.x;\n\t    this.height = corner.y - origin.y;\n\t    return this;\n\t  },\n\t  toJSON: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  },\n\t  topLine: function () {\n\t    return new Line(this.topLeft(), this.topRight());\n\t  },\n\t  topMiddle: function () {\n\t    return new Point(this.x + this.width / 2, this.y);\n\t  },\n\t  topRight: function () {\n\t    return new Point(this.x + this.width, this.y);\n\t  },\n\t  toString: function () {\n\t    return this.origin().toString() + ' ' + this.corner().toString();\n\t  },\n\t  // @return {rect} representing the union of both rectangles.\n\t  union: function (rect) {\n\t    return Rect.fromRectUnion(this, rect);\n\t  },\n\t  update: function (x, y, w, h) {\n\t    if (Object(x) === x) {\n\t      y = x.y;\n\t      w = x.width;\n\t      h = x.height;\n\t      x = x.x;\n\t    }\n\t    this.x = x || 0;\n\t    this.y = y || 0;\n\t    this.width = w || 0;\n\t    this.height = h || 0;\n\t    return this;\n\t  }\n\t};\n\tRect.prototype.bottomRight = Rect.prototype.corner;\n\tRect.prototype.topLeft = Rect.prototype.origin;\n\tRect.prototype.translate = Rect.prototype.offset;\n\n\t// For backwards compatibility:\n\tconst rect = Rect;\n\n\tfunction parsePoints(svgString) {\n\t  // Step 1: Discard surrounding spaces\n\t  const trimmedString = svgString.trim();\n\t  if (trimmedString === '') return [];\n\t  const points = [];\n\n\t  // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n\t  // ReDoS mitigation: Have an anchor at the beginning of each alternation\n\t  // Note: This doesn't simplify double (or more) commas - causes empty coords\n\t  // This regex is used by `split()`, so it doesn't need to use /g\n\t  const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\t  const numCoords = coords.length;\n\t  for (let i = 0; i < numCoords; i += 2) {\n\t    // Step 3: Convert each coord to number\n\t    // Note: If the coord cannot be converted to a number, it will be `NaN`\n\t    // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n\t    // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n\t    points.push({\n\t      x: +coords[i],\n\t      y: +coords[i + 1]\n\t    });\n\t  }\n\t  return points;\n\t}\n\tfunction clonePoints(points) {\n\t  const numPoints = points.length;\n\t  if (numPoints === 0) return [];\n\t  const newPoints = [];\n\t  for (let i = 0; i < numPoints; i++) {\n\t    const point = points[i].clone();\n\t    newPoints.push(point);\n\t  }\n\t  return newPoints;\n\t}\n\n\t// Returns a convex-hull polyline from this polyline.\n\t// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n\t// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n\t// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n\tfunction convexHull(points) {\n\t  const {\n\t    abs\n\t  } = Math;\n\t  var i;\n\t  var n;\n\t  var numPoints = points.length;\n\t  if (numPoints === 0) return []; // if points array is empty\n\n\t  // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\t  var startPoint;\n\t  for (i = 0; i < numPoints; i++) {\n\t    if (startPoint === undefined) {\n\t      // if this is the first point we see, set it as start point\n\t      startPoint = points[i];\n\t    } else if (points[i].y < startPoint.y) {\n\t      // start point should have lowest y from all points\n\t      startPoint = points[i];\n\t    } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n\t      // if two points have the lowest y, choose the one that has highest x\n\t      // there are no points to the right of startPoint - no ambiguity about theta 0\n\t      // if there are several coincident start point candidates, first one is reported\n\t      startPoint = points[i];\n\t    }\n\t  }\n\n\t  // step 2: sort the list of points\n\t  // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n\t  // step 2a: create the point records = [point, originalIndex, angle]\n\t  var sortedPointRecords = [];\n\t  for (i = 0; i < numPoints; i++) {\n\t    var angle = startPoint.theta(points[i]);\n\t    if (angle === 0) {\n\t      angle = 360; // give highest angle to start point\n\t      // the start point will end up at end of sorted list\n\t      // the start point will end up at beginning of hull points list\n\t    }\n\t    var entry = [points[i], i, angle];\n\t    sortedPointRecords.push(entry);\n\t  }\n\n\t  // step 2b: sort the list in place\n\t  sortedPointRecords.sort(function (record1, record2) {\n\t    // returning a negative number here sorts record1 before record2\n\t    // if first angle is smaller than second, first angle should come before second\n\n\t    var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n\t    if (sortOutput === 0) {\n\t      // if the two angles are equal, sort by originalIndex\n\t      sortOutput = record2[1] - record1[1]; // negative if first index larger\n\t      // coincident points will be sorted in reverse-numerical order\n\t      // so the coincident points with lower original index will be considered first\n\t    }\n\t    return sortOutput;\n\t  });\n\n\t  // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\t  if (sortedPointRecords.length > 2) {\n\t    var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n\t    sortedPointRecords.unshift(startPointRecord);\n\t  }\n\n\t  // step 3a: go through sorted points in order and find those with right turns\n\t  // we want to get our results in clockwise order\n\t  var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\t  var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n\t  var currentPointRecord;\n\t  var currentPoint;\n\t  var lastHullPointRecord;\n\t  var lastHullPoint;\n\t  var secondLastHullPointRecord;\n\t  var secondLastHullPoint;\n\t  while (sortedPointRecords.length !== 0) {\n\t    currentPointRecord = sortedPointRecords.pop();\n\t    currentPoint = currentPointRecord[0];\n\n\t    // check if point has already been discarded\n\t    // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\t    if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n\t      // this point had an incorrect turn at some previous iteration of this loop\n\t      // this disqualifies it from possibly being on the hull\n\t      continue;\n\t    }\n\t    var correctTurnFound = false;\n\t    while (!correctTurnFound) {\n\t      if (hullPointRecords.length < 2) {\n\t        // not enough points for comparison, just add current point\n\t        hullPointRecords.push(currentPointRecord);\n\t        correctTurnFound = true;\n\t      } else {\n\t        lastHullPointRecord = hullPointRecords.pop();\n\t        lastHullPoint = lastHullPointRecord[0];\n\t        secondLastHullPointRecord = hullPointRecords.pop();\n\t        secondLastHullPoint = secondLastHullPointRecord[0];\n\t        var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\t        if (crossProduct < 0) {\n\t          // found a right turn\n\t          hullPointRecords.push(secondLastHullPointRecord);\n\t          hullPointRecords.push(lastHullPointRecord);\n\t          hullPointRecords.push(currentPointRecord);\n\t          correctTurnFound = true;\n\t        } else if (crossProduct === 0) {\n\t          // the three points are collinear\n\t          // three options:\n\t          // there may be a 180 or 0 degree angle at lastHullPoint\n\t          // or two of the three points are coincident\n\t          var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\t          var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\t          if (abs(angleBetween - 180) < THRESHOLD) {\n\t            // rounding around 180 to 180\n\t            // if the cross product is 0 because the angle is 180 degrees\n\t            // discard last hull point (add to insidePoints)\n\t            //insidePoints.unshift(lastHullPoint);\n\t            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // do not do anything with current point\n\t            // correct turn not found\n\t          } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n\t            // if the cross product is 0 because two points are the same\n\t            // discard last hull point (add to insidePoints)\n\t            //insidePoints.unshift(lastHullPoint);\n\t            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // do not do anything with current point\n\t            // correct turn not found\n\t          } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n\t            // rounding around 0 and 360 to 0\n\t            // if the cross product is 0 because the angle is 0 degrees\n\t            // remove last hull point from hull BUT do not discard it\n\t            // reenter second-to-last hull point (will be last at next iter)\n\t            hullPointRecords.push(secondLastHullPointRecord);\n\t            // put last hull point back into the sorted point records list\n\t            sortedPointRecords.push(lastHullPointRecord);\n\t            // we are switching the order of the 0deg and 180deg points\n\t            // correct turn not found\n\t          }\n\t        } else {\n\t          // found a left turn\n\t          // discard last hull point (add to insidePoints)\n\t          //insidePoints.unshift(lastHullPoint);\n\t          insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t          // reenter second-to-last hull point (will be last at next iter of loop)\n\t          hullPointRecords.push(secondLastHullPointRecord);\n\t          // do not do anything with current point\n\t          // correct turn not found\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // at this point, hullPointRecords contains the output points in clockwise order\n\t  // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n\t  // step 3b: remove duplicated startPointRecord from the end of the array\n\t  if (hullPointRecords.length > 2) {\n\t    hullPointRecords.pop();\n\t  }\n\n\t  // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\t  var lowestHullIndex; // the lowest originalIndex on the hull\n\t  var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\t  n = hullPointRecords.length;\n\t  for (i = 0; i < n; i++) {\n\t    var currentHullIndex = hullPointRecords[i][1];\n\t    if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n\t      lowestHullIndex = currentHullIndex;\n\t      indexOfLowestHullIndexRecord = i;\n\t    }\n\t  }\n\t  var hullPointRecordsReordered = [];\n\t  if (indexOfLowestHullIndexRecord > 0) {\n\t    var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n\t    var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n\t    hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\t  } else {\n\t    hullPointRecordsReordered = hullPointRecords;\n\t  }\n\t  var hullPoints = [];\n\t  n = hullPointRecordsReordered.length;\n\t  for (i = 0; i < n; i++) {\n\t    hullPoints.push(hullPointRecordsReordered[i][0]);\n\t  }\n\t  return hullPoints;\n\t}\n\n\tconst Polyline$1 = function (points) {\n\t  if (!(this instanceof Polyline$1)) {\n\t    return new Polyline$1(points);\n\t  }\n\t  if (typeof points === 'string') {\n\t    return new Polyline$1.parse(points);\n\t  }\n\t  this.points = Array.isArray(points) ? points.map(Point) : [];\n\t};\n\tPolyline$1.parse = function (svgString) {\n\t  return new Polyline$1(parsePoints(svgString));\n\t};\n\tPolyline$1.fromRect = function (rect) {\n\t  return new Polyline$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft(), rect.topLeft()]);\n\t};\n\tPolyline$1.prototype = {\n\t  type: types.Polyline,\n\t  bbox: function () {\n\t    var x1 = Infinity;\n\t    var x2 = -Infinity;\n\t    var y1 = Infinity;\n\t    var y2 = -Infinity;\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      var x = point.x;\n\t      var y = point.y;\n\t      if (x < x1) x1 = x;\n\t      if (x > x2) x2 = x;\n\t      if (y < y1) y1 = y;\n\t      if (y > y2) y2 = y;\n\t    }\n\t    return new Rect(x1, y1, x2 - x1, y2 - y1);\n\t  },\n\t  clone: function () {\n\t    return new Polyline$1(clonePoints(this.points));\n\t  },\n\t  closestPoint: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    return this.pointAtLength(cpLength);\n\t  },\n\t  closestPointLength: function (p) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return 0; // if points array is empty\n\t    if (numPoints === 1) return 0; // if there is only one point\n\n\t    var cpLength;\n\t    var minSqrDistance = Infinity;\n\t    var length = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var line = new Line(points[i], points[i + 1]);\n\t      var lineLength = line.length();\n\t      var cpNormalizedLength = line.closestPointNormalizedLength(p);\n\t      var cp = line.pointAt(cpNormalizedLength);\n\t      var sqrDistance = cp.squaredDistance(p);\n\t      if (sqrDistance < minSqrDistance) {\n\t        minSqrDistance = sqrDistance;\n\t        cpLength = length + cpNormalizedLength * lineLength;\n\t      }\n\t      length += lineLength;\n\t    }\n\t    return cpLength;\n\t  },\n\t  closestPointNormalizedLength: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    if (cpLength === 0) return 0; // shortcut\n\n\t    var length = this.length();\n\t    if (length === 0) return 0; // prevents division by zero\n\n\t    return cpLength / length;\n\t  },\n\t  closestPointTangent: function (p) {\n\t    var cpLength = this.closestPointLength(p);\n\t    return this.tangentAtLength(cpLength);\n\t  },\n\t  // Returns `true` if the area surrounded by the polyline contains the point `p`.\n\t  // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n\t  // (Uses horizontal rays to the right of `p` to look for intersections.)\n\t  // Closes open polylines (always imagines a final closing segment).\n\t  containsPoint: function (p) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n\t    var x = p.x;\n\t    var y = p.y;\n\n\t    // initialize a final closing segment by creating one from last-first points on polyline\n\t    var startIndex = numPoints - 1; // start of current polyline segment\n\t    var endIndex = 0; // end of current polyline segment\n\t    var numIntersections = 0;\n\t    var segment = new Line();\n\t    var ray = new Line();\n\t    var rayEnd = new Point();\n\t    for (; endIndex < numPoints; endIndex++) {\n\t      var start = points[startIndex];\n\t      var end = points[endIndex];\n\t      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n\t      // current polyline segment\n\t      segment.start = start;\n\t      segment.end = end;\n\t      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n\t      // do we have an intersection?\n\t      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n\t        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n\t        // (when `y === start.y === end.y`)\n\t        // this conditional branch IS entered when `segment` touches `ray` at only one point\n\t        // (e.g. when `y === start.y !== end.y`)\n\t        // since this branch is entered again for the following segment, the two touches cancel out\n\n\t        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\t        if (xDifference >= 0) {\n\t          // segment lies at least partially to the right of `p`\n\t          rayEnd.x = x + xDifference;\n\t          rayEnd.y = y; // right\n\t          ray.start = p;\n\t          ray.end = rayEnd;\n\t          if (segment.intersect(ray)) {\n\t            // an intersection was detected to the right of `p`\n\t            numIntersections++;\n\t          }\n\t        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\t      }\n\n\t      // move to check the next polyline segment\n\t      startIndex = endIndex;\n\t    }\n\n\t    // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t    return numIntersections % 2 === 1;\n\t  },\n\t  close: function () {\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = this;\n\t    if (start && end && !start.equals(end)) {\n\t      points.push(start.clone());\n\t    }\n\t    return this;\n\t  },\n\t  lengthPoints: function () {\n\t    return this.points;\n\t  },\n\t  convexHull: function () {\n\t    return new Polyline$1(convexHull(this.points));\n\t  },\n\t  // Checks whether two polylines are exactly the same.\n\t  // If `p` is undefined or null, returns false.\n\t  equals: function (p) {\n\t    if (!p) return false;\n\t    var points = this.points;\n\t    var otherPoints = p.points;\n\t    var numPoints = points.length;\n\t    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      var otherPoint = p.points[i];\n\n\t      // as soon as an inequality is found in points, return false\n\t      if (!point.equals(otherPoint)) return false;\n\t    }\n\n\t    // if no inequality found in points, return true\n\t    return true;\n\t  },\n\t  intersectionWithLine: function (l) {\n\t    var line = new Line(l);\n\t    var intersections = [];\n\t    var points = this.lengthPoints();\n\t    var l2 = new Line();\n\t    for (var i = 0, n = points.length - 1; i < n; i++) {\n\t      l2.start = points[i];\n\t      l2.end = points[i + 1];\n\t      var int = line.intersectionWithLine(l2);\n\t      if (int) intersections.push(int[0]);\n\t    }\n\t    return intersections.length > 0 ? intersections : null;\n\t  },\n\t  isDifferentiable: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return false;\n\t    var line = new Line();\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      line.start = points[i];\n\t      line.end = points[i + 1];\n\t      // as soon as a differentiable line is found between two points, return true\n\t      if (line.isDifferentiable()) return true;\n\t    }\n\n\t    // if no differentiable line is found between pairs of points, return false\n\t    return false;\n\t  },\n\t  length: function () {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return 0; // if points array is empty\n\n\t    var length = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      length += points[i].distance(points[i + 1]);\n\t    }\n\t    return length;\n\t  },\n\t  pointAt: function (ratio) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n\t    if (ratio <= 0) return points[0].clone();\n\t    if (ratio >= 1) return points[numPoints - 1].clone();\n\t    var polylineLength = this.length();\n\t    var length = polylineLength * ratio;\n\t    return this.pointAtLength(length);\n\t  },\n\t  pointAtLength: function (length) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var l = 0;\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var a = points[index];\n\t      var b = points[index + 1];\n\t      var line = new Line(a, b);\n\t      var d = a.distance(b);\n\t      if (length <= l + d) {\n\t        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the polyline, return last endpoint\n\t    var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n\t    return lastPoint.clone();\n\t  },\n\t  round: function (precision) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].round(precision);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].scale(sx, sy, origin);\n\t    }\n\t    return this;\n\t  },\n\t  simplify: function (opt = {}) {\n\t    const points = this.points;\n\t    if (points.length < 3) return this; // we need at least 3 points\n\n\t    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n\t    // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n\t    // because of the rounding errors that can occur when comparing distances.\n\t    const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n\t    // start at the beginning of the polyline and go forward\n\t    let currentIndex = 0;\n\t    // we need at least one intermediate point (3 points) in every iteration\n\t    // as soon as that stops being true, we know we reached the end of the polyline\n\t    while (points[currentIndex + 2]) {\n\t      const firstIndex = currentIndex;\n\t      const middleIndex = currentIndex + 1;\n\t      const lastIndex = currentIndex + 2;\n\t      const firstPoint = points[firstIndex];\n\t      const middlePoint = points[middleIndex];\n\t      const lastPoint = points[lastIndex];\n\t      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\t      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\t      const closestPointDistance = closestPoint.distance(middlePoint);\n\t      if (closestPointDistance <= threshold) {\n\t        // middle point is close enough to the chord = simplify\n\t        // 1) remove middle point:\n\t        points.splice(middleIndex, 1);\n\t        // 2) in next iteration, investigate the newly-created triplet of points\n\t        //    - do not change `currentIndex`\n\t        //    = (first point stays, point after removed point becomes middle point)\n\t      } else {\n\t        // middle point is far from the chord\n\t        // 1) preserve middle point\n\t        // 2) in next iteration, move `currentIndex` by one step:\n\t        currentIndex += 1;\n\t        //    = (point after first point becomes first point)\n\t      }\n\t    }\n\n\t    // `points` array was modified in-place\n\t    return this;\n\t  },\n\t  tangentAt: function (ratio) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return null; // if there is only one point\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    var polylineLength = this.length();\n\t    var length = polylineLength * ratio;\n\t    return this.tangentAtLength(length);\n\t  },\n\t  tangentAtLength: function (length) {\n\t    var points = this.lengthPoints();\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\t    if (numPoints === 1) return null; // if there is only one point\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    var lastValidLine; // differentiable (with a tangent)\n\t    var l = 0; // length so far\n\t    var n = numPoints - 1;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var a = points[index];\n\t      var b = points[index + 1];\n\t      var line = new Line(a, b);\n\t      var d = a.distance(b);\n\t      if (line.isDifferentiable()) {\n\t        // has a tangent line (line length is not 0)\n\t        if (length <= l + d) {\n\t          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n\t        }\n\t        lastValidLine = line;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the polyline, return last valid endpoint\n\t    if (lastValidLine) {\n\t      var ratio = fromStart ? 1 : 0;\n\t      return lastValidLine.tangentAt(ratio);\n\t    }\n\n\t    // if no valid line, return null\n\t    return null;\n\t  },\n\t  toString: function () {\n\t    return this.points + '';\n\t  },\n\t  translate: function (tx, ty) {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    for (var i = 0; i < numPoints; i++) {\n\t      points[i].translate(tx, ty);\n\t    }\n\t    return this;\n\t  },\n\t  // Return svgString that can be used to recreate this line.\n\t  serialize: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return ''; // if points array is empty\n\n\t    var output = '';\n\t    for (var i = 0; i < numPoints; i++) {\n\t      var point = points[i];\n\t      output += point.x + ',' + point.y + ' ';\n\t    }\n\t    return output.trim();\n\t  }\n\t};\n\tObject.defineProperty(Polyline$1.prototype, 'start', {\n\t  // Getter for the first point of the polyline.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    return this.points[0];\n\t  }\n\t});\n\tObject.defineProperty(Polyline$1.prototype, 'end', {\n\t  // Getter for the last point of the polyline.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var points = this.points;\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) return null; // if points array is empty\n\n\t    return this.points[numPoints - 1];\n\t  }\n\t});\n\n\tconst {\n\t  abs,\n\t  sqrt,\n\t  min,\n\t  max,\n\t  pow\n\t} = Math;\n\tconst Curve = function (p1, p2, p3, p4) {\n\t  if (!(this instanceof Curve)) {\n\t    return new Curve(p1, p2, p3, p4);\n\t  }\n\t  if (p1 instanceof Curve) {\n\t    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n\t  }\n\t  this.start = new Point(p1);\n\t  this.controlPoint1 = new Point(p2);\n\t  this.controlPoint2 = new Point(p3);\n\t  this.end = new Point(p4);\n\t};\n\n\t// Curve passing through points.\n\t// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n\t// @param {array} points Array of points through which the smooth line will go.\n\t// @return {array} curves.\n\tCurve.throughPoints = function () {\n\t  // Get open-ended Bezier Spline Control Points.\n\t  // @param knots Input Knot Bezier spline points (At least two points!).\n\t  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t  function getCurveControlPoints(knots) {\n\t    var firstControlPoints = [];\n\t    var secondControlPoints = [];\n\t    var n = knots.length - 1;\n\t    var i;\n\n\t    // Special case: Bezier curve should be a straight line.\n\t    if (n == 1) {\n\t      // 3P1 = 2P0 + P3\n\t      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n\t      // P2 = 2P1  P0\n\t      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n\t      return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Calculate first Bezier control points.\n\t    // Right hand side vector.\n\t    var rhs = [];\n\n\t    // Set right hand side X values.\n\t    for (i = 1; i < n - 1; i++) {\n\t      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t    }\n\t    rhs[0] = knots[0].x + 2 * knots[1].x;\n\t    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t    // Get first control points X-values.\n\t    var x = getFirstControlPoints(rhs);\n\n\t    // Set right hand side Y values.\n\t    for (i = 1; i < n - 1; ++i) {\n\t      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t    }\n\t    rhs[0] = knots[0].y + 2 * knots[1].y;\n\t    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t    // Get first control points Y-values.\n\t    var y = getFirstControlPoints(rhs);\n\n\t    // Fill output arrays.\n\t    for (i = 0; i < n; i++) {\n\t      // First control point.\n\t      firstControlPoints.push(new Point(x[i], y[i]));\n\n\t      // Second control point.\n\t      if (i < n - 1) {\n\t        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n\t      } else {\n\t        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n\t      }\n\t    }\n\t    return [firstControlPoints, secondControlPoints];\n\t  }\n\n\t  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t  // @param rhs Right hand side vector.\n\t  // @return Solution vector.\n\t  function getFirstControlPoints(rhs) {\n\t    var n = rhs.length;\n\t    // `x` is a solution vector.\n\t    var x = [];\n\t    var tmp = [];\n\t    var b = 2.0;\n\t    x[0] = rhs[0] / b;\n\n\t    // Decomposition and forward substitution.\n\t    for (var i = 1; i < n; i++) {\n\t      tmp[i] = 1 / b;\n\t      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t      x[i] = (rhs[i] - x[i - 1]) / b;\n\t    }\n\t    for (i = 1; i < n; i++) {\n\t      // Backsubstitution.\n\t      x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t    }\n\t    return x;\n\t  }\n\t  return function (points) {\n\t    if (!points || Array.isArray(points) && points.length < 2) {\n\t      throw new Error('At least 2 points are required');\n\t    }\n\t    var controlPoints = getCurveControlPoints(points);\n\t    var curves = [];\n\t    var n = controlPoints[0].length;\n\t    for (var i = 0; i < n; i++) {\n\t      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n\t      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\t      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n\t    }\n\t    return curves;\n\t  };\n\t}();\n\tCurve.prototype = {\n\t  type: types.Curve,\n\t  // Returns a bbox that tightly envelops the curve.\n\t  bbox: function () {\n\t    var start = this.start;\n\t    var controlPoint1 = this.controlPoint1;\n\t    var controlPoint2 = this.controlPoint2;\n\t    var end = this.end;\n\t    var x0 = start.x;\n\t    var y0 = start.y;\n\t    var x1 = controlPoint1.x;\n\t    var y1 = controlPoint1.y;\n\t    var x2 = controlPoint2.x;\n\t    var y2 = controlPoint2.y;\n\t    var x3 = end.x;\n\t    var y3 = end.y;\n\t    var points = new Array(); // local extremes\n\t    var tvalues = new Array(); // t values of local extremes\n\t    var bounds = [new Array(), new Array()];\n\t    var a, b, c, t;\n\t    var t1, t2;\n\t    var b2ac, sqrtb2ac;\n\t    for (var i = 0; i < 2; ++i) {\n\t      if (i === 0) {\n\t        b = 6 * x0 - 12 * x1 + 6 * x2;\n\t        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t        c = 3 * x1 - 3 * x0;\n\t      } else {\n\t        b = 6 * y0 - 12 * y1 + 6 * y2;\n\t        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t        c = 3 * y1 - 3 * y0;\n\t      }\n\t      if (abs(a) < 1e-12) {\n\t        // Numerical robustness\n\t        if (abs(b) < 1e-12) {\n\t          // Numerical robustness\n\t          continue;\n\t        }\n\t        t = -c / b;\n\t        if (0 < t && t < 1) tvalues.push(t);\n\t        continue;\n\t      }\n\t      b2ac = b * b - 4 * c * a;\n\t      sqrtb2ac = sqrt(b2ac);\n\t      if (b2ac < 0) continue;\n\t      t1 = (-b + sqrtb2ac) / (2 * a);\n\t      if (0 < t1 && t1 < 1) tvalues.push(t1);\n\t      t2 = (-b - sqrtb2ac) / (2 * a);\n\t      if (0 < t2 && t2 < 1) tvalues.push(t2);\n\t    }\n\t    var j = tvalues.length;\n\t    var jlen = j;\n\t    var mt;\n\t    var x, y;\n\t    while (j--) {\n\t      t = tvalues[j];\n\t      mt = 1 - t;\n\t      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n\t      bounds[0][j] = x;\n\t      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n\t      bounds[1][j] = y;\n\t      points[j] = {\n\t        X: x,\n\t        Y: y\n\t      };\n\t    }\n\t    tvalues[jlen] = 0;\n\t    tvalues[jlen + 1] = 1;\n\t    points[jlen] = {\n\t      X: x0,\n\t      Y: y0\n\t    };\n\t    points[jlen + 1] = {\n\t      X: x3,\n\t      Y: y3\n\t    };\n\t    bounds[0][jlen] = x0;\n\t    bounds[1][jlen] = y0;\n\t    bounds[0][jlen + 1] = x3;\n\t    bounds[1][jlen + 1] = y3;\n\t    tvalues.length = jlen + 2;\n\t    bounds[0].length = jlen + 2;\n\t    bounds[1].length = jlen + 2;\n\t    points.length = jlen + 2;\n\t    var left = min.apply(null, bounds[0]);\n\t    var top = min.apply(null, bounds[1]);\n\t    var right = max.apply(null, bounds[0]);\n\t    var bottom = max.apply(null, bounds[1]);\n\t    return new Rect(left, top, right - left, bottom - top);\n\t  },\n\t  clone: function () {\n\t    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t  },\n\t  // Returns the point on the curve closest to point `p`\n\t  closestPoint: function (p, opt) {\n\t    return this.pointAtT(this.closestPointT(p, opt));\n\t  },\n\t  closestPointLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n\t  },\n\t  closestPointNormalizedLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    var cpLength = this.closestPointLength(p, localOpt);\n\t    if (!cpLength) return 0;\n\t    var length = this.length(localOpt);\n\t    if (length === 0) return 0;\n\t    return cpLength / length;\n\t  },\n\t  // Returns `t` of the point on the curve closest to point `p`\n\t  closestPointT: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // does not use localOpt\n\n\t    // identify the subdivision that contains the point:\n\t    var investigatedSubdivision;\n\t    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t    var investigatedSubdivisionEndT;\n\t    var distFromStart; // distance of point from start of baseline\n\t    var distFromEnd; // distance of point from end of baseline\n\t    var chordLength; // distance between start and end of the subdivision\n\t    var minSumDist; // lowest observed sum of the two distances\n\t    var n = subdivisions.length;\n\t    var subdivisionSize = n ? 1 / n : 0;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      var startDist = currentSubdivision.start.distance(p);\n\t      var endDist = currentSubdivision.end.distance(p);\n\t      var sumDist = startDist + endDist;\n\n\t      // check that the point is closest to current subdivision and not any other\n\t      if (!minSumDist || sumDist < minSumDist) {\n\t        investigatedSubdivision = currentSubdivision;\n\t        investigatedSubdivisionStartT = i * subdivisionSize;\n\t        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\t        distFromStart = startDist;\n\t        distFromEnd = endDist;\n\t        chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\t        minSumDist = sumDist;\n\t      }\n\t    }\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // recursively divide investigated subdivision:\n\t    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t    // then return the closest endpoint of that final subdivision\n\t    while (true) {\n\t      // check if we have reached at least one required observed precision\n\t      // - calculated as: the difference in distances from point to start and end divided by the distance\n\t      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n\t      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n\t      // - this criterion works well for points lying far away from the curve\n\t      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n\t      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n\t      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n\n\t      // check if we have reached at least one required minimal distance\n\t      // - calculated as: the subdivision chord length multiplied by precisionRatio\n\t      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n\t      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\t      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n\t      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n\t      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;\n\n\t      // do we stop now?\n\t      if (hasRequiredPrecision || hasMinimalDistance) {\n\t        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n\t      }\n\n\t      // otherwise, set up for next iteration\n\t      var divided = investigatedSubdivision.divide(0.5);\n\t      subdivisionSize /= 2;\n\t      var startDist1 = divided[0].start.distance(p);\n\t      var endDist1 = divided[0].end.distance(p);\n\t      var sumDist1 = startDist1 + endDist1;\n\t      var startDist2 = divided[1].start.distance(p);\n\t      var endDist2 = divided[1].end.distance(p);\n\t      var sumDist2 = startDist2 + endDist2;\n\t      if (sumDist1 <= sumDist2) {\n\t        investigatedSubdivision = divided[0];\n\t        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n\t        distFromStart = startDist1;\n\t        distFromEnd = endDist1;\n\t      } else {\n\t        investigatedSubdivision = divided[1];\n\t        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t        distFromStart = startDist2;\n\t        distFromEnd = endDist2;\n\t      }\n\t    }\n\t  },\n\t  closestPointTangent: function (p, opt) {\n\t    return this.tangentAtT(this.closestPointT(p, opt));\n\t  },\n\t  // Returns `true` if the area surrounded by the curve contains the point `p`.\n\t  // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t  // Closes open curves (always imagines a closing segment).\n\t  // Precision may be adjusted by passing an `opt` object.\n\t  containsPoint: function (p, opt) {\n\t    var polyline = this.toPolyline(opt);\n\t    return polyline.containsPoint(p);\n\t  },\n\t  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // For a function that uses `t`, use Curve.divideAtT().\n\t  divideAt: function (ratio, opt) {\n\t    if (ratio <= 0) return this.divideAtT(0);\n\t    if (ratio >= 1) return this.divideAtT(1);\n\t    var t = this.tAt(ratio, opt);\n\t    return this.divideAtT(t);\n\t  },\n\t  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAtLength: function (length, opt) {\n\t    var t = this.tAtLength(length, opt);\n\t    return this.divideAtT(t);\n\t  },\n\t  // Divides the curve into two at point defined by `t` between 0 and 1.\n\t  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n\t  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n\t  divideAtT: function (t) {\n\t    var start = this.start;\n\t    var controlPoint1 = this.controlPoint1;\n\t    var controlPoint2 = this.controlPoint2;\n\t    var end = this.end;\n\n\t    // shortcuts for `t` values that are out of range\n\t    if (t <= 0) {\n\t      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n\t    }\n\t    if (t >= 1) {\n\t      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n\t    }\n\t    var dividerPoints = this.getSkeletonPoints(t);\n\t    var startControl1 = dividerPoints.startControlPoint1;\n\t    var startControl2 = dividerPoints.startControlPoint2;\n\t    var divider = dividerPoints.divider;\n\t    var dividerControl1 = dividerPoints.dividerControlPoint1;\n\t    var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n\t    // return array with two new curves\n\t    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n\t  },\n\t  // Returns the distance between the curve's start and end points.\n\t  endpointDistance: function () {\n\t    return this.start.distance(this.end);\n\t  },\n\t  // Checks whether two curves are exactly the same.\n\t  equals: function (c) {\n\t    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n\t  },\n\t  // Returns five helper points necessary for curve division.\n\t  getSkeletonPoints: function (t) {\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\n\t    // shortcuts for `t` values that are out of range\n\t    if (t <= 0) {\n\t      return {\n\t        startControlPoint1: start.clone(),\n\t        startControlPoint2: start.clone(),\n\t        divider: start.clone(),\n\t        dividerControlPoint1: control1.clone(),\n\t        dividerControlPoint2: control2.clone()\n\t      };\n\t    }\n\t    if (t >= 1) {\n\t      return {\n\t        startControlPoint1: control1.clone(),\n\t        startControlPoint2: control2.clone(),\n\t        divider: end.clone(),\n\t        dividerControlPoint1: end.clone(),\n\t        dividerControlPoint2: end.clone()\n\t      };\n\t    }\n\t    var midpoint1 = new Line(start, control1).pointAt(t);\n\t    var midpoint2 = new Line(control1, control2).pointAt(t);\n\t    var midpoint3 = new Line(control2, end).pointAt(t);\n\t    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n\t    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n\t    var divider = new Line(subControl1, subControl2).pointAt(t);\n\t    var output = {\n\t      startControlPoint1: midpoint1,\n\t      startControlPoint2: subControl1,\n\t      divider: divider,\n\t      dividerControlPoint1: subControl2,\n\t      dividerControlPoint2: midpoint3\n\t    };\n\t    return output;\n\t  },\n\t  // Returns a list of curves whose flattened length is better than `opt.precision`.\n\t  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n\t  // (Observed difference is not real precision, but close enough as long as special cases are covered)\n\t  // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n\t  // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n\t  // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n\t  // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n\t  // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n\t  // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n\t  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n\t  getSubdivisions: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.subdivisions\n\t    // not using localOpt\n\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    var subdivisions = [new Curve(start, control1, control2, end)];\n\t    if (precision === 0) return subdivisions;\n\n\t    // special case #1: point-like curves\n\t    // - no need to calculate subdivisions, they would all be identical\n\t    var isPoint = !this.isDifferentiable();\n\t    if (isPoint) return subdivisions;\n\t    var previousLength = this.endpointDistance();\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n\t    // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n\t    // - (i.e. cubic curves cannot intersect the baseline more than once)\n\t    // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n\t    // - (unless it's a straight-line curve, see below)\n\t    var minIterations = 2; // = 2*1\n\n\t    // special case #3: straight-line curves have the same observed length in all iterations\n\t    // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n\t    // - we enforce the expected number of iterations = 2 * precision\n\t    var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;\n\t    if (isLine) {\n\t      minIterations = 2 * precision;\n\t    }\n\n\t    // recursively divide curve at `t = 0.5`\n\t    // until we reach `minIterations`\n\t    // and until the difference between observed length at subsequent iterations is lower than `precision`\n\t    var iteration = 0;\n\t    while (true) {\n\t      iteration += 1;\n\n\t      // divide all subdivisions\n\t      var newSubdivisions = [];\n\t      var numSubdivisions = subdivisions.length;\n\t      for (var i = 0; i < numSubdivisions; i++) {\n\t        var currentSubdivision = subdivisions[i];\n\t        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\t        newSubdivisions.push(divided[0], divided[1]);\n\t      }\n\n\t      // measure new length\n\t      var length = 0;\n\t      var numNewSubdivisions = newSubdivisions.length;\n\t      for (var j = 0; j < numNewSubdivisions; j++) {\n\t        var currentNewSubdivision = newSubdivisions[j];\n\t        length += currentNewSubdivision.endpointDistance();\n\t      }\n\n\t      // check if we have reached minimum number of iterations\n\t      if (iteration >= minIterations) {\n\t        // check if we have reached required observed precision\n\t        var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n\t        if (observedPrecisionRatio < precisionRatio) {\n\t          return newSubdivisions;\n\t        }\n\t      }\n\n\t      // otherwise, set up for next iteration\n\t      subdivisions = newSubdivisions;\n\t      previousLength = length;\n\t    }\n\t  },\n\t  isDifferentiable: function () {\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t  },\n\t  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n\t  length: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // not using localOpt\n\n\t    var length = 0;\n\t    var n = subdivisions.length;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      length += currentSubdivision.endpointDistance();\n\t    }\n\t    return length;\n\t  },\n\t  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n\t  lengthAtT: function (t, opt) {\n\t    if (t <= 0) return 0;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.subdivisions\n\t    // not using localOpt\n\n\t    var subCurve = this.divide(t)[0];\n\t    var subCurveLength = subCurve.length({\n\t      precision: precision\n\t    });\n\t    return subCurveLength;\n\t  },\n\t  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // Mirrors Line.pointAt() function.\n\t  // For a function that tracks `t`, use Curve.pointAtT().\n\t  pointAt: function (ratio, opt) {\n\t    if (ratio <= 0) return this.start.clone();\n\t    if (ratio >= 1) return this.end.clone();\n\t    var t = this.tAt(ratio, opt);\n\t    return this.pointAtT(t);\n\t  },\n\t  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  pointAtLength: function (length, opt) {\n\t    var t = this.tAtLength(length, opt);\n\t    return this.pointAtT(t);\n\t  },\n\t  // Returns the point at provided `t` between 0 and 1.\n\t  // `t` does not track distance along curve as it does in Line objects.\n\t  // Non-linear relationship, speeds up and slows down as curve warps!\n\t  // For linear length-based solution, use Curve.pointAt().\n\t  pointAtT: function (t) {\n\t    if (t <= 0) return this.start.clone();\n\t    if (t >= 1) return this.end.clone();\n\t    return this.getSkeletonPoints(t).divider;\n\t  },\n\t  // Default precision\n\t  PRECISION: 3,\n\t  round: function (precision) {\n\t    this.start.round(precision);\n\t    this.controlPoint1.round(precision);\n\t    this.controlPoint2.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.start.scale(sx, sy, origin);\n\t    this.controlPoint1.scale(sx, sy, origin);\n\t    this.controlPoint2.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t  tangentAt: function (ratio, opt) {\n\t    if (!this.isDifferentiable()) return null;\n\t    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;\n\t    var t = this.tAt(ratio, opt);\n\t    return this.tangentAtT(t);\n\t  },\n\t  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t  tangentAtLength: function (length, opt) {\n\t    if (!this.isDifferentiable()) return null;\n\t    var t = this.tAtLength(length, opt);\n\t    return this.tangentAtT(t);\n\t  },\n\t  // Returns a tangent line at requested `t`.\n\t  tangentAtT: function (t) {\n\t    if (!this.isDifferentiable()) return null;\n\t    if (t < 0) t = 0;else if (t > 1) t = 1;\n\t    var skeletonPoints = this.getSkeletonPoints(t);\n\t    var p1 = skeletonPoints.startControlPoint2;\n\t    var p2 = skeletonPoints.dividerControlPoint1;\n\t    var tangentStart = skeletonPoints.divider;\n\t    var tangentLine = new Line(p1, p2);\n\t    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n\t    return tangentLine;\n\t  },\n\t  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  tAt: function (ratio, opt) {\n\t    if (ratio <= 0) return 0;\n\t    if (ratio >= 1) return 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\t    var curveLength = this.length(localOpt);\n\t    var length = curveLength * ratio;\n\t    return this.tAtLength(length, localOpt);\n\t  },\n\t  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  // Uses `precision` to approximate length within `precision` (always underestimates)\n\t  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n\t  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n\t  // - Precision 0 (chooses one of the two endpoints) - 0 levels\n\t  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n\t  // - Precision 2 (<1% error) - 3 levels\n\t  // - Precision 3 (<0.1% error) - 7 levels\n\t  // - Precision 4 (<0.01% error) - 15 levels\n\t  tAtLength: function (length, opt) {\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      subdivisions: subdivisions\n\t    };\n\n\t    // identify the subdivision that contains the point at requested `length`:\n\t    var investigatedSubdivision;\n\t    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t    var investigatedSubdivisionEndT;\n\t    //var baseline; // straightened version of subdivision to investigate\n\t    //var baselinePoint; // point on the baseline that is the requested distance away from start\n\t    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\t    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\t    var l = 0; // length so far\n\t    var n = subdivisions.length;\n\t    var subdivisionSize = 1 / n;\n\t    for (var i = 0; i < n; i++) {\n\t      var index = fromStart ? i : n - 1 - i;\n\t      var currentSubdivision = subdivisions[i];\n\t      var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n\t      if (length <= l + d) {\n\t        investigatedSubdivision = currentSubdivision;\n\t        investigatedSubdivisionStartT = index * subdivisionSize;\n\t        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\t        baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n\t        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n\t        break;\n\t      }\n\t      l += d;\n\t    }\n\t    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n\t    // note that precision affects what length is recorded\n\t    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n\t    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\t    var curveLength = this.length(localOpt);\n\t    var precisionRatio = pow(10, -precision);\n\n\t    // recursively divide investigated subdivision:\n\t    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t    // then return the closest endpoint of that final subdivision\n\t    while (true) {\n\t      // check if we have reached required observed precision\n\t      var observedPrecisionRatio;\n\t      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n\t      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n\t      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n\t      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n\t      // otherwise, set up for next iteration\n\t      var newBaselinePointDistFromStart;\n\t      var newBaselinePointDistFromEnd;\n\t      var divided = investigatedSubdivision.divide(0.5);\n\t      subdivisionSize /= 2;\n\t      var baseline1Length = divided[0].endpointDistance();\n\t      var baseline2Length = divided[1].endpointDistance();\n\t      if (baselinePointDistFromStart <= baseline1Length) {\n\t        // point at requested length is inside divided[0]\n\t        investigatedSubdivision = divided[0];\n\t        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n\t        newBaselinePointDistFromStart = baselinePointDistFromStart;\n\t        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\t      } else {\n\t        // point at requested length is inside divided[1]\n\t        investigatedSubdivision = divided[1];\n\t        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n\t        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n\t      }\n\t      baselinePointDistFromStart = newBaselinePointDistFromStart;\n\t      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n\t    }\n\t  },\n\t  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t  // Flattened length is no more than 10^(-precision) away from real curve length.\n\t  toPoints: function (opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n\t      precision: precision\n\t    }) : opt.subdivisions;\n\t    // not using localOpt\n\n\t    var points = [subdivisions[0].start.clone()];\n\t    var n = subdivisions.length;\n\t    for (var i = 0; i < n; i++) {\n\t      var currentSubdivision = subdivisions[i];\n\t      points.push(currentSubdivision.end.clone());\n\t    }\n\t    return points;\n\t  },\n\t  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t  // Flattened length is no more than 10^(-precision) away from real curve length.\n\t  toPolyline: function (opt) {\n\t    return new Polyline$1(this.toPoints(opt));\n\t  },\n\t  toString: function () {\n\t    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.start.translate(tx, ty);\n\t    this.controlPoint1.translate(tx, ty);\n\t    this.controlPoint2.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tCurve.prototype.divide = Curve.prototype.divideAtT;\n\n\t// Local helper function.\n\t// Add properties from arguments on top of properties from `obj`.\n\t// This allows for rudimentary inheritance.\n\t// - The `obj` argument acts as parent.\n\t// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n\t// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n\tfunction extend$1(obj) {\n\t  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n\t  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n\t  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n\t  // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n\t  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n\t  // - This method provides a way to do exactly that.\n\t  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n\t  // - Therefore, to continue with the example above:\n\t  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n\t  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n\t  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n\t  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n\t  // - Multiple inheritance is also possible, if multiple arguments are provided.\n\t  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n\t  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n\t  //   - The ancestors are applied in order of appearance.\n\t  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n\t  //   - Any number of ancestors may be provided.\n\t  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n\t  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n\t  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n\t  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n\t  // - Therefore, both of the following are valid:\n\t  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n\t  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n\t  var i;\n\t  var n;\n\t  var args = [];\n\t  n = arguments.length;\n\t  for (i = 1; i < n; i++) {\n\t    // skip over obj\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!obj) throw new Error('Missing a parent object.');\n\t  var child = Object.create(obj);\n\t  n = args.length;\n\t  for (i = 0; i < n; i++) {\n\t    var src = args[i];\n\t    var inheritedProperty;\n\t    var key;\n\t    for (key in src) {\n\t      if (src.hasOwnProperty(key)) {\n\t        delete child[key]; // delete property inherited from parent\n\t        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\t        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n\t      }\n\t    }\n\t  }\n\t  return child;\n\t}\n\n\t// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n\t// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\tconst Path$1 = function (arg) {\n\t  if (!(this instanceof Path$1)) {\n\t    return new Path$1(arg);\n\t  }\n\t  if (typeof arg === 'string') {\n\t    // create from a path data string\n\t    return new Path$1.parse(arg);\n\t  }\n\t  this.segments = [];\n\t  var i;\n\t  var n;\n\t  if (!arg) {\n\t    // don't do anything\n\t  } else if (Array.isArray(arg) && arg.length !== 0) {\n\t    // if arg is a non-empty array\n\t    // flatten one level deep\n\t    // so we can chain arbitrary Path.createSegment results\n\t    arg = arg.reduce(function (acc, val) {\n\t      return acc.concat(val);\n\t    }, []);\n\t    n = arg.length;\n\t    if (arg[0].isSegment) {\n\t      // create from an array of segments\n\t      for (i = 0; i < n; i++) {\n\t        var segment = arg[i];\n\t        this.appendSegment(segment);\n\t      }\n\t    } else {\n\t      // create from an array of Curves and/or Lines\n\t      var previousObj = null;\n\t      for (i = 0; i < n; i++) {\n\t        var obj = arg[i];\n\t        if (!(obj instanceof Line || obj instanceof Curve)) {\n\t          throw new Error('Cannot construct a path segment from the provided object.');\n\t        }\n\t        if (i === 0) this.appendSegment(Path$1.createSegment('M', obj.start));\n\n\t        // if objects do not link up, moveto segments are inserted to cover the gaps\n\t        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path$1.createSegment('M', obj.start));\n\t        if (obj instanceof Line) {\n\t          this.appendSegment(Path$1.createSegment('L', obj.end));\n\t        } else if (obj instanceof Curve) {\n\t          this.appendSegment(Path$1.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n\t        }\n\t        previousObj = obj;\n\t      }\n\t    }\n\t  } else if (arg.isSegment) {\n\t    // create from a single segment\n\t    this.appendSegment(arg);\n\t  } else if (arg instanceof Line) {\n\t    // create from a single Line\n\t    this.appendSegment(Path$1.createSegment('M', arg.start));\n\t    this.appendSegment(Path$1.createSegment('L', arg.end));\n\t  } else if (arg instanceof Curve) {\n\t    // create from a single Curve\n\t    this.appendSegment(Path$1.createSegment('M', arg.start));\n\t    this.appendSegment(Path$1.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\t  } else if (arg instanceof Polyline$1) {\n\t    // create from a Polyline\n\t    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n\n\t    n = arg.points.length;\n\t    for (i = 0; i < n; i++) {\n\t      var point = arg.points[i];\n\t      if (i === 0) this.appendSegment(Path$1.createSegment('M', point));else this.appendSegment(Path$1.createSegment('L', point));\n\t    }\n\t  } else {\n\t    // unknown object\n\t    throw new Error('Cannot construct a path from the provided object.');\n\t  }\n\t};\n\n\t// More permissive than V.normalizePathData and Path.prototype.serialize.\n\t// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n\t// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n\t// Allows for command argument chaining.\n\t// Throws an error if wrong number of arguments is provided with a command.\n\t// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\tPath$1.parse = function (pathData) {\n\t  if (!pathData) return new Path$1();\n\t  var path = new Path$1();\n\t  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n\t  var commands = pathData.match(commandRe);\n\t  var numCommands = commands.length;\n\t  for (var i = 0; i < numCommands; i++) {\n\t    var command = commands[i];\n\t    var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n\t    var args = command.match(argRe);\n\t    var segment = Path$1.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\t    path.appendSegment(segment);\n\t  }\n\t  return path;\n\t};\n\n\t// Create a segment or an array of segments.\n\t// Accepts unlimited points/coords arguments after `type`.\n\tPath$1.createSegment = function (type) {\n\t  if (!type) throw new Error('Type must be provided.');\n\t  var segmentConstructor = Path$1.segmentTypes[type];\n\t  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 1; i < n; i++) {\n\t    // do not add first element (`type`) to args array\n\t    args.push(arguments[i]);\n\t  }\n\t  return applyToNew(segmentConstructor, args);\n\t};\n\tPath$1.prototype = {\n\t  type: types.Path,\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  appendSegment: function (arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    var currentSegment;\n\t    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n\t    var nextSegment = null;\n\t    if (!Array.isArray(arg)) {\n\t      // arg is a segment\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.push(currentSegment);\n\t    } else {\n\t      // arg is an array of segments\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.push(currentSegment);\n\t        previousSegment = currentSegment;\n\t      }\n\t    }\n\t  },\n\t  // Returns the bbox of the path.\n\t  // If path has no segments, returns null.\n\t  // If path has only invisible segments, returns bbox of the end point of last segment.\n\t  bbox: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var bbox;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) {\n\t        var segmentBBox = segment.bbox();\n\t        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n\t      }\n\t    }\n\t    if (bbox) return bbox;\n\n\t    // if the path has only invisible elements, return end point of last segment\n\t    var lastSegment = segments[numSegments - 1];\n\t    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n\t  },\n\t  // Returns a new path that is a clone of this path.\n\t  clone: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    var path = new Path$1();\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i].clone();\n\t      path.appendSegment(segment);\n\t    }\n\t    return path;\n\t  },\n\t  closestPoint: function (p, opt) {\n\t    var t = this.closestPointT(p, opt);\n\t    if (!t) return null;\n\t    return this.pointAtT(t);\n\t  },\n\t  closestPointLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var t = this.closestPointT(p, localOpt);\n\t    if (!t) return 0;\n\t    return this.lengthAtT(t, localOpt);\n\t  },\n\t  closestPointNormalizedLength: function (p, opt) {\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var cpLength = this.closestPointLength(p, localOpt);\n\t    if (cpLength === 0) return 0; // shortcut\n\n\t    var length = this.length(localOpt);\n\t    if (length === 0) return 0; // prevents division by zero\n\n\t    return cpLength / length;\n\t  },\n\t  // Private function.\n\t  closestPointT: function (p, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var closestPointT;\n\t    var minSquaredDistance = Infinity;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      if (segment.isVisible) {\n\t        var segmentClosestPointT = segment.closestPointT(p, {\n\t          precision: precision,\n\t          subdivisions: subdivisions\n\t        });\n\t        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\t        if (squaredDistance < minSquaredDistance) {\n\t          closestPointT = {\n\t            segmentIndex: i,\n\t            value: segmentClosestPointT\n\t          };\n\t          minSquaredDistance = squaredDistance;\n\t        }\n\t      }\n\t    }\n\t    if (closestPointT) return closestPointT;\n\n\t    // if no visible segment, return end of last segment\n\t    return {\n\t      segmentIndex: numSegments - 1,\n\t      value: 1\n\t    };\n\t  },\n\t  closestPointTangent: function (p, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var closestPointTangent;\n\t    var minSquaredDistance = Infinity;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      if (segment.isDifferentiable()) {\n\t        var segmentClosestPointT = segment.closestPointT(p, {\n\t          precision: precision,\n\t          subdivisions: subdivisions\n\t        });\n\t        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\t        if (squaredDistance < minSquaredDistance) {\n\t          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n\t          minSquaredDistance = squaredDistance;\n\t        }\n\t      }\n\t    }\n\t    if (closestPointTangent) return closestPointTangent;\n\n\t    // if no valid segment, return null\n\t    return null;\n\t  },\n\t  // Returns `true` if the area surrounded by the path contains the point `p`.\n\t  // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t  // Closes open paths (always imagines a final closing segment).\n\t  // Precision may be adjusted by passing an `opt` object.\n\t  containsPoint: function (p, opt) {\n\t    var polylines = this.toPolylines(opt);\n\t    if (!polylines) return false; // shortcut (this path has no polylines)\n\n\t    var numPolylines = polylines.length;\n\n\t    // how many component polylines does `p` lie within?\n\t    var numIntersections = 0;\n\t    for (var i = 0; i < numPolylines; i++) {\n\t      var polyline = polylines[i];\n\t      if (polyline.containsPoint(p)) {\n\t        // `p` lies within this polyline\n\t        numIntersections++;\n\t      }\n\t    }\n\n\t    // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t    return numIntersections % 2 === 1;\n\t  },\n\t  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.divideAtLength(length, localOpt);\n\t  },\n\t  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t  divideAtLength: function (length, opt) {\n\t    var numSegments = this.segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var i;\n\t    var segment;\n\n\t    // identify the segment to divide:\n\n\t    var l = 0; // length so far\n\t    var divided;\n\t    var dividedSegmentIndex;\n\t    var lastValidSegment; // visible AND differentiable\n\t    var lastValidSegmentIndex;\n\t    var t;\n\t    for (i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      segment = this.getSegment(index);\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isDifferentiable()) {\n\t        // segment is not just a point\n\t        lastValidSegment = segment;\n\t        lastValidSegmentIndex = index;\n\t        if (length <= l + d) {\n\t          dividedSegmentIndex = index;\n\t          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t          break;\n\t        }\n\t      }\n\t      l += d;\n\t    }\n\t    if (!lastValidSegment) {\n\t      // no valid segment found\n\t      return null;\n\t    }\n\n\t    // else: the path contains at least one valid segment\n\n\t    if (!divided) {\n\t      // the desired length is greater than the length of the path\n\t      dividedSegmentIndex = lastValidSegmentIndex;\n\t      t = fromStart ? 1 : 0;\n\t      divided = lastValidSegment.divideAtT(t);\n\t    }\n\n\t    // create a copy of this path and replace the identified segment with its two divided parts:\n\n\t    var pathCopy = this.clone();\n\t    pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\t    var divisionStartIndex = dividedSegmentIndex;\n\t    var divisionMidIndex = dividedSegmentIndex + 1;\n\t    var divisionEndIndex = dividedSegmentIndex + 2;\n\n\t    // do not insert the part if it looks like a point\n\t    if (!divided[0].isDifferentiable()) {\n\t      pathCopy.removeSegment(divisionStartIndex);\n\t      divisionMidIndex -= 1;\n\t      divisionEndIndex -= 1;\n\t    }\n\n\t    // insert a Moveto segment to ensure secondPath will be valid:\n\t    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n\t    pathCopy.insertSegment(divisionMidIndex, Path$1.createSegment('M', movetoEnd));\n\t    divisionEndIndex += 1;\n\n\t    // do not insert the part if it looks like a point\n\t    if (!divided[1].isDifferentiable()) {\n\t      pathCopy.removeSegment(divisionEndIndex - 1);\n\t      divisionEndIndex -= 1;\n\t    }\n\n\t    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\t    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\t    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\t      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n\t      segment = pathCopy.getSegment(i);\n\t      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n\t        // pathCopy segment's subpathStartSegment is different from original segment's one\n\t        // convert this Closepath segment to a Lineto and replace it in pathCopy\n\t        var convertedSegment = Path$1.createSegment('L', originalSegment.end);\n\t        pathCopy.replaceSegment(i, convertedSegment);\n\t      }\n\t    }\n\n\t    // distribute pathCopy segments into two paths and return those:\n\n\t    var firstPath = new Path$1(pathCopy.segments.slice(0, divisionMidIndex));\n\t    var secondPath = new Path$1(pathCopy.segments.slice(divisionMidIndex));\n\t    return [firstPath, secondPath];\n\t  },\n\t  // Checks whether two paths are exactly the same.\n\t  // If `p` is undefined or null, returns false.\n\t  equals: function (p) {\n\t    if (!p) return false;\n\t    var segments = this.segments;\n\t    var otherSegments = p.segments;\n\t    var numSegments = segments.length;\n\t    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var otherSegment = otherSegments[i];\n\n\t      // as soon as an inequality is found in segments, return false\n\t      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n\t    }\n\n\t    // if no inequality found in segments, return true\n\t    return true;\n\t  },\n\t  // Accepts negative indices.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  getSegment: function (index) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    return segments[index];\n\t  },\n\t  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n\t  getSegmentSubdivisions: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    // not using opt.segmentSubdivisions\n\t    // not using localOpt\n\n\t    var segmentSubdivisions = [];\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segment.getSubdivisions({\n\t        precision: precision\n\t      });\n\t      segmentSubdivisions.push(subdivisions);\n\t    }\n\t    return segmentSubdivisions;\n\t  },\n\t  // Returns an array of subpaths of this path.\n\t  // Invalid paths are validated first.\n\t  // Returns `[]` if path has no segments.\n\t  getSubpaths: function () {\n\t    const validatedPath = this.clone().validate();\n\t    const segments = validatedPath.segments;\n\t    const numSegments = segments.length;\n\t    const subpaths = [];\n\t    for (let i = 0; i < numSegments; i++) {\n\t      const segment = segments[i];\n\t      if (segment.isSubpathStart) {\n\t        // we encountered a subpath start segment\n\t        // create a new path for segment, and push it to list of subpaths\n\t        subpaths.push(new Path$1(segment));\n\t      } else {\n\t        // append current segment to the last subpath\n\t        subpaths[subpaths.length - 1].appendSegment(segment);\n\t      }\n\t    }\n\t    return subpaths;\n\t  },\n\t  // Insert `arg` at given `index`.\n\t  // `index = 0` means insert at the beginning.\n\t  // `index = segments.length` means insert at the end.\n\t  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if index is out of range.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  insertSegment: function (index, arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    // works even if path has no segments\n\n\t    // note that these are incremented compared to getSegments()\n\t    // we can insert after last element (note that this changes the meaning of index -1)\n\t    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n\t    if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\t    var currentSegment;\n\t    var previousSegment = null;\n\t    var nextSegment = null;\n\t    if (numSegments !== 0) {\n\t      if (index >= 1) {\n\t        previousSegment = segments[index - 1];\n\t        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\t      } else {\n\t        // if index === 0\n\t        // previousSegment is null\n\t        nextSegment = segments[0];\n\t      }\n\t    }\n\t    if (!Array.isArray(arg)) {\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.splice(index, 0, currentSegment);\n\t    } else {\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t        previousSegment = currentSegment;\n\t      }\n\t    }\n\t  },\n\t  intersectionWithLine: function (line, opt) {\n\t    var intersection = null;\n\t    var polylines = this.toPolylines(opt);\n\t    if (!polylines) return null;\n\t    for (var i = 0, n = polylines.length; i < n; i++) {\n\t      var polyline = polylines[i];\n\t      var polylineIntersection = line.intersect(polyline);\n\t      if (polylineIntersection) {\n\t        intersection || (intersection = []);\n\t        if (Array.isArray(polylineIntersection)) {\n\t          Array.prototype.push.apply(intersection, polylineIntersection);\n\t        } else {\n\t          intersection.push(polylineIntersection);\n\t        }\n\t      }\n\t    }\n\t    return intersection;\n\t  },\n\t  isDifferentiable: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      // as soon as a differentiable segment is found in segments, return true\n\t      if (segment.isDifferentiable()) return true;\n\t    }\n\n\t    // if no differentiable segment is found in segments, return false\n\t    return false;\n\t  },\n\t  // Checks whether current path segments are valid.\n\t  // Note that d is allowed to be empty - should disable rendering of the path.\n\t  isValid: function () {\n\t    var segments = this.segments;\n\t    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto\n\t    return isValid;\n\t  },\n\t  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n\t  // If path has no segments, returns 0.\n\t  length: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return 0; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var length = 0;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      var subdivisions = segmentSubdivisions[i];\n\t      length += segment.length({\n\t        subdivisions: subdivisions\n\t      });\n\t    }\n\t    return length;\n\t  },\n\t  // Private function.\n\t  lengthAtT: function (t, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return 0; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return 0; // regardless of t.value\n\n\t    var tValue = t.value;\n\t    if (segmentIndex >= numSegments) {\n\t      segmentIndex = numSegments - 1;\n\t      tValue = 1;\n\t    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var subdivisions;\n\t    var length = 0;\n\t    for (var i = 0; i < segmentIndex; i++) {\n\t      var segment = segments[i];\n\t      subdivisions = segmentSubdivisions[i];\n\t      length += segment.length({\n\t        precisison: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t    }\n\t    segment = segments[segmentIndex];\n\t    subdivisions = segmentSubdivisions[segmentIndex];\n\t    length += segment.lengthAtT(tValue, {\n\t      precisison: precision,\n\t      subdivisions: subdivisions\n\t    });\n\t    return length;\n\t  },\n\t  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  pointAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio <= 0) return this.start.clone();\n\t    if (ratio >= 1) return this.end.clone();\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.pointAtLength(length, localOpt);\n\t  },\n\t  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  // Accepts negative length.\n\t  pointAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (length === 0) return this.start.clone();\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastVisibleSegment;\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isVisible) {\n\t        if (length <= l + d) {\n\t          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t        }\n\t        lastVisibleSegment = segment;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return last visible segment endpoint\n\t    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n\n\t    // if no visible segment, return last segment end point (no matter if fromStart or no)\n\t    var lastSegment = segments[numSegments - 1];\n\t    return lastSegment.end.clone();\n\t  },\n\t  // Private function.\n\t  pointAtT: function (t) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return segments[0].pointAtT(0);\n\t    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\t    var tValue = t.value;\n\t    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    return segments[segmentIndex].pointAtT(tValue);\n\t  },\n\t  // Default precision\n\t  PRECISION: 3,\n\t  // Helper method for adding segments.\n\t  prepareSegment: function (segment, previousSegment, nextSegment) {\n\t    // insert after previous segment and before previous segment's next segment\n\t    segment.previousSegment = previousSegment;\n\t    segment.nextSegment = nextSegment;\n\t    if (previousSegment) previousSegment.nextSegment = segment;\n\t    if (nextSegment) nextSegment.previousSegment = segment;\n\t    var updateSubpathStart = segment;\n\t    if (segment.isSubpathStart) {\n\t      segment.subpathStartSegment = segment; // assign self as subpath start segment\n\t      updateSubpathStart = nextSegment; // start updating from next segment\n\t    }\n\n\t    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\t    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\t    return segment;\n\t  },\n\t  // Remove the segment at `index`.\n\t  // Accepts negative indices, from `-1` to `-segments.length`.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  removeSegment: function (index) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    var removedSegment = segments.splice(index, 1)[0];\n\t    var previousSegment = removedSegment.previousSegment;\n\t    var nextSegment = removedSegment.nextSegment;\n\n\t    // link the previous and next segments together (if present)\n\t    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n\t    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n\t    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\t    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n\t  },\n\t  // Replace the segment at `index` with `arg`.\n\t  // Accepts negative indices, from `-1` to `-segments.length`.\n\t  // Accepts one segment or an array of segments as argument.\n\t  // Throws an error if path has no segments.\n\t  // Throws an error if index is out of range.\n\t  // Throws an error if argument is not a segment or an array of segments.\n\t  replaceSegment: function (index, arg) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) throw new Error('Path has no segments.');\n\t    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\t    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\t    var currentSegment;\n\t    var replacedSegment = segments[index];\n\t    var previousSegment = replacedSegment.previousSegment;\n\t    var nextSegment = replacedSegment.nextSegment;\n\t    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n\t    if (!Array.isArray(arg)) {\n\t      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\t      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t      segments.splice(index, 1, currentSegment); // directly replace\n\n\t      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\t    } else {\n\t      // flatten one level deep\n\t      // so we can chain arbitrary Path.createSegment results\n\t      arg = arg.reduce(function (acc, val) {\n\t        return acc.concat(val);\n\t      }, []);\n\t      if (!arg[0].isSegment) throw new Error('Segments required.');\n\t      segments.splice(index, 1);\n\t      var n = arg.length;\n\t      for (var i = 0; i < n; i++) {\n\t        var currentArg = arg[i];\n\t        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t        previousSegment = currentSegment;\n\t        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\t      }\n\t    }\n\n\t    // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\t    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n\t  },\n\t  round: function (precision) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.round(precision);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.scale(sx, sy, origin);\n\t    }\n\t    return this;\n\t  },\n\t  segmentAt: function (ratio, opt) {\n\t    var index = this.segmentIndexAt(ratio, opt);\n\t    if (!index) return null;\n\t    return this.getSegment(index);\n\t  },\n\t  // Accepts negative length.\n\t  segmentAtLength: function (length, opt) {\n\t    var index = this.segmentIndexAtLength(length, opt);\n\t    if (!index) return null;\n\t    return this.getSegment(index);\n\t  },\n\t  segmentIndexAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.segmentIndexAtLength(length, localOpt);\n\t  },\n\t  // Accepts negative length.\n\t  segmentIndexAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastVisibleSegmentIndex = null;\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isVisible) {\n\t        if (length <= l + d) return index;\n\t        lastVisibleSegmentIndex = index;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return last visible segment index\n\t    // if no visible segment, return null\n\t    return lastVisibleSegmentIndex;\n\t  },\n\t  // Returns a string that can be used to reconstruct the path.\n\t  // Additional error checking compared to toString (must start with M segment).\n\t  serialize: function () {\n\t    if (!this.isValid()) throw new Error('Invalid path segments.');\n\t    return this.toString();\n\t  },\n\t  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  tangentAt: function (ratio, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    if (ratio < 0) ratio = 0;\n\t    if (ratio > 1) ratio = 1;\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var localOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: segmentSubdivisions\n\t    };\n\t    var pathLength = this.length(localOpt);\n\t    var length = pathLength * ratio;\n\t    return this.tangentAtLength(length, localOpt);\n\t  },\n\t  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t  // Accepts negative length.\n\t  tangentAtLength: function (length, opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var fromStart = true;\n\t    if (length < 0) {\n\t      fromStart = false; // negative lengths mean start calculation from end point\n\t      length = -length; // absolute value\n\t    }\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    // not using localOpt\n\n\t    var lastValidSegment; // visible AND differentiable (with a tangent)\n\t    var l = 0; // length so far\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var index = fromStart ? i : numSegments - 1 - i;\n\t      var segment = segments[index];\n\t      var subdivisions = segmentSubdivisions[index];\n\t      var d = segment.length({\n\t        precision: precision,\n\t        subdivisions: subdivisions\n\t      });\n\t      if (segment.isDifferentiable()) {\n\t        if (length <= l + d) {\n\t          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n\t            precision: precision,\n\t            subdivisions: subdivisions\n\t          });\n\t        }\n\t        lastValidSegment = segment;\n\t      }\n\t      l += d;\n\t    }\n\n\t    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\t    if (lastValidSegment) {\n\t      var t = fromStart ? 1 : 0;\n\t      return lastValidSegment.tangentAtT(t);\n\t    }\n\n\t    // if no valid segment, return null\n\t    return null;\n\t  },\n\t  // Private function.\n\t  tangentAtT: function (t) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    var segmentIndex = t.segmentIndex;\n\t    if (segmentIndex < 0) return segments[0].tangentAtT(0);\n\t    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\t    var tValue = t.value;\n\t    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\t    return segments[segmentIndex].tangentAtT(tValue);\n\t  },\n\t  toPoints: function (opt) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null; // if segments is an empty array\n\n\t    opt = opt || {};\n\t    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n\t    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n\t      precision: precision\n\t    }) : opt.segmentSubdivisions;\n\t    var points = [];\n\t    var partialPoints = [];\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) {\n\t        var currentSegmentSubdivisions = segmentSubdivisions[i];\n\t        if (currentSegmentSubdivisions.length > 0) {\n\t          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {\n\t            return curve.start;\n\t          });\n\t          Array.prototype.push.apply(partialPoints, subdivisionPoints);\n\t        } else {\n\t          partialPoints.push(segment.start);\n\t        }\n\t      } else if (partialPoints.length > 0) {\n\t        partialPoints.push(segments[i - 1].end);\n\t        points.push(partialPoints);\n\t        partialPoints = [];\n\t      }\n\t    }\n\t    if (partialPoints.length > 0) {\n\t      partialPoints.push(this.end);\n\t      points.push(partialPoints);\n\t    }\n\t    return points;\n\t  },\n\t  toPolylines: function (opt) {\n\t    var polylines = [];\n\t    var points = this.toPoints(opt);\n\t    if (!points) return null;\n\t    for (var i = 0, n = points.length; i < n; i++) {\n\t      polylines.push(new Polyline$1(points[i]));\n\t    }\n\t    return polylines;\n\t  },\n\t  toString: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    var pathData = '';\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      pathData += segment.serialize() + ' ';\n\t    }\n\t    return pathData.trim();\n\t  },\n\t  translate: function (tx, ty) {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      segment.translate(tx, ty);\n\t    }\n\t    return this;\n\t  },\n\t  // Helper method for updating subpath start of segments, starting with the one provided.\n\t  updateSubpathStartSegment: function (segment) {\n\t    var previousSegment = segment.previousSegment; // may be null\n\t    while (segment && !segment.isSubpathStart) {\n\t      // assign previous segment's subpath start segment to this segment\n\t      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n\t      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n\t      previousSegment = segment;\n\t      segment = segment.nextSegment; // move on to the segment after etc.\n\t    }\n\t  },\n\t  // If the path is not valid, insert M 0 0 at the beginning.\n\t  // Path with no segments is considered valid, so nothing is inserted.\n\t  validate: function () {\n\t    if (!this.isValid()) this.insertSegment(0, Path$1.createSegment('M', 0, 0));\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(Path$1.prototype, 'start', {\n\t  // Getter for the first visible endpoint of the path.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null;\n\t    for (var i = 0; i < numSegments; i++) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) return segment.start;\n\t    }\n\n\t    // if no visible segment, return last segment end point\n\t    return segments[numSegments - 1].end;\n\t  }\n\t});\n\tObject.defineProperty(Path$1.prototype, 'end', {\n\t  // Getter for the last visible endpoint of the path.\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    var segments = this.segments;\n\t    var numSegments = segments.length;\n\t    if (numSegments === 0) return null;\n\t    for (var i = numSegments - 1; i >= 0; i--) {\n\t      var segment = segments[i];\n\t      if (segment.isVisible) return segment.end;\n\t    }\n\n\t    // if no visible segment, return last segment end point\n\t    return segments[numSegments - 1].end;\n\t  }\n\t});\n\n\t// Local helper function.\n\t// Use an array of arguments to call a constructor (function called with `new`).\n\t// Adapted from https://stackoverflow.com/a/8843181/2263595\n\t// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n\t// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n\t// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n\t// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\tfunction applyToNew(constructor, argsArray) {\n\t  // The `new` keyword can only be applied to functions that take a limited number of arguments.\n\t  // - We can fake that with .bind().\n\t  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n\t  // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n\t  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n\t  // We need to pass in a variable number of arguments to the bind() call.\n\t  // - We can use .apply().\n\t  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\t  // - `thisArg` can still be anything because `new` overwrites it.\n\t  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n\t  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n\t  // The function expects `argsArray[0]` to be `thisArg`.\n\t  // - This means that whatever is sent as the first element will be ignored.\n\t  // - The constructor will only see arguments starting from argsArray[1].\n\t  // - So, a new dummy element is inserted at the start of the array.\n\t  argsArray.unshift(null);\n\t  return new (Function.prototype.bind.apply(constructor, argsArray))();\n\t}\n\n\t// Path segment interface:\n\tvar segmentPrototype = {\n\t  // virtual\n\t  bbox: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  clone: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPoint: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPointLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  closestPointNormalizedLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n\t  closestPointT: function (p) {\n\t    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\t    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n\t  },\n\t  // virtual\n\t  closestPointTangent: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  divideAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  divideAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n\t  divideAtT: function (t) {\n\t    if (this.divideAt) return this.divideAt(t);\n\t    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n\t  },\n\t  // virtual\n\t  equals: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  getSubdivisions: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  isDifferentiable: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  isSegment: true,\n\t  isSubpathStart: false,\n\t  // true for Moveto segments\n\n\t  isVisible: true,\n\t  // false for Moveto segments\n\n\t  // virtual\n\t  length: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n\t  lengthAtT: function (t) {\n\t    if (t <= 0) return 0;\n\t    var length = this.length();\n\t    if (t >= 1) return length;\n\t    return length * t;\n\t  },\n\t  nextSegment: null,\n\t  // needed for subpath start segment updating\n\n\t  // virtual\n\t  pointAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  pointAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n\t  pointAtT: function (t) {\n\t    if (this.pointAt) return this.pointAt(t);\n\t    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n\t  },\n\t  previousSegment: null,\n\t  // needed to get segment start property\n\n\t  // virtual\n\t  round: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  subpathStartSegment: null,\n\t  // needed to get Closepath segment end property\n\n\t  // virtual\n\t  scale: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  serialize: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  tangentAt: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  tangentAtLength: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n\t  tangentAtT: function (t) {\n\t    if (this.tangentAt) return this.tangentAt(t);\n\t    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n\t  },\n\t  // virtual\n\t  toString: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  },\n\t  // virtual\n\t  translate: function () {\n\t    throw new Error('Declaration missing for virtual function.');\n\t  }\n\t};\n\n\t// usually directly assigned\n\t// getter for Closepath\n\tObject.defineProperty(segmentPrototype, 'end', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  writable: true\n\t});\n\n\t// always a getter\n\t// always throws error for Moveto\n\tObject.defineProperty(segmentPrototype, 'start', {\n\t  // get a reference to the end point of previous segment\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\t    return this.previousSegment.end;\n\t  }\n\t});\n\n\t// virtual\n\tObject.defineProperty(segmentPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    throw new Error('Bad segment declaration. No type specified.');\n\t  }\n\t});\n\n\t// Path segment implementations:\n\tvar Lineto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Lineto)) {\n\t    // switching context of `this` to Lineto when called without `new`\n\t    return applyToNew(Lineto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Line) {\n\t    // lines provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 2) {\n\t      this.end = new Point(+args[0], +args[1]);\n\t      return this;\n\t    } else if (n < 2) {\n\t      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a poly-line segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 2) {\n\t        // coords come in groups of two\n\n\t        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t        outputArray.push(applyToNew(Lineto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 1) {\n\t      this.end = new Point(args[0]);\n\t      return this;\n\t    } else {\n\t      // this is a poly-line segment\n\t      var segmentPoint;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 1) {\n\t        segmentPoint = args[i];\n\t        outputArray.push(new Lineto(segmentPoint));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar linetoPrototype = {\n\t  clone: function () {\n\t    return new Lineto(this.end);\n\t  },\n\t  divideAt: function (ratio) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAt(ratio);\n\t    return [new Lineto(divided[0]), new Lineto(divided[1])];\n\t  },\n\t  divideAtLength: function (length) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAtLength(length);\n\t    return [new Lineto(divided[0]), new Lineto(divided[1])];\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment) return false;\n\t    return !this.start.equals(this.end);\n\t  },\n\t  round: function (precision) {\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var end = this.end;\n\t    return this.type + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(linetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'L'\n\t});\n\tLineto.prototype = extend$1(segmentPrototype, Line.prototype, linetoPrototype);\n\tvar Curveto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Curveto)) {\n\t    // switching context of `this` to Curveto when called without `new`\n\t    return applyToNew(Curveto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Curve) {\n\t    // curves provided\n\t    if (n === 1) {\n\t      this.controlPoint1 = args[0].controlPoint1.clone();\n\t      this.controlPoint2 = args[0].controlPoint2.clone();\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 6) {\n\t      this.controlPoint1 = new Point(+args[0], +args[1]);\n\t      this.controlPoint2 = new Point(+args[2], +args[3]);\n\t      this.end = new Point(+args[4], +args[5]);\n\t      return this;\n\t    } else if (n < 6) {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a poly-bezier segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 6) {\n\t        // coords come in groups of six\n\n\t        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\t        outputArray.push(applyToNew(Curveto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 3) {\n\t      this.controlPoint1 = new Point(args[0]);\n\t      this.controlPoint2 = new Point(args[1]);\n\t      this.end = new Point(args[2]);\n\t      return this;\n\t    } else if (n < 3) {\n\t      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\t    } else {\n\t      // this is a poly-bezier segment\n\t      var segmentPoints;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 3) {\n\t        // points come in groups of three\n\n\t        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\t        outputArray.push(applyToNew(Curveto, segmentPoints));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar curvetoPrototype = {\n\t  clone: function () {\n\t    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n\t  },\n\t  divideAt: function (ratio, opt) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAt(ratio, opt);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  divideAtLength: function (length, opt) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAtLength(length, opt);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  divideAtT: function (t) {\n\t    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    var divided = curve.divideAtT(t);\n\t    return [new Curveto(divided[0]), new Curveto(divided[1])];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment) return false;\n\t    var start = this.start;\n\t    var control1 = this.controlPoint1;\n\t    var control2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t  },\n\t  round: function (precision) {\n\t    this.controlPoint1.round(precision);\n\t    this.controlPoint2.round(precision);\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.controlPoint1.scale(sx, sy, origin);\n\t    this.controlPoint2.scale(sx, sy, origin);\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var c1 = this.controlPoint1;\n\t    var c2 = this.controlPoint2;\n\t    var end = this.end;\n\t    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.controlPoint1.translate(tx, ty);\n\t    this.controlPoint2.translate(tx, ty);\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(curvetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'C'\n\t});\n\tCurveto.prototype = extend$1(segmentPrototype, Curve.prototype, curvetoPrototype);\n\tvar Moveto = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Moveto)) {\n\t    // switching context of `this` to Moveto when called without `new`\n\t    return applyToNew(Moveto, args);\n\t  }\n\t  if (n === 0) {\n\t    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n\t  }\n\t  var outputArray;\n\t  if (args[0] instanceof Line) {\n\t    // lines provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t    }\n\t  } else if (args[0] instanceof Curve) {\n\t    // curves provided\n\t    if (n === 1) {\n\t      this.end = args[0].end.clone();\n\t      return this;\n\t    } else {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n\t    }\n\t  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n\t    // coordinates provided\n\t    if (n === 2) {\n\t      this.end = new Point(+args[0], +args[1]);\n\t      return this;\n\t    } else if (n < 2) {\n\t      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\t    } else {\n\t      // this is a moveto-with-subsequent-poly-line segment\n\t      var segmentCoords;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 2) {\n\t        // coords come in groups of two\n\n\t        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));\n\t      }\n\t      return outputArray;\n\t    }\n\t  } else {\n\t    // points provided (needs to be last to also cover plain objects with x and y)\n\t    if (n === 1) {\n\t      this.end = new Point(args[0]);\n\t      return this;\n\t    } else {\n\t      // this is a moveto-with-subsequent-poly-line segment\n\t      var segmentPoint;\n\t      outputArray = [];\n\t      for (i = 0; i < n; i += 1) {\n\t        // points come one by one\n\n\t        segmentPoint = args[i];\n\t        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));\n\t      }\n\t      return outputArray;\n\t    }\n\t  }\n\t};\n\tvar movetoPrototype = {\n\t  bbox: function () {\n\t    return null;\n\t  },\n\t  clone: function () {\n\t    return new Moveto(this.end);\n\t  },\n\t  closestPoint: function () {\n\t    return this.end.clone();\n\t  },\n\t  closestPointNormalizedLength: function () {\n\t    return 0;\n\t  },\n\t  closestPointLength: function () {\n\t    return 0;\n\t  },\n\t  closestPointT: function () {\n\t    return 1;\n\t  },\n\t  closestPointTangent: function () {\n\t    return null;\n\t  },\n\t  divideAt: function () {\n\t    return [this.clone(), this.clone()];\n\t  },\n\t  divideAtLength: function () {\n\t    return [this.clone(), this.clone()];\n\t  },\n\t  equals: function (m) {\n\t    return this.end.equals(m.end);\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    return false;\n\t  },\n\t  isSubpathStart: true,\n\t  isVisible: false,\n\t  length: function () {\n\t    return 0;\n\t  },\n\t  lengthAtT: function () {\n\t    return 0;\n\t  },\n\t  pointAt: function () {\n\t    return this.end.clone();\n\t  },\n\t  pointAtLength: function () {\n\t    return this.end.clone();\n\t  },\n\t  pointAtT: function () {\n\t    return this.end.clone();\n\t  },\n\t  round: function (precision) {\n\t    this.end.round(precision);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin) {\n\t    this.end.scale(sx, sy, origin);\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    var end = this.end;\n\t    return this.type + ' ' + end.x + ' ' + end.y;\n\t  },\n\t  tangentAt: function () {\n\t    return null;\n\t  },\n\t  tangentAtLength: function () {\n\t    return null;\n\t  },\n\t  tangentAtT: function () {\n\t    return null;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.end;\n\t  },\n\t  translate: function (tx, ty) {\n\t    this.end.translate(tx, ty);\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(movetoPrototype, 'start', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    throw new Error('Illegal access. Moveto segments should not need a start property.');\n\t  }\n\t});\n\tObject.defineProperty(movetoPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'M'\n\t});\n\tMoveto.prototype = extend$1(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\n\tvar Closepath = function () {\n\t  var args = [];\n\t  var n = arguments.length;\n\t  for (var i = 0; i < n; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  if (!(this instanceof Closepath)) {\n\t    // switching context of `this` to Closepath when called without `new`\n\t    return applyToNew(Closepath, args);\n\t  }\n\t  if (n > 0) {\n\t    throw new Error('Closepath constructor expects no arguments.');\n\t  }\n\t  return this;\n\t};\n\tvar closepathPrototype = {\n\t  clone: function () {\n\t    return new Closepath();\n\t  },\n\t  divideAt: function (ratio) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAt(ratio);\n\t    return [\n\t    // if we didn't actually cut into the segment, first divided part can stay as Z\n\t    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n\t  },\n\t  divideAtLength: function (length) {\n\t    var line = new Line(this.start, this.end);\n\t    var divided = line.divideAtLength(length);\n\t    return [\n\t    // if we didn't actually cut into the segment, first divided part can stay as Z\n\t    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n\t  },\n\t  getSubdivisions: function () {\n\t    return [];\n\t  },\n\t  isDifferentiable: function () {\n\t    if (!this.previousSegment || !this.subpathStartSegment) return false;\n\t    return !this.start.equals(this.end);\n\t  },\n\t  round: function () {\n\t    return this;\n\t  },\n\t  scale: function () {\n\t    return this;\n\t  },\n\t  serialize: function () {\n\t    return this.type;\n\t  },\n\t  toString: function () {\n\t    return this.type + ' ' + this.start + ' ' + this.end;\n\t  },\n\t  translate: function () {\n\t    return this;\n\t  }\n\t};\n\tObject.defineProperty(closepathPrototype, 'end', {\n\t  // get a reference to the end point of subpath start segment\n\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\t    return this.subpathStartSegment.end;\n\t  }\n\t});\n\tObject.defineProperty(closepathPrototype, 'type', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  value: 'Z'\n\t});\n\tClosepath.prototype = extend$1(segmentPrototype, Line.prototype, closepathPrototype);\n\tvar segmentTypes = Path$1.segmentTypes = {\n\t  L: Lineto,\n\t  C: Curveto,\n\t  M: Moveto,\n\t  Z: Closepath,\n\t  z: Closepath\n\t};\n\tPath$1.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\tPath$1.isDataSupported = function (data) {\n\t  if (typeof data !== 'string') return false;\n\t  return this.regexSupportedData.test(data);\n\t};\n\n\tconst bezier = {\n\t  // Cubic Bezier curve path through points.\n\t  // @deprecated\n\t  // @param {array} points Array of points through which the smooth line will go.\n\t  // @return {array} SVG Path commands as an array\n\t  curveThroughPoints: function (points) {\n\t    console.warn('deprecated');\n\t    return new Path$1(Curve.throughPoints(points)).serialize();\n\t  },\n\t  // Get open-ended Bezier Spline Control Points.\n\t  // @deprecated\n\t  // @param knots Input Knot Bezier spline points (At least two points!).\n\t  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t  getCurveControlPoints: function (knots) {\n\t    console.warn('deprecated');\n\t    var firstControlPoints = [];\n\t    var secondControlPoints = [];\n\t    var n = knots.length - 1;\n\t    var i;\n\n\t    // Special case: Bezier curve should be a straight line.\n\t    if (n == 1) {\n\t      // 3P1 = 2P0 + P3\n\t      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n\t      // P2 = 2P1  P0\n\t      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n\t      return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Calculate first Bezier control points.\n\t    // Right hand side vector.\n\t    var rhs = [];\n\n\t    // Set right hand side X values.\n\t    for (i = 1; i < n - 1; i++) {\n\t      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t    }\n\t    rhs[0] = knots[0].x + 2 * knots[1].x;\n\t    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t    // Get first control points X-values.\n\t    var x = this.getFirstControlPoints(rhs);\n\n\t    // Set right hand side Y values.\n\t    for (i = 1; i < n - 1; ++i) {\n\t      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t    }\n\t    rhs[0] = knots[0].y + 2 * knots[1].y;\n\t    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t    // Get first control points Y-values.\n\t    var y = this.getFirstControlPoints(rhs);\n\n\t    // Fill output arrays.\n\t    for (i = 0; i < n; i++) {\n\t      // First control point.\n\t      firstControlPoints.push(new Point(x[i], y[i]));\n\n\t      // Second control point.\n\t      if (i < n - 1) {\n\t        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n\t      } else {\n\t        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n\t      }\n\t    }\n\t    return [firstControlPoints, secondControlPoints];\n\t  },\n\t  // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n\t  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n\t  // @deprecated\n\t  // @param control points (start, control start, control end, end)\n\t  // @return a function that accepts t and returns 2 curves.\n\t  getCurveDivider: function (p0, p1, p2, p3) {\n\t    console.warn('deprecated');\n\t    var curve = new Curve(p0, p1, p2, p3);\n\t    return function divideCurve(t) {\n\t      var divided = curve.divide(t);\n\t      return [{\n\t        p0: divided[0].start,\n\t        p1: divided[0].controlPoint1,\n\t        p2: divided[0].controlPoint2,\n\t        p3: divided[0].end\n\t      }, {\n\t        p0: divided[1].start,\n\t        p1: divided[1].controlPoint1,\n\t        p2: divided[1].controlPoint2,\n\t        p3: divided[1].end\n\t      }];\n\t    };\n\t  },\n\t  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t  // @deprecated\n\t  // @param rhs Right hand side vector.\n\t  // @return Solution vector.\n\t  getFirstControlPoints: function (rhs) {\n\t    console.warn('deprecated');\n\t    var n = rhs.length;\n\t    // `x` is a solution vector.\n\t    var x = [];\n\t    var tmp = [];\n\t    var b = 2.0;\n\t    x[0] = rhs[0] / b;\n\n\t    // Decomposition and forward substitution.\n\t    for (var i = 1; i < n; i++) {\n\t      tmp[i] = 1 / b;\n\t      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t      x[i] = (rhs[i] - x[i - 1]) / b;\n\t    }\n\t    for (i = 1; i < n; i++) {\n\t      // Backsubstitution.\n\t      x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t    }\n\t    return x;\n\t  },\n\t  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n\t  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n\t  // which corresponds to that point.\n\t  // @deprecated\n\t  // @param control points (start, control start, control end, end)\n\t  // @return a function that accepts a point and returns t.\n\t  getInversionSolver: function (p0, p1, p2, p3) {\n\t    console.warn('deprecated');\n\t    var curve = new Curve(p0, p1, p2, p3);\n\t    return function solveInversion(p) {\n\t      return curve.closestPointT(p);\n\t    };\n\t  }\n\t};\n\n\tconst Polygon$1 = function (points) {\n\t  if (!(this instanceof Polygon$1)) {\n\t    return new Polygon$1(points);\n\t  }\n\t  if (typeof points === 'string') {\n\t    return new Polygon$1.parse(points);\n\t  }\n\t  this.points = Array.isArray(points) ? points.map(Point) : [];\n\t};\n\tPolygon$1.parse = function (svgString) {\n\t  return new Polygon$1(parsePoints(svgString));\n\t};\n\tPolygon$1.fromRect = function (rect) {\n\t  return new Polygon$1([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft()]);\n\t};\n\tPolygon$1.prototype = extend$1(Polyline$1.prototype, {\n\t  type: types.Polygon,\n\t  clone: function () {\n\t    return new Polygon$1(clonePoints(this.points));\n\t  },\n\t  convexHull: function () {\n\t    return new Polygon$1(convexHull(this.points));\n\t  },\n\t  lengthPoints: function () {\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = this;\n\t    if (points.length <= 1 || start.equals(end)) return points;\n\t    return [...points, start.clone()];\n\t  }\n\t});\n\n\tfunction exists(shape1, shape2, shape1opt, shape2opt) {\n\t  switch (shape1.type) {\n\t    case types.Line:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return lineWithLine(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Ellipse:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return ellipseWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return ellipseWithEllipse(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Rect:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return rectWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return rectWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return rectWithRect(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Polyline:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return polylineWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return polylineWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return polylineWithRect(shape1, shape2);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return polylineWithPolyline(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Polygon:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return polygonWithLine(shape1, shape2);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return polygonWithEllipse(shape1, shape2);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return polygonWithRect(shape1, shape2);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return polygonWithPolyline(shape1, shape2);\n\t            }\n\t          case types.Polygon:\n\t            {\n\t              return polygonWithPolygon(shape1, shape2);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t    case types.Path:\n\t      {\n\t        switch (shape2.type) {\n\t          case types.Line:\n\t            {\n\t              return pathWithLine(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Ellipse:\n\t            {\n\t              return pathWithEllipse(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Rect:\n\t            {\n\t              return pathWithRect(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Polyline:\n\t            {\n\t              return pathWithPolyline(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Polygon:\n\t            {\n\t              return pathWithPolygon(shape1, shape2, shape1opt);\n\t            }\n\t          case types.Path:\n\t            {\n\t              return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n\t            }\n\t        }\n\t        break;\n\t      }\n\t  }\n\t  // None of the cases above\n\t  switch (shape2.type) {\n\t    case types.Ellipse:\n\t    case types.Rect:\n\t    case types.Polyline:\n\t    case types.Polygon:\n\t    case types.Path:\n\t      {\n\t        return exists(shape2, shape1, shape2opt, shape1opt);\n\t      }\n\t    default:\n\t      {\n\t        throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n\t      }\n\t  }\n\t}\n\n\t/* Line */\n\n\tfunction lineWithLine(line1, line2) {\n\t  const x1 = line1.start.x;\n\t  const y1 = line1.start.y;\n\t  const x2 = line1.end.x;\n\t  const y2 = line1.end.y;\n\t  const x3 = line2.start.x;\n\t  const y3 = line2.start.y;\n\t  const x4 = line2.end.x;\n\t  const y4 = line2.end.y;\n\t  const s1x = x2 - x1;\n\t  const s1y = y2 - y1;\n\t  const s2x = x4 - x3;\n\t  const s2y = y4 - y3;\n\t  const s3x = x1 - x3;\n\t  const s3y = y1 - y3;\n\t  const p = s1x * s2y - s2x * s1y;\n\t  const s = (s1x * s3y - s1y * s3x) / p;\n\t  const t = (s2x * s3y - s2y * s3x) / p;\n\t  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n\t}\n\n\t/* Ellipse */\n\n\tfunction ellipseWithLine(ellipse, line) {\n\t  const rex = ellipse.a;\n\t  const rey = ellipse.b;\n\t  const xe = ellipse.x;\n\t  const ye = ellipse.y;\n\t  const x1 = line.start.x - xe;\n\t  const x2 = line.end.x - xe;\n\t  const y1 = line.start.y - ye;\n\t  const y2 = line.end.y - ye;\n\t  const rex_2 = rex * rex;\n\t  const rey_2 = rey * rey;\n\t  const dx = x2 - x1;\n\t  const dy = y2 - y1;\n\t  const A = dx * dx / rex_2 + dy * dy / rey_2;\n\t  const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n\t  const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n\t  const D = B * B - 4 * A * C;\n\t  if (D === 0) {\n\t    const t = -B / 2 / A;\n\t    return t >= 0 && t <= 1;\n\t  } else if (D > 0) {\n\t    const sqrt = Math.sqrt(D);\n\t    const t1 = (-B + sqrt) / 2 / A;\n\t    const t2 = (-B - sqrt) / 2 / A;\n\t    return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;\n\t  }\n\t  return false;\n\t}\n\tfunction ellipseWithEllipse(ellipse1, ellipse2) {\n\t  return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n\t}\n\n\t/* Rect */\n\n\tfunction rectWithLine(rect, line) {\n\t  const {\n\t    start,\n\t    end\n\t  } = line;\n\t  const {\n\t    x,\n\t    y,\n\t    width,\n\t    height\n\t  } = rect;\n\t  if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) {\n\t    return false;\n\t  }\n\t  if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n\t    return true;\n\t  }\n\t  return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);\n\t}\n\tfunction rectWithEllipse(rect, ellipse) {\n\t  if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n\t  return polygonWithEllipse(Polygon$1.fromRect(rect), ellipse);\n\t}\n\tfunction rectWithRect(rect1, rect2) {\n\t  return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;\n\t}\n\n\t/* Polyline */\n\n\tfunction polylineWithLine(polyline, line) {\n\t  return _polylineWithLine(polyline, line, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithEllipse(polyline, ellipse) {\n\t  return _polylineWithEllipse(polyline, ellipse, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithRect(polyline, rect) {\n\t  return _polylineWithRect(polyline, rect, {\n\t    interior: false\n\t  });\n\t}\n\tfunction polylineWithPolyline(polyline1, polyline2) {\n\t  return _polylineWithPolyline(polyline1, polyline2, {\n\t    interior: false\n\t  });\n\t}\n\n\t/* Polygon */\n\n\tfunction polygonWithLine(polygon, line) {\n\t  return _polylineWithLine(polygon, line, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithEllipse(polygon, ellipse) {\n\t  return _polylineWithEllipse(polygon, ellipse, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithRect(polygon, rect) {\n\t  return _polylineWithRect(polygon, rect, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithPolyline(polygon, polyline) {\n\t  return _polylineWithPolyline(polygon, polyline, {\n\t    interior: true\n\t  });\n\t}\n\tfunction polygonWithPolygon(polygon1, polygon2) {\n\t  return _polylineWithPolygon(polygon1, polygon2, {\n\t    interior: true\n\t  });\n\t}\n\n\t/* Path */\n\n\tfunction pathWithLine(path, line, pathOpt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return polygonWithLine(polyline, line);\n\t    } else {\n\t      return polylineWithLine(polyline, line);\n\t    }\n\t  });\n\t}\n\tfunction pathWithEllipse(path, ellipse, pathOpt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return polygonWithEllipse(polyline, ellipse);\n\t    } else {\n\t      return polylineWithEllipse(polyline, ellipse);\n\t    }\n\t  });\n\t}\n\tfunction pathWithRect(path, rect, pathOpt) {\n\t  return pathWithPolygon(path, Polygon$1.fromRect(rect), pathOpt);\n\t}\n\tfunction pathWithPolyline(path, polyline, pathOpt) {\n\t  return _pathWithPolyline(path, polyline, pathOpt, {\n\t    interior: false\n\t  });\n\t}\n\tfunction pathWithPolygon(path, polygon, pathOpt) {\n\t  return _pathWithPolyline(path, polygon, pathOpt, {\n\t    interior: true\n\t  });\n\t}\n\tfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n\t  return path1.getSubpaths().some(subpath => {\n\t    const [polyline1] = subpath.toPolylines(pathOpt1);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return pathWithPolygon(path2, polyline1, pathOpt2);\n\t    } else {\n\t      return pathWithPolyline(path2, polyline1, pathOpt2);\n\t    }\n\t  });\n\t}\n\tfunction _polylineWithLine(polyline, line, opt = {}) {\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  let thisPoints;\n\t  if (interior) {\n\t    if (polyline.containsPoint(line.start)) {\n\t      // If any point of the polyline lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the start point)\n\t      return true;\n\t    }\n\t    const {\n\t      start,\n\t      end,\n\t      points\n\t    } = polyline;\n\t    thisPoints = end.equals(start) ? points : [...points, start];\n\t  } else {\n\t    thisPoints = polyline.points;\n\t  }\n\t  const {\n\t    length\n\t  } = thisPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = thisPoints[i];\n\t    segment.end = thisPoints[i + 1];\n\t    if (lineWithLine(line, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n\t  const {\n\t    start,\n\t    end,\n\t    points\n\t  } = polyline;\n\t  if (ellipse.containsPoint(start)) {\n\t    return true;\n\t  }\n\t  let thisPoints;\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  if (interior) {\n\t    if (polyline.containsPoint(ellipse.center())) {\n\t      // If any point of the ellipse lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the center point)\n\t      return true;\n\t    }\n\t    thisPoints = end.equals(start) ? points : [...points, start];\n\t  } else {\n\t    thisPoints = points;\n\t  }\n\t  const {\n\t    length\n\t  } = thisPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = thisPoints[i];\n\t    segment.end = thisPoints[i + 1];\n\t    if (ellipseWithLine(ellipse, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithRect(polyline, rect, opt) {\n\t  const polygon = Polygon$1.fromRect(rect);\n\t  return _polylineWithPolygon(polyline, polygon, opt);\n\t}\n\tfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n\t  return path.getSubpaths().some(subpath => {\n\t    const [polyline2] = subpath.toPolylines(pathOpt);\n\t    const {\n\t      type\n\t    } = subpath.getSegment(-1);\n\t    if (type === 'Z') {\n\t      return _polylineWithPolygon(polyline1, polyline2, opt);\n\t    } else {\n\t      return _polylineWithPolyline(polyline1, polyline2, opt);\n\t    }\n\t  });\n\t}\n\tfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n\t  const {\n\t    interior = false\n\t  } = opt;\n\t  let thisPolyline;\n\t  if (interior) {\n\t    const {\n\t      start\n\t    } = polyline2;\n\t    if (polyline1.containsPoint(start)) {\n\t      // If any point of the polyline lies inside this polygon (interior = true)\n\t      // there is an intersection (we've chosen the start point)\n\t      return true;\n\t    }\n\t    thisPolyline = polyline1.clone().close();\n\t  } else {\n\t    thisPolyline = polyline1;\n\t  }\n\t  const otherPoints = polyline2.points;\n\t  const {\n\t    length\n\t  } = otherPoints;\n\t  const segment = new Line();\n\t  for (let i = 0; i < length - 1; i++) {\n\t    segment.start = otherPoints[i];\n\t    segment.end = otherPoints[i + 1];\n\t    if (polylineWithLine(thisPolyline, segment)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\tfunction _polylineWithPolygon(polyline, polygon, opt) {\n\t  return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n\t}\n\tfunction _ellipsesIntersection(e1, w1, e2, w2) {\n\t  const {\n\t    cos,\n\t    sin\n\t  } = Math;\n\t  const sinW1 = sin(w1);\n\t  const cosW1 = cos(w1);\n\t  const sinW2 = sin(w2);\n\t  const cosW2 = cos(w2);\n\t  const sinW1s = sinW1 * sinW1;\n\t  const cosW1s = cosW1 * cosW1;\n\t  const sinCos1 = sinW1 * cosW1;\n\t  const sinW2s = sinW2 * sinW2;\n\t  const cosW2s = cosW2 * cosW2;\n\t  const sinCos2 = sinW2 * cosW2;\n\t  const a1s = e1.a * e1.a;\n\t  const b1s = e1.b * e1.b;\n\t  const a2s = e2.a * e2.a;\n\t  const b2s = e2.b * e2.b;\n\t  const A1 = a1s * sinW1s + b1s * cosW1s;\n\t  const A2 = a2s * sinW2s + b2s * cosW2s;\n\t  const B1 = a1s * cosW1s + b1s * sinW1s;\n\t  const B2 = a2s * cosW2s + b2s * sinW2s;\n\t  let C1 = 2 * (b1s - a1s) * sinCos1;\n\t  let C2 = 2 * (b2s - a2s) * sinCos2;\n\t  let D1 = -2 * A1 * e1.x - C1 * e1.y;\n\t  let D2 = -2 * A2 * e2.x - C2 * e2.y;\n\t  let E1 = -C1 * e1.x - 2 * B1 * e1.y;\n\t  let E2 = -C2 * e2.x - 2 * B2 * e2.y;\n\t  const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n\t  const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\t  C1 = C1 / 2;\n\t  C2 = C2 / 2;\n\t  D1 = D1 / 2;\n\t  D2 = D2 / 2;\n\t  E1 = E1 / 2;\n\t  E2 = E2 / 2;\n\t  const l3 = det3([[A1, C1, D1], [C1, B1, E1], [D1, E1, F1]]);\n\t  const l0 = det3([[A2, C2, D2], [C2, B2, E2], [D2, E2, F2]]);\n\t  const l2 = 0.33333333 * (det3([[A2, C1, D1], [C2, B1, E1], [D2, E1, F1]]) + det3([[A1, C2, D1], [C1, B2, E1], [D1, E2, F1]]) + det3([[A1, C1, D2], [C1, B1, E2], [D1, E1, F2]]));\n\t  const l1 = 0.33333333 * (det3([[A1, C2, D2], [C1, B2, E2], [D1, E2, F2]]) + det3([[A2, C1, D2], [C2, B1, E2], [D2, E1, F2]]) + det3([[A2, C2, D1], [C2, B2, E1], [D2, E2, F1]]));\n\t  const delta1 = det2([[l3, l2], [l2, l1]]);\n\t  const delta2 = det2([[l3, l1], [l2, l0]]);\n\t  const delta3 = det2([[l2, l1], [l1, l0]]);\n\t  const dP = det2([[2 * delta1, delta2], [delta2, 2 * delta3]]);\n\t  if (dP > 0 && (l1 > 0 || l2 > 0)) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\tfunction det2(m) {\n\t  return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n\t}\n\tfunction det3(m) {\n\t  return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];\n\t}\n\n\tvar _intersection = {\n\t\t__proto__: null,\n\t\tellipseWithEllipse: ellipseWithEllipse,\n\t\tellipseWithLine: ellipseWithLine,\n\t\texists: exists,\n\t\tlineWithLine: lineWithLine,\n\t\tpathWithEllipse: pathWithEllipse,\n\t\tpathWithLine: pathWithLine,\n\t\tpathWithPath: pathWithPath,\n\t\tpathWithPolygon: pathWithPolygon,\n\t\tpathWithPolyline: pathWithPolyline,\n\t\tpathWithRect: pathWithRect,\n\t\tpolygonWithEllipse: polygonWithEllipse,\n\t\tpolygonWithLine: polygonWithLine,\n\t\tpolygonWithPolygon: polygonWithPolygon,\n\t\tpolygonWithPolyline: polygonWithPolyline,\n\t\tpolygonWithRect: polygonWithRect,\n\t\tpolylineWithEllipse: polylineWithEllipse,\n\t\tpolylineWithLine: polylineWithLine,\n\t\tpolylineWithPolyline: polylineWithPolyline,\n\t\tpolylineWithRect: polylineWithRect,\n\t\trectWithEllipse: rectWithEllipse,\n\t\trectWithLine: rectWithLine,\n\t\trectWithRect: rectWithRect\n\t};\n\n\t// Geometry library.\n\t// -----------------\n\n\tconst intersection$1 = _intersection;\n\n\tvar g = {\n\t\t__proto__: null,\n\t\tCurve: Curve,\n\t\tEllipse: Ellipse$1,\n\t\tLine: Line,\n\t\tPath: Path$1,\n\t\tPoint: Point,\n\t\tPolygon: Polygon$1,\n\t\tPolyline: Polyline$1,\n\t\tRect: Rect,\n\t\tbezier: bezier,\n\t\tellipse: ellipse$1,\n\t\tintersection: intersection$1,\n\t\tline: line$1,\n\t\tnormalizeAngle: normalizeAngle,\n\t\tpoint: point,\n\t\trandom: random,\n\t\trect: rect,\n\t\tscale: scale,\n\t\tsnapToGrid: snapToGrid$1,\n\t\ttoDeg: toDeg,\n\t\ttoRad: toRad,\n\t\ttypes: types\n\t};\n\n\t// code is inspired by https://github.com/lodash/lodash\n\n\t/* eslint-disable no-case-declarations */\n\t// -- helper constants\n\tconst argsTag = '[object Arguments]';\n\tconst arrayTag = '[object Array]';\n\tconst boolTag = '[object Boolean]';\n\tconst dateTag = '[object Date]';\n\tconst errorTag = '[object Error]';\n\tconst funcTag = '[object Function]';\n\tconst mapTag = '[object Map]';\n\tconst numberTag = '[object Number]';\n\tconst nullTag = '[object Null]';\n\tconst objectTag = '[object Object]';\n\tconst regexpTag = '[object RegExp]';\n\tconst setTag = '[object Set]';\n\tconst stringTag = '[object String]';\n\tconst symbolTag = '[object Symbol]';\n\tconst undefinedTag = '[object Undefined]';\n\tconst weakMapTag = '[object WeakMap]';\n\tconst arrayBufferTag = '[object ArrayBuffer]';\n\tconst dataViewTag = '[object DataView]';\n\tconst float32Tag = '[object Float32Array]';\n\tconst float64Tag = '[object Float64Array]';\n\tconst int8Tag = '[object Int8Array]';\n\tconst int16Tag = '[object Int16Array]';\n\tconst int32Tag = '[object Int32Array]';\n\tconst uint8Tag = '[object Uint8Array]';\n\tconst uint8ClampedTag = '[object Uint8ClampedArray]';\n\tconst uint16Tag = '[object Uint16Array]';\n\tconst uint32Tag = '[object Uint32Array]';\n\tconst CLONEABLE_TAGS = {\n\t  [argsTag]: true,\n\t  [arrayTag]: true,\n\t  [arrayBufferTag]: true,\n\t  [dataViewTag]: true,\n\t  [boolTag]: true,\n\t  [dateTag]: true,\n\t  [float32Tag]: true,\n\t  [float64Tag]: true,\n\t  [int8Tag]: true,\n\t  [int16Tag]: true,\n\t  [int32Tag]: true,\n\t  [mapTag]: true,\n\t  [numberTag]: true,\n\t  [objectTag]: true,\n\t  [regexpTag]: true,\n\t  [setTag]: true,\n\t  [stringTag]: true,\n\t  [symbolTag]: true,\n\t  [uint8Tag]: true,\n\t  [uint8ClampedTag]: true,\n\t  [uint16Tag]: true,\n\t  [uint32Tag]: true,\n\t  [errorTag]: false,\n\t  [funcTag]: false,\n\t  [weakMapTag]: false\n\t};\n\n\t/** Used to compose unicode character classes. */\n\tconst rsAstralRange = '\\\\ud800-\\\\udfff';\n\tconst rsComboMarksRange = '\\\\u0300-\\\\u036f';\n\tconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\n\tconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\n\tconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\n\tconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\n\tconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n\tconst rsDingbatRange = '\\\\u2700-\\\\u27bf';\n\tconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\n\tconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\n\tconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\n\tconst rsPunctuationRange = '\\\\u2000-\\\\u206f';\n\tconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\n\tconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\n\tconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\tconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n\t/** Used to compose unicode capture groups. */\n\tconst rsApos = '[\\'\\u2019]';\n\tconst rsBreak = `[${rsBreakRange}]`;\n\tconst rsCombo = `[${rsComboRange}]`;\n\tconst rsDigit = '\\\\d';\n\tconst rsDingbat = `[${rsDingbatRange}]`;\n\tconst rsLower = `[${rsLowerRange}]`;\n\tconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\n\tconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\n\tconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\n\tconst rsNonAstral = `[^${rsAstralRange}]`;\n\tconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\n\tconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\n\tconst rsUpper = `[${rsUpperRange}]`;\n\tconst rsZWJ = '\\\\u200d';\n\n\t/** Used to compose unicode regexes. */\n\tconst rsMiscLower = `(?:${rsLower}|${rsMisc})`;\n\tconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\n\tconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\n\tconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\n\tconst reOptMod = `${rsModifier}?`;\n\tconst rsOptVar = `[${rsVarRange}]?`;\n\tconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;\n\tconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\n\tconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\n\tconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\n\tconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;\n\n\t// eslint-disable-next-line no-misleading-character-class\n\tconst reUnicodeWords = RegExp([`${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`, `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`, `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`, `${rsUpper}+${rsOptContrUpper}`, rsOrdUpper, rsOrdLower, `${rsDigit}+`, rsEmoji].join('|'), 'g');\n\tconst LARGE_ARRAY_SIZE = 200;\n\tconst HASH_UNDEFINED = '__hash_undefined__';\n\n\t// Used to match `toStringTag` values of typed arrays\n\tconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n\t// Used to compose unicode capture groups\n\tconst rsAstral = `[${rsAstralRange}]`;\n\n\t// Used to compose unicode regexes\n\tconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\n\tconst rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;\n\n\t// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\n\t// eslint-disable-next-line no-misleading-character-class\n\tconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');\n\tconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n\tconst reIsPlainProp = /^\\w*$/;\n\tconst charCodeOfDot = '.'.charCodeAt(0);\n\tconst reEscapeChar = /\\\\(\\\\)?/g;\n\tconst rePropName = RegExp(\n\t// Match anything that isn't a dot or bracket.\n\t'[^.[\\\\]]+' + '|' +\n\t// Or match property names within brackets.\n\t'\\\\[(?:' +\n\t// Match a non-string expression.\n\t'([^\"\\'][^[]*)' + '|' +\n\t// Or match strings (supports escaping characters).\n\t'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' +\n\t// Or match \"\" as the space between consecutive dots or empty brackets.\n\t'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\n\tconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\tconst hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);\n\tconst MAX_ARRAY_INDEX = 4294967295 - 1;\n\n\t/** Used to match words composed of alphanumeric characters. */\n\t// eslint-disable-next-line no-control-regex\n\tconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\t// -- helper functions\n\tconst hasUnicode = string => {\n\t  return reUnicode.test(string);\n\t};\n\tconst unicodeToArray = string => {\n\t  return string.match(reUnicode) || [];\n\t};\n\tconst asciiToArray = string => {\n\t  return string.split('');\n\t};\n\tconst stringToArray = string => {\n\t  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n\t};\n\tconst values = object => {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  return keys(object).map(key => object[key]);\n\t};\n\tconst keys = object => {\n\t  return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n\t};\n\tconst baseKeys = object => {\n\t  if (!isPrototype(object)) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t  for (var key in Object(object)) {\n\t    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst arrayLikeKeys = (value, inherited) => {\n\t  const isArr = Array.isArray(value);\n\t  const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n\t  const isType = !isArr && !isArg && isTypedArray(value);\n\t  const skipIndexes = isArr || isArg || isType;\n\t  const length = value.length;\n\t  const result = new Array(skipIndexes ? length : 0);\n\t  let index = skipIndexes ? -1 : length;\n\t  while (++index < length) {\n\t    result[index] = `${index}`;\n\t  }\n\t  for (const key in value) {\n\t    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (\n\t    // Safari 9 has enumerable `arguments.length` in strict mode.\n\t    key === 'length' ||\n\t    // Skip index properties.\n\t    isIndex(key, length)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst assocIndexOf = (array, key) => {\n\t  let {\n\t    length\n\t  } = array;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t};\n\tconst eq = (value, other) => {\n\t  return value === other || value !== value && other !== other;\n\t};\n\tconst isObjectLike = value => {\n\t  return value != null && typeof value == 'object';\n\t};\n\tconst isIterateeCall = (value, index, object) => {\n\t  if (!isObject(object)) {\n\t    return false;\n\t  }\n\t  const type = typeof index;\n\t  const isPossibleIteratee = type == 'number' ? isArrayLike(object) && index > -1 && index < object.length : type == 'string' && index in object;\n\t  if (isPossibleIteratee) {\n\t    return eq(object[index], value);\n\t  }\n\t  return false;\n\t};\n\tconst isSet = value => {\n\t  return isObjectLike(value) && getTag(value) == setTag;\n\t};\n\tconst isMap = value => {\n\t  return isObjectLike(value) && getTag(value) == mapTag;\n\t};\n\tconst isPrototype = value => {\n\t  const Ctor = value && value.constructor;\n\t  const proto = typeof Ctor === 'function' && Ctor.prototype || Object.prototype;\n\t  return value === proto;\n\t};\n\tconst assignValue = (object, key, value) => {\n\t  const objValue = object[key];\n\t  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n\t    object[key] = value;\n\t  }\n\t};\n\tconst copyObject = (source, props, object) => {\n\t  let index = -1;\n\t  const length = props.length;\n\t  while (++index < length) {\n\t    const key = props[index];\n\t    assignValue(object, key, source[key]);\n\t  }\n\t  return object;\n\t};\n\tconst isArrayLike = value => {\n\t  return value != null && typeof value !== 'function' && typeof value.length === 'number' && value.length > -1 && value.length % 1 === 0;\n\t};\n\tconst isSymbol = value => {\n\t  return typeof value == 'symbol' || isObjectLike(value) && getTag(value) === symbolTag;\n\t};\n\tconst initCloneArray = array => {\n\t  const length = array.length;\n\t  let result = new array.constructor(length);\n\t  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t    result.index = array.index;\n\t    result.input = array.input;\n\t  }\n\t  return result;\n\t};\n\tconst copyArray = (source, array) => {\n\t  let index = -1;\n\t  const length = source.length;\n\t  array || (array = new Array(length));\n\t  while (++index < length) {\n\t    array[index] = source[index];\n\t  }\n\t  return array;\n\t};\n\tconst getTag = value => {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag : nullTag;\n\t  }\n\t  return Object.prototype.toString.call(value);\n\t};\n\tconst cloneArrayBuffer = arrayBuffer => {\n\t  const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n\t  return result;\n\t};\n\tconst cloneTypedArray = (typedArray, isDeep) => {\n\t  const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t};\n\tconst cloneRegExp = regexp => {\n\t  const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n\t  result.lastIndex = regexp.lastIndex;\n\t  return result;\n\t};\n\tconst initCloneObject = object => {\n\t  return typeof object.constructor == 'function' && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};\n\t};\n\tconst getSymbols = object => {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  object = Object(object);\n\t  const symbols = Object.getOwnPropertySymbols(object);\n\t  return symbols.filter(symbol => propertyIsEnumerable.call(object, symbol));\n\t};\n\tconst copySymbols = (source, object) => {\n\t  return copyObject(source, getSymbols(source), object);\n\t};\n\tfunction cloneDataView(dataView, isDeep) {\n\t  const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t}\n\tconst initCloneByTag = (object, tag, isDeep) => {\n\t  const Constructor = object.constructor;\n\t  switch (tag) {\n\t    case arrayBufferTag:\n\t      return cloneArrayBuffer(object);\n\t    case boolTag:\n\t    case dateTag:\n\t      return new Constructor(+object);\n\t    case dataViewTag:\n\t      return cloneDataView(object, isDeep);\n\t    case float32Tag:\n\t    case float64Tag:\n\t    case int8Tag:\n\t    case int16Tag:\n\t    case int32Tag:\n\t    case uint8Tag:\n\t    case uint8ClampedTag:\n\t    case uint16Tag:\n\t    case uint32Tag:\n\t      return cloneTypedArray(object, isDeep);\n\t    case mapTag:\n\t      return new Constructor(object);\n\t    case numberTag:\n\t    case stringTag:\n\t      return new Constructor(object);\n\t    case regexpTag:\n\t      return cloneRegExp(object);\n\t    case setTag:\n\t      return new Constructor();\n\t    case symbolTag:\n\t      return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n\t  }\n\t};\n\tconst isTypedArray = value => {\n\t  return isObjectLike(value) && reTypedTag.test(getTag(value));\n\t};\n\tconst getAllKeys = object => {\n\t  const result = Object.keys(object);\n\t  if (!Array.isArray(object) && object != null) {\n\t    result.push(...getSymbols(Object(object)));\n\t  }\n\t  return result;\n\t};\n\tconst getSymbolsIn = object => {\n\t  const result = [];\n\t  while (object) {\n\t    result.push(...getSymbols(object));\n\t    object = Object.getPrototypeOf(Object(object));\n\t  }\n\t  return result;\n\t};\n\tconst getAllKeysIn = object => {\n\t  const result = [];\n\t  for (const key in object) {\n\t    result.push(key);\n\t  }\n\t  if (!Array.isArray(object)) {\n\t    result.push(...getSymbolsIn(object));\n\t  }\n\t  return result;\n\t};\n\tconst getMapData = ({\n\t  __data__\n\t}, key) => {\n\t  const data = __data__;\n\t  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;\n\t};\n\tconst equalObjects = (object, other, equalFunc, stack) => {\n\t  const objProps = getAllKeys(object);\n\t  const objLength = objProps.length;\n\t  const othProps = getAllKeys(other);\n\t  const othLength = othProps.length;\n\t  if (objLength != othLength) {\n\t    return false;\n\t  }\n\t  let key;\n\t  let index = objLength;\n\t  while (index--) {\n\t    key = objProps[index];\n\t    if (!hasOwnProperty.call(other, key)) {\n\t      return false;\n\t    }\n\t  }\n\t  const objStacked = stack.get(object);\n\t  const othStacked = stack.get(other);\n\t  if (objStacked && othStacked) {\n\t    return objStacked == other && othStacked == object;\n\t  }\n\t  let result = true;\n\t  stack.set(object, other);\n\t  stack.set(other, object);\n\t  let compared;\n\t  let skipCtor;\n\t  while (++index < objLength) {\n\t    key = objProps[index];\n\t    const objValue = object[key];\n\t    const othValue = other[key];\n\t    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {\n\t      result = false;\n\t      break;\n\t    }\n\t    skipCtor || (skipCtor = key == 'constructor');\n\t  }\n\t  if (result && !skipCtor) {\n\t    const objCtor = object.constructor;\n\t    const othCtor = other.constructor;\n\t    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n\t      result = false;\n\t    }\n\t  }\n\t  stack['delete'](object);\n\t  stack['delete'](other);\n\t  return result;\n\t};\n\tconst baseIsEqual = (value, other, stack) => {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n\t    return value !== value && other !== other;\n\t  }\n\t  return baseIsEqualDeep(value, other, baseIsEqual, stack);\n\t};\n\tconst baseIsEqualDeep = (object, other, equalFunc, stack) => {\n\t  let objIsArr = Array.isArray(object);\n\t  const othIsArr = Array.isArray(other);\n\t  let objTag = objIsArr ? arrayTag : getTag(object);\n\t  let othTag = othIsArr ? arrayTag : getTag(other);\n\t  objTag = objTag == argsTag ? objectTag : objTag;\n\t  othTag = othTag == argsTag ? objectTag : othTag;\n\t  let objIsObj = objTag == objectTag;\n\t  const othIsObj = othTag == objectTag;\n\t  const isSameTag = objTag == othTag;\n\t  if (isSameTag && !objIsObj) {\n\t    stack || (stack = new Stack());\n\t    return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);\n\t  }\n\t  const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n\t  const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t  if (objIsWrapped || othIsWrapped) {\n\t    const objUnwrapped = objIsWrapped ? object.value() : object;\n\t    const othUnwrapped = othIsWrapped ? other.value() : other;\n\t    stack || (stack = new Stack());\n\t    return equalFunc(objUnwrapped, othUnwrapped, stack);\n\t  }\n\t  if (!isSameTag) {\n\t    return false;\n\t  }\n\t  stack || (stack = new Stack());\n\t  return equalObjects(object, other, equalFunc, stack);\n\t};\n\tconst equalArrays = (array, other, compareUnordered, equalFunc, stack) => {\n\t  const isPartial = false;\n\t  const arrLength = array.length;\n\t  const othLength = other.length;\n\t  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t    return false;\n\t  }\n\t  // Assume cyclic values are equal.\n\t  const arrStacked = stack.get(array);\n\t  const othStacked = stack.get(other);\n\t  if (arrStacked && othStacked) {\n\t    return arrStacked == other && othStacked == array;\n\t  }\n\t  let index = -1;\n\t  let result = true;\n\t  const seen = compareUnordered ? new SetCache() : undefined;\n\t  stack.set(array, other);\n\t  stack.set(other, array);\n\t  while (++index < arrLength) {\n\t    let compared;\n\t    const arrValue = array[index];\n\t    const othValue = other[index];\n\t    if (compared !== undefined) {\n\t      if (compared) {\n\t        continue;\n\t      }\n\t      result = false;\n\t      break;\n\t    }\n\t    if (seen) {\n\t      if (!some(other, (othValue, othIndex) => {\n\t        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n\t          return seen.push(othIndex);\n\t        }\n\t      })) {\n\t        result = false;\n\t        break;\n\t      }\n\t    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n\t      result = false;\n\t      break;\n\t    }\n\t  }\n\t  stack['delete'](array);\n\t  stack['delete'](other);\n\t  return result;\n\t};\n\tconst some = (array, predicate) => {\n\t  let index = -1;\n\t  const length = array == null ? 0 : array.length;\n\t  while (++index < length) {\n\t    if (predicate(array[index], index, array)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t};\n\tconst cacheHas = (cache, key) => {\n\t  return cache.has(key);\n\t};\n\tconst compareArrayBufferTag = (object, other, equalFunc, stack) => {\n\t  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tconst equalByTag = (object, other, tag, equalFunc, stack) => {\n\t  switch (tag) {\n\t    case dataViewTag:\n\t      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n\t        return false;\n\t      }\n\t      object = object.buffer;\n\t      other = other.buffer;\n\t      return compareArrayBufferTag(object, other, equalFunc, stack);\n\t    case arrayBufferTag:\n\t      return compareArrayBufferTag(object, other, equalFunc, stack);\n\t    case boolTag:\n\t    case dateTag:\n\t    case numberTag:\n\t      return eq(+object, +other);\n\t    case errorTag:\n\t      return object.name == other.name && object.message == other.message;\n\t    case regexpTag:\n\t    case stringTag:\n\t      return object == `${other}`;\n\t    case mapTag:\n\t      // This use of 'var' is intentional. Don't remove if replacing all instances.\n\t      var convert = mapToArray;\n\t    // Intentional fallthrough\n\t    // eslint-disable-next-line no-fallthrough\n\t    case setTag:\n\t      convert || (convert = setToArray);\n\t      if (object.size != other.size) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      const stacked = stack.get(object);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\n\t      // Recursively compare objects (susceptible to call stack limits).\n\t      stack.set(object, other);\n\t      const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n\t      stack['delete'](object);\n\t      return result;\n\t    case symbolTag:\n\t      return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n\t  }\n\t  return false;\n\t};\n\tconst mapToArray = map => {\n\t  let index = -1;\n\t  let result = Array(map.size);\n\t  map.forEach((value, key) => {\n\t    result[++index] = [key, value];\n\t  });\n\t  return result;\n\t};\n\tconst setToArray = set => {\n\t  let index = -1;\n\t  const result = new Array(set.size);\n\t  set.forEach(value => {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t};\n\tconst isKey = (value, object) => {\n\t  if (Array.isArray(value)) {\n\t    return false;\n\t  }\n\t  const type = typeof value;\n\t  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n\t    return true;\n\t  }\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n\t};\n\tconst stringToPath = string => {\n\t  const result = [];\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\n\t    result.push('');\n\t  }\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\n\t    let key = match;\n\t    if (quote) {\n\t      key = subString.replace(reEscapeChar, '$1');\n\t    } else if (expression) {\n\t      key = expression.trim();\n\t    }\n\t    result.push(key);\n\t  });\n\t  return result;\n\t};\n\tconst castPath = (path, object) => {\n\t  if (Array.isArray(path)) {\n\t    return path;\n\t  }\n\t  return isKey(path, object) ? [path] : stringToPath(`${path}`);\n\t};\n\tconst get = (object, path) => {\n\t  path = castPath(path, object);\n\t  let index = 0;\n\t  const length = path.length;\n\t  while (object != null && index < length) {\n\t    object = object[toKey(path[index])];\n\t    index++;\n\t  }\n\t  return index && index == length ? object : undefined;\n\t};\n\tfunction compareAscending(value, other) {\n\t  if (value !== other) {\n\t    const valIsDefined = value !== undefined;\n\t    const valIsNull = value === null;\n\t    const valIsReflexive = value === value;\n\t    const valIsSymbol = isSymbol(value);\n\t    const othIsDefined = other !== undefined;\n\t    const othIsNull = other === null;\n\t    const othIsReflexive = other === other;\n\t    const othIsSymbol = isSymbol(other);\n\t    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n\t      return 1;\n\t    }\n\t    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n\t      return -1;\n\t    }\n\t  }\n\t  return 0;\n\t}\n\tfunction compareMultiple(object, other, orders) {\n\t  let index = -1;\n\t  const objCriteria = object.criteria;\n\t  const othCriteria = other.criteria;\n\t  const length = objCriteria.length;\n\t  const ordersLength = orders.length;\n\t  while (++index < length) {\n\t    const order = index < ordersLength ? orders[index] : null;\n\t    const cmpFn = order && typeof order === 'function' ? order : compareAscending;\n\t    const result = cmpFn(objCriteria[index], othCriteria[index]);\n\t    if (result) {\n\t      if (order && typeof order !== 'function') {\n\t        return result * (order == 'desc' ? -1 : 1);\n\t      }\n\t      return result;\n\t    }\n\t  }\n\t  return object.index - other.index;\n\t}\n\tconst diff = (array, values) => {\n\t  let includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  let isCommon = true;\n\t  const result = [];\n\t  const valuesLength = values.length;\n\t  if (!array.length) {\n\t    return result;\n\t  }\n\t  if (values.length >= LARGE_ARRAY_SIZE) {\n\t    includes = (cache, key) => cache.has(key);\n\t    isCommon = false;\n\t    values = new SetCache(values);\n\t  }\n\t  outer: for (let key in array) {\n\t    let value = array[key];\n\t    const computed = value;\n\t    value = value !== 0 ? value : 0;\n\t    if (isCommon && computed === computed) {\n\t      let valuesIndex = valuesLength;\n\t      while (valuesIndex--) {\n\t        if (values[valuesIndex] === computed) {\n\t          continue outer;\n\t        }\n\t      }\n\t      result.push(value);\n\t    } else if (!includes(values, computed)) {\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst intersect = arrays => {\n\t  const includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  const cacheHas = (cache, key) => cache.has(key);\n\t  const length = arrays[0].length;\n\t  const othLength = arrays.length;\n\t  const caches = new Array(othLength);\n\t  const result = [];\n\t  let array;\n\t  let maxLength = Infinity;\n\t  let othIndex = othLength;\n\t  while (othIndex--) {\n\t    array = arrays[othIndex];\n\t    maxLength = Math.min(array.length, maxLength);\n\t    caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;\n\t  }\n\t  array = arrays[0];\n\t  let index = -1;\n\t  const seen = caches[0];\n\t  outer: while (++index < length && result.length < maxLength) {\n\t    let value = array[index];\n\t    const computed = value;\n\t    value = value !== 0 ? value : 0;\n\t    if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {\n\t      othIndex = othLength;\n\t      while (--othIndex) {\n\t        const cache = caches[othIndex];\n\t        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) {\n\t          continue outer;\n\t        }\n\t      }\n\t      if (seen) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst toKey = value => {\n\t  if (typeof value === 'string' || isSymbol(value)) {\n\t    return value;\n\t  }\n\t  const result = `${value}`;\n\t  return result == '0' && 1 / value == -Infinity ? '-0' : result;\n\t};\n\tconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {\n\t  let result;\n\t  if (customizer) {\n\t    result = object ? customizer(value, key, object, stack) : customizer(value);\n\t  }\n\t  if (result !== undefined) {\n\t    return result;\n\t  }\n\t  if (!isObject(value)) {\n\t    return value;\n\t  }\n\t  const isArr = Array.isArray(value);\n\t  const tag = getTag(value);\n\t  if (isArr) {\n\t    result = initCloneArray(value);\n\t    if (!isDeep) {\n\t      return copyArray(value, result);\n\t    }\n\t  } else {\n\t    const isFunc = typeof value === 'function';\n\t    if (tag === objectTag || tag === argsTag || isFunc && !object) {\n\t      result = isFlat || isFunc ? {} : initCloneObject(value);\n\t      if (!isDeep) {\n\t        return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));\n\t      }\n\t    } else {\n\t      if (isFunc || !CLONEABLE_TAGS[tag]) {\n\t        return object ? value : {};\n\t      }\n\t      result = initCloneByTag(value, tag, isDeep);\n\t    }\n\t  }\n\t  stack || (stack = new Stack());\n\t  const stacked = stack.get(value);\n\t  if (stacked) {\n\t    return stacked;\n\t  }\n\t  stack.set(value, result);\n\t  if (isMap(value)) {\n\t    value.forEach((subValue, key) => {\n\t      result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t    });\n\t    return result;\n\t  }\n\t  if (isSet(value)) {\n\t    value.forEach(subValue => {\n\t      result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n\t    });\n\t    return result;\n\t  }\n\t  if (isTypedArray(value)) {\n\t    return result;\n\t  }\n\t  const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n\t  const props = isArr ? undefined : keysFunc(value);\n\t  (props || value).forEach((subValue, key) => {\n\t    if (props) {\n\t      key = subValue;\n\t      subValue = value[key];\n\t    }\n\t    assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t  });\n\t  return result;\n\t};\n\tconst copySymbolsIn = (source, object) => {\n\t  return copyObject(source, getSymbolsIn(source), object);\n\t};\n\tconst parent = (object, path) => {\n\t  return path.length < 2 ? object : get(object, path.slice(0, -1));\n\t};\n\tconst set = (object, path, value) => {\n\t  if (!isObject(object)) {\n\t    return object;\n\t  }\n\t  path = castPath(path, object);\n\t  const length = path.length;\n\t  const lastIndex = length - 1;\n\t  let index = -1;\n\t  let nested = object;\n\t  while (nested != null && ++index < length) {\n\t    const key = toKey(path[index]);\n\t    let newValue = value;\n\t    if (index != lastIndex) {\n\t      const objValue = nested[key];\n\t      newValue = undefined;\n\t      if (newValue === undefined) {\n\t        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n\t      }\n\t    }\n\t    assignValue(nested, key, newValue);\n\t    nested = nested[key];\n\t  }\n\t  return object;\n\t};\n\tconst isIndex = (value, length) => {\n\t  const type = typeof value;\n\t  length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\t  return !!length && (type === 'number' || type !== 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n\t};\n\tconst unset = (object, path) => {\n\t  path = castPath(path, object);\n\t  object = parent(object, path);\n\t  const lastSegment = path[path.length - 1];\n\t  return object == null || delete object[toKey(lastSegment)];\n\t};\n\tconst isKeyable = value => {\n\t  const type = typeof value;\n\t  return type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean' ? value !== '__proto__' : value === null;\n\t};\n\tconst keysIn = object => {\n\t  const result = [];\n\t  for (const key in object) {\n\t    result.push(key);\n\t  }\n\t  return result;\n\t};\n\tconst toPlainObject = value => {\n\t  value = Object(value);\n\t  const result = {};\n\t  for (const key in value) {\n\t    result[key] = value[key];\n\t  }\n\t  return result;\n\t};\n\tconst safeGet = (object, key) => {\n\t  if (key === 'constructor' && typeof object[key] === 'function') {\n\t    return;\n\t  }\n\t  if (key == '__proto__') {\n\t    return;\n\t  }\n\t  return object[key];\n\t};\n\tfunction createAssigner(assigner, isMerge = false) {\n\t  return (object, ...sources) => {\n\t    let index = -1;\n\t    let length = sources.length;\n\t    let customizer = length > 1 ? sources[length - 1] : undefined;\n\t    const guard = length > 2 ? sources[2] : undefined;\n\t    customizer = assigner.length > 3 && typeof customizer === 'function' ? (length--, customizer) : isMerge ? (a, b) => {\n\t      if (Array.isArray(a) && !Array.isArray(b)) {\n\t        return b;\n\t      }\n\t    } : undefined;\n\t    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t      customizer = length < 3 ? undefined : customizer;\n\t      length = 1;\n\t    }\n\t    object = Object(object);\n\t    while (++index < length) {\n\t      const source = sources[index];\n\t      if (source) {\n\t        assigner(object, source, index, customizer);\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\tconst baseMerge = (object, source, srcIndex, customizer, stack) => {\n\t  if (object === source) {\n\t    return;\n\t  }\n\t  forIn(source, (srcValue, key) => {\n\t    if (isObject(srcValue)) {\n\t      stack || (stack = new Stack());\n\t      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n\t    } else {\n\t      let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : undefined;\n\t      if (newValue === undefined) {\n\t        newValue = srcValue;\n\t      }\n\t      assignMergeValue(object, key, newValue);\n\t    }\n\t  });\n\t};\n\tconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {\n\t  const objValue = safeGet(object, key);\n\t  const srcValue = safeGet(source, key);\n\t  const stacked = stack.get(srcValue);\n\t  if (stacked) {\n\t    assignMergeValue(object, key, stacked);\n\t    return;\n\t  }\n\t  let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : undefined;\n\t  let isCommon = newValue === undefined;\n\t  if (isCommon) {\n\t    const isArr = Array.isArray(srcValue);\n\t    const isTyped = !isArr && isTypedArray(srcValue);\n\t    newValue = srcValue;\n\t    if (isArr || isTyped) {\n\t      if (Array.isArray(objValue)) {\n\t        newValue = objValue;\n\t      } else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n\t        newValue = copyArray(objValue);\n\t      } else if (isTyped) {\n\t        isCommon = false;\n\t        newValue = cloneTypedArray(srcValue, true);\n\t      } else {\n\t        newValue = [];\n\t      }\n\t    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t      newValue = objValue;\n\t      if (isArguments(objValue)) {\n\t        newValue = toPlainObject(objValue);\n\t      } else if (typeof objValue === 'function' || !isObject(objValue)) {\n\t        newValue = initCloneObject(srcValue);\n\t      }\n\t    } else {\n\t      isCommon = false;\n\t    }\n\t  }\n\t  if (isCommon) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t    stack.set(srcValue, newValue);\n\t    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n\t    stack['delete'](srcValue);\n\t  }\n\t  assignMergeValue(object, key, newValue);\n\t};\n\tconst assignMergeValue = (object, key, value) => {\n\t  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n\t    assignValue(object, key, value);\n\t  }\n\t};\n\tfunction baseFor(object, iteratee, keysFunc) {\n\t  const iterable = Object(object);\n\t  const props = keysFunc(object);\n\t  let {\n\t    length\n\t  } = props;\n\t  let index = -1;\n\t  while (length--) {\n\t    const key = props[++index];\n\t    if (iteratee(iterable[key], key, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return object;\n\t}\n\tconst baseForOwn = (object, iteratee) => {\n\t  return object && baseFor(object, iteratee, keys);\n\t};\n\tconst baseEach = (collection, iteratee) => {\n\t  if (collection == null) {\n\t    return collection;\n\t  }\n\t  if (!isArrayLike(collection)) {\n\t    return baseForOwn(collection, iteratee);\n\t  }\n\t  const length = collection.length;\n\t  const iterable = Object(collection);\n\t  let index = -1;\n\t  while (++index < length) {\n\t    if (iteratee(iterable[index], index, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return collection;\n\t};\n\tfunction last(array) {\n\t  const length = array == null ? 0 : array.length;\n\t  return length ? array[length - 1] : undefined;\n\t}\n\tconst createSet = Set && 1 / setToArray(new Set([undefined, -0]))[1] == 1 / 0 ? values => new Set(values) : () => {/* no-op */};\n\tfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n\t  if (isObject(objValue) && isObject(srcValue)) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t    stack.set(srcValue, objValue);\n\t    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n\t    stack['delete'](srcValue);\n\t  }\n\t  return objValue;\n\t}\n\tfunction baseOrderBy(collection, iteratees, orders) {\n\t  if (iteratees.length) {\n\t    iteratees = iteratees.map(iteratee => {\n\t      if (Array.isArray(iteratee)) {\n\t        return value => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n\t      }\n\t      return iteratee;\n\t    });\n\t  } else {\n\t    iteratees = [value => value];\n\t  }\n\t  let criteriaIndex = -1;\n\t  let eachIndex = -1;\n\t  const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\t  baseEach(collection, value => {\n\t    const criteria = iteratees.map(iteratee => iteratee(value));\n\t    result[++eachIndex] = {\n\t      criteria,\n\t      index: ++criteriaIndex,\n\t      value\n\t    };\n\t  });\n\t  return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));\n\t}\n\tfunction baseSortBy(array, comparer) {\n\t  let {\n\t    length\n\t  } = array;\n\t  array.sort(comparer);\n\t  while (length--) {\n\t    array[length] = array[length].value;\n\t  }\n\t  return array;\n\t}\n\tfunction isStrictComparable(value) {\n\t  return value === value && !isObject(value);\n\t}\n\tfunction matchesStrictComparable(key, srcValue) {\n\t  return object => {\n\t    if (object == null) {\n\t      return false;\n\t    }\n\t    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n\t  };\n\t}\n\tfunction hasIn(object, path) {\n\t  return object != null && hasPath(object, path, baseHasIn);\n\t}\n\tfunction baseMatchesProperty(path, srcValue) {\n\t  if (isKey(path) && isStrictComparable(srcValue)) {\n\t    return matchesStrictComparable(toKey(path), srcValue);\n\t  }\n\t  return object => {\n\t    const objValue = get(object, path);\n\t    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);\n\t  };\n\t}\n\tfunction baseMatches(source) {\n\t  const matchData = getMatchData(source);\n\t  if (matchData.length === 1 && matchData[0][2]) {\n\t    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t  }\n\t  return object => object === source || baseIsMatch(object, source, matchData);\n\t}\n\tfunction getMatchData(object) {\n\t  const result = keys(object);\n\t  let length = result.length;\n\t  while (length--) {\n\t    const key = result[length];\n\t    const value = object[key];\n\t    result[length] = [key, value, isStrictComparable(value)];\n\t  }\n\t  return result;\n\t}\n\tfunction baseIsMatch(object, source, matchData, customizer) {\n\t  let index = matchData.length;\n\t  const length = index;\n\t  const noCustomizer = !customizer;\n\t  if (object == null) {\n\t    return !length;\n\t  }\n\t  let data;\n\t  let result;\n\t  object = Object(object);\n\t  while (index--) {\n\t    data = matchData[index];\n\t    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n\t      return false;\n\t    }\n\t  }\n\t  while (++index < length) {\n\t    data = matchData[index];\n\t    const key = data[0];\n\t    const objValue = object[key];\n\t    const srcValue = data[1];\n\t    if (noCustomizer && data[2]) {\n\t      if (objValue === undefined && !(key in object)) {\n\t        return false;\n\t      }\n\t    } else {\n\t      const stack = new Stack();\n\t      if (customizer) {\n\t        result = customizer(objValue, srcValue, key, object, source, stack);\n\t      }\n\t      if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\tfunction property(path) {\n\t  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t}\n\tfunction baseProperty(key) {\n\t  return object => object == null ? undefined : object[key];\n\t}\n\tfunction basePropertyDeep(path) {\n\t  return object => get(object, path);\n\t}\n\tfunction baseIteratee(value) {\n\t  if (typeof value == 'function') {\n\t    return value;\n\t  }\n\t  if (value == null) {\n\t    return val => val;\n\t  }\n\t  if (typeof value == 'object') {\n\t    return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n\t  }\n\t  return property(value);\n\t}\n\tfunction getIteratee() {\n\t  const result = baseIteratee;\n\t  return arguments.length ? result(arguments[0], arguments[1]) : result;\n\t}\n\tconst arrayReduce = (array, iteratee, accumulator, initAccum) => {\n\t  let index = -1;\n\t  const length = array == null ? 0 : array.length;\n\t  if (initAccum && length) {\n\t    accumulator = array[++index];\n\t  }\n\t  while (++index < length) {\n\t    accumulator = iteratee(accumulator, array[index], index, array);\n\t  }\n\t  return accumulator;\n\t};\n\tconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {\n\t  eachFunc(collection, (value, index, collection) => {\n\t    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n\t  });\n\t  return accumulator;\n\t};\n\tfunction reduce(collection, iteratee, accumulator) {\n\t  const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n\t  const initAccum = arguments.length < 3;\n\t  return func(collection, iteratee, accumulator, initAccum, baseEach);\n\t}\n\tconst isFlattenable = value => {\n\t  return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);\n\t};\n\tfunction baseFlatten(array, depth, predicate, isStrict, result) {\n\t  let index = -1;\n\t  const length = array.length;\n\t  predicate || (predicate = isFlattenable);\n\t  result || (result = []);\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    if (depth > 0 && predicate(value)) {\n\t      if (depth > 1) {\n\t        // Recursively flatten arrays (susceptible to call stack limits).\n\t        baseFlatten(value, depth - 1, predicate, isStrict, result);\n\t      } else {\n\t        result.push(...value);\n\t      }\n\t    } else if (!isStrict) {\n\t      result[result.length] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\tconst isArguments = value => {\n\t  return isObjectLike(value) && getTag(value) == '[object Arguments]';\n\t};\n\tconst basePick = (object, paths) => {\n\t  return basePickBy(object, paths, (value, path) => hasIn(object, path));\n\t};\n\tconst basePickBy = (object, paths, predicate) => {\n\t  let index = -1;\n\t  const length = paths.length;\n\t  const result = {};\n\t  while (++index < length) {\n\t    const path = paths[index];\n\t    const value = get(object, path);\n\t    if (predicate(value, path)) {\n\t      set(result, castPath(path, object), value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst isLength = value => {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n\t};\n\tconst baseHasIn = (object, key) => {\n\t  return object != null && key in Object(object);\n\t};\n\tconst hasPath = (object, path, hasFunc) => {\n\t  path = castPath(path, object);\n\t  var index = -1,\n\t    length = path.length,\n\t    result = false;\n\t  while (++index < length) {\n\t    var key = toKey(path[index]);\n\t    if (!(result = object != null && hasFunc(object, key))) {\n\t      break;\n\t    }\n\t    object = object[key];\n\t  }\n\t  if (result || ++index != length) {\n\t    return result;\n\t  }\n\t  length = object == null ? 0 : object.length;\n\t  return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));\n\t};\n\tconst asciiWords = string => {\n\t  return string.match(reAsciiWord);\n\t};\n\tconst unicodeWords = string => {\n\t  return string.match(reUnicodeWords);\n\t};\n\tconst words = (string, pattern) => {\n\t  if (pattern === undefined) {\n\t    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n\t    return result || [];\n\t  }\n\t  return string.match(pattern) || [];\n\t};\n\tconst castSlice = (array, start, end) => {\n\t  const {\n\t    length\n\t  } = array;\n\t  end = end === undefined ? length : end;\n\t  return !start && end >= length ? array : array.slice(start, end);\n\t};\n\tconst upperFirst = createCaseFirst('toUpperCase');\n\tfunction createCaseFirst(methodName) {\n\t  return string => {\n\t    if (!string) {\n\t      return '';\n\t    }\n\t    const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n\t    const chr = strSymbols ? strSymbols[0] : string[0];\n\t    const trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);\n\t    return chr[methodName]() + trailing;\n\t  };\n\t}\n\tfunction matches(source) {\n\t  return baseMatches(baseClone(source, true));\n\t}\n\n\t// -- helper classes\n\tclass Stack {\n\t  constructor(entries) {\n\t    const data = this.__data__ = new ListCache(entries);\n\t    this.size = data.size;\n\t  }\n\t  clear() {\n\t    this.__data__ = new ListCache();\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const data = this.__data__;\n\t    const result = data['delete'](key);\n\t    this.size = data.size;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    return this.__data__.get(key);\n\t  }\n\t  has(key) {\n\t    return this.__data__.has(key);\n\t  }\n\t  set(key, value) {\n\t    let data = this.__data__;\n\t    if (data instanceof ListCache) {\n\t      const pairs = data.__data__;\n\t      if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n\t        pairs.push([key, value]);\n\t        this.size = ++data.size;\n\t        return this;\n\t      }\n\t      data = this.__data__ = new MapCache(pairs);\n\t    }\n\t    data.set(key, value);\n\t    this.size = data.size;\n\t    return this;\n\t  }\n\t}\n\tclass ListCache {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.__data__ = [];\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    if (index < 0) {\n\t      return false;\n\t    }\n\t    const lastIndex = data.length - 1;\n\t    if (index == lastIndex) {\n\t      data.pop();\n\t    } else {\n\t      data.splice(index, 1);\n\t    }\n\t    --this.size;\n\t    return true;\n\t  }\n\t  get(key) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    return index < 0 ? undefined : data[index][1];\n\t  }\n\t  has(key) {\n\t    return assocIndexOf(this.__data__, key) > -1;\n\t  }\n\t  set(key, value) {\n\t    const data = this.__data__;\n\t    const index = assocIndexOf(data, key);\n\t    if (index < 0) {\n\t      ++this.size;\n\t      data.push([key, value]);\n\t    } else {\n\t      data[index][1] = value;\n\t    }\n\t    return this;\n\t  }\n\t}\n\tclass MapCache {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.size = 0;\n\t    this.__data__ = {\n\t      'hash': new Hash(),\n\t      'map': new Map(),\n\t      'string': new Hash()\n\t    };\n\t  }\n\t  delete(key) {\n\t    const result = getMapData(this, key)['delete'](key);\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    return getMapData(this, key).get(key);\n\t  }\n\t  has(key) {\n\t    return getMapData(this, key).has(key);\n\t  }\n\t  set(key, value) {\n\t    const data = getMapData(this, key);\n\t    const size = data.size;\n\t    data.set(key, value);\n\t    this.size += data.size == size ? 0 : 1;\n\t    return this;\n\t  }\n\t}\n\tclass Hash {\n\t  constructor(entries) {\n\t    let index = -1;\n\t    const length = entries == null ? 0 : entries.length;\n\t    this.clear();\n\t    while (++index < length) {\n\t      const entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\t  clear() {\n\t    this.__data__ = Object.create(null);\n\t    this.size = 0;\n\t  }\n\t  delete(key) {\n\t    const result = this.has(key) && delete this.__data__[key];\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\t  get(key) {\n\t    const data = this.__data__;\n\t    const result = data[key];\n\t    return result === HASH_UNDEFINED ? undefined : result;\n\t  }\n\t  has(key) {\n\t    const data = this.__data__;\n\t    return data[key] !== undefined;\n\t  }\n\t  set(key, value) {\n\t    const data = this.__data__;\n\t    this.size += this.has(key) ? 0 : 1;\n\t    data[key] = value === undefined ? HASH_UNDEFINED : value;\n\t    return this;\n\t  }\n\t}\n\tclass SetCache {\n\t  constructor(values) {\n\t    let index = -1;\n\t    const length = values == null ? 0 : values.length;\n\t    this.__data__ = new MapCache();\n\t    while (++index < length) {\n\t      this.add(values[index]);\n\t    }\n\t  }\n\t  add(value) {\n\t    this.__data__.set(value, HASH_UNDEFINED);\n\t    return this;\n\t  }\n\t  has(value) {\n\t    return this.__data__.has(value);\n\t  }\n\t}\n\tSetCache.prototype.push = SetCache.prototype.add;\n\n\t// -- top level functions\n\n\tconst isBoolean = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return value === true || value === false || !!value && typeof value === 'object' && toString.call(value) === boolTag;\n\t};\n\tconst isObject = function (value) {\n\t  return !!value && (typeof value === 'object' || typeof value === 'function');\n\t};\n\tconst isNumber = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return typeof value === 'number' || !!value && typeof value === 'object' && toString.call(value) === numberTag;\n\t};\n\tconst isString = function (value) {\n\t  var toString = Object.prototype.toString;\n\t  return typeof value === 'string' || !!value && typeof value === 'object' && toString.call(value) === stringTag;\n\t};\n\tconst assign = createAssigner((object, source) => {\n\t  if (isPrototype(source) || isArrayLike(source)) {\n\t    copyObject(source, keys(source), object);\n\t    return;\n\t  }\n\t  for (var key in source) {\n\t    if (hasOwnProperty.call(source, key)) {\n\t      assignValue(object, key, source[key]);\n\t    }\n\t  }\n\t});\n\tconst mixin = assign;\n\tconst deepMixin = mixin;\n\tconst supplement = (object, ...sources) => {\n\t  let index = -1;\n\t  let length = sources.length;\n\t  const guard = length > 2 ? sources[2] : undefined;\n\t  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t    length = 1;\n\t  }\n\t  while (++index < length) {\n\t    const source = sources[index];\n\t    if (source == null) {\n\t      continue;\n\t    }\n\t    const props = Object.keys(source);\n\t    const propsLength = props.length;\n\t    let propsIndex = -1;\n\t    while (++propsIndex < propsLength) {\n\t      const key = props[propsIndex];\n\t      const value = object[key];\n\t      if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) {\n\t        object[key] = source[key];\n\t      }\n\t    }\n\t  }\n\t  return object;\n\t};\n\tconst defaults = supplement;\n\tconst deepSupplement = function defaultsDeep(...args) {\n\t  args.push(undefined, customDefaultsMerge);\n\t  return merge.apply(undefined, args);\n\t};\n\tconst defaultsDeep = deepSupplement;\n\n\t// _.invokeMap\n\tconst invoke = (collection, path, ...args) => {\n\t  let index = -1;\n\t  const isFunc = typeof path === 'function';\n\t  const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\t  baseEach(collection, value => {\n\t    result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n\t  });\n\t  return result;\n\t};\n\n\t// _.invoke\n\tconst invokeProperty = (object, path, ...args) => {\n\t  path = castPath(path, object);\n\t  object = parent(object, path);\n\t  const func = object == null ? object : object[toKey(last(path))];\n\t  return func == null ? undefined : func.apply(object, args);\n\t};\n\tconst sortedIndex = (array, value, iteratee) => {\n\t  let low = 0;\n\t  let high = array == null ? 0 : array.length;\n\t  if (high == 0) {\n\t    return 0;\n\t  }\n\t  iteratee = getIteratee(iteratee, 2);\n\t  value = iteratee(value);\n\t  const valIsNaN = value !== value;\n\t  const valIsNull = value === null;\n\t  const valIsSymbol = isSymbol(value);\n\t  const valIsUndefined = value === undefined;\n\t  while (low < high) {\n\t    let setLow;\n\t    const mid = Math.floor((low + high) / 2);\n\t    const computed = iteratee(array[mid]);\n\t    const othIsDefined = computed !== undefined;\n\t    const othIsNull = computed === null;\n\t    const othIsReflexive = computed === computed;\n\t    const othIsSymbol = isSymbol(computed);\n\t    if (valIsNaN) {\n\t      setLow = othIsReflexive;\n\t    } else if (valIsUndefined) {\n\t      setLow = othIsReflexive && othIsDefined;\n\t    } else if (valIsNull) {\n\t      setLow = othIsReflexive && othIsDefined && !othIsNull;\n\t    } else if (valIsSymbol) {\n\t      setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n\t    } else if (othIsNull || othIsSymbol) {\n\t      setLow = false;\n\t    } else {\n\t      setLow = computed < value;\n\t    }\n\t    if (setLow) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return Math.min(high, MAX_ARRAY_INDEX);\n\t};\n\tconst uniq = (array, iteratee) => {\n\t  let index = -1;\n\t  let includes = (array, value) => {\n\t    const length = array == null ? 0 : array.length;\n\t    return !!length && array.indexOf(value) > -1;\n\t  };\n\t  iteratee = getIteratee(iteratee, 2);\n\t  let isCommon = true;\n\t  const {\n\t    length\n\t  } = array;\n\t  const result = [];\n\t  let seen = result;\n\t  if (length >= LARGE_ARRAY_SIZE) {\n\t    const set = iteratee ? null : createSet(array);\n\t    if (set) {\n\t      return setToArray(set);\n\t    }\n\t    isCommon = false;\n\t    includes = (cache, key) => cache.has(key);\n\t    seen = new SetCache();\n\t  } else {\n\t    seen = iteratee ? [] : result;\n\t  }\n\t  outer: while (++index < length) {\n\t    let value = array[index];\n\t    const computed = iteratee ? iteratee(value) : value;\n\t    value = value !== 0 ? value : 0;\n\t    if (isCommon && computed === computed) {\n\t      let seenIndex = seen.length;\n\t      while (seenIndex--) {\n\t        if (seen[seenIndex] === computed) {\n\t          continue outer;\n\t        }\n\t      }\n\t      if (iteratee) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    } else if (!includes(seen, computed)) {\n\t      if (seen !== result) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t};\n\tconst clone$1 = value => baseClone(value);\n\tconst cloneDeep = value => baseClone(value, true);\n\tconst isEmpty = value => {\n\t  if (value == null) {\n\t    return true;\n\t  }\n\t  if (isArrayLike(value) && (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' || isTypedArray(value) || isArguments(value))) {\n\t    return !value.length;\n\t  }\n\t  const tag = getTag(value);\n\t  if (tag == '[object Map]' || tag == '[object Set]') {\n\t    return !value.size;\n\t  }\n\t  if (isPrototype(value)) {\n\t    return !baseKeys(value).length;\n\t  }\n\t  for (const key in value) {\n\t    if (hasOwnProperty.call(value, key)) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\tconst isEqual = (object, other) => baseIsEqual(object, other);\n\tconst isFunction = value => typeof value === 'function';\n\tconst isPlainObject = value => {\n\t  if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n\t    return false;\n\t  }\n\t  if (Object.getPrototypeOf(value) === null) {\n\t    return true;\n\t  }\n\t  let proto = value;\n\t  while (Object.getPrototypeOf(proto) !== null) {\n\t    proto = Object.getPrototypeOf(proto);\n\t  }\n\t  return Object.getPrototypeOf(value) === proto;\n\t};\n\tconst toArray$1 = value => {\n\t  if (!value) {\n\t    return [];\n\t  }\n\t  if (isArrayLike(value)) {\n\t    return isString(value) ? stringToArray(value) : copyArray(value);\n\t  }\n\t  if (Symbol.iterator && Symbol.iterator in Object(value)) {\n\t    const iterator = value[Symbol.iterator]();\n\t    let data;\n\t    const result = [];\n\t    while (!(data = iterator.next()).done) {\n\t      result.push(data.value);\n\t    }\n\t    return result;\n\t  }\n\t  const tag = getTag(value);\n\t  const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n\t  return func(value);\n\t};\n\tfunction debounce(func, wait, opt) {\n\t  if (typeof func !== 'function') {\n\t    throw new TypeError('Expected a function');\n\t  }\n\t  let lastArgs;\n\t  let lastThis;\n\t  let maxWait;\n\t  let result;\n\t  let timerId;\n\t  let lastCallTime;\n\t  let lastInvokeTime = 0;\n\t  let leading = false;\n\t  let maxing = false;\n\t  let trailing = true;\n\t  const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function';\n\t  wait = +wait || 0;\n\t  if (isObject(opt)) {\n\t    leading = !!opt.leading;\n\t    maxing = 'maxWait' in opt;\n\t    maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n\t    trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n\t  }\n\t  function invokeFunc(time) {\n\t    const args = lastArgs;\n\t    const thisArg = lastThis;\n\t    lastArgs = lastThis = undefined;\n\t    lastInvokeTime = time;\n\t    result = func.apply(thisArg, args);\n\t    return result;\n\t  }\n\t  function startTimer(pendingFunc, wait) {\n\t    if (useRaf) {\n\t      window.cancelAnimationFrame(timerId);\n\t      return window.requestAnimationFrame(pendingFunc);\n\t    }\n\t    return setTimeout(pendingFunc, wait);\n\t  }\n\t  function cancelTimer(id) {\n\t    if (useRaf) {\n\t      return window.cancelAnimationFrame(id);\n\t    }\n\t    clearTimeout(id);\n\t  }\n\t  function leadingEdge(time) {\n\t    lastInvokeTime = time;\n\t    timerId = startTimer(timerExpired, wait);\n\t    return leading ? invokeFunc(time) : result;\n\t  }\n\t  function remainingWait(time) {\n\t    const timeSinceLastCall = time - lastCallTime;\n\t    const timeSinceLastInvoke = time - lastInvokeTime;\n\t    const timeWaiting = wait - timeSinceLastCall;\n\t    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n\t  }\n\t  function shouldInvoke(time) {\n\t    const timeSinceLastCall = time - lastCallTime;\n\t    const timeSinceLastInvoke = time - lastInvokeTime;\n\t    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n\t  }\n\t  function timerExpired() {\n\t    const time = Date.now();\n\t    if (shouldInvoke(time)) {\n\t      return trailingEdge(time);\n\t    }\n\t    timerId = startTimer(timerExpired, remainingWait(time));\n\t  }\n\t  function trailingEdge(time) {\n\t    timerId = undefined;\n\t    if (trailing && lastArgs) {\n\t      return invokeFunc(time);\n\t    }\n\t    lastArgs = lastThis = undefined;\n\t    return result;\n\t  }\n\t  function debounced(...args) {\n\t    const time = Date.now();\n\t    const isInvoking = shouldInvoke(time);\n\t    lastArgs = args;\n\t    lastThis = this;\n\t    lastCallTime = time;\n\t    if (isInvoking) {\n\t      if (timerId === undefined) {\n\t        return leadingEdge(lastCallTime);\n\t      }\n\t      if (maxing) {\n\t        timerId = startTimer(timerExpired, wait);\n\t        return invokeFunc(lastCallTime);\n\t      }\n\t    }\n\t    if (timerId === undefined) {\n\t      timerId = startTimer(timerExpired, wait);\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = () => {\n\t    if (timerId !== undefined) {\n\t      cancelTimer(timerId);\n\t    }\n\t    lastInvokeTime = 0;\n\t    lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t  };\n\t  debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());\n\t  debounced.pending = () => timerId !== undefined;\n\t  return debounced;\n\t}\n\tconst groupBy = (collection, iteratee) => {\n\t  iteratee = getIteratee(iteratee, 2);\n\t  return reduce(collection, (result, value) => {\n\t    const key = iteratee(value);\n\t    if (hasOwnProperty.call(result, key)) {\n\t      result[key].push(value);\n\t    } else {\n\t      assignValue(result, key, [value]);\n\t    }\n\t    return result;\n\t  }, {});\n\t};\n\tconst sortBy = (collection, iteratees = []) => {\n\t  if (collection == null) {\n\t    return [];\n\t  }\n\t  const length = iteratees.length;\n\t  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n\t    iteratees = [];\n\t  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n\t    iteratees = [iteratees[0]];\n\t  }\n\t  if (!Array.isArray(iteratees)) {\n\t    iteratees = [getIteratee(iteratees, 2)];\n\t  }\n\t  return baseOrderBy(collection, iteratees.flat(1), []);\n\t};\n\tconst flattenDeep = array => {\n\t  const length = array == null ? 0 : array.length;\n\t  return length ? baseFlatten(array, Infinity) : [];\n\t};\n\tconst without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];\n\tconst difference = (array, ...values) => isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];\n\tconst intersection = (...arrays) => {\n\t  const mapped = arrays.map(array => isObjectLike(array) && isArrayLike(array) ? array : []);\n\t  return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];\n\t};\n\tconst union = (...arrays) => {\n\t  const array = arrays.flat(1);\n\t  return uniq(array);\n\t};\n\tconst has = (object, key) => {\n\t  if (object == null) {\n\t    return false;\n\t  }\n\t  if (typeof key === 'string') {\n\t    key = key.split('.');\n\t  }\n\t  let index = -1;\n\t  let value = object;\n\t  while (++index < key.length) {\n\t    if (!value || !hasOwnProperty.call(value, key[index])) {\n\t      return false;\n\t    }\n\t    value = value[key[index]];\n\t  }\n\t  return true;\n\t};\n\tconst result = (object, path, defaultValue) => {\n\t  path = castPath(path, object);\n\t  let index = -1;\n\t  let length = path.length;\n\t  if (!length) {\n\t    length = 1;\n\t    object = undefined;\n\t  }\n\t  while (++index < length) {\n\t    let value = object == null ? undefined : object[toKey(path[index])];\n\t    if (value === undefined) {\n\t      index = length;\n\t      value = defaultValue;\n\t    }\n\t    object = typeof value === 'function' ? value.call(object) : value;\n\t  }\n\t  return object;\n\t};\n\tconst omit = (object, ...paths) => {\n\t  let result = {};\n\t  if (object == null) {\n\t    return result;\n\t  }\n\t  let isDeep = false;\n\t  paths = paths.flat(1).map(path => {\n\t    path = castPath(path, object);\n\t    isDeep || (isDeep = path.length > 1);\n\t    return path;\n\t  });\n\t  copyObject(object, getAllKeysIn(object), result);\n\t  if (isDeep) {\n\t    result = baseClone(result, true, true, true, value => isPlainObject(value) ? undefined : value);\n\t  }\n\t  let length = paths.length;\n\t  while (length--) {\n\t    unset(result, paths[length]);\n\t  }\n\t  return result;\n\t};\n\tconst pick = (object, ...paths) => {\n\t  return object == null ? {} : basePick(object, paths.flat(Infinity));\n\t};\n\tconst bindAll = (object, ...methodNames) => {\n\t  methodNames.flat(1).forEach(key => {\n\t    key = toKey(key);\n\t    assignValue(object, key, object[key].bind(object));\n\t  });\n\t  return object;\n\t};\n\tconst forIn = (object, iteratee = value => value) => {\n\t  let index = -1;\n\t  const iterable = Object(object);\n\t  const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n\t  let length = props.length;\n\t  while (length--) {\n\t    const key = props[++index];\n\t    if (iteratee(iterable[key], key, iterable) === false) {\n\t      break;\n\t    }\n\t  }\n\t};\n\tconst camelCase = (string = '') => words(`${string}`.replace(/['\\u2019]/g, '')).reduce((result, word, index) => {\n\t  word = word.toLowerCase();\n\t  return result + (index ? upperFirst(word) : word);\n\t}, '');\n\tlet idCounter = 0;\n\tconst uniqueId = (prefix = '') => {\n\t  const id = ++idCounter;\n\t  return `${prefix}` + id;\n\t};\n\tconst merge = createAssigner((object, source, srcIndex, customizer) => {\n\t  baseMerge(object, source, srcIndex, customizer);\n\t}, true);\n\n\tclass Data {\n\t  constructor() {\n\t    this.map = new WeakMap();\n\t  }\n\t  has(obj, key) {\n\t    if (key === undefined) return this.map.has(obj);\n\t    return key in this.map.get(obj);\n\t  }\n\t  create(obj) {\n\t    if (!this.has(obj)) this.map.set(obj, Object.create(null));\n\t    return this.get(obj);\n\t  }\n\t  get(obj, key) {\n\t    if (!this.has(obj)) return undefined;\n\t    const data = this.map.get(obj);\n\t    if (key === undefined) return data;\n\t    return data[key];\n\t  }\n\t  set(obj, key, value) {\n\t    if (key === undefined) return;\n\t    const data = this.create(obj);\n\t    if (typeof key === 'string') {\n\t      data[key] = value;\n\t    } else {\n\t      Object.assign(data, key);\n\t    }\n\t  }\n\t  remove(obj, key) {\n\t    if (!this.has(obj)) return;\n\t    if (key === undefined) {\n\t      this.map.delete(obj);\n\t    } else {\n\t      const data = this.map.get(obj);\n\t      delete data[key];\n\t    }\n\t  }\n\t}\n\n\tconst dataPriv = new Data();\n\tconst dataUser = new Data();\n\n\tconst Event = function (src, props) {\n\t  // Allow instantiation without the 'new' keyword\n\t  if (!(this instanceof Event)) {\n\t    return new Event(src, props);\n\t  }\n\n\t  // Event object\n\t  if (src && src.type) {\n\t    this.originalEvent = src;\n\t    this.type = src.type;\n\n\t    // Events bubbling up the document may have been marked as prevented\n\t    // by a handler lower down the tree; reflect the correct value.\n\t    this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n\n\t    // Create target properties\n\t    this.target = src.target;\n\t    this.currentTarget = src.currentTarget;\n\t    this.relatedTarget = src.relatedTarget;\n\n\t    // Event type\n\t  } else {\n\t    this.type = src;\n\t  }\n\n\t  // Put explicitly provided properties onto the event object\n\t  if (props) {\n\t    Object.assign(this, props);\n\t  }\n\n\t  // Create a timestamp if incoming event doesn't have one\n\t  this.timeStamp = src && src.timeStamp || Date.now();\n\n\t  // Mark it as fixed\n\t  this.envelope = true;\n\t};\n\n\t// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tEvent.prototype = {\n\t  constructor: Event,\n\t  isDefaultPrevented: returnFalse,\n\t  isPropagationStopped: returnFalse,\n\t  isImmediatePropagationStopped: returnFalse,\n\t  preventDefault: function () {\n\t    const evt = this.originalEvent;\n\t    this.isDefaultPrevented = returnTrue;\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t  },\n\t  stopPropagation: function () {\n\t    const evt = this.originalEvent;\n\t    this.isPropagationStopped = returnTrue;\n\t    if (evt) {\n\t      evt.stopPropagation();\n\t    }\n\t  },\n\t  stopImmediatePropagation: function () {\n\t    const evt = this.originalEvent;\n\t    this.isImmediatePropagationStopped = returnTrue;\n\t    if (evt) {\n\t      evt.stopImmediatePropagation();\n\t    }\n\t    this.stopPropagation();\n\t  }\n\t};\n\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\t['altKey', 'bubbles', 'cancelable', 'changedTouches', 'ctrlKey', 'detail', 'eventPhase', 'metaKey', 'pageX', 'pageY', 'shiftKey', 'view', 'char', 'code', 'charCode', 'key', 'keyCode', 'button', 'buttons', 'clientX', 'clientY', 'offsetX', 'offsetY', 'pointerId', 'pointerType', 'screenX', 'screenY', 'targetTouches', 'toElement', 'touches', 'which'].forEach(name => addProp(name));\n\tfunction addProp(name) {\n\t  Object.defineProperty(Event.prototype, name, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function () {\n\t      return this.originalEvent ? this.originalEvent[name] : undefined;\n\t    },\n\t    set: function (value) {\n\t      Object.defineProperty(this, name, {\n\t        enumerable: true,\n\t        configurable: true,\n\t        writable: true,\n\t        value: value\n\t      });\n\t    }\n\t  });\n\t}\n\tfunction returnTrue() {\n\t  return true;\n\t}\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\n\t/*!\n\t * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n\t * https://jquery.com/\n\t *\n\t * Copyright OpenJS Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2023-11-24T14:04Z\n\t */\n\n\tconst document$1 = typeof window !== 'undefined' ? window.document : null;\n\tconst documentElement = document$1 && document$1.documentElement;\n\tconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n\t// Only count HTML whitespace\n\t// Other whitespace should count in values\n\t// https://infra.spec.whatwg.org/#ascii-whitespace\n\tconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n\t// Define a local copy of $\n\tconst $ = function (selector) {\n\t  // The $ object is actually just the init constructor 'enhanced'\n\t  // Need init if $ is called (just allow error to be thrown if not included)\n\t  return new $.Dom(selector);\n\t};\n\t$.fn = $.prototype = {\n\t  constructor: $,\n\t  // The default length of a $ object is 0\n\t  length: 0\n\t};\n\n\t// A global GUID counter for objects\n\t$.guid = 1;\n\n\t// User data storage\n\t$.data = dataUser;\n\t$.merge = function (first, second) {\n\t  let len = +second.length;\n\t  let i = first.length;\n\t  for (let j = 0; j < len; j++) {\n\t    first[i++] = second[j];\n\t  }\n\t  first.length = i;\n\t  return first;\n\t};\n\t$.parseHTML = function (string) {\n\t  // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\t  const context = document$1.implementation.createHTMLDocument();\n\t  // Set the base href for the created document so any parsed elements with URLs\n\t  // are based on the document's URL\n\t  const base = context.createElement('base');\n\t  base.href = document$1.location.href;\n\t  context.head.appendChild(base);\n\t  context.body.innerHTML = string;\n\t  // remove scripts\n\t  const scripts = context.getElementsByTagName('script');\n\t  for (let i = 0; i < scripts.length; i++) {\n\t    scripts[i].remove();\n\t  }\n\t  return Array.from(context.body.childNodes);\n\t};\n\tif (typeof Symbol === 'function') {\n\t  $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n\t}\n\t$.fn.toArray = function () {\n\t  return Array.from(this);\n\t};\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\t$.fn.pushStack = function (elements) {\n\t  // Build a new $ matched element set\n\t  const ret = $.merge(this.constructor(), elements);\n\t  // Add the old object onto the stack (as a reference)\n\t  ret.prevObject = this;\n\t  // Return the newly-formed element set\n\t  return ret;\n\t};\n\t$.fn.find = function (selector) {\n\t  const [el] = this;\n\t  const ret = this.pushStack([]);\n\t  if (!el) return ret;\n\t  // Early return if context is not an element, document or document fragment\n\t  const {\n\t    nodeType\n\t  } = el;\n\t  if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\t    return ret;\n\t  }\n\t  if (typeof selector !== 'string') {\n\t    if (el !== selector && el.contains(selector)) {\n\t      $.merge(ret, [selector]);\n\t    }\n\t  } else {\n\t    $.merge(ret, el.querySelectorAll(selector));\n\t  }\n\t  return ret;\n\t};\n\t$.fn.add = function (selector) {\n\t  const newElements = $(selector).toArray();\n\t  const prevElements = this.toArray();\n\t  const ret = this.pushStack([]);\n\t  $.merge(ret, uniq(prevElements.concat(newElements)));\n\t  return ret;\n\t};\n\t$.fn.addBack = function () {\n\t  return this.add(this.prevObject);\n\t};\n\t$.fn.filter = function (selector) {\n\t  const matches = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    if (!node.matches(selector)) continue;\n\t    matches.push(node);\n\t  }\n\t  return this.pushStack(matches);\n\t};\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n\t// Strict HTML recognition (trac-11290: must start with <)\n\t// Shortcut simple #id case for speed\n\tconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\tfunction isObviousHtml(input) {\n\t  return input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3;\n\t}\n\tconst Dom = function (selector) {\n\t  if (!selector) {\n\t    // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t    return this;\n\t  }\n\t  if (typeof selector === 'function') {\n\t    // HANDLE: $(function)\n\t    // Shortcut for document ready\n\t    throw new Error('function not supported');\n\t  }\n\t  if (arguments.length > 1) {\n\t    throw new Error('selector with context not supported');\n\t  }\n\t  if (selector.nodeType) {\n\t    // HANDLE: $(DOMElement)\n\t    this[0] = selector;\n\t    this.length = 1;\n\t    return this;\n\t  }\n\t  let match;\n\t  if (isObviousHtml(selector + '')) {\n\t    // Handle obvious HTML strings\n\t    // Assume that strings that start and end with <> are HTML and skip\n\t    // the regex check. This also handles browser-supported HTML wrappers\n\t    // like TrustedHTML.\n\t    match = [null, selector, null];\n\t  } else if (typeof selector === 'string') {\n\t    // Handle HTML strings or selectors\n\t    match = rQuickExpr.exec(selector);\n\t  } else {\n\t    // Array-like\n\t    return $.merge(this, selector);\n\t  }\n\t  if (!match || !match[1]) {\n\t    // HANDLE: $(expr)\n\t    return $root.find(selector);\n\t  }\n\t  // Match html or make sure no context is specified for #id\n\t  // Note: match[1] may be a string or a TrustedHTML wrapper\n\t  if (match[1]) {\n\t    // HANDLE: $(html) -> $(array)\n\t    $.merge(this, $.parseHTML(match[1]));\n\t    return this;\n\t  }\n\t  // HANDLE: $(#id)\n\t  const el = document$1.getElementById(match[2]);\n\t  if (el) {\n\t    // Inject the element directly into the $ object\n\t    this[0] = el;\n\t    this.length = 1;\n\t  }\n\t  return this;\n\t};\n\t$.Dom = Dom;\n\n\t// Give the init function the $ prototype for later instantiation\n\tDom.prototype = $.fn;\n\n\t// Events\n\n\t$.Event = Event;\n\t$.event = {\n\t  special: Object.create(null)\n\t};\n\t$.event.has = function (elem, eventType) {\n\t  const events = dataPriv.get(elem, 'events');\n\t  if (!events) return false;\n\t  if (!eventType) return true;\n\t  return Array.isArray(events[eventType]) && events[eventType].length > 0;\n\t};\n\t$.event.on = function (elem, types, selector, data, fn, one) {\n\t  // Types can be a map of types/handlers\n\t  if (typeof types === 'object') {\n\t    // ( types-Object, selector, data )\n\t    if (typeof selector !== 'string') {\n\t      // ( types-Object, data )\n\t      data = data || selector;\n\t      selector = undefined;\n\t    }\n\t    for (let type in types) {\n\t      $.event.on(elem, type, selector, data, types[type], one);\n\t    }\n\t    return elem;\n\t  }\n\t  if (data == null && fn == null) {\n\t    // ( types, fn )\n\t    fn = selector;\n\t    data = selector = undefined;\n\t  } else if (fn == null) {\n\t    if (typeof selector === 'string') {\n\t      // ( types, selector, fn )\n\t      fn = data;\n\t      data = undefined;\n\t    } else {\n\t      // ( types, data, fn )\n\t      fn = data;\n\t      data = selector;\n\t      selector = undefined;\n\t    }\n\t  }\n\t  if (!fn) {\n\t    return elem;\n\t  }\n\t  if (one === 1) {\n\t    const origFn = fn;\n\t    fn = function (event) {\n\t      // Can use an empty set, since event contains the info\n\t      $().off(event);\n\t      return origFn.apply(this, arguments);\n\t    };\n\n\t    // Use same guid so caller can remove using origFn\n\t    fn.guid = origFn.guid || (origFn.guid = $.guid++);\n\t  }\n\t  for (let i = 0; i < elem.length; i++) {\n\t    $.event.add(elem[i], types, fn, data, selector);\n\t  }\n\t};\n\t$.event.add = function (elem, types, handler, data, selector) {\n\t  // Only attach events to objects for which we can store data\n\t  if (typeof elem != 'object') {\n\t    return;\n\t  }\n\t  const elemData = dataPriv.create(elem);\n\n\t  // Caller can pass in an object of custom data in lieu of the handler\n\t  let handleObjIn;\n\t  if (handler.handler) {\n\t    handleObjIn = handler;\n\t    handler = handleObjIn.handler;\n\t    selector = handleObjIn.selector;\n\t  }\n\n\t  // Ensure that invalid selectors throw exceptions at attach time\n\t  // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t  if (selector) {\n\t    documentElement.matches(selector);\n\t  }\n\n\t  // Make sure that the handler has a unique ID, used to find/remove it later\n\t  if (!handler.guid) {\n\t    handler.guid = $.guid++;\n\t  }\n\n\t  // Init the element's event structure and main handler, if this is the first\n\t  let events;\n\t  if (!(events = elemData.events)) {\n\t    events = elemData.events = Object.create(null);\n\t  }\n\t  let eventHandle;\n\t  if (!(eventHandle = elemData.handle)) {\n\t    eventHandle = elemData.handle = function (e) {\n\t      // Discard the second event of a $.event.trigger() and\n\t      // when an event is called after a page has unloaded\n\t      return typeof $ !== 'undefined' ? $.event.dispatch.apply(elem, arguments) : undefined;\n\t    };\n\t  }\n\n\t  // Handle multiple events separated by a space\n\t  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n\t  let i = typesArr.length;\n\t  while (i--) {\n\t    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n\t    // There *must* be a type, no attaching namespace-only handlers\n\t    if (!origType) {\n\t      continue;\n\t    }\n\t    const namespaces = ns.split('.').sort();\n\t    // If event changes its type, use the special event handlers for the changed type\n\t    let special = $.event.special[origType];\n\t    // If selector defined, determine special event api type, otherwise given type\n\t    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n\t    // Update special based on newly reset type\n\t    special = $.event.special[type];\n\t    // handleObj is passed to all event handlers\n\t    const handleObj = Object.assign({\n\t      type: type,\n\t      origType: origType,\n\t      data: data,\n\t      handler: handler,\n\t      guid: handler.guid,\n\t      selector: selector,\n\t      namespace: namespaces.join('.')\n\t    }, handleObjIn);\n\t    let handlers;\n\t    // Init the event handler queue if we're the first\n\t    if (!(handlers = events[type])) {\n\t      handlers = events[type] = [];\n\t      handlers.delegateCount = 0;\n\n\t      // Only use addEventListener if the special events handler returns false\n\t      if (!special || !special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\t        if (elem.addEventListener) {\n\t          elem.addEventListener(type, eventHandle);\n\t        }\n\t      }\n\t    }\n\t    if (special && special.add) {\n\t      special.add.call(elem, handleObj);\n\t      if (!handleObj.handler.guid) {\n\t        handleObj.handler.guid = handler.guid;\n\t      }\n\t    }\n\n\t    // Add to the element's handler list, delegates in front\n\t    if (selector) {\n\t      handlers.splice(handlers.delegateCount++, 0, handleObj);\n\t    } else {\n\t      handlers.push(handleObj);\n\t    }\n\t  }\n\t};\n\n\t// Detach an event or set of events from an element\n\t$.event.remove = function (elem, types, handler, selector, mappedTypes) {\n\t  const elemData = dataPriv.get(elem);\n\t  if (!elemData || !elemData.events) return;\n\t  const events = elemData.events;\n\n\t  // Once for each type.namespace in types; type may be omitted\n\t  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n\t  let i = typesArr.length;\n\t  while (i--) {\n\t    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n\t    // Unbind all events (on this namespace, if provided) for the element\n\t    if (!origType) {\n\t      for (const type in events) {\n\t        $.event.remove(elem, type + typesArr[i], handler, selector, true);\n\t      }\n\t      continue;\n\t    }\n\t    const special = $.event.special[origType];\n\t    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n\t    const handlers = events[type];\n\t    if (!handlers || handlers.length === 0) continue;\n\t    const namespaces = ns.split('.').sort();\n\t    const rNamespace = ns ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null;\n\n\t    // Remove matching events\n\t    const origCount = handlers.length;\n\t    let j = origCount;\n\t    while (j--) {\n\t      const handleObj = handlers[j];\n\t      if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!rNamespace || rNamespace.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {\n\t        handlers.splice(j, 1);\n\t        if (handleObj.selector) {\n\t          handlers.delegateCount--;\n\t        }\n\t        if (special && special.remove) {\n\t          special.remove.call(elem, handleObj);\n\t        }\n\t      }\n\t    }\n\n\t    // Remove generic event handler if we removed something and no more handlers exist\n\t    // (avoids potential for endless recursion during removal of special event handlers)\n\t    if (origCount && handlers.length === 0) {\n\t      if (!special || !special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\t        // This \"if\" is needed for plain objects\n\t        if (elem.removeEventListener) {\n\t          elem.removeEventListener(type, elemData.handle);\n\t        }\n\t      }\n\t      delete events[type];\n\t    }\n\t  }\n\n\t  // Remove data if it's no longer used\n\t  if (isEmpty(events)) {\n\t    dataPriv.remove(elem, 'handle');\n\t    dataPriv.remove(elem, 'events');\n\t  }\n\t};\n\t$.event.dispatch = function (nativeEvent) {\n\t  const elem = this;\n\t  // Make a writable $.Event from the native event object\n\t  const event = $.event.fix(nativeEvent);\n\t  event.delegateTarget = elem;\n\t  // Use the fix-ed $.Event rather than the (read-only) native event\n\t  const args = Array.from(arguments);\n\t  args[0] = event;\n\t  const eventsData = dataPriv.get(elem, 'events');\n\t  const handlers = eventsData && eventsData[event.type] || [];\n\t  const special = $.event.special[event.type];\n\n\t  // Call the preDispatch hook for the mapped type, and let it bail if desired\n\t  if (special && special.preDispatch) {\n\t    if (special.preDispatch.call(elem, event) === false) return;\n\t  }\n\n\t  // Determine handlers\n\t  const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n\t  // Run delegates first; they may want to stop propagation beneath us\n\t  let i = 0;\n\t  let matched;\n\t  while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t    event.currentTarget = matched.elem;\n\t    let j = 0;\n\t    let handleObj;\n\t    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\t      event.handleObj = handleObj;\n\t      event.data = handleObj.data;\n\t      const origSpecial = $.event.special[handleObj.origType];\n\t      let handler;\n\t      if (origSpecial && origSpecial.handle) {\n\t        handler = origSpecial.handle;\n\t      } else {\n\t        handler = handleObj.handler;\n\t      }\n\t      const ret = handler.apply(matched.elem, args);\n\t      if (ret !== undefined) {\n\t        if ((event.result = ret) === false) {\n\t          event.preventDefault();\n\t          event.stopPropagation();\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Call the postDispatch hook for the mapped type\n\t  if (special && special.postDispatch) {\n\t    special.postDispatch.call(elem, event);\n\t  }\n\t  return event.result;\n\t};\n\t$.event.handlers = function (event, handlers) {\n\t  const delegateCount = handlers.delegateCount;\n\t  const handlerQueue = [];\n\n\t  // Find delegate handlers\n\t  if (delegateCount &&\n\t  // Support: Firefox <=42 - 66+\n\t  // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t  // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t  // Support: IE 11+\n\t  // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t  !(event.type === 'click' && event.button >= 1)) {\n\t    for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n\t      // Don't check non-elements (trac-13208)\n\t      // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n\t      if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {\n\t        const matchedHandlers = [];\n\t        const matchedSelectors = {};\n\t        for (let i = 0; i < delegateCount; i++) {\n\t          const handleObj = handlers[i];\n\t          // Don't conflict with Object.prototype properties (trac-13203)\n\t          const sel = handleObj.selector + ' ';\n\t          if (matchedSelectors[sel] === undefined) {\n\t            matchedSelectors[sel] = cur.matches(sel);\n\t          }\n\t          if (matchedSelectors[sel]) {\n\t            matchedHandlers.push(handleObj);\n\t          }\n\t        }\n\t        if (matchedHandlers.length) {\n\t          handlerQueue.push({\n\t            elem: cur,\n\t            handlers: matchedHandlers\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Add the remaining (directly-bound) handlers\n\t  if (delegateCount < handlers.length) {\n\t    handlerQueue.push({\n\t      elem: this,\n\t      handlers: handlers.slice(delegateCount)\n\t    });\n\t  }\n\t  return handlerQueue;\n\t};\n\t$.event.fix = function (originalEvent) {\n\t  return originalEvent.envelope ? originalEvent : new Event(originalEvent);\n\t};\n\n\t// A central reference to the root $(document)\n\tconst $root = $(document$1);\n\n\tconst svg$1 = 'http://www.w3.org/2000/svg';\n\tconst xmlns = 'http://www.w3.org/2000/xmlns/';\n\tconst xml = 'http://www.w3.org/XML/1998/namespace';\n\tconst xlink = 'http://www.w3.org/1999/xlink';\n\tconst xhtml = 'http://www.w3.org/1999/xhtml';\n\n\tvar ns = {\n\t\t__proto__: null,\n\t\tsvg: svg$1,\n\t\txhtml: xhtml,\n\t\txlink: xlink,\n\t\txml: xml,\n\t\txmlns: xmlns\n\t};\n\n\t/**\n\t * @constant {boolean}\n\t * @description Indicates the environment supports SVG.\n\t */\n\tconst isSVGSupported = typeof window === 'object' && !!window.SVGAngle;\n\n\t/**\n\t * @constant {string}\n\t * @description The version of the SVG document.\n\t */\n\tconst SVG_VERSION = '1.1';\n\n\t/**\n\t * @constant {SVGSVGElement}\n\t * @description The detached SVG document for various internal purposes.\n\t * e.g. SVGMatrix has no constructor, so the only way to create it is\n\t * to create an SVG document and then call `createSVGMatrix()`.\n\t */\n\tconst internalSVGDocument = isSVGSupported ? createSVGDocument() : null;\n\n\t/**\n\t * @constant {SVGGElement}\n\t * @description The detached SVG group element for various internal purposes.\n\t */\n\tconst internalSVGGroup = isSVGSupported ? createSVGElement('g') : null;\n\n\t/**\n\t * @returns {SVGSVGElement}\n\t * @description Creates an SVG document.\n\t */\n\tfunction createSVGDocument() {\n\t  const svg = createSVGElement('svg');\n\t  svg.setAttributeNS(xmlns, 'xmlns:xlink', xlink);\n\t  svg.setAttribute('version', SVG_VERSION);\n\t  return svg;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {SVGElement}\n\t * @description Creates an SVG element with the given name.\n\t */\n\tfunction createSVGElement(name) {\n\t  return document.createElementNS(svg$1, name);\n\t}\n\n\t/**\n\t * @param {SVGElement} node1\n\t * @param {SVGElement} node2\n\t * @returns {SVGElement|null}\n\t * @description Finds the common ancestor node of two nodes.\n\t */\n\tfunction getCommonAncestor(node1, node2) {\n\t  // Find the common ancestor node of two nodes.\n\t  let parent = node1;\n\t  do {\n\t    if (parent.contains(node2)) return parent;\n\t    parent = parent.parentNode;\n\t  } while (parent);\n\t  return null;\n\t}\n\n\t/**\n\t * @returns {SVGMatrix}\n\t * @description Creates an identity matrix.\n\t */\n\tfunction createIdentityMatrix() {\n\t  return internalSVGDocument.createSVGMatrix();\n\t}\n\n\t/**\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @returns {SVGMatrix}\n\t * @description Creates a new SVGMatrix object.\n\t * If no matrix is provided, it returns the identity matrix.\n\t * If a matrix like object is provided, it sets the matrix values.\n\t */\n\tfunction createMatrix(matrixInit = {}) {\n\t  const matrix = internalSVGDocument.createSVGMatrix();\n\t  if (!matrixInit) return matrix;\n\t  if ('a' in matrixInit) matrix.a = matrixInit.a;\n\t  if ('b' in matrixInit) matrix.b = matrixInit.b;\n\t  if ('c' in matrixInit) matrix.c = matrixInit.c;\n\t  if ('d' in matrixInit) matrix.d = matrixInit.d;\n\t  if ('e' in matrixInit) matrix.e = matrixInit.e;\n\t  if ('f' in matrixInit) matrix.f = matrixInit.f;\n\t  return matrix;\n\t}\n\n\t/**\n\t * @returns {SVGTransform}\n\t * @description Creates a new SVGTransform object.\n\t */\n\tfunction createSVGTransform() {\n\t  return internalSVGDocument.createSVGTransform();\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @returns {SVGMatrix|null}\n\t * @description Returns the transformation matrix of the given node.\n\t * If the node has no transformation, it returns null.\n\t */\n\tfunction getNodeMatrix(node) {\n\t  const consolidatedTransformation = node.transform.baseVal.consolidate();\n\t  return consolidatedTransformation ? consolidatedTransformation.matrix : null;\n\t}\n\n\t/**\n\t * @param {string} transformString\n\t * @returns {SVGMatrix}\n\t * @description Creates a matrix from the given transform string.\n\t */\n\tfunction createMatrixFromTransformString(transformString) {\n\t  internalSVGGroup.setAttribute('transform', transformString);\n\t  return getNodeMatrix(internalSVGGroup);\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @param {boolean} override\n\t * @description Sets the transformation matrix of the given node.\n\t * We don't use `node.transform.baseVal` here (@see `transformNode`)\n\t * for the following reasons:\n\t * - Performance: while Chrome performs slightly better, Firefox\n\t *   and Safari are significantly slower\n\t *   https://www.measurethat.net/Benchmarks/Show/34447/1/overriding-svg-transform-attribute\n\t * - Limited support: JSDOM does not support `node.transform.baseVal`\n\t */\n\tfunction replaceTransformNode(node, matrixInit) {\n\t  node.setAttribute('transform', matrixToTransformString(matrixInit));\n\t}\n\n\t/**\n\t * @param {SVGElement} node\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @description Applies a transformation matrix to the given node.\n\t * If the node already has a transformation, it appends the new transformation.\n\t * If the node has no transformation, it creates a new one.\n\t */\n\tfunction transformNode(node, matrixInit) {\n\t  const transform = createSVGTransform();\n\t  const matrix = isSVGMatrix(matrixInit) ? matrixInit : createMatrix(matrixInit);\n\t  transform.setMatrix(matrix);\n\t  node.transform.baseVal.appendItem(transform);\n\t}\n\tconst MATRIX_TYPE = '[object SVGMatrix]';\n\n\t/**\n\t * @param {any} obj\n\t * @returns {boolean}\n\t * @description Checks if the given object is an SVGMatrix.\n\t */\n\tfunction isSVGMatrix(obj) {\n\t  return Object.prototype.toString.call(obj) === MATRIX_TYPE;\n\t}\n\n\t/**\n\t * @param {Partial<SVGMatrix>} matrixInit\n\t * @returns {string}\n\t * @description Converts a matrix to a transform string.\n\t * If no matrix is provided, it returns the identity matrix string.\n\t */\n\tfunction matrixToTransformString(matrixInit = {}) {\n\t  const {\n\t    a = 1,\n\t    b = 0,\n\t    c = 0,\n\t    d = 1,\n\t    e = 0,\n\t    f = 0\n\t  } = matrixInit;\n\t  return `matrix(${a},${b},${c},${d},${e},${f})`;\n\t}\n\n\t/**\n\t *\n\t * @param {SVGElement} a\n\t * @param {SVGElement} b\n\t * @returns {SVGMatrix|null}\n\t * @description Finds the transformation matrix from `a` to `b`.\n\t * It requires that both elements to be visible (in the render tree)\n\t * in order to calculate the correct transformation matrix.\n\t */\n\tfunction getRelativeTransformation(a, b) {\n\t  // Different SVG elements, no transformation possible\n\t  // Note: SVGSVGElement has no `ownerSVGElement`\n\t  if ((a.ownerSVGElement || a) !== (b.ownerSVGElement || b)) return null;\n\t  // Get the transformation matrix from `a` to `b`.\n\t  const am = b.getScreenCTM();\n\t  if (!am) return null;\n\t  const bm = a.getScreenCTM();\n\t  if (!bm) return null;\n\t  return am.inverse().multiply(bm);\n\t}\n\n\t/**\n\t * @param {SVGElement} a\n\t * @param {SVGElement} b\n\t * @returns {SVGMatrix|null}\n\t * @description Finds the transformation matrix from `a` to `b`.\n\t * A safe way to calculate the transformation matrix between two elements.\n\t * It does not require the elements to be visible (in the render tree).\n\t */\n\tfunction getRelativeTransformationSafe(a, b) {\n\t  if (a === b) {\n\t    // No transformation needed\n\t    return createIdentityMatrix();\n\t  }\n\t  const position = a.compareDocumentPosition(b);\n\t  if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n\t    // `b` is a descendant of `a`\n\t    return getLinealTransformation(a, b).inverse();\n\t  } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n\t    // `a` is a descendant of `b`\n\t    return getLinealTransformation(b, a);\n\t  }\n\t  const c = getCommonAncestor(a, b);\n\t  if (!c) {\n\t    // No common ancestor\n\t    return null;\n\t  }\n\t  const mca = getLinealTransformation(c, a);\n\t  const mcb = getLinealTransformation(c, b);\n\t  return mcb.inverse().multiply(mca);\n\t}\n\n\t/**\n\t * @param {SVGElement} descendant\n\t * @param {SVGElement} ancestor\n\t * @returns {SVGMatrix}\n\t * @description Finds the transformation matrix between the `ancestor` and `descendant`.\n\t */\n\tfunction getLinealTransformation(ancestor, descendant) {\n\t  const transformations = [];\n\t  let n = descendant;\n\t  while (n && n.nodeType === Node.ELEMENT_NODE && n !== ancestor) {\n\t    const nm = getNodeMatrix(n);\n\t    if (nm) {\n\t      transformations.unshift(nm);\n\t    }\n\t    n = n.parentNode;\n\t  }\n\t  return transformations.reduce((m, t) => m.multiply(t), createIdentityMatrix());\n\t}\n\n\t// Vectorizer.\n\t// -----------\n\n\tconst V = function () {\n\t  // SVG support is required.\n\t  if (!isSVGSupported) {\n\t    // Return a function that throws an error when it is used.\n\t    return function () {\n\t      throw new Error('SVG is required to use Vectorizer.');\n\t    };\n\t  }\n\n\t  // Declare shorthands to the most used math functions.\n\t  var math = Math;\n\t  var PI = math.PI;\n\t  var atan2 = math.atan2;\n\t  var sqrt = math.sqrt;\n\t  var min = math.min;\n\t  var max = math.max;\n\t  var cos = math.cos;\n\t  var sin = math.sin;\n\t  var V = function (el, attrs, children) {\n\t    // This allows using V() without the new keyword.\n\t    if (!(this instanceof V)) {\n\t      return V.apply(Object.create(V.prototype), arguments);\n\t    }\n\t    if (!el) return;\n\t    if (V.isV(el)) {\n\t      el = el.node;\n\t    }\n\t    attrs = attrs || {};\n\t    if (V.isString(el)) {\n\t      el = el.trim();\n\t      if (el.toLowerCase() === 'svg') {\n\t        // Create a new SVG canvas.\n\t        el = V.createSvgDocument();\n\t      } else if (el[0] === '<') {\n\t        // Create element from an SVG string.\n\t        // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n\t        var svgDoc = V.createSvgDocument(el);\n\n\t        // Note that `V()` might also return an array should the SVG string passed as\n\t        // the first argument contain more than one root element.\n\t        if (svgDoc.childNodes.length > 1) {\n\t          // Map child nodes to `V`s.\n\t          var arrayOfVels = [];\n\t          var i, len;\n\t          for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\t            var childNode = svgDoc.childNodes[i];\n\t            arrayOfVels.push(new V(document.importNode(childNode, true)));\n\t          }\n\t          return arrayOfVels;\n\t        }\n\t        el = document.importNode(svgDoc.firstChild, true);\n\t      } else {\n\t        el = createSVGElement(el);\n\t      }\n\t      V.ensureId(el);\n\t    }\n\t    this.node = el;\n\t    this.setAttributes(attrs);\n\t    if (children) {\n\t      this.append(children);\n\t    }\n\t    return this;\n\t  };\n\t  var VPrototype = V.prototype;\n\t  Object.defineProperty(VPrototype, 'id', {\n\t    enumerable: true,\n\t    get: function () {\n\t      return this.node.id;\n\t    },\n\t    set: function (id) {\n\t      this.node.id = id;\n\t    }\n\t  });\n\n\t  /**\n\t   * Calculates the transformation matrix from this element to the target element.\n\t   * @param {SVGElement|V} target - The target element.\n\t   * @param {Object} [opt] - Options object for transformation calculation.\n\t   * @param {boolean} [opt.safe] - Use a safe traversal method to compute the matrix.\n\t   * @returns {DOMMatrix} The transformation matrix from this element to the target element.\n\t   */\n\t  VPrototype.getTransformToElement = function (target, opt) {\n\t    const node = this.node;\n\t    const targetNode = V.toNode(target);\n\t    let m;\n\t    if (V.isSVGGraphicsElement(targetNode) && V.isSVGGraphicsElement(node)) {\n\t      if (opt && opt.safe) {\n\t        // Use the traversal method to get the transformation matrix.\n\t        m = getRelativeTransformationSafe(node, targetNode);\n\t      } else {\n\t        m = getRelativeTransformation(node, targetNode);\n\t      }\n\t    }\n\t    return m || createIdentityMatrix();\n\t  };\n\n\t  /**\n\t   * @param {SVGMatrix} matrix\n\t   * @param {Object=} opt\n\t   * @returns {Vectorizer|SVGMatrix} Setter / Getter\n\t   */\n\t  VPrototype.transform = function (matrix, opt) {\n\t    const node = this.node;\n\n\t    // Getter\n\t    if (V.isUndefined(matrix)) {\n\t      return getNodeMatrix(node) || createIdentityMatrix();\n\t    }\n\n\t    // Setter\n\t    if (opt && opt.absolute) {\n\t      replaceTransformNode(node, matrix);\n\t    } else {\n\t      transformNode(node, matrix);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.translate = function (tx, ty, opt) {\n\t    opt = opt || {};\n\t    ty = ty || 0;\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\t    // Is it a getter?\n\t    if (V.isUndefined(tx)) {\n\t      return transform.translate;\n\t    }\n\t    transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\t    var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n\t    var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n\t    var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n\t    // Note that `translate()` is always the first transformation. This is\n\t    // usually the desired case.\n\t    this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n\t    return this;\n\t  };\n\t  VPrototype.rotate = function (angle, cx, cy, opt) {\n\t    opt = opt || {};\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\n\t    // Is it a getter?\n\t    if (V.isUndefined(angle)) {\n\t      return transform.rotate;\n\t    }\n\t    transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\t    angle %= 360;\n\t    var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n\t    var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';\n\t    var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\t    this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n\t    return this;\n\t  };\n\n\t  // Note that `scale` as the only transformation does not combine with previous values.\n\t  VPrototype.scale = function (sx, sy) {\n\t    sy = V.isUndefined(sy) ? sx : sy;\n\t    var transformAttr = this.attr('transform') || '';\n\t    var transform = V.parseTransformString(transformAttr);\n\t    transformAttr = transform.value;\n\n\t    // Is it a getter?\n\t    if (V.isUndefined(sx)) {\n\t      return transform.scale;\n\t    }\n\t    transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\t    var newScale = 'scale(' + sx + ',' + sy + ')';\n\t    this.attr('transform', (transformAttr + ' ' + newScale).trim());\n\t    return this;\n\t  };\n\n\t  // Get SVGRect that contains coordinates and dimension of the real bounding box,\n\t  // i.e. after transformations are applied.\n\t  // If `target` is specified, bounding box will be computed relatively to `target` element.\n\t  VPrototype.bbox = function (withoutTransformations, target) {\n\t    var box;\n\t    var node = this.node;\n\t    var ownerSVGElement = node.ownerSVGElement;\n\n\t    // If the element is not in the live DOM, it does not have a bounding box defined and\n\t    // so fall back to 'zero' dimension element.\n\t    if (!ownerSVGElement) {\n\t      return new Rect(0, 0, 0, 0);\n\t    }\n\t    try {\n\t      box = node.getBBox();\n\t    } catch {\n\t      // Fallback for IE.\n\t      box = {\n\t        x: node.clientLeft,\n\t        y: node.clientTop,\n\t        width: node.clientWidth,\n\t        height: node.clientHeight\n\t      };\n\t    }\n\t    if (withoutTransformations) {\n\t      return new Rect(box);\n\t    }\n\t    var matrix = this.getTransformToElement(target || ownerSVGElement);\n\t    return V.transformRect(box, matrix);\n\t  };\n\n\t  // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n\t  // i.e. after transformations are applied.\n\t  // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n\t  // Takes an (Object) `opt` argument (optional) with the following attributes:\n\t  // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n\t  // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n\t  VPrototype.getBBox = function (opt) {\n\t    var options = {};\n\t    var outputBBox;\n\t    var node = this.node;\n\t    var ownerSVGElement = node.ownerSVGElement;\n\n\t    // If the element is not in the live DOM, it does not have a bounding box defined and\n\t    // so fall back to 'zero' dimension element.\n\t    // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n\t    if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n\t      return new Rect(0, 0, 0, 0);\n\t    }\n\t    if (opt) {\n\t      if (opt.target) {\n\t        // check if target exists\n\t        options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n\t      }\n\t      if (opt.recursive) {\n\t        options.recursive = opt.recursive;\n\t      }\n\t    }\n\t    if (!options.recursive) {\n\t      try {\n\t        outputBBox = node.getBBox();\n\t      } catch {\n\t        // Fallback for IE.\n\t        outputBBox = {\n\t          x: node.clientLeft,\n\t          y: node.clientTop,\n\t          width: node.clientWidth,\n\t          height: node.clientHeight\n\t        };\n\t      }\n\t      if (!options.target) {\n\t        // transform like this (that is, not at all)\n\t        return new Rect(outputBBox);\n\t      } else {\n\t        // transform like target\n\t        var matrix = this.getTransformToElement(options.target);\n\t        return V.transformRect(outputBBox, matrix);\n\t      }\n\t    } else {\n\t      // if we want to calculate the bbox recursively\n\t      // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n\t      // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n\t      // this happens even if we wrap a single svg element into a group!\n\t      // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n\t      var children = this.children();\n\t      var n = children.length;\n\t      if (n === 0) {\n\t        return this.getBBox({\n\t          target: options.target,\n\t          recursive: false\n\t        });\n\t      }\n\n\t      // recursion's initial pass-through setting:\n\t      // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n\t      if (!options.target) {\n\t        // transform children/descendants like this (their parent/ancestor)\n\t        options.target = this;\n\t      } // else transform children/descendants like target\n\n\t      for (var i = 0; i < n; i++) {\n\t        var currentChild = children[i];\n\t        var childBBox;\n\n\t        // if currentChild is not a group element, get its bbox with a nonrecursive call\n\t        if (currentChild.children().length === 0) {\n\t          childBBox = currentChild.getBBox({\n\t            target: options.target,\n\t            recursive: false\n\t          });\n\t        } else {\n\t          // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n\t          childBBox = currentChild.getBBox({\n\t            target: options.target,\n\t            recursive: true\n\t          });\n\t        }\n\t        if (!outputBBox) {\n\t          // if this is the first iteration\n\t          outputBBox = childBBox;\n\t        } else {\n\t          // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n\t          outputBBox = outputBBox.union(childBBox);\n\t        }\n\t      }\n\t      return outputBBox;\n\t    }\n\t  };\n\n\t  // Text() helpers\n\n\t  function createTextPathNode(attrs, vel) {\n\t    attrs || (attrs = {});\n\t    var textPathElement = V('textPath');\n\t    var d = attrs.d;\n\t    if (d && attrs['xlink:href'] === undefined) {\n\t      // If `opt.attrs` is a plain string, consider it to be directly the\n\t      // SVG path data for the text to go along (this is a shortcut).\n\t      // Otherwise if it is an object and contains the `d` property, then this is our path.\n\t      // Wrap the text in the SVG <textPath> element that points\n\t      // to a path defined by `opt.attrs` inside the `<defs>` element.\n\t      var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n\t      textPathElement.attr('xlink:href', '#' + linkedPath.id);\n\t    }\n\t    if (V.isObject(attrs)) {\n\t      // Set attributes on the `<textPath>`. The most important one\n\t      // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n\t      // Note that we also allow the following construct:\n\t      // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n\t      // In other words, one can completely skip the auto-creation of the path\n\t      // and use any other arbitrary path that is in the document.\n\t      textPathElement.attr(attrs);\n\t    }\n\t    return textPathElement.node;\n\t  }\n\t  function annotateTextLine(lineNode, lineAnnotations, opt) {\n\t    opt || (opt = {});\n\t    var includeAnnotationIndices = opt.includeAnnotationIndices;\n\t    var eol = opt.eol;\n\t    var lineHeight = opt.lineHeight;\n\t    var baseSize = opt.baseSize;\n\t    var maxFontSize = 0;\n\t    var fontMetrics = {};\n\t    var lastJ = lineAnnotations.length - 1;\n\t    for (var j = 0; j <= lastJ; j++) {\n\t      var annotation = lineAnnotations[j];\n\t      var fontSize = null;\n\t      if (V.isObject(annotation)) {\n\t        var annotationAttrs = annotation.attrs;\n\t        var vTSpan = V('tspan', annotationAttrs);\n\t        var tspanNode = vTSpan.node;\n\t        var t = annotation.t;\n\t        if (eol && j === lastJ) t += eol;\n\t        tspanNode.textContent = t;\n\t        // Per annotation className\n\t        var annotationClass = annotationAttrs['class'];\n\t        if (annotationClass) vTSpan.addClass(annotationClass);\n\t        // If `opt.includeAnnotationIndices` is `true`,\n\t        // set the list of indices of all the applied annotations\n\t        // in the `annotations` attribute. This list is a comma\n\t        // separated list of indices.\n\t        if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n\t        // Check for max font size\n\t        fontSize = parseFloat(annotationAttrs['font-size']);\n\t        if (!isFinite(fontSize)) fontSize = baseSize;\n\t        if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n\t      } else {\n\t        if (eol && j === lastJ) annotation += eol;\n\t        tspanNode = document.createTextNode(annotation || ' ');\n\t        if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n\t      }\n\t      lineNode.appendChild(tspanNode);\n\t    }\n\t    if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n\t    if (lineHeight) {\n\t      fontMetrics.lineHeight = lineHeight;\n\t    } else if (maxFontSize) {\n\t      fontMetrics.lineHeight = maxFontSize * 1.2;\n\t    }\n\t    return fontMetrics;\n\t  }\n\t  var emRegex = /em$/;\n\t  function convertEmToPx(em, fontSize) {\n\t    var numerical = parseFloat(em);\n\t    if (emRegex.test(em)) return numerical * fontSize;\n\t    return numerical;\n\t  }\n\t  function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n\t    if (!Array.isArray(linesMetrics)) return 0;\n\t    var n = linesMetrics.length;\n\t    if (!n) return 0;\n\t    var lineMetrics = linesMetrics[0];\n\t    var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t    var rLineHeights = 0;\n\t    var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n\t    for (var i = 1; i < n; i++) {\n\t      lineMetrics = linesMetrics[i];\n\t      var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n\t      rLineHeights += iLineHeight;\n\t    }\n\t    var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t    var dy;\n\t    switch (alignment) {\n\t      case 'middle':\n\t        dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n\t        break;\n\t      case 'bottom':\n\t        dy = -(0.25 * llMaxFont) - rLineHeights;\n\t        break;\n\t      case 'top':\n\t      default:\n\t        dy = 0.8 * flMaxFont;\n\t        break;\n\t    }\n\t    return dy;\n\t  }\n\t  VPrototype.text = function (content, opt) {\n\t    if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\t    opt || (opt = {});\n\n\t    // Backwards-compatibility: if no content was provided, treat it as an\n\t    // empty string so that subsequent string operations (e.g. split) do\n\t    // not throw and behaviour matches the previous implementation that\n\t    // always sanitised the input.\n\t    if (content == null) content = '';\n\t    if (opt.useNoBreakSpace) {\n\t      // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t      // IE would otherwise collapse all spaces into one.\n\t      content = V.sanitizeText(content);\n\t    }\n\t    // Should we allow the text to be selected?\n\t    var displayEmpty = opt.displayEmpty;\n\t    // End of Line character\n\t    var eol = opt.eol;\n\t    // Text along path\n\t    var textPath = opt.textPath;\n\t    // Vertical shift\n\t    var verticalAnchor = opt.textVerticalAnchor;\n\t    var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';\n\t    // Horizontal shift applied to all the lines but the first.\n\t    var x = opt.x;\n\t    if (x === undefined) x = this.attr('x') || 0;\n\t    // Annotations\n\t    var iai = opt.includeAnnotationIndices;\n\t    var annotations = opt.annotations;\n\t    if (annotations && !V.isArray(annotations)) annotations = [annotations];\n\t    // Shift all the <tspan> but first by one line (`1em`)\n\t    var defaultLineHeight = opt.lineHeight;\n\t    var autoLineHeight = defaultLineHeight === 'auto';\n\t    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n\t    // Clearing the element\n\t    this.empty();\n\t    this.attr({\n\t      // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n\t      'xml:space': 'preserve',\n\t      // An empty text gets rendered into the DOM in webkit-based browsers.\n\t      // In order to unify this behaviour across all browsers\n\t      // we rather hide the text element when it's empty.\n\t      'display': content || displayEmpty ? null : 'none'\n\t    });\n\n\t    // Set default font-size if none\n\t    var fontSize = parseFloat(this.attr('font-size'));\n\t    if (!fontSize) {\n\t      fontSize = 16;\n\t      if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n\t    }\n\t    var doc = document;\n\t    var containerNode;\n\t    if (textPath) {\n\t      // Now all the `<tspan>`s will be inside the `<textPath>`.\n\t      if (typeof textPath === 'string') textPath = {\n\t        d: textPath\n\t      };\n\t      containerNode = createTextPathNode(textPath, this);\n\t    } else {\n\t      containerNode = doc.createDocumentFragment();\n\t    }\n\t    var offset = 0;\n\t    var lines = content.split('\\n');\n\t    var linesMetrics = [];\n\t    var annotatedY;\n\t    for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n\t      var dy = lineHeight;\n\t      var lineClassName = 'v-line';\n\t      var lineNode = doc.createElementNS(svg$1, 'tspan');\n\t      var line = lines[i];\n\t      var lineMetrics;\n\t      if (line) {\n\t        if (annotations) {\n\t          // Find the *compacted* annotations for this line.\n\t          var lineAnnotations = V.annotateString(line, annotations, {\n\t            offset: -offset,\n\t            includeAnnotationIndices: iai\n\t          });\n\t          lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n\t            includeAnnotationIndices: iai,\n\t            eol: i !== lastI && eol,\n\t            lineHeight: autoLineHeight ? null : lineHeight,\n\t            baseSize: fontSize\n\t          });\n\t          // Get the line height based on the biggest font size in the annotations for this line.\n\t          var iLineHeight = lineMetrics.lineHeight;\n\t          if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n\t          if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n\t        } else {\n\t          if (eol && i !== lastI) line += eol;\n\t          lineNode.textContent = line;\n\t        }\n\t      } else {\n\t        // Make sure the textContent is never empty. If it is, add a dummy\n\t        // character and make it invisible, making the following lines correctly\n\t        // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n\t        lineNode.textContent = '-';\n\t        lineClassName += ' v-empty-line';\n\t        // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n\t        // is not applied in Firefox\n\t        var lineNodeStyle = lineNode.style;\n\t        lineNodeStyle.fillOpacity = 0;\n\t        lineNodeStyle.strokeOpacity = 0;\n\t        if (annotations) {\n\t          // Empty line with annotations.\n\t          lineMetrics = {};\n\t          lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n\t          let lineFontSize = fontSize;\n\t          // Check if any of the annotations overrides the font size.\n\t          for (let j = lineAnnotations.length; j > 0; j--) {\n\t            const attrs = lineAnnotations[j - 1].attrs;\n\t            if (!attrs || !('font-size' in attrs)) continue;\n\t            const fs = parseFloat(attrs['font-size']);\n\t            if (isFinite(fs)) {\n\t              lineFontSize = fs;\n\t              break;\n\t            }\n\t          }\n\t          if (autoLineHeight) {\n\t            if (i > 0) {\n\t              dy = lineFontSize * 1.2;\n\t            } else {\n\t              annotatedY = lineFontSize * 0.8;\n\t            }\n\t          }\n\t          // The font size is important for the native selection box height.\n\t          lineNode.setAttribute('font-size', lineFontSize);\n\t          lineMetrics.maxFontSize = lineFontSize;\n\t        }\n\t      }\n\t      if (lineMetrics) linesMetrics.push(lineMetrics);\n\t      if (i > 0) lineNode.setAttribute('dy', dy);\n\t      // Firefox requires 'x' to be set on the first line when inside a text path\n\t      if (i > 0 || textPath) lineNode.setAttribute('x', x);\n\t      lineNode.className.baseVal = lineClassName;\n\t      containerNode.appendChild(lineNode);\n\t      offset += line.length + 1; // + 1 = newline character.\n\t    }\n\t    // Y Alignment calculation\n\t    if (namedVerticalAnchor) {\n\t      if (annotations) {\n\t        dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n\t      } else if (verticalAnchor === 'top') {\n\t        // A shortcut for top alignment. It does not depend on font-size nor line-height\n\t        dy = '0.8em';\n\t      } else {\n\t        var rh; // remaining height\n\t        if (lastI > 0) {\n\t          rh = parseFloat(lineHeight) || 1;\n\t          rh *= lastI;\n\t          if (!emRegex.test(lineHeight)) rh /= fontSize;\n\t        } else {\n\t          // Single-line text\n\t          rh = 0;\n\t        }\n\t        switch (verticalAnchor) {\n\t          case 'middle':\n\t            dy = 0.3 - rh / 2 + 'em';\n\t            break;\n\t          case 'bottom':\n\t            dy = -rh - 0.3 + 'em';\n\t            break;\n\t        }\n\t      }\n\t    } else {\n\t      if (verticalAnchor === 0) {\n\t        dy = '0em';\n\t      } else if (verticalAnchor) {\n\t        dy = verticalAnchor;\n\t      } else {\n\t        // No vertical anchor is defined\n\t        dy = 0;\n\t        // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\t        if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n\t      }\n\t    }\n\t    containerNode.firstChild.setAttribute('dy', dy);\n\t    // Appending lines to the element.\n\t    this.append(containerNode);\n\t    return this;\n\t  };\n\n\t  /**\n\t   * @public\n\t   * @param {string} name\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.removeAttr = function (name) {\n\t    const trueName = attributeNames[name];\n\t    const {\n\t      ns,\n\t      local\n\t    } = V.qualifyAttr(trueName);\n\t    const el = this.node;\n\t    if (ns) {\n\t      if (el.hasAttributeNS(ns, local)) {\n\t        el.removeAttributeNS(ns, local);\n\t      }\n\t    } else if (el.hasAttribute(trueName)) {\n\t      el.removeAttribute(trueName);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.attr = function (name, value) {\n\t    if (V.isUndefined(name)) {\n\t      // Return all attributes.\n\t      var attributes = this.node.attributes;\n\t      var attrs = {};\n\t      for (var i = 0; i < attributes.length; i++) {\n\t        attrs[attributes[i].name] = attributes[i].value;\n\t      }\n\t      return attrs;\n\t    }\n\t    if (V.isString(name) && V.isUndefined(value)) {\n\t      return this.node.getAttribute(attributeNames[name]);\n\t    }\n\t    if (typeof name === 'object') {\n\t      for (var attrName in name) {\n\t        if (name.hasOwnProperty(attrName)) {\n\t          this.setAttribute(attrName, name[attrName]);\n\t        }\n\t      }\n\t    } else {\n\t      this.setAttribute(name, value);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.normalizePath = function () {\n\t    var tagName = this.tagName();\n\t    if (tagName === 'PATH') {\n\t      this.attr('d', V.normalizePathData(this.attr('d')));\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.remove = function () {\n\t    if (this.node.parentNode) {\n\t      this.node.parentNode.removeChild(this.node);\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.empty = function () {\n\t    while (this.node.firstChild) {\n\t      this.node.removeChild(this.node.firstChild);\n\t    }\n\t    return this;\n\t  };\n\n\t  /**\n\t   * @private\n\t   * @param {object} attrs\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.setAttributes = function (attrs) {\n\t    for (var key in attrs) {\n\t      if (attrs.hasOwnProperty(key)) {\n\t        this.setAttribute(key, attrs[key]);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.append = function (els) {\n\t    if (!V.isArray(els)) {\n\t      els = [els];\n\t    }\n\t    for (var i = 0, len = els.length; i < len; i++) {\n\t      this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.prepend = function (els) {\n\t    var child = this.node.firstChild;\n\t    return child ? V(child).before(els) : this.append(els);\n\t  };\n\t  VPrototype.before = function (els) {\n\t    var node = this.node;\n\t    var parent = node.parentNode;\n\t    if (parent) {\n\t      if (!V.isArray(els)) {\n\t        els = [els];\n\t      }\n\t      for (var i = 0, len = els.length; i < len; i++) {\n\t        parent.insertBefore(V.toNode(els[i]), node);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  VPrototype.appendTo = function (node) {\n\t    V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n\t    return this;\n\t  };\n\t  VPrototype.svg = function () {\n\t    return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n\t  };\n\t  VPrototype.tagName = function () {\n\t    return this.node.tagName.toUpperCase();\n\t  };\n\t  VPrototype.defs = function () {\n\t    var context = this.svg() || this;\n\t    var defsNode = context.node.getElementsByTagName('defs')[0];\n\t    if (defsNode) return V(defsNode);\n\t    return V('defs').appendTo(context);\n\t  };\n\t  VPrototype.clone = function () {\n\t    var clone = V(this.node.cloneNode(true /* deep */));\n\t    // Note that clone inherits also ID. Therefore, we need to change it here.\n\t    clone.node.id = V.uniqueId();\n\t    return clone;\n\t  };\n\t  VPrototype.findOne = function (selector) {\n\t    var found = this.node.querySelector(selector);\n\t    return found ? V(found) : undefined;\n\t  };\n\t  VPrototype.find = function (selector) {\n\t    var vels = [];\n\t    var nodes = this.node.querySelectorAll(selector);\n\t    if (nodes) {\n\t      // Map DOM elements to `V`s.\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        vels.push(V(nodes[i]));\n\t      }\n\t    }\n\t    return vels;\n\t  };\n\n\t  // Returns an array of V elements made from children of this.node.\n\t  VPrototype.children = function () {\n\t    var children = this.node.childNodes;\n\t    var outputArray = [];\n\t    for (var i = 0; i < children.length; i++) {\n\t      var currentChild = children[i];\n\t      if (currentChild.nodeType === 1) {\n\t        outputArray.push(V(children[i]));\n\t      }\n\t    }\n\t    return outputArray;\n\t  };\n\n\t  // Returns the V element from parentNode of this.node.\n\t  VPrototype.parent = function () {\n\t    return V(this.node.parentNode) || null;\n\t  },\n\t  // Find an index of an element inside its container.\n\t  VPrototype.index = function () {\n\t    var index = 0;\n\t    var node = this.node.previousSibling;\n\t    while (node) {\n\t      // nodeType 1 for ELEMENT_NODE\n\t      if (node.nodeType === 1) index++;\n\t      node = node.previousSibling;\n\t    }\n\t    return index;\n\t  };\n\t  VPrototype.findParentByClass = function (className, terminator) {\n\t    var ownerSVGElement = this.node.ownerSVGElement;\n\t    var node = this.node.parentNode;\n\t    while (node && node !== terminator && node !== ownerSVGElement) {\n\t      var vel = V(node);\n\t      if (vel.hasClass(className)) {\n\t        return vel;\n\t      }\n\t      node = node.parentNode;\n\t    }\n\t    return null;\n\t  };\n\n\t  // https://jsperf.com/get-common-parent\n\t  VPrototype.contains = function (el) {\n\t    var a = this.node;\n\t    var b = V.toNode(el);\n\t    var bup = b && b.parentNode;\n\t    return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n\t  };\n\n\t  // Convert global point into the coordinate space of this element.\n\t  VPrototype.toLocalPoint = function (x, y) {\n\t    var svg = this.svg().node;\n\t    var p = svg.createSVGPoint();\n\t    p.x = x;\n\t    p.y = y;\n\t    try {\n\t      var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n\t      var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\t    } catch {\n\t      // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n\t      // We have to make do with the original coordinates.\n\t      return p;\n\t    }\n\t    return globalPoint.matrixTransform(globalToLocalMatrix);\n\t  };\n\t  VPrototype.translateCenterToPoint = function (p) {\n\t    var bbox = this.getBBox({\n\t      target: this.svg()\n\t    });\n\t    var center = bbox.center();\n\t    this.translate(p.x - center.x, p.y - center.y);\n\t    return this;\n\t  };\n\n\t  // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n\t  // of markers. The easiest way of understanding on what this does is to imagine the element is an\n\t  // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n\t  // being auto-oriented (properly rotated) towards the `reference` point.\n\t  // `target` is the element relative to which the transformations are applied. Usually a viewport.\n\t  VPrototype.translateAndAutoOrient = function (position, reference, target) {\n\t    position = new Point(position);\n\t    reference = new Point(reference);\n\t    target || (target = this.svg());\n\n\t    // Clean-up previously set transformations except the scale. If we didn't clean up the\n\t    // previous transformations then they'd add up with the old ones. Scale is an exception as\n\t    // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n\t    // element is scaled by the factor 2, not 8.\n\t    var scale = this.scale();\n\t    this.attr('transform', '');\n\t    var bbox = this.getBBox({\n\t      target: target\n\t    }).scale(scale.sx, scale.sy);\n\n\t    // 1. Translate to origin.\n\t    var translateToOrigin = V.createSVGTransform();\n\t    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n\t    // 2. Rotate around origin.\n\t    var rotateAroundOrigin = V.createSVGTransform();\n\t    var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n\t    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n\t    // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n\t    var translateFromOrigin = V.createSVGTransform();\n\t    var finalPosition = position.clone().move(reference, bbox.width / 2);\n\t    translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n\t    // 4. Get the current transformation matrix of this node\n\t    var ctm = this.getTransformToElement(target);\n\n\t    // 5. Apply transformations and the scale\n\t    var transform = V.createSVGTransform();\n\t    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n\t    this.attr('transform', matrixToTransformString(transform.matrix));\n\t    return this;\n\t  };\n\t  VPrototype.animateAlongPath = function (attrs, path) {\n\t    path = V.toNode(path);\n\t    var id = V.ensureId(path);\n\t    var animateMotion = V('animateMotion', attrs);\n\t    var mpath = V('mpath', {\n\t      'xlink:href': '#' + id\n\t    });\n\t    animateMotion.append(mpath);\n\t    this.append(animateMotion);\n\t    try {\n\t      animateMotion.node.beginElement();\n\t    } catch {\n\t      // Fallback for IE 9.\n\t      // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n\t      if (document.documentElement.getAttribute('smiling') === 'fake') {\n\t        /* global getTargets:true, Animator:true, animators:true id2anim:true */\n\t        // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n\t        var animation = animateMotion.node;\n\t        animation.animators = [];\n\t        var animationID = animation.getAttribute('id');\n\t        if (animationID) id2anim[animationID] = animation;\n\t        var targets = getTargets(animation);\n\t        for (var i = 0, len = targets.length; i < len; i++) {\n\t          var target = targets[i];\n\t          var animator = new Animator(animation, target, i);\n\t          animators.push(animator);\n\t          animation.animators[i] = animator;\n\t          animator.register();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\n\t  // Split a string into an array of tokens.\n\t  // https://infra.spec.whatwg.org/#ascii-whitespace\n\t  const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n\t  function getTokenList(str) {\n\t    if (!V.isString(str)) return [];\n\t    return str.trim().match(noHTMLWhitespaceRegex) || [];\n\t  }\n\t  VPrototype.hasClass = function (className) {\n\t    if (!V.isString(className)) return false;\n\t    return this.node.classList.contains(className.trim());\n\t  };\n\t  VPrototype.addClass = function (className) {\n\t    this.node.classList.add(...getTokenList(className));\n\t    return this;\n\t  };\n\t  VPrototype.removeClass = function (className) {\n\t    this.node.classList.remove(...getTokenList(className));\n\t    return this;\n\t  };\n\t  VPrototype.toggleClass = function (className, toAdd) {\n\t    const tokens = getTokenList(className);\n\t    for (let i = 0; i < tokens.length; i++) {\n\t      this.node.classList.toggle(tokens[i], toAdd);\n\t    }\n\t    return this;\n\t  };\n\n\t  // Interpolate path by discrete points. The precision of the sampling\n\t  // is controlled by `interval`. In other words, `sample()` will generate\n\t  // a point on the path starting at the beginning of the path going to the end\n\t  // every `interval` pixels.\n\t  // The sampler can be very useful for e.g. finding intersection between two\n\t  // paths (finding the two closest points from two samples).\n\t  VPrototype.sample = function (interval) {\n\t    interval = interval || 1;\n\t    var node = this.node;\n\t    var length = node.getTotalLength();\n\t    var samples = [];\n\t    var distance = 0;\n\t    var sample;\n\t    while (distance < length) {\n\t      sample = node.getPointAtLength(distance);\n\t      samples.push({\n\t        x: sample.x,\n\t        y: sample.y,\n\t        distance: distance\n\t      });\n\t      distance += interval;\n\t    }\n\t    return samples;\n\t  };\n\t  VPrototype.convertToPath = function () {\n\t    var path = V('path');\n\t    path.attr(this.attr());\n\t    var d = this.convertToPathData();\n\t    if (d) {\n\t      path.attr('d', d);\n\t    }\n\t    return path;\n\t  };\n\t  VPrototype.convertToPathData = function () {\n\t    var tagName = this.tagName();\n\t    switch (tagName) {\n\t      case 'PATH':\n\t        return this.attr('d');\n\t      case 'LINE':\n\t        return V.convertLineToPathData(this.node);\n\t      case 'POLYGON':\n\t        return V.convertPolygonToPathData(this.node);\n\t      case 'POLYLINE':\n\t        return V.convertPolylineToPathData(this.node);\n\t      case 'ELLIPSE':\n\t        return V.convertEllipseToPathData(this.node);\n\t      case 'CIRCLE':\n\t        return V.convertCircleToPathData(this.node);\n\t      case 'RECT':\n\t        return V.convertRectToPathData(this.node);\n\t    }\n\t    throw new Error(tagName + ' cannot be converted to PATH.');\n\t  };\n\t  V.prototype.toGeometryShape = function () {\n\t    var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n\t    switch (this.tagName()) {\n\t      case 'RECT':\n\t        x = parseFloat(this.attr('x')) || 0;\n\t        y = parseFloat(this.attr('y')) || 0;\n\t        width = parseFloat(this.attr('width')) || 0;\n\t        height = parseFloat(this.attr('height')) || 0;\n\t        return new Rect(x, y, width, height);\n\t      case 'CIRCLE':\n\t        cx = parseFloat(this.attr('cx')) || 0;\n\t        cy = parseFloat(this.attr('cy')) || 0;\n\t        r = parseFloat(this.attr('r')) || 0;\n\t        return new Ellipse$1({\n\t          x: cx,\n\t          y: cy\n\t        }, r, r);\n\t      case 'ELLIPSE':\n\t        cx = parseFloat(this.attr('cx')) || 0;\n\t        cy = parseFloat(this.attr('cy')) || 0;\n\t        rx = parseFloat(this.attr('rx')) || 0;\n\t        ry = parseFloat(this.attr('ry')) || 0;\n\t        return new Ellipse$1({\n\t          x: cx,\n\t          y: cy\n\t        }, rx, ry);\n\t      case 'POLYLINE':\n\t        points = V.getPointsFromSvgNode(this);\n\t        return new Polyline$1(points);\n\t      case 'POLYGON':\n\t        points = V.getPointsFromSvgNode(this);\n\t        if (points.length > 1) points.push(points[0]);\n\t        return new Polyline$1(points);\n\t      case 'PATH':\n\t        d = this.attr('d');\n\t        if (!Path$1.isDataSupported(d)) d = V.normalizePathData(d);\n\t        return new Path$1(d);\n\t      case 'LINE':\n\t        x1 = parseFloat(this.attr('x1')) || 0;\n\t        y1 = parseFloat(this.attr('y1')) || 0;\n\t        x2 = parseFloat(this.attr('x2')) || 0;\n\t        y2 = parseFloat(this.attr('y2')) || 0;\n\t        return new Line({\n\t          x: x1,\n\t          y: y1\n\t        }, {\n\t          x: x2,\n\t          y: y2\n\t        });\n\t    }\n\n\t    // Anything else is a rectangle\n\t    return this.getBBox();\n\t  };\n\n\t  // Find the intersection of a line starting in the center\n\t  // of the SVG `node` ending in the point `ref`.\n\t  // `target` is an SVG element to which `node`s transformations are relative to.\n\t  // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n\t  // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n\t  // an intersection is found. Returns `undefined` otherwise.\n\t  VPrototype.findIntersection = function (ref, target) {\n\t    var svg = this.svg().node;\n\t    target = target || svg;\n\t    var bbox = this.getBBox({\n\t      target: target\n\t    });\n\t    var center = bbox.center();\n\t    if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\t    var spot;\n\t    var tagName = this.tagName();\n\n\t    // Little speed up optimization for `<rect>` element. We do not do conversion\n\t    // to path element and sampling but directly calculate the intersection through\n\t    // a transformed geometrical rectangle.\n\t    if (tagName === 'RECT') {\n\t      var gRect = new Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height')));\n\t      // Get the rect transformation matrix with regards to the SVG document.\n\t      var rectMatrix = this.getTransformToElement(target);\n\t      // Decompose the matrix to find the rotation angle.\n\t      var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n\t      // Now we want to rotate the rectangle back so that we\n\t      // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n\t      var resetRotation = svg.createSVGTransform();\n\t      resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n\t      var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n\t      spot = new Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\t    } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\t      var pathNode = tagName === 'PATH' ? this : this.convertToPath();\n\t      var samples = pathNode.sample();\n\t      var minDistance = Infinity;\n\t      var closestSamples = [];\n\t      var i, sample, gp, centerDistance, refDistance, distance;\n\t      for (i = 0; i < samples.length; i++) {\n\t        sample = samples[i];\n\t        // Convert the sample point in the local coordinate system to the global coordinate system.\n\t        gp = V.createSVGPoint(sample.x, sample.y);\n\t        gp = gp.matrixTransform(this.getTransformToElement(target));\n\t        sample = new Point(gp);\n\t        centerDistance = sample.distance(center);\n\t        // Penalize a higher distance to the reference point by 10%.\n\t        // This gives better results. This is due to\n\t        // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\t        refDistance = sample.distance(ref) * 1.1;\n\t        distance = centerDistance + refDistance;\n\t        if (distance < minDistance) {\n\t          minDistance = distance;\n\t          closestSamples = [{\n\t            sample: sample,\n\t            refDistance: refDistance\n\t          }];\n\t        } else if (distance < minDistance + 1) {\n\t          closestSamples.push({\n\t            sample: sample,\n\t            refDistance: refDistance\n\t          });\n\t        }\n\t      }\n\t      closestSamples.sort(function (a, b) {\n\t        return a.refDistance - b.refDistance;\n\t      });\n\t      if (closestSamples[0]) {\n\t        spot = closestSamples[0].sample;\n\t      }\n\t    }\n\t    return spot;\n\t  };\n\n\t  /**\n\t   * @private\n\t   * @param {string} name\n\t   * @param {string} value\n\t   * @returns {Vectorizer}\n\t   */\n\t  VPrototype.setAttribute = function (name, value) {\n\t    const el = this.node;\n\t    if (value === null) {\n\t      this.removeAttr(name);\n\t      return this;\n\t    }\n\t    const trueName = attributeNames[name];\n\t    const {\n\t      ns\n\t    } = V.qualifyAttr(trueName);\n\t    if (ns) {\n\t      // Attribute names can be namespaced. E.g. `image` elements\n\t      // have a `xlink:href` attribute to set the source of the image.\n\t      el.setAttributeNS(ns, trueName, value);\n\t    } else if (trueName === 'id') {\n\t      el.id = value;\n\t    } else {\n\t      el.setAttribute(trueName, value);\n\t    }\n\t    return this;\n\t  };\n\n\t  // Create an SVG document element.\n\t  // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n\t  V.createSvgDocument = function (content) {\n\t    if (content) {\n\t      const XMLString = `<svg xmlns=\"${svg$1}\" xmlns:xlink=\"${xlink}\" version=\"${SVG_VERSION}\">${content}</svg>`;\n\t      const {\n\t        documentElement\n\t      } = V.parseXML(XMLString, {\n\t        async: false\n\t      });\n\t      return documentElement;\n\t    }\n\t    return createSVGDocument();\n\t  };\n\t  V.createSVGStyle = function (stylesheet) {\n\t    const {\n\t      node\n\t    } = V('style', {\n\t      type: 'text/css'\n\t    }, [V.createCDATASection(stylesheet)]);\n\t    return node;\n\t  }, V.createCDATASection = function (data = '') {\n\t    const xml = document.implementation.createDocument(null, 'xml', null);\n\t    return xml.createCDATASection(data);\n\t  };\n\t  V.idCounter = 0;\n\n\t  // A function returning a unique identifier for this client session with every call.\n\t  V.uniqueId = function () {\n\t    return 'v-' + ++V.idCounter;\n\t  };\n\t  V.toNode = function (el) {\n\t    return V.isV(el) ? el.node : el.nodeName && el || el[0];\n\t  };\n\t  V.ensureId = function (node) {\n\t    node = V.toNode(node);\n\t    return node.id || (node.id = V.uniqueId());\n\t  };\n\n\t  // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t  // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n\t  // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n\t  // when you want to compare the actual DOM text content without having to add the unicode character in\n\t  // the place of all spaces.\n\t  /**\n\t   * @deprecated Use regular spaces and rely on xml:space=\"preserve\" instead.\n\t   */\n\t  V.sanitizeText = function (text) {\n\t    return (text || '').replace(/ /g, '\\u00A0');\n\t  };\n\t  V.isUndefined = function (value) {\n\t    return typeof value === 'undefined';\n\t  };\n\t  V.isString = function (value) {\n\t    return typeof value === 'string';\n\t  };\n\t  V.isObject = function (value) {\n\t    return value && typeof value === 'object';\n\t  };\n\t  V.isArray = Array.isArray;\n\t  V.parseXML = function (data, opt) {\n\t    opt = opt || {};\n\t    var xml;\n\t    try {\n\t      var parser = new DOMParser();\n\t      if (!V.isUndefined(opt.async)) {\n\t        parser.async = opt.async;\n\t      }\n\t      xml = parser.parseFromString(data, 'text/xml');\n\t    } catch {\n\t      xml = undefined;\n\t    }\n\t    if (!xml || xml.getElementsByTagName('parsererror').length) {\n\t      throw new Error('Invalid XML: ' + data);\n\t    }\n\t    return xml;\n\t  };\n\n\t  // Create an empty object which does not inherit any properties from `Object.prototype`.\n\t  // This is useful when we want to use an object as a dictionary without having to\n\t  // worry about inherited properties such as `toString`, `valueOf` etc.\n\t  const _attributeNames = Object.create(null);\n\n\t  // List of attributes for which not to split camel case words.\n\t  // It contains known SVG attribute names and may be extended with user-defined attribute names.\n\t  ['attributeName', 'baseFrequency', 'baseProfile', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes',\n\t  // deprecated\n\t  'filterUnits', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'requiredExtensions', 'requiredFeatures', 'repeatCount', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget',\n\t  // deprecated\n\t  'xChannelSelector', 'yChannelSelector', 'zoomAndPan' // deprecated\n\t  ].forEach(name => _attributeNames[name] = name);\n\t  _attributeNames['xlinkShow'] = 'xlink:show';\n\t  _attributeNames['xlinkRole'] = 'xlink:role';\n\t  _attributeNames['xlinkActuate'] = 'xlink:actuate';\n\t  _attributeNames['xlinkHref'] = 'xlink:href';\n\t  _attributeNames['xlinkType'] = 'xlink:type';\n\t  _attributeNames['xlinkTitle'] = 'xlink:title';\n\t  _attributeNames['xmlBase'] = 'xml:base';\n\t  _attributeNames['xmlLang'] = 'xml:lang';\n\t  _attributeNames['xmlSpace'] = 'xml:space';\n\t  const attributeNames = new Proxy(_attributeNames, {\n\t    get(cache, name) {\n\t      // The cache is a dictionary of attribute names. See `_attributeNames` above.\n\t      // If the attribute name is not in the cache, it means that it is not\n\t      // a camel-case attribute name. In that case, we need to convert\n\t      // the attribute name to dash-separated words.\n\t      if (!V.supportCamelCaseAttributes) return name;\n\t      if (name in cache) {\n\t        return cache[name];\n\t      }\n\t      // Convert camel case to dash-separated words.\n\t      return cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t    }\n\t  });\n\n\t  // Dictionary of attribute names\n\t  Object.defineProperty(V, 'attributeNames', {\n\t    enumerable: true,\n\t    value: attributeNames,\n\t    writable: false\n\t  });\n\n\t  // Should camel case attributes be supported?\n\t  Object.defineProperty(V, 'supportCamelCaseAttributes', {\n\t    enumerable: true,\n\t    value: true,\n\t    writable: true\n\t  });\n\n\t  /**\n\t   * @param {string} name\n\t   * @returns {{ns: string|null, local: string}} namespace and attribute name\n\t   */\n\t  V.qualifyAttr = function (name) {\n\t    if (name.indexOf(':') !== -1) {\n\t      var combinedKey = name.split(':');\n\t      return {\n\t        ns: ns[combinedKey[0]],\n\t        local: combinedKey[1]\n\t      };\n\t    }\n\t    return {\n\t      ns: null,\n\t      local: name\n\t    };\n\t  };\n\n\t  // Note: This regex allows multiple commas as separator which is incorrect in SVG\n\t  // This regex is used by `split()`, so it doesn't need to use /g\n\t  V.transformSeparatorRegex = /[ ,]+/;\n\t  // Note: All following regexes are more restrictive than SVG specification\n\t  // ReDoS mitigation: Use an anchor at the beginning of the match\n\t  // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n\t  // ReDoS mitigation: Don't match initial `(` inside repeated part\n\t  // The following regexes need to use capturing groups (= cannot use /g)\n\t  V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n\t  V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n\t  V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n\t  V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\t  V.transformStringToMatrix = function (transform) {\n\t    let matrix;\n\t    if (V.isString(transform)) {\n\t      matrix = createMatrixFromTransformString(transform);\n\t    }\n\t    return matrix || createIdentityMatrix();\n\t  };\n\t  V.matrixToTransformString = matrixToTransformString;\n\t  V.parseTransformString = function (transform) {\n\t    var translate, rotate, scale;\n\t    if (transform) {\n\t      var separator = V.transformSeparatorRegex;\n\n\t      // Special handling for `transform` with one or more matrix functions\n\t      if (transform.trim().indexOf('matrix') >= 0) {\n\t        // Convert EVERYTHING in `transform` string to a matrix\n\t        // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n\t        // Note: In non-matrix case, we only take first one of each (if any)\n\t        var matrix = V.transformStringToMatrix(transform);\n\t        var decomposedMatrix = V.decomposeMatrix(matrix);\n\n\t        // Extract `translate`, `scale`, `rotate` from matrix\n\t        translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n\t        scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n\t        rotate = [decomposedMatrix.rotation];\n\n\t        // Rewrite `transform` string in `translate scale rotate` format\n\t        var transformations = [];\n\t        if (translate[0] !== 0 || translate[1] !== 0) {\n\t          transformations.push('translate(' + translate + ')');\n\t        }\n\t        if (scale[0] !== 1 || scale[1] !== 1) {\n\t          transformations.push('scale(' + scale + ')');\n\t        }\n\t        if (rotate[0] !== 0) {\n\t          transformations.push('rotate(' + rotate + ')');\n\t        }\n\t        transform = transformations.join(' ');\n\t      } else {\n\t        // Extract `translate`, `rotate`, `scale` functions from `transform` string\n\t        // Note: We only detect the first match of each (if any)\n\t        // `match()` returns value of capturing group as `[1]`\n\t        const translateMatch = transform.match(V.transformTranslateRegex);\n\t        if (translateMatch) {\n\t          translate = translateMatch[1].split(separator);\n\t        }\n\t        const rotateMatch = transform.match(V.transformRotateRegex);\n\t        if (rotateMatch) {\n\t          rotate = rotateMatch[1].split(separator);\n\t        }\n\t        const scaleMatch = transform.match(V.transformScaleRegex);\n\t        if (scaleMatch) {\n\t          scale = scaleMatch[1].split(separator);\n\t        }\n\t      }\n\t    }\n\t    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n\t    return {\n\t      value: transform,\n\t      translate: {\n\t        tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n\t        ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n\t      },\n\t      rotate: {\n\t        angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n\t        cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n\t        cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n\t      },\n\t      scale: {\n\t        sx: sx,\n\t        sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n\t      }\n\t    };\n\t  };\n\t  V.deltaTransformPoint = function (matrix, point) {\n\t    var dx = point.x * matrix.a + point.y * matrix.c + 0;\n\t    var dy = point.x * matrix.b + point.y * matrix.d + 0;\n\t    return {\n\t      x: dx,\n\t      y: dy\n\t    };\n\t  };\n\t  V.decomposeMatrix = function (matrix) {\n\t    // @see https://gist.github.com/2052247\n\n\t    // calculate delta transform point\n\t    var px = V.deltaTransformPoint(matrix, {\n\t      x: 0,\n\t      y: 1\n\t    });\n\t    var py = V.deltaTransformPoint(matrix, {\n\t      x: 1,\n\t      y: 0\n\t    });\n\n\t    // calculate skew\n\t    var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n\t    var skewY = 180 / PI * atan2(py.y, py.x);\n\t    return {\n\t      translateX: matrix.e,\n\t      translateY: matrix.f,\n\t      scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n\t      scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n\t      skewX: skewX,\n\t      skewY: skewY,\n\t      rotation: skewX // rotation is the same as skew x\n\t    };\n\t  };\n\n\t  // Return the `scale` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToScale = function (matrix) {\n\t    var a, b, c, d;\n\t    if (matrix) {\n\t      a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n\t      d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n\t      b = matrix.b;\n\t      c = matrix.c;\n\t    } else {\n\t      a = d = 1;\n\t    }\n\t    return {\n\t      sx: b ? sqrt(a * a + b * b) : a,\n\t      sy: c ? sqrt(c * c + d * d) : d\n\t    };\n\t  };\n\n\t  // Return the `rotate` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToRotate = function (matrix) {\n\t    var p = {\n\t      x: 0,\n\t      y: 1\n\t    };\n\t    if (matrix) {\n\t      p = V.deltaTransformPoint(matrix, p);\n\t    }\n\t    return {\n\t      angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)\n\t    };\n\t  };\n\n\t  // Return the `translate` transformation from the following equation:\n\t  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t  V.matrixToTranslate = function (matrix) {\n\t    return {\n\t      tx: matrix && matrix.e || 0,\n\t      ty: matrix && matrix.f || 0\n\t    };\n\t  };\n\t  V.isV = function (object) {\n\t    return object instanceof V;\n\t  };\n\n\t  // For backwards compatibility:\n\t  V.isVElement = V.isV;\n\n\t  // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n\t  // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n\t  V.isSVGGraphicsElement = function (node) {\n\t    if (!node) return false;\n\t    node = V.toNode(node);\n\t    // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n\t    return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n\t  };\n\t  V.createSVGMatrix = createMatrix;\n\t  V.createSVGTransform = function (matrix) {\n\t    if (!V.isUndefined(matrix)) {\n\t      if (!isSVGMatrix(matrix)) {\n\t        matrix = createMatrix(matrix);\n\t      }\n\t      return internalSVGDocument.createSVGTransformFromMatrix(matrix);\n\t    }\n\t    return internalSVGDocument.createSVGTransform();\n\t  };\n\t  V.createSVGPoint = function (x, y) {\n\t    var p = internalSVGDocument.createSVGPoint();\n\t    p.x = x;\n\t    p.y = y;\n\t    return p;\n\t  };\n\t  V.transformRect = function (r, matrix) {\n\t    var p = internalSVGDocument.createSVGPoint();\n\t    p.x = r.x;\n\t    p.y = r.y;\n\t    var corner1 = p.matrixTransform(matrix);\n\t    p.x = r.x + r.width;\n\t    p.y = r.y;\n\t    var corner2 = p.matrixTransform(matrix);\n\t    p.x = r.x + r.width;\n\t    p.y = r.y + r.height;\n\t    var corner3 = p.matrixTransform(matrix);\n\t    p.x = r.x;\n\t    p.y = r.y + r.height;\n\t    var corner4 = p.matrixTransform(matrix);\n\t    var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n\t    var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n\t    var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n\t    var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\t    return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t  };\n\t  V.transformPoint = function (p, matrix) {\n\t    return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n\t  };\n\t  V.transformLine = function (l, matrix) {\n\t    return new Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n\t  };\n\t  V.transformPolyline = function (p, matrix) {\n\t    var inPoints = p instanceof Polyline$1 ? p.points : p;\n\t    if (!V.isArray(inPoints)) inPoints = [];\n\t    var outPoints = [];\n\t    for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n\t    return new Polyline$1(outPoints);\n\t  };\n\n\t  // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n\t  // an object (`{ fill: 'blue', stroke: 'red' }`).\n\t  V.styleToObject = function (styleString) {\n\t    var ret = {};\n\t    var styles = styleString.split(';');\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var style = styles[i];\n\t      var pair = style.split('=');\n\t      ret[pair[0].trim()] = pair[1].trim();\n\t    }\n\t    return ret;\n\t  };\n\n\t  // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\t  V.createSlicePathData = function (innerRadius, outerRadius, startAngle, endAngle) {\n\t    var svgArcMax = 2 * PI - 1e-6;\n\t    var r0 = innerRadius;\n\t    var r1 = outerRadius;\n\t    var a0 = startAngle;\n\t    var a1 = endAngle;\n\t    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n\t    var df = da < PI ? '0' : '1';\n\t    var c0 = cos(a0);\n\t    var s0 = sin(a0);\n\t    var c1 = cos(a1);\n\t    var s1 = sin(a1);\n\t    return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';\n\t  };\n\n\t  // Merge attributes from object `b` with attributes in object `a`.\n\t  // Note that this modifies the object `a`.\n\t  // Also important to note that attributes are merged but CSS classes are concatenated.\n\t  V.mergeAttrs = function (a, b) {\n\t    for (var attr in b) {\n\t      if (attr === 'class') {\n\t        // Concatenate classes.\n\t        a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n\t      } else if (attr === 'style') {\n\t        // `style` attribute can be an object.\n\t        if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n\t          // `style` stored in `a` is an object.\n\t          a[attr] = V.mergeAttrs(a[attr], b[attr]);\n\t        } else if (V.isObject(a[attr])) {\n\t          // `style` in `a` is an object but it's a string in `b`.\n\t          // Convert the style represented as a string to an object in `b`.\n\t          a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n\t        } else if (V.isObject(b[attr])) {\n\t          // `style` in `a` is a string, in `b` it's an object.\n\t          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n\t        } else {\n\t          // Both styles are strings.\n\t          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n\t        }\n\t      } else {\n\t        a[attr] = b[attr];\n\t      }\n\t    }\n\t    return a;\n\t  };\n\t  V.annotateString = function (t, annotations, opt) {\n\t    annotations = annotations || [];\n\t    opt = opt || {};\n\t    var offset = opt.offset || 0;\n\t    var compacted = [];\n\t    var batch;\n\t    var ret = [];\n\t    var item;\n\t    var prev;\n\t    for (var i = 0; i < t.length; i++) {\n\t      item = ret[i] = t[i];\n\t      for (var j = 0; j < annotations.length; j++) {\n\t        var annotation = annotations[j];\n\t        var start = annotation.start + offset;\n\t        var end = annotation.end + offset;\n\t        if (i >= start && i < end) {\n\t          // Annotation applies.\n\t          if (V.isObject(item)) {\n\t            // There is more than one annotation to be applied => Merge attributes.\n\t            item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n\t          } else {\n\t            item = ret[i] = {\n\t              t: t[i],\n\t              attrs: annotation.attrs\n\t            };\n\t          }\n\t          if (opt.includeAnnotationIndices) {\n\t            (item.annotations || (item.annotations = [])).push(j);\n\t          }\n\t        }\n\t      }\n\t      prev = ret[i - 1];\n\t      if (!prev) {\n\t        batch = item;\n\t      } else if (V.isObject(item) && V.isObject(prev)) {\n\t        // Both previous item and the current one are annotations. If the attributes\n\t        // didn't change, merge the text.\n\t        if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n\t          batch.t += item.t;\n\t        } else {\n\t          compacted.push(batch);\n\t          batch = item;\n\t        }\n\t      } else if (V.isObject(item)) {\n\t        // Previous item was a string, current item is an annotation.\n\t        compacted.push(batch);\n\t        batch = item;\n\t      } else if (V.isObject(prev)) {\n\t        // Previous item was an annotation, current item is a string.\n\t        compacted.push(batch);\n\t        batch = item;\n\t      } else {\n\t        // Both previous and current item are strings.\n\t        batch = (batch || '') + item;\n\t      }\n\t    }\n\t    if (batch) {\n\t      compacted.push(batch);\n\t    }\n\t    return compacted;\n\t  };\n\t  V.findAnnotationsAtIndex = function (annotations, index) {\n\t    var found = [];\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (annotation.start < index && index <= annotation.end) {\n\t          found.push(annotation);\n\t        }\n\t      });\n\t    }\n\t    return found;\n\t  };\n\t  V.findAnnotationsBetweenIndexes = function (annotations, start, end) {\n\t    var found = [];\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {\n\t          found.push(annotation);\n\t        }\n\t      });\n\t    }\n\t    return found;\n\t  };\n\n\t  // Shift all the text annotations after character `index` by `offset` positions.\n\t  V.shiftAnnotations = function (annotations, index, offset) {\n\t    if (annotations) {\n\t      annotations.forEach(function (annotation) {\n\t        if (annotation.start < index && annotation.end >= index) {\n\t          annotation.end += offset;\n\t        } else if (annotation.start >= index) {\n\t          annotation.start += offset;\n\t          annotation.end += offset;\n\t        }\n\t      });\n\t    }\n\t    return annotations;\n\t  };\n\t  V.convertLineToPathData = function (line) {\n\t    line = V(line);\n\t    var d = ['M', line.attr('x1') || '0', line.attr('y1') || '0', 'L', line.attr('x2') || '0', line.attr('y2') || '0'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertPolygonToPathData = function (polygon) {\n\t    var points = V.getPointsFromSvgNode(polygon);\n\t    if (points.length === 0) return null;\n\t    return V.svgPointsToPath(points) + ' Z';\n\t  };\n\t  V.convertPolylineToPathData = function (polyline) {\n\t    var points = V.getPointsFromSvgNode(polyline);\n\t    if (points.length === 0) return null;\n\t    return V.svgPointsToPath(points);\n\t  };\n\t  V.svgPointsToPath = function (points) {\n\t    for (var i = 0, n = points.length; i < n; i++) {\n\t      points[i] = points[i].x + ' ' + points[i].y;\n\t    }\n\t    return 'M ' + points.join(' L');\n\t  };\n\t  V.getPointsFromSvgNode = function (node) {\n\t    node = V.toNode(node);\n\t    var points = [];\n\t    var nodePoints = node.points;\n\t    if (nodePoints) {\n\t      for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n\t        points.push(nodePoints.getItem(i));\n\t      }\n\t    }\n\t    return points;\n\t  };\n\t  V.KAPPA = 0.551784;\n\t  V.convertCircleToPathData = function (circle) {\n\t    circle = V(circle);\n\t    var cx = parseFloat(circle.attr('cx')) || 0;\n\t    var cy = parseFloat(circle.attr('cy')) || 0;\n\t    var r = parseFloat(circle.attr('r'));\n\t    var cd = r * V.KAPPA; // Control distance.\n\n\t    var d = ['M', cx, cy - r,\n\t    // Move to the first point.\n\t    'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy,\n\t    // I. Quadrant.\n\t    'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r,\n\t    // II. Quadrant.\n\t    'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy,\n\t    // III. Quadrant.\n\t    'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r,\n\t    // IV. Quadrant.\n\t    'Z'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertEllipseToPathData = function (ellipse) {\n\t    ellipse = V(ellipse);\n\t    var cx = parseFloat(ellipse.attr('cx')) || 0;\n\t    var cy = parseFloat(ellipse.attr('cy')) || 0;\n\t    var rx = parseFloat(ellipse.attr('rx'));\n\t    var ry = parseFloat(ellipse.attr('ry')) || rx;\n\t    var cdx = rx * V.KAPPA; // Control distance x.\n\t    var cdy = ry * V.KAPPA; // Control distance y.\n\n\t    var d = ['M', cx, cy - ry,\n\t    // Move to the first point.\n\t    'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy,\n\t    // I. Quadrant.\n\t    'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry,\n\t    // II. Quadrant.\n\t    'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy,\n\t    // III. Quadrant.\n\t    'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry,\n\t    // IV. Quadrant.\n\t    'Z'].join(' ');\n\t    return d;\n\t  };\n\t  V.convertRectToPathData = function (rect) {\n\t    rect = V(rect);\n\t    return V.rectToPath({\n\t      x: parseFloat(rect.attr('x')) || 0,\n\t      y: parseFloat(rect.attr('y')) || 0,\n\t      width: parseFloat(rect.attr('width')) || 0,\n\t      height: parseFloat(rect.attr('height')) || 0,\n\t      rx: parseFloat(rect.attr('rx')) || 0,\n\t      ry: parseFloat(rect.attr('ry')) || 0\n\t    });\n\t  };\n\n\t  // Convert a rectangle to SVG path commands. `r` is an object of the form:\n\t  // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n\t  // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n\t  // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n\t  // that has only `rx` and `ry` attributes).\n\t  V.rectToPath = function (r) {\n\t    var d;\n\t    var x = r.x;\n\t    var y = r.y;\n\t    var width = r.width;\n\t    var height = r.height;\n\t    var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n\t    var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n\t    var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n\t    var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\t    if (topRx || bottomRx || topRy || bottomRy) {\n\t      d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n\t    } else {\n\t      d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n\t    }\n\t    return d.join(' ');\n\t  };\n\n\t  // Take a path data string\n\t  // Return a normalized path data string\n\t  // If data cannot be parsed, return 'M 0 0'\n\t  // Highly inspired by Raphael Library (www.raphael.com)\n\t  V.normalizePathData = function () {\n\t    var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n\t    var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n\t    var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\t    var math = Math;\n\t    var PI = math.PI;\n\t    var sin = math.sin;\n\t    var cos = math.cos;\n\t    var tan = math.tan;\n\t    var asin = math.asin;\n\t    var sqrt = math.sqrt;\n\t    var abs = math.abs;\n\t    function q2c(x1, y1, ax, ay, x2, y2) {\n\t      var _13 = 1 / 3;\n\t      var _23 = 2 / 3;\n\t      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n\t    }\n\t    function rotate(x, y, rad) {\n\t      var X = x * cos(rad) - y * sin(rad);\n\t      var Y = x * sin(rad) + y * cos(rad);\n\t      return {\n\t        x: X,\n\t        y: Y\n\t      };\n\t    }\n\t    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t      // for more information of where this math came from visit:\n\t      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t      var _120 = PI * 120 / 180;\n\t      var rad = PI / 180 * (+angle || 0);\n\t      var res = [];\n\t      var xy;\n\t      if (!recursive) {\n\t        xy = rotate(x1, y1, -rad);\n\t        x1 = xy.x;\n\t        y1 = xy.y;\n\t        xy = rotate(x2, y2, -rad);\n\t        x2 = xy.x;\n\t        y2 = xy.y;\n\t        var x = (x1 - x2) / 2;\n\t        var y = (y1 - y2) / 2;\n\t        var h = x * x / (rx * rx) + y * y / (ry * ry);\n\t        if (h > 1) {\n\t          h = sqrt(h);\n\t          rx = h * rx;\n\t          ry = h * ry;\n\t        }\n\t        var rx2 = rx * rx;\n\t        var ry2 = ry * ry;\n\t        var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\t        if (!Number.isFinite(k)) {\n\t          // Arc is a single point\n\t          return [x1, y1, x2, y2, x2, y2];\n\t        }\n\t        var cx = k * rx * y / ry + (x1 + x2) / 2;\n\t        var cy = k * -ry * x / rx + (y1 + y2) / 2;\n\t        var f1 = asin(((y1 - cy) / ry).toFixed(9));\n\t        var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\t        f1 = x1 < cx ? PI - f1 : f1;\n\t        f2 = x2 < cx ? PI - f2 : f2;\n\t        if (f1 < 0) f1 = PI * 2 + f1;\n\t        if (f2 < 0) f2 = PI * 2 + f2;\n\t        if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n\t        if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n\t      } else {\n\t        f1 = recursive[0];\n\t        f2 = recursive[1];\n\t        cx = recursive[2];\n\t        cy = recursive[3];\n\t      }\n\t      var df = f2 - f1;\n\t      if (abs(df) > _120) {\n\t        var f2old = f2;\n\t        var x2old = x2;\n\t        var y2old = y2;\n\t        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t        x2 = cx + rx * cos(f2);\n\t        y2 = cy + ry * sin(f2);\n\t        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t      }\n\t      df = f2 - f1;\n\t      var c1 = cos(f1);\n\t      var s1 = sin(f1);\n\t      var c2 = cos(f2);\n\t      var s2 = sin(f2);\n\t      var t = tan(df / 4);\n\t      var hx = 4 / 3 * (rx * t);\n\t      var hy = 4 / 3 * (ry * t);\n\t      var m1 = [x1, y1];\n\t      var m2 = [x1 + hx * s1, y1 - hy * c1];\n\t      var m3 = [x2 + hx * s2, y2 - hy * c2];\n\t      var m4 = [x2, y2];\n\t      m2[0] = 2 * m1[0] - m2[0];\n\t      m2[1] = 2 * m1[1] - m2[1];\n\t      if (recursive) {\n\t        return [m2, m3, m4].concat(res);\n\t      } else {\n\t        res = [m2, m3, m4].concat(res).join().split(',');\n\t        var newres = [];\n\t        var ii = res.length;\n\t        for (var i = 0; i < ii; i++) {\n\t          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t        }\n\t        return newres;\n\t      }\n\t    }\n\t    function parsePathString(pathString) {\n\t      if (!pathString) return null;\n\t      var paramCounts = {\n\t        a: 7,\n\t        c: 6,\n\t        h: 1,\n\t        l: 2,\n\t        m: 2,\n\t        q: 4,\n\t        s: 4,\n\t        t: 2,\n\t        v: 1,\n\t        z: 0\n\t      };\n\t      var data = [];\n\t      String(pathString).replace(pathCommand, function (a, b, c) {\n\t        var params = [];\n\t        var name = b.toLowerCase();\n\t        c.replace(pathValues, function (a, b) {\n\t          if (b) params.push(+b);\n\t        });\n\t        if (name === 'm' && params.length > 2) {\n\t          data.push([b].concat(params.splice(0, 2)));\n\t          name = 'l';\n\t          b = b === 'm' ? 'l' : 'L';\n\t        }\n\t        while (params.length >= paramCounts[name]) {\n\t          data.push([b].concat(params.splice(0, paramCounts[name])));\n\t          if (!paramCounts[name]) break;\n\t        }\n\t      });\n\t      return data;\n\t    }\n\t    function pathToAbsolute(pathArray) {\n\t      if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {\n\t        // rough assumption\n\t        pathArray = parsePathString(pathArray);\n\t      }\n\n\t      // if invalid string, return 'M 0 0'\n\t      if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\t      var res = [];\n\t      var x = 0;\n\t      var y = 0;\n\t      var mx = 0;\n\t      var my = 0;\n\t      var start = 0;\n\t      var pa0;\n\t      var ii = pathArray.length;\n\t      for (var i = start; i < ii; i++) {\n\t        var r = [];\n\t        res.push(r);\n\t        var pa = pathArray[i];\n\t        pa0 = pa[0];\n\t        if (pa0 != pa0.toUpperCase()) {\n\t          r[0] = pa0.toUpperCase();\n\t          var jj;\n\t          var j;\n\t          switch (r[0]) {\n\t            case 'A':\n\t              r[1] = pa[1];\n\t              r[2] = pa[2];\n\t              r[3] = pa[3];\n\t              r[4] = pa[4];\n\t              r[5] = pa[5];\n\t              r[6] = +pa[6] + x;\n\t              r[7] = +pa[7] + y;\n\t              break;\n\t            case 'V':\n\t              r[1] = +pa[1] + y;\n\t              break;\n\t            case 'H':\n\t              r[1] = +pa[1] + x;\n\t              break;\n\t            case 'M':\n\t              mx = +pa[1] + x;\n\t              my = +pa[2] + y;\n\t              jj = pa.length;\n\t              for (j = 1; j < jj; j++) {\n\t                r[j] = +pa[j] + (j % 2 ? x : y);\n\t              }\n\t              break;\n\t            default:\n\t              jj = pa.length;\n\t              for (j = 1; j < jj; j++) {\n\t                r[j] = +pa[j] + (j % 2 ? x : y);\n\t              }\n\t              break;\n\t          }\n\t        } else {\n\t          var kk = pa.length;\n\t          for (var k = 0; k < kk; k++) {\n\t            r[k] = pa[k];\n\t          }\n\t        }\n\t        switch (r[0]) {\n\t          case 'Z':\n\t            x = +mx;\n\t            y = +my;\n\t            break;\n\t          case 'H':\n\t            x = r[1];\n\t            break;\n\t          case 'V':\n\t            y = r[1];\n\t            break;\n\t          case 'M':\n\t            mx = r[r.length - 2];\n\t            my = r[r.length - 1];\n\t            x = r[r.length - 2];\n\t            y = r[r.length - 1];\n\t            break;\n\t          default:\n\t            x = r[r.length - 2];\n\t            y = r[r.length - 1];\n\t            break;\n\t        }\n\t      }\n\t      return res;\n\t    }\n\t    function normalize(path) {\n\t      var p = pathToAbsolute(path);\n\t      var attrs = {\n\t        x: 0,\n\t        y: 0,\n\t        bx: 0,\n\t        by: 0,\n\t        X: 0,\n\t        Y: 0,\n\t        qx: null,\n\t        qy: null\n\t      };\n\t      function processPath(path, d, pcom) {\n\t        var nx, ny;\n\t        if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\t        if (!(path[0] in {\n\t          T: 1,\n\t          Q: 1\n\t        })) {\n\t          d.qx = null;\n\t          d.qy = null;\n\t        }\n\t        switch (path[0]) {\n\t          case 'M':\n\t            d.X = path[1];\n\t            d.Y = path[2];\n\t            break;\n\t          case 'A':\n\t            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n\t              // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n\t              // \"If either rx or ry is 0, then this arc is treated as a\n\t              // straight line segment (a \"lineto\") joining the endpoints.\"\n\t              path = ['L', path[6], path[7]];\n\t            } else {\n\t              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t            }\n\t            break;\n\t          case 'S':\n\t            if (pcom === 'C' || pcom === 'S') {\n\t              // In 'S' case we have to take into account, if the previous command is C/S.\n\t              nx = d.x * 2 - d.bx; // And reflect the previous\n\t              ny = d.y * 2 - d.by; // command's control point relative to the current point.\n\t            } else {\n\t              // or some else or nothing\n\t              nx = d.x;\n\t              ny = d.y;\n\t            }\n\t            path = ['C', nx, ny].concat(path.slice(1));\n\t            break;\n\t          case 'T':\n\t            if (pcom === 'Q' || pcom === 'T') {\n\t              // In 'T' case we have to take into account, if the previous command is Q/T.\n\t              d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\t              d.qy = d.y * 2 - d.qy; // to case 'S'.\n\t            } else {\n\t              // or something else or nothing\n\t              d.qx = d.x;\n\t              d.qy = d.y;\n\t            }\n\t            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t            break;\n\t          case 'Q':\n\t            d.qx = path[1];\n\t            d.qy = path[2];\n\t            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t            break;\n\t          case 'H':\n\t            path = ['L'].concat(path[1], d.y);\n\t            break;\n\t          case 'V':\n\t            path = ['L'].concat(d.x, path[1]);\n\t            break;\n\t          case 'L':\n\t            break;\n\t          case 'Z':\n\t            break;\n\t        }\n\t        return path;\n\t      }\n\t      function fixArc(pp, i) {\n\t        if (pp[i].length > 7) {\n\t          pp[i].shift();\n\t          var pi = pp[i];\n\t          while (pi.length) {\n\t            pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n\t            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n\t          }\n\t          pp.splice(i, 1);\n\t          ii = p.length;\n\t        }\n\t      }\n\t      var pcoms = []; // path commands of original path p\n\t      var pfirst = ''; // temporary holder for original path command\n\t      var pcom = ''; // holder for previous path command of original path\n\n\t      var ii = p.length;\n\t      for (var i = 0; i < ii; i++) {\n\t        if (p[i]) pfirst = p[i][0]; // save current path command\n\n\t        if (pfirst !== 'C') {\n\t          // C is not saved yet, because it may be result of conversion\n\t          pcoms[i] = pfirst; // Save current path command\n\t          if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n\t        }\n\t        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t        if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n\t        // which may produce multiple 'C's\n\t        // so we have to make sure that 'C' is also 'C' in original path\n\n\t        fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n\t        var seg = p[i];\n\t        var seglen = seg.length;\n\t        attrs.x = seg[seglen - 2];\n\t        attrs.y = seg[seglen - 1];\n\t        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n\t        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n\t      }\n\n\t      // make sure normalized path data string starts with an M segment\n\t      if (!p[0][0] || p[0][0] !== 'M') {\n\t        p.unshift(['M', 0, 0]);\n\t      }\n\t      return p;\n\t    }\n\t    return function (pathData) {\n\t      return normalize(pathData).join(',').split(',').join(' ');\n\t    };\n\t  }();\n\n\t  /**\n\t   *\n\t   * @param {SVGElement|V} node1\n\t   * @param {SVGElement|V} node2\n\t   * @returns {SVGElement|null}\n\t   */\n\t  V.getCommonAncestor = function (node1, node2) {\n\t    if (!node1 || !node2) return null;\n\t    return getCommonAncestor(V.toNode(node1), V.toNode(node2));\n\t  };\n\t  V.namespace = {\n\t    ...ns\n\t  };\n\t  V.g = g;\n\t  return V;\n\t}();\n\n\t// Manipulation\n\n\tfunction cleanNodesData(nodes) {\n\t  let i = nodes.length;\n\t  while (i--) cleanNodeData(nodes[i]);\n\t}\n\tfunction cleanNodeData(node) {\n\t  $.event.remove(node);\n\t  dataPriv.remove(node);\n\t  dataUser.remove(node);\n\t}\n\tfunction removeNodes(nodes) {\n\t  for (let i = 0; i < nodes.length; i++) {\n\t    const node = nodes[i];\n\t    if (node.parentNode) {\n\t      node.parentNode.removeChild(node);\n\t    }\n\t  }\n\t}\n\tfunction remove() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    cleanNodeData(node);\n\t    cleanNodesData(node.getElementsByTagName('*'));\n\t  }\n\t  removeNodes(this);\n\t  return this;\n\t}\n\tfunction detach() {\n\t  removeNodes(this);\n\t  return this;\n\t}\n\tfunction empty() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    if (node.nodeType === 1) {\n\t      cleanNodesData(node.getElementsByTagName('*'));\n\t      // Remove any remaining nodes\n\t      node.textContent = '';\n\t    }\n\t  }\n\t  return this;\n\t}\n\tfunction clone() {\n\t  const clones = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    clones.push(this[i].cloneNode(true));\n\t  }\n\t  return this.pushStack(clones);\n\t}\n\tfunction html(html) {\n\t  const [el] = this;\n\t  if (!el) return null;\n\t  if (arguments.length === 0) return el.innerHTML;\n\t  if (html === undefined) return this; // do nothing\n\t  cleanNodesData(el.getElementsByTagName('*'));\n\t  if (typeof html === 'string' || typeof html === 'number') {\n\t    el.innerHTML = html;\n\t  } else {\n\t    el.innerHTML = '';\n\t    return this.append(html);\n\t  }\n\t  return this;\n\t}\n\tfunction append(...nodes) {\n\t  const [parent] = this;\n\t  if (!parent) return this;\n\t  nodes.forEach(node => {\n\t    if (!node) return;\n\t    if (typeof node === 'string') {\n\t      parent.append(...$.parseHTML(node));\n\t    } else if (node.toString() === '[object Object]') {\n\t      // $ object\n\t      this.append(...Array.from(node));\n\t    } else if (Array.isArray(node)) {\n\t      this.append(...node);\n\t    } else {\n\t      // DOM node\n\t      parent.appendChild(node);\n\t    }\n\t  });\n\t  return this;\n\t}\n\tfunction prepend(...nodes) {\n\t  const [parent] = this;\n\t  if (!parent) return this;\n\t  nodes.forEach(node => {\n\t    if (!node) return;\n\t    if (typeof node === 'string') {\n\t      parent.prepend(...$.parseHTML(node));\n\t    } else if (node.toString() === '[object Object]') {\n\t      // $ object\n\t      this.prepend(...Array.from(node));\n\t    } else if (Array.isArray(node)) {\n\t      this.prepend(...node);\n\t    } else {\n\t      // DOM node\n\t      parent.insertBefore(node, parent.firstChild);\n\t    }\n\t  });\n\t  return this;\n\t}\n\tfunction appendTo(parent) {\n\t  $(parent).append(this);\n\t  return this;\n\t}\n\tfunction prependTo(parent) {\n\t  $(parent).prepend(this);\n\t  return this;\n\t}\n\n\t// Styles and attributes\n\n\tconst requireUnits = {};\n\t['width', 'height', 'top', 'bottom', 'left', 'right', 'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight'].forEach(cssProp => {\n\t  requireUnits[cssProp] = true;\n\t});\n\tfunction setCSSProperty(el, name, value) {\n\t  if (typeof value === 'number' && requireUnits[camelCase(name)]) {\n\t    value += 'px';\n\t  }\n\t  el.style[name] = value;\n\t}\n\tfunction css(name, value) {\n\t  let styles;\n\t  if (typeof name === 'string') {\n\t    if (value === undefined) {\n\t      const [el] = this;\n\t      if (!el) return null;\n\t      return el.style[name];\n\t    } else {\n\t      styles = {\n\t        [name]: value\n\t      };\n\t    }\n\t  } else if (!name) {\n\t    throw new Error('no styles provided');\n\t  } else {\n\t    styles = name;\n\t  }\n\t  for (let style in styles) {\n\t    if (styles.hasOwnProperty(style)) {\n\t      for (let i = 0; i < this.length; i++) {\n\t        setCSSProperty(this[i], style, styles[style]);\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t}\n\tfunction data(name, value) {\n\t  if (arguments.length < 2) {\n\t    const [el] = this;\n\t    if (!el) return null;\n\t    if (name === undefined) {\n\t      return el.dataset;\n\t    }\n\t    return el.dataset[name];\n\t  }\n\t  for (let i = 0; i < this.length; i++) {\n\t    this[i].dataset[name] = value;\n\t  }\n\t  return this;\n\t}\n\n\t// Classes\n\n\tfunction setNodesClass(method, nodes, args) {\n\t  for (let i = 0; i < nodes.length; i++) {\n\t    const node = nodes[i];\n\t    V.prototype[method].apply({\n\t      node\n\t    }, args);\n\t  }\n\t}\n\tfunction removeClass() {\n\t  setNodesClass('removeClass', this, arguments);\n\t  return this;\n\t}\n\tfunction addClass$1() {\n\t  setNodesClass('addClass', this, arguments);\n\t  return this;\n\t}\n\tfunction toggleClass() {\n\t  setNodesClass('toggleClass', this, arguments);\n\t  return this;\n\t}\n\tfunction hasClass() {\n\t  const [node] = this;\n\t  if (!node) return false;\n\t  return V.prototype.hasClass.apply({\n\t    node\n\t  }, arguments);\n\t}\n\n\t// Traversing\n\n\tfunction children(selector) {\n\t  const matches = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const node = this[i];\n\t    let children = Array.from(node.children);\n\t    if (typeof selector === 'string') {\n\t      children = children.filter(child => child.matches(selector));\n\t    }\n\t    matches.push(...children);\n\t  }\n\t  return this.pushStack(matches);\n\t}\n\tfunction closest(selector) {\n\t  const closest = [];\n\t  for (let i = 0; i < this.length; i++) {\n\t    const el = this[i];\n\t    if (typeof selector === 'string') {\n\t      const closestEl = el.closest(selector);\n\t      if (closestEl) {\n\t        closest.push(closestEl);\n\t      }\n\t    } else {\n\t      const [ancestorEl] = $(selector);\n\t      if (ancestorEl && ancestorEl.contains(el)) {\n\t        closest.push(ancestorEl);\n\t      }\n\t    }\n\t  }\n\t  return this.pushStack(closest);\n\t}\n\n\t// Events\n\n\tfunction on(types, selector, data, fn) {\n\t  $.event.on(this, types, selector, data, fn);\n\t  return this;\n\t}\n\tfunction one(types, selector, data, fn) {\n\t  $.event.on(this, types, selector, data, fn, 1);\n\t  return this;\n\t}\n\tfunction off(types, selector, fn) {\n\t  if (types && types.preventDefault && types.handleObj) {\n\t    // ( event )  dispatched $.Event\n\t    const handleObj = types.handleObj;\n\t    $(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t    return this;\n\t  }\n\t  if (typeof types === 'object') {\n\t    // ( types-object [, selector] )\n\t    for (let type in types) {\n\t      this.off(type, selector, types[type]);\n\t    }\n\t    return this;\n\t  }\n\t  if (selector === false || typeof selector === 'function') {\n\t    // ( types [, fn] )\n\t    fn = selector;\n\t    selector = undefined;\n\t  }\n\t  for (let i = 0; i < this.length; i++) {\n\t    $.event.remove(this[i], types, fn, selector);\n\t  }\n\t  return this;\n\t}\n\n\t// Measurements\n\n\tfunction width() {\n\t  const [el] = this;\n\t  if (el === window) return el.document.documentElement.clientWidth;else if (!el) return undefined;\n\t  const styles = window.getComputedStyle(el);\n\t  const height = el.offsetWidth;\n\t  const borderTopWidth = parseFloat(styles.borderTopWidth);\n\t  const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n\t  const paddingTop = parseFloat(styles.paddingTop);\n\t  const paddingBottom = parseFloat(styles.paddingBottom);\n\t  return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;\n\t}\n\tfunction height() {\n\t  const [el] = this;\n\t  if (el === window) return el.document.documentElement.clientHeight;\n\t  if (!el) return undefined;\n\t  const styles = window.getComputedStyle(el);\n\t  const width = el.offsetHeight;\n\t  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\t  const borderRightWidth = parseFloat(styles.borderRightWidth);\n\t  const paddingLeft = parseFloat(styles.paddingLeft);\n\t  const paddingRight = parseFloat(styles.paddingRight);\n\t  return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;\n\t}\n\tfunction position() {\n\t  const [el] = this;\n\t  if (!el) return;\n\t  let $el = $(el);\n\t  let offsetParent;\n\t  let offset;\n\t  let doc;\n\t  let parentOffset = {\n\t    top: 0,\n\t    left: 0\n\t  };\n\t  // position:fixed elements are offset from the viewport, which itself always has zero offset\n\t  if ($el.css('position') === 'fixed') {\n\t    // Assume position:fixed implies availability of getBoundingClientRect\n\t    offset = el.getBoundingClientRect();\n\t  } else {\n\t    offset = $el.offset();\n\t    // Account for the *real* offset parent, which can be the document or its root element\n\t    // when a statically positioned element is identified\n\t    doc = el.ownerDocument;\n\t    offsetParent = el.offsetParent || doc.documentElement;\n\t    const isStaticallyPositioned = el => {\n\t      const {\n\t        position\n\t      } = getComputedStyle(el);\n\t      return position === 'static';\n\t    };\n\t    while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {\n\t      offsetParent = offsetParent.offsetParent || doc.documentElement;\n\t    }\n\t    if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {\n\t      // Incorporate borders into its offset, since they are outside its content origin\n\t      const offsetParentStyles = window.getComputedStyle(offsetParent);\n\t      const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;\n\t      const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;\n\t      parentOffset = $(offsetParent).offset();\n\t      parentOffset.top += borderTopWidth;\n\t      parentOffset.left += borderLeftWidth;\n\t    }\n\t  }\n\t  const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;\n\t  const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;\n\t  // Subtract parent offsets and element margins\n\t  return {\n\t    top: offset.top - parentOffset.top - marginTop,\n\t    left: offset.left - parentOffset.left - marginLeft\n\t  };\n\t}\n\tfunction offset(coordinates) {\n\t  const [el] = this;\n\t  //  Getter\n\t  if (coordinates === undefined) {\n\t    if (!el) return null;\n\t    if (!el.getClientRects().length) {\n\t      return {\n\t        top: 0,\n\t        left: 0\n\t      };\n\t    }\n\t    const rect = el.getBoundingClientRect();\n\t    return {\n\t      top: rect.top + window.scrollY,\n\t      left: rect.left + window.scrollX\n\t    };\n\t  }\n\t  // Setter\n\t  if (!el) return this;\n\t  const currentStyle = window.getComputedStyle(el);\n\t  if (currentStyle.position === 'static') {\n\t    this.css('position', 'relative');\n\t  }\n\t  const currentOffset = this.offset();\n\t  const topDifference = coordinates.top - currentOffset.top;\n\t  const leftDifference = coordinates.left - currentOffset.left;\n\t  this.css({\n\t    top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',\n\t    left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'\n\t  });\n\t  return this;\n\t}\n\n\tvar methods$1 = {\n\t\t__proto__: null,\n\t\taddClass: addClass$1,\n\t\tappend: append,\n\t\tappendTo: appendTo,\n\t\tchildren: children,\n\t\tclone: clone,\n\t\tclosest: closest,\n\t\tcss: css,\n\t\tdata: data,\n\t\tdetach: detach,\n\t\tempty: empty,\n\t\thasClass: hasClass,\n\t\theight: height,\n\t\thtml: html,\n\t\toff: off,\n\t\toffset: offset,\n\t\ton: on,\n\t\tone: one,\n\t\tposition: position,\n\t\tprepend: prepend,\n\t\tprependTo: prependTo,\n\t\tremove: remove,\n\t\tremoveClass: removeClass,\n\t\ttoggleClass: toggleClass,\n\t\twidth: width\n\t};\n\n\tconst animationKey = 'animationFrameId';\n\tconst cssReset = {};\n\tcssReset['transition-property'] = cssReset['transition-duration'] = cssReset['transition-delay'] = cssReset['transition-timing-function'] = cssReset['animation-name'] = cssReset['animation-duration'] = cssReset['animation-delay'] = cssReset['animation-timing-function'] = '';\n\tfunction animate(properties, opt = {}) {\n\t  this.stop();\n\t  for (let i = 0; i < this.length; i++) {\n\t    animateNode(this[i], properties, opt);\n\t  }\n\t  return this;\n\t}\n\tfunction animateNode(el, properties, opt = {}) {\n\t  let {\n\t    duration = 400,\n\t    easing = 'ease-in-out',\n\t    delay = 0,\n\t    complete\n\t  } = opt;\n\t  const delayId = setTimeout(function () {\n\t    const $el = $(el);\n\t    let fired = false;\n\t    let endEvent = 'transitionend';\n\n\t    // Convert milliseconds to seconds for CSS\n\t    duration = duration / 1000;\n\t    delay = delay / 1000;\n\n\t    // Set up CSS values for transition or keyframe animation\n\t    const cssValues = {};\n\t    if (typeof properties === 'string') {\n\t      // Keyframe animation\n\t      cssValues['animation-name'] = properties;\n\t      cssValues['animation-duration'] = duration + 's';\n\t      cssValues['animation-delay'] = delay + 's';\n\t      cssValues['animation-timing-function'] = easing;\n\t      endEvent = 'animationend';\n\t    } else {\n\t      // CSS transitions\n\t      const transitionProperties = [];\n\t      for (var key in properties) {\n\t        if (properties.hasOwnProperty(key)) {\n\t          cssValues[key] = properties[key];\n\t          transitionProperties.push(key);\n\t        }\n\t      }\n\t      if (duration > 0) {\n\t        cssValues['transition-property'] = transitionProperties.join(', ');\n\t        cssValues['transition-duration'] = duration + 's';\n\t        cssValues['transition-delay'] = delay + 's';\n\t        cssValues['transition-timing-function'] = easing;\n\t      }\n\t    }\n\t    const wrappedCallback = function (event) {\n\t      if (event) {\n\t        if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n\t        event.target.removeEventListener(endEvent, wrappedCallback);\n\t      } else {\n\t        el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout\n\t      }\n\t      fired = true;\n\t      $el.css(cssReset);\n\t      complete && complete.call(el);\n\t    };\n\t    if (duration > 0) {\n\t      el.addEventListener(endEvent, wrappedCallback);\n\t      // transitionEnd is not always firing on older Android phones\n\t      // so make sure it gets fired\n\t      const callbackId = setTimeout(function () {\n\t        if (fired) return;\n\t        wrappedCallback(null);\n\t      }, (duration + delay) * 1000 + 25);\n\t      dataPriv.set(el, animationKey, {\n\t        id: callbackId,\n\t        stop: () => {\n\t          clearTimeout(callbackId);\n\t          el.removeEventListener(endEvent, wrappedCallback);\n\t        }\n\t      });\n\t    }\n\t    $el.css(cssValues);\n\t    if (duration <= 0) {\n\t      wrappedCallback(null);\n\t    }\n\t  });\n\t  dataPriv.set(el, animationKey, {\n\t    stop: () => clearTimeout(delayId)\n\t  });\n\t}\n\tfunction stop() {\n\t  for (let i = 0; i < this.length; i++) {\n\t    const el = this[i];\n\t    const animation = dataPriv.get(el, animationKey);\n\t    if (!animation) continue;\n\t    animation.stop();\n\t    dataPriv.remove(el, animationKey);\n\t  }\n\t  this.css(cssReset);\n\t  return this;\n\t}\n\n\tvar animations = {\n\t\t__proto__: null,\n\t\tanimate: animate,\n\t\tstop: stop\n\t};\n\n\tconst propertySetters = {\n\t  outerWidth: 'offsetWidth',\n\t  outerHeight: 'offsetHeight',\n\t  innerWidth: 'clientWidth',\n\t  innerHeight: 'clientHeight',\n\t  scrollLeft: 'scrollLeft',\n\t  scrollTop: 'scrollTop',\n\t  val: 'value',\n\t  text: 'textContent'\n\t};\n\tconst propertiesMap = {\n\t  disabled: 'disabled',\n\t  value: 'value',\n\t  text: 'textContent'\n\t};\n\tfunction prop(name, value) {\n\t  if (!name) throw new Error('no property provided');\n\t  if (arguments.length === 1) {\n\t    const [el] = this;\n\t    if (!el) return null;\n\t    return el[name];\n\t  }\n\t  if (value === undefined) return this;\n\t  for (let i = 0; i < this.length; i++) {\n\t    this[i][name] = value;\n\t  }\n\t  return this;\n\t}\n\tfunction attr(name, value) {\n\t  let attributes;\n\t  if (typeof name === 'string') {\n\t    if (value === undefined) {\n\t      const [el] = this;\n\t      if (!el) return null;\n\t      return el.getAttribute(name);\n\t    } else {\n\t      attributes = {\n\t        [name]: value\n\t      };\n\t    }\n\t  } else if (!name) {\n\t    throw new Error('no attributes provided');\n\t  } else {\n\t    attributes = name;\n\t  }\n\t  for (let attr in attributes) {\n\t    if (attributes.hasOwnProperty(attr)) {\n\t      const value = attributes[attr];\n\t      if (propertiesMap[attr]) {\n\t        this.prop(propertiesMap[attr], value);\n\t        continue;\n\t      }\n\t      for (let i = 0; i < this.length; i++) {\n\t        if (value === null) {\n\t          this[i].removeAttribute(attr);\n\t        } else {\n\t          this[i].setAttribute(attr, value);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t}\n\tconst methods = {\n\t  prop,\n\t  attr\n\t};\n\tObject.keys(propertySetters).forEach(methodName => {\n\t  methods[methodName] = function (...args) {\n\t    return this.prop(propertySetters[methodName], ...args);\n\t  };\n\t});\n\n\tconst config$3 = {\n\t  // How the cell attributes are merged when `cell.prop()` is called.\n\t  // DEFAULT: the arrays are merged into the source array.\n\t  cellMergeStrategy: null,\n\t  // How the cell default attributes are merged with the attributes provided\n\t  // in the cell constructor.\n\t  // DEFAULT: the arrays are merged by replacing the source array\n\t  // with the destination array.\n\t  cellDefaultsMergeStrategy: null,\n\t  // When set to `true` the cell selectors could be defined as CSS selectors.\n\t  // If not, only JSON Markup selectors are taken into account.\n\t  useCSSSelectors: false,\n\t  // The class name prefix config is for advanced use only.\n\t  // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n\t  classNamePrefix: 'joint-',\n\t  defaultTheme: 'default',\n\t  // The maximum delay required for two consecutive touchend events to be interpreted\n\t  // as a double-tap.\n\t  doubleTapInterval: 300,\n\t  // Name of the attribute used to store the layer id on the cell model.\n\t  layerAttribute: 'layer'\n\t};\n\n\t// TODO: should not read config outside the mvc package\n\n\t// Special events\n\n\tconst special = Object.create(null);\n\tspecial.load = {\n\t  // Prevent triggered image.load events from bubbling to window.load\n\t  noBubble: true\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in $.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t[['mouseenter', 'mouseover'], ['mouseleave', 'mouseout'], ['pointerenter', 'pointerover'], ['pointerleave', 'pointerout']].forEach(([orig, fix]) => {\n\t  special[orig] = {\n\t    delegateType: fix,\n\t    bindType: fix,\n\t    handle: function (event) {\n\t      const target = this;\n\t      const related = event.relatedTarget;\n\t      const handleObj = event.handleObj;\n\t      let ret;\n\t      // For mouseenter/leave call the handler if related is outside the target.\n\t      // NB: No relatedTarget if the mouse left/entered the browser window\n\t      if (!related || !target.contains(related)) {\n\t        event.type = handleObj.origType;\n\t        ret = handleObj.handler.apply(target, arguments);\n\t        event.type = fix;\n\t      }\n\t      return ret;\n\t    }\n\t  };\n\t});\n\n\t// Gestures\n\n\tconst maxDelay = config$3.doubleTapInterval;\n\tconst minDelay = 30;\n\tspecial.dbltap = {\n\t  bindType: 'touchend',\n\t  delegateType: 'touchend',\n\t  handle: function (event, ...args) {\n\t    const {\n\t      handleObj,\n\t      target\n\t    } = event;\n\t    const targetData = $.data.create(target);\n\t    const now = new Date().getTime();\n\t    const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n\t    if (delta < maxDelay && delta > minDelay) {\n\t      targetData.lastTouch = null;\n\t      event.type = handleObj.origType;\n\t      // let $ handle the triggering of \"dbltap\" event handlers\n\t      handleObj.handler.call(this, event, ...args);\n\t    } else {\n\t      targetData.lastTouch = now;\n\t    }\n\t  }\n\t};\n\n\tObject.assign($.fn, methods$1);\n\tObject.assign($.fn, animations);\n\tObject.assign($.fn, methods);\n\tObject.assign($.event.special, special);\n\n\tconst addClassNamePrefix = function (className) {\n\t  if (!className) return className;\n\t  return className.toString().split(' ').map(function (_className) {\n\t    if (_className.substr(0, config$3.classNamePrefix.length) !== config$3.classNamePrefix) {\n\t      _className = config$3.classNamePrefix + _className;\n\t    }\n\t    return _className;\n\t  }).join(' ');\n\t};\n\tconst removeClassNamePrefix = function (className) {\n\t  if (!className) return className;\n\t  return className.toString().split(' ').map(function (_className) {\n\t    if (_className.substr(0, config$3.classNamePrefix.length) === config$3.classNamePrefix) {\n\t      _className = _className.substr(config$3.classNamePrefix.length);\n\t    }\n\t    return _className;\n\t  }).join(' ');\n\t};\n\tconst parseDOMJSON = function (json, namespace) {\n\t  const selectors = {};\n\t  const groupSelectors = {};\n\t  const svgNamespace = V.namespace.svg;\n\t  const initialNS = namespace || svgNamespace;\n\t  const fragment = document.createDocumentFragment();\n\t  const parseNode = function (siblingsDef, parentNode, parentNS) {\n\t    for (let i = 0; i < siblingsDef.length; i++) {\n\t      const nodeDef = siblingsDef[i];\n\n\t      // Text node\n\t      if (typeof nodeDef === 'string') {\n\t        const textNode = document.createTextNode(nodeDef);\n\t        parentNode.appendChild(textNode);\n\t        continue;\n\t      }\n\n\t      // TagName\n\t      if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n\t      const tagName = nodeDef.tagName;\n\t      let node;\n\n\t      // Namespace URI\n\t      const ns = nodeDef.hasOwnProperty('namespaceURI') ? nodeDef.namespaceURI : parentNS;\n\t      node = document.createElementNS(ns, tagName);\n\t      const svg = ns === svgNamespace;\n\t      const wrapperNode = svg ? V(node) : $(node);\n\t      // Attributes\n\t      const attributes = nodeDef.attributes;\n\t      if (attributes) wrapperNode.attr(attributes);\n\t      // Style\n\t      const style = nodeDef.style;\n\t      if (style) $(node).css(style);\n\t      // ClassName\n\t      if (nodeDef.hasOwnProperty('className')) {\n\t        const className = nodeDef.className;\n\t        if (svg) {\n\t          node.className.baseVal = className;\n\t        } else {\n\t          node.className = className;\n\t        }\n\t      }\n\t      // TextContent\n\t      if (nodeDef.hasOwnProperty('textContent')) {\n\t        node.textContent = nodeDef.textContent;\n\t      }\n\t      // Selector\n\t      if (nodeDef.hasOwnProperty('selector')) {\n\t        const nodeSelector = nodeDef.selector;\n\t        if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n\t        selectors[nodeSelector] = node;\n\t        wrapperNode.attr('joint-selector', nodeSelector);\n\t      }\n\t      // Groups\n\t      if (nodeDef.hasOwnProperty('groupSelector')) {\n\t        let nodeGroups = nodeDef.groupSelector;\n\t        if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n\t        for (let j = 0; j < nodeGroups.length; j++) {\n\t          const nodeGroup = nodeGroups[j];\n\t          let group = groupSelectors[nodeGroup];\n\t          if (!group) group = groupSelectors[nodeGroup] = [];\n\t          group.push(node);\n\t        }\n\t      }\n\t      parentNode.appendChild(node);\n\n\t      // Children\n\t      const childrenDef = nodeDef.children;\n\t      if (Array.isArray(childrenDef)) {\n\t        parseNode(childrenDef, node, ns);\n\t      }\n\t    }\n\t  };\n\t  parseNode(json, fragment, initialNS);\n\t  return {\n\t    fragment: fragment,\n\t    selectors: selectors,\n\t    groupSelectors: groupSelectors\n\t  };\n\t};\n\n\t// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\n\tconst hashCode = function (str) {\n\t  let hash = 0;\n\t  if (str.length === 0) return hash;\n\t  for (let i = 0; i < str.length; i++) {\n\t    const c = str.charCodeAt(i);\n\t    hash = (hash << 5) - hash + c;\n\t    hash = hash & hash; // Convert to 32bit integer\n\t  }\n\t  return hash;\n\t};\n\tconst getByPath = function (obj, path, delimiter) {\n\t  var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  var key;\n\t  var i = 0;\n\t  var length = keys.length;\n\t  while (i < length) {\n\t    key = keys[i++];\n\t    if (Object(obj) === obj && key in obj) {\n\t      obj = obj[key];\n\t    } else {\n\t      return undefined;\n\t    }\n\t  }\n\t  return obj;\n\t};\n\tconst isGetSafe = function (obj, key) {\n\t  // Prevent prototype pollution\n\t  // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n\t  if (typeof key !== 'string' && typeof key !== 'number') {\n\t    key = String(key);\n\t  }\n\t  if (key === 'constructor' && typeof obj[key] === 'function') {\n\t    return false;\n\t  }\n\t  if (key === '__proto__') {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tconst setByPath = function (obj, path, value, delimiter) {\n\t  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  const last = keys.length - 1;\n\t  let diver = obj;\n\t  let i = 0;\n\t  for (; i < last; i++) {\n\t    const key = keys[i];\n\t    if (!isGetSafe(diver, key)) return obj;\n\t    const value = diver[key];\n\t    // diver creates an empty object if there is no nested object under such a key.\n\t    // This means that one can populate an empty nested object with setByPath().\n\t    diver = value || (diver[key] = {});\n\t  }\n\t  diver[keys[last]] = value;\n\t  return obj;\n\t};\n\tconst unsetByPath = function (obj, path, delimiter) {\n\t  const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t  const last = keys.length - 1;\n\t  let diver = obj;\n\t  let i = 0;\n\t  for (; i < last; i++) {\n\t    const key = keys[i];\n\t    if (!isGetSafe(diver, key)) return obj;\n\t    const value = diver[key];\n\t    if (!value) return obj;\n\t    diver = value;\n\t  }\n\t  delete diver[keys[last]];\n\t  return obj;\n\t};\n\tconst flattenObject = function (obj, delim, stop) {\n\t  delim = delim || '/';\n\t  var ret = {};\n\t  for (var key in obj) {\n\t    if (!obj.hasOwnProperty(key)) continue;\n\t    var shouldGoDeeper = typeof obj[key] === 'object';\n\t    if (shouldGoDeeper && stop && stop(obj[key])) {\n\t      shouldGoDeeper = false;\n\t    }\n\t    if (shouldGoDeeper) {\n\t      var flatObject = flattenObject(obj[key], delim, stop);\n\t      for (var flatKey in flatObject) {\n\t        if (!flatObject.hasOwnProperty(flatKey)) continue;\n\t        ret[key + delim + flatKey] = flatObject[flatKey];\n\t      }\n\t    } else {\n\t      ret[key] = obj[key];\n\t    }\n\t  }\n\t  return ret;\n\t};\n\tconst uuid = function () {\n\t  // credit: http://stackoverflow.com/posts/2117523/revisions\n\n\t  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t};\n\n\t// Generates global unique id and stores it as a property of the object, if provided.\n\tconst guid = function (obj) {\n\t  guid.id = guid.id || 1;\n\t  if (obj === undefined) {\n\t    return 'j_' + guid.id++;\n\t  }\n\t  obj.id = obj.id === undefined ? 'j_' + guid.id++ : obj.id;\n\t  return obj.id;\n\t};\n\tconst toKebabCase = function (string) {\n\t  return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t};\n\tconst normalizeEvent = function (evt) {\n\t  if (evt.normalized) return evt;\n\t  const {\n\t    originalEvent,\n\t    target\n\t  } = evt;\n\n\t  // If the event is a touch event, normalize it to a mouse event.\n\t  const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n\t  if (touch) {\n\t    for (let property in touch) {\n\t      // copy all the properties from the first touch that are not\n\t      // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n\t      if (evt[property] === undefined) {\n\t        evt[property] = touch[property];\n\t      }\n\t    }\n\t  }\n\t  // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n\t  if (target) {\n\t    const useElement = target.correspondingUseElement;\n\t    if (useElement) evt.target = useElement;\n\t  }\n\t  evt.normalized = true;\n\t  return evt;\n\t};\n\tconst normalizeWheel = function (evt) {\n\t  // Sane values derived empirically\n\t  const PIXEL_STEP = 10;\n\t  const LINE_HEIGHT = 40;\n\t  const PAGE_HEIGHT = 800;\n\t  let sX = 0,\n\t    sY = 0,\n\t    pX = 0,\n\t    pY = 0;\n\n\t  // Legacy\n\t  if ('detail' in evt) {\n\t    sY = evt.detail;\n\t  }\n\t  if ('wheelDelta' in evt) {\n\t    sY = -evt.wheelDelta / 120;\n\t  }\n\t  if ('wheelDeltaY' in evt) {\n\t    sY = -evt.wheelDeltaY / 120;\n\t  }\n\t  if ('wheelDeltaX' in evt) {\n\t    sX = -evt.wheelDeltaX / 120;\n\t  }\n\n\t  // side scrolling on FF with DOMMouseScroll\n\t  if ('axis' in evt && evt.axis === evt.HORIZONTAL_AXIS) {\n\t    sX = sY;\n\t    sY = 0;\n\t  }\n\t  pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n\t  pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\t  if ((pX || pY) && evt.deltaMode) {\n\t    if (evt.deltaMode == 1) {\n\t      pX *= LINE_HEIGHT;\n\t      pY *= LINE_HEIGHT;\n\t    } else {\n\t      pX *= PAGE_HEIGHT;\n\t      pY *= PAGE_HEIGHT;\n\t    }\n\t  }\n\n\t  // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n\t  if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n\t    pX = pY;\n\t    pY = 0;\n\t    sX = sY;\n\t    sY = 0;\n\t  }\n\n\t  // Fall-back if spin cannot be determined\n\t  if (pX && !sX) {\n\t    sX = pX < 1 ? -1 : 1;\n\t  }\n\t  if (pY && !sY) {\n\t    sY = pY < 1 ? -1 : 1;\n\t  }\n\t  return {\n\t    spinX: sX,\n\t    spinY: sY,\n\t    deltaX: pX,\n\t    deltaY: pY\n\t  };\n\t};\n\tconst cap = function (val, max) {\n\t  return val > max ? max : val < -max ? -max : val;\n\t};\n\tconst nextFrame = function () {\n\t  var raf;\n\t  if (typeof window !== 'undefined') {\n\t    raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t  }\n\t  if (!raf) {\n\t    var lastTime = 0;\n\t    raf = function (callback) {\n\t      var currTime = new Date().getTime();\n\t      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t      var id = setTimeout(function () {\n\t        callback(currTime + timeToCall);\n\t      }, timeToCall);\n\t      lastTime = currTime + timeToCall;\n\t      return id;\n\t    };\n\t  }\n\t  return function (callback, context, ...rest) {\n\t    return context !== undefined ? raf(callback.bind(context, ...rest)) : raf(callback);\n\t  };\n\t}();\n\tconst cancelFrame = function () {\n\t  var caf;\n\t  var client = typeof window != 'undefined';\n\t  if (client) {\n\t    caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;\n\t  }\n\t  caf = caf || clearTimeout;\n\t  return client ? caf.bind(window) : caf;\n\t}();\n\tconst isPercentage = function (val) {\n\t  return isString(val) && val.slice(-1) === '%';\n\t};\n\tconst parseCssNumeric = function (val, restrictUnits) {\n\t  function getUnit(validUnitExp) {\n\t    // one or more numbers, followed by\n\t    // any number of (\n\t    //  `.`, followed by\n\t    //  one or more numbers\n\t    // ), followed by\n\t    // `validUnitExp`, followed by\n\t    // end of string\n\t    var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\t    if (!matches) return null;\n\t    return matches[1];\n\t  }\n\t  var number = parseFloat(val);\n\n\t  // if `val` cannot be parsed as a number, return `null`\n\t  if (Number.isNaN(number)) return null;\n\n\t  // else: we know `output.value`\n\t  var output = {};\n\t  output.value = number;\n\n\t  // determine the unit\n\t  var validUnitExp;\n\t  if (restrictUnits == null) {\n\t    // no restriction\n\t    // accept any unit, as well as no unit\n\t    validUnitExp = '[A-Za-z]*';\n\t  } else if (Array.isArray(restrictUnits)) {\n\t    // if this is an empty array, top restriction - return `null`\n\t    if (restrictUnits.length === 0) return null;\n\n\t    // else: restriction - an array of valid unit strings\n\t    validUnitExp = restrictUnits.join('|');\n\t  } else if (isString(restrictUnits)) {\n\t    // restriction - a single valid unit string\n\t    validUnitExp = restrictUnits;\n\t  }\n\t  var unit = getUnit(validUnitExp);\n\n\t  // if we found no matches for `restrictUnits`, return `null`\n\t  if (unit === null) return null;\n\n\t  // else: we know the unit\n\t  output.unit = unit;\n\t  return output;\n\t};\n\tconst NO_SPACE = 0;\n\tfunction splitWordWithEOL(word, eol) {\n\t  const eolWords = word.split(eol);\n\t  let n = 1;\n\t  for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {\n\t    const replacement = [];\n\t    if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);\n\t    replacement.push(eol);\n\t    if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);\n\t    eolWords.splice(n, 0, ...replacement);\n\t    n += replacement.length + 1;\n\t  }\n\t  return eolWords.filter(word => word !== '');\n\t}\n\tfunction getLineHeight(heightValue, textElement) {\n\t  if (heightValue === null) {\n\t    // Default 1em lineHeight\n\t    return textElement.getBBox().height;\n\t  }\n\t  switch (heightValue.unit) {\n\t    case 'em':\n\t      return textElement.getBBox().height * heightValue.value;\n\t    case 'px':\n\t    case '':\n\t      return heightValue.value;\n\t  }\n\t}\n\tconst breakText = function (text, size, styles = {}, opt = {}) {\n\t  var width = size.width;\n\t  var height = size.height;\n\t  var svgDocument = opt.svgDocument || V('svg').node;\n\t  var textSpan = V('tspan').node;\n\t  var textElement = V('text').attr(styles).append(textSpan).node;\n\t  var textNode = document.createTextNode('');\n\n\t  // Prevent flickering\n\t  textElement.style.opacity = 0;\n\t  // Prevent FF from throwing an uncaught exception when `getBBox()`\n\t  // called on element that is not in the render tree (is not measurable).\n\t  // <tspan>.getComputedTextLength() returns always 0 in this case.\n\t  // Note that the `textElement` resp. `textSpan` can become hidden\n\t  // when it's appended to the DOM and a `display: none` CSS stylesheet\n\t  // rule gets applied.\n\t  textElement.style.display = 'block';\n\t  textSpan.style.display = 'block';\n\t  textSpan.appendChild(textNode);\n\t  svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n\t  if (!opt.svgDocument) {\n\t    document.body.appendChild(svgDocument);\n\t  }\n\t  const preserveSpaces = opt.preserveSpaces;\n\t  const space = ' ';\n\t  const separator = opt.separator || opt.separator === '' ? opt.separator : space;\n\t  // If separator is a RegExp, we use the space character to join words together again (not ideal)\n\t  const separatorChar = typeof separator === 'string' ? separator : space;\n\t  var eol = opt.eol || '\\n';\n\t  var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n\t  var maxLineCount = opt.maxLineCount;\n\t  if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n\t  var words = text.split(separator);\n\t  var full = [];\n\t  var lines = [];\n\t  var p, h;\n\t  var lineHeight;\n\t  if (preserveSpaces) {\n\t    V(textSpan).attr('xml:space', 'preserve');\n\t  }\n\t  for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\t    var word = words[i];\n\t    if (!word && !preserveSpaces) continue;\n\t    if (typeof word !== 'string') continue;\n\t    var isEol = false;\n\t    if (eol && word.indexOf(eol) >= 0) {\n\t      // word contains end-of-line character\n\t      if (word.length > 1) {\n\t        // separate word and continue cycle\n\t        const eolWords = splitWordWithEOL(words[i], eol);\n\t        words.splice(i, 1, ...eolWords);\n\t        i--;\n\t        len = words.length;\n\t        continue;\n\t      } else {\n\t        // creates a new line\n\t        if (preserveSpaces && typeof words[i - 1] === 'string') {\n\t          words.splice(i, NO_SPACE, '', NO_SPACE);\n\t          len += 2;\n\t          i--;\n\t          continue;\n\t        }\n\t        lines[++l] = !preserveSpaces || typeof words[i + 1] === 'string' ? '' : undefined;\n\t        isEol = true;\n\t      }\n\t    }\n\t    if (!isEol) {\n\t      let data;\n\t      if (preserveSpaces) {\n\t        data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n\t      } else {\n\t        data = lines[l] ? lines[l] + separatorChar + word : word;\n\t      }\n\t      textNode.data = data;\n\t      if (textSpan.getComputedTextLength() <= width) {\n\t        // the current line fits\n\t        lines[l] = data;\n\t        if (p || h) {\n\t          // We were partitioning. Put rest of the word onto next line\n\t          full[l++] = true;\n\n\t          // cancel partitioning and splitting by hyphens\n\t          p = 0;\n\t          h = 0;\n\t        }\n\t      } else {\n\t        if (!lines[l] || p) {\n\t          var partition = !!p;\n\t          p = word.length - 1;\n\t          if (partition || !p) {\n\t            // word has only one character.\n\t            if (!p) {\n\t              if (!lines[l]) {\n\t                // we won't fit this text within our rect\n\t                lines = [];\n\t                break;\n\t              }\n\n\t              // partitioning didn't help on the non-empty line\n\t              // try again, but this time start with a new line\n\n\t              // cancel partitions created\n\t              words.splice(i, 2, word + words[i + 1]);\n\n\t              // adjust word length\n\t              len--;\n\t              full[l++] = true;\n\t              i--;\n\t              continue;\n\t            }\n\n\t            // move last letter to the beginning of the next word\n\t            words[i] = word.substring(0, p);\n\t            const nextWord = words[i + 1];\n\t            words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);\n\t          } else {\n\t            if (h) {\n\t              // cancel splitting and put the words together again\n\t              words.splice(i, 2, words[i] + words[i + 1]);\n\t              h = 0;\n\t            } else {\n\t              var hyphenIndex = word.search(hyphen);\n\t              if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n\t                h = hyphenIndex + 1;\n\t                p = 0;\n\t              }\n\n\t              // We initiate partitioning or splitting\n\t              // split the long word into two words\n\t              words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));\n\t              // adjust words length\n\t              len++;\n\t            }\n\t            if (l && !full[l - 1]) {\n\t              // if the previous line is not full, try to fit max part of\n\t              // the current word there\n\t              l--;\n\t            }\n\t          }\n\t          if (!preserveSpaces || lines[l] !== '') {\n\t            i--;\n\t          }\n\t          continue;\n\t        }\n\t        l++;\n\t        i--;\n\t      }\n\t    }\n\t    var lastL = null;\n\t    if (lines.length > maxLineCount) {\n\t      lastL = maxLineCount - 1;\n\t    } else if (height !== undefined) {\n\t      // if size.height is defined we have to check whether the height of the entire\n\t      // text exceeds the rect height\n\n\t      if (lineHeight === undefined && textNode.data !== '') {\n\t        // use the same defaults as in V.prototype.text\n\t        if (styles.lineHeight === 'auto') {\n\t          lineHeight = getLineHeight({\n\t            value: 1.5,\n\t            unit: 'em'\n\t          }, textElement);\n\t        } else {\n\t          const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\t          lineHeight = getLineHeight(parsed, textElement);\n\t        }\n\t      }\n\t      if (lineHeight * lines.length > height) {\n\t        // remove overflowing lines\n\t        lastL = Math.floor(height / lineHeight) - 1;\n\t      }\n\t    }\n\t    if (lastL !== null) {\n\t      lines.splice(lastL + 1);\n\n\t      // add ellipsis\n\t      var ellipsis = opt.ellipsis;\n\t      if (!ellipsis || lastL < 0) break;\n\t      if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\t      var lastLine = lines[lastL];\n\t      if (!lastLine && !isEol) break;\n\t      var k = lastLine.length;\n\t      var lastLineWithOmission, lastChar;\n\t      do {\n\t        lastChar = lastLine[k];\n\t        lastLineWithOmission = lastLine.substring(0, k);\n\t        if (!lastChar) {\n\t          lastLineWithOmission += separatorChar;\n\t        } else if (lastChar.match(separator)) {\n\t          lastLineWithOmission += lastChar;\n\t        }\n\t        lastLineWithOmission += ellipsis;\n\t        textNode.data = lastLineWithOmission;\n\t        if (textSpan.getComputedTextLength() <= width) {\n\t          lines[lastL] = lastLineWithOmission;\n\t          break;\n\t        }\n\t        k--;\n\t      } while (k >= 0);\n\t      break;\n\t    }\n\t  }\n\t  if (opt.svgDocument) {\n\t    // svg document was provided, remove the text element only\n\t    svgDocument.removeChild(textElement);\n\t  } else {\n\t    // clean svg document\n\t    document.body.removeChild(svgDocument);\n\t  }\n\t  return lines.join(eol);\n\t};\n\n\t// Sanitize HTML\n\t// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n\t// Parses a string into an array of DOM nodes.\n\t// Then outputs it back as a string.\n\tconst sanitizeHTML = function (html) {\n\t  // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\t  const [outputEl] = $.parseHTML('<div>' + html + '</div>');\n\t  Array.from(outputEl.getElementsByTagName('*')).forEach(function (node) {\n\t    // for all nodes\n\t    const names = node.getAttributeNames();\n\t    names.forEach(function (name) {\n\t      const value = node.getAttribute(name);\n\t      // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n\t      // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n\t      if (name.startsWith('on') || value.startsWith('javascript:') || value.startsWith('data:') || value.startsWith('vbscript:')) {\n\t        node.removeAttribute(name);\n\t      }\n\t    });\n\t  });\n\t  return outputEl.innerHTML;\n\t};\n\n\t// Download `blob` as file with `fileName`.\n\t// Does not work in IE9.\n\tconst downloadBlob = function (blob, fileName) {\n\t  if (window.navigator.msSaveBlob) {\n\t    // requires IE 10+\n\t    // pulls up a save dialog\n\t    window.navigator.msSaveBlob(blob, fileName);\n\t  } else {\n\t    // other browsers\n\t    // downloads directly in Chrome and Safari\n\n\t    // presents a save/open dialog in Firefox\n\t    // Firefox bug: `from` field in save dialog always shows `from:blob:`\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n\t    var url = window.URL.createObjectURL(blob);\n\t    var link = document.createElement('a');\n\t    link.href = url;\n\t    link.download = fileName;\n\t    document.body.appendChild(link);\n\t    link.click();\n\t    document.body.removeChild(link);\n\t    window.URL.revokeObjectURL(url); // mark the url for garbage collection\n\t  }\n\t};\n\n\t// Download `dataUri` as file with `fileName`.\n\t// Does not work in IE9.\n\tconst downloadDataUri = function (dataUri, fileName) {\n\t  const blob = dataUriToBlob(dataUri);\n\t  downloadBlob(blob, fileName);\n\t};\n\n\t// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\n\tconst dataUriToBlob = function (dataUri) {\n\t  // first, make sure there are no newlines in the data uri\n\t  dataUri = dataUri.replace(/\\s/g, '');\n\t  dataUri = decodeURIComponent(dataUri);\n\t  var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n\t  var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n\t  var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n\t  var data = dataUri.slice(firstCommaIndex + 1);\n\t  var decodedString;\n\t  if (dataTypeString.indexOf('base64') >= 0) {\n\t    // data may be encoded in base64\n\t    decodedString = atob(data); // decode data\n\t  } else {\n\t    // convert the decoded string to UTF-8\n\t    decodedString = unescape(encodeURIComponent(data));\n\t  }\n\t  // write the bytes of the string to a typed array\n\t  var ia = new Uint8Array(decodedString.length);\n\t  for (var i = 0; i < decodedString.length; i++) {\n\t    ia[i] = decodedString.charCodeAt(i);\n\t  }\n\t  return new Blob([ia], {\n\t    type: mimeString\n\t  }); // return the typed array as Blob\n\t};\n\n\t// Read an image at `url` and return it as base64-encoded data uri.\n\t// The mime type of the image is inferred from the `url` file extension.\n\t// If data uri is provided as `url`, it is returned back unchanged.\n\t// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n\t// Works with IE9.\n\tconst imageToDataUri = function (url, callback) {\n\t  if (!url || url.substr(0, 'data:'.length) === 'data:') {\n\t    // No need to convert to data uri if it is already in data uri.\n\n\t    // This not only convenient but desired. For example,\n\t    // IE throws a security error if data:image/svg+xml is used to render\n\t    // an image to the canvas and an attempt is made to read out data uri.\n\t    // Now if our image is already in data uri, there is no need to render it to the canvas\n\t    // and so we can bypass this error.\n\n\t    // Keep the async nature of the function.\n\t    return setTimeout(function () {\n\t      callback(null, url);\n\t    }, 0);\n\t  }\n\n\t  // chrome, IE10+\n\t  var modernHandler = function (xhr, callback) {\n\t    if (xhr.status === 200) {\n\t      var reader = new FileReader();\n\t      reader.onload = function (evt) {\n\t        var dataUri = evt.target.result;\n\t        callback(null, dataUri);\n\t      };\n\t      reader.onerror = function () {\n\t        callback(new Error('Failed to load image ' + url));\n\t      };\n\t      reader.readAsDataURL(xhr.response);\n\t    } else {\n\t      callback(new Error('Failed to load image ' + url));\n\t    }\n\t  };\n\t  var legacyHandler = function (xhr, callback) {\n\t    var Uint8ToString = function (u8a) {\n\t      var CHUNK_SZ = 0x8000;\n\t      var c = [];\n\t      for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n\t        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n\t      }\n\t      return c.join('');\n\t    };\n\t    if (xhr.status === 200) {\n\t      var bytes = new Uint8Array(xhr.response);\n\t      var suffix = url.split('.').pop() || 'png';\n\t      var map = {\n\t        'svg': 'svg+xml'\n\t      };\n\t      var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n\t      var b64encoded = meta + btoa(Uint8ToString(bytes));\n\t      callback(null, b64encoded);\n\t    } else {\n\t      callback(new Error('Failed to load image ' + url));\n\t    }\n\t  };\n\t  var xhr = new XMLHttpRequest();\n\t  xhr.open('GET', url, true);\n\t  xhr.addEventListener('error', function () {\n\t    callback(new Error('Failed to load image ' + url));\n\t  });\n\t  xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\t  xhr.addEventListener('load', function () {\n\t    if (window.FileReader) {\n\t      modernHandler(xhr, callback);\n\t    } else {\n\t      legacyHandler(xhr, callback);\n\t    }\n\t  });\n\t  xhr.send();\n\t};\n\tconst getElementBBox = function (el) {\n\t  var $el = $(el);\n\t  if ($el.length === 0) {\n\t    throw new Error('Element not found');\n\t  }\n\t  var element = $el[0];\n\t  var doc = element.ownerDocument;\n\t  var clientBBox = element.getBoundingClientRect();\n\t  var strokeWidthX = 0;\n\t  var strokeWidthY = 0;\n\n\t  // Firefox correction\n\t  if (element.ownerSVGElement) {\n\t    var vel = V(element);\n\t    var bbox = vel.getBBox({\n\t      target: vel.svg()\n\t    });\n\n\t    // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n\t    // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n\t    strokeWidthX = clientBBox.width - bbox.width;\n\t    strokeWidthY = clientBBox.height - bbox.height;\n\t  }\n\t  return {\n\t    x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n\t    y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n\t    width: clientBBox.width - strokeWidthX,\n\t    height: clientBBox.height - strokeWidthY\n\t  };\n\t};\n\n\t// Highly inspired by the jquery.sortElements plugin by Padolsey.\n\t// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n\tconst sortElements = function (elements, comparator) {\n\t  elements = $(elements).toArray();\n\t  var placements = elements.map(function (sortElement) {\n\t    var parentNode = sortElement.parentNode;\n\t    // Since the element itself will change position, we have\n\t    // to have some way of storing it's original position in\n\t    // the DOM. The easiest way is to have a 'flag' node:\n\t    var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\t    return function () {\n\t      if (parentNode === this) {\n\t        throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n\t      }\n\n\t      // Insert before flag:\n\t      parentNode.insertBefore(this, nextSibling);\n\t      // Remove flag:\n\t      parentNode.removeChild(nextSibling);\n\t    };\n\t  });\n\t  elements.sort(comparator);\n\t  for (var i = 0; i < placements.length; i++) {\n\t    placements[i].call(elements[i]);\n\t  }\n\t  return elements;\n\t};\n\n\t// Sets attributes on the given element and its descendants based on the selector.\n\t// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\n\tconst setAttributesBySelector = function (element, attrs) {\n\t  var $element = $(element);\n\t  forIn(attrs, function (attrs, selector) {\n\t    var $elements = $element.find(selector).addBack().filter(selector);\n\t    // Make a special case for setting classes.\n\t    // We do not want to overwrite any existing class.\n\t    if (has(attrs, 'class')) {\n\t      $elements.addClass(attrs['class']);\n\t      attrs = omit(attrs, 'class');\n\t    }\n\t    $elements.attr(attrs);\n\t  });\n\t};\n\n\t// Return a new object with all four sides (top, right, bottom, left) in it.\n\t// Value of each side is taken from the given argument (either number or object).\n\t// Default value for a side is 0.\n\t// Examples:\n\t// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n\t// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n\t// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\tconst normalizeSides = function (box) {\n\t  if (Object(box) !== box) {\n\t    // `box` is not an object\n\t    var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n\t    if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n\t    return {\n\t      top: val,\n\t      right: val,\n\t      bottom: val,\n\t      left: val\n\t    };\n\t  }\n\n\t  // `box` is an object\n\t  var top, right, bottom, left;\n\t  top = right = bottom = left = 0;\n\t  if (isFinite(box.vertical)) top = bottom = +box.vertical;\n\t  if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\t  if (isFinite(box.top)) top = +box.top; // overwrite vertical\n\t  if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n\t  if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n\t  if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n\t  return {\n\t    top: top,\n\t    right: right,\n\t    bottom: bottom,\n\t    left: left\n\t  };\n\t};\n\tconst timing = {\n\t  linear: function (t) {\n\t    return t;\n\t  },\n\t  quad: function (t) {\n\t    return t * t;\n\t  },\n\t  cubic: function (t) {\n\t    return t * t * t;\n\t  },\n\t  inout: function (t) {\n\t    if (t <= 0) return 0;\n\t    if (t >= 1) return 1;\n\t    var t2 = t * t;\n\t    var t3 = t2 * t;\n\t    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n\t  },\n\t  exponential: function (t) {\n\t    return Math.pow(2, 10 * (t - 1));\n\t  },\n\t  bounce: function (t) {\n\t    for (var a = 0, b = 1; 1; a += b, b /= 2) {\n\t      if (t >= (7 - 4 * a) / 11) {\n\t        var q = (11 - 6 * a - 11 * t) / 4;\n\t        return -q * q + b * b;\n\t      }\n\t    }\n\t  },\n\t  reverse: function (f) {\n\t    return function (t) {\n\t      return 1 - f(1 - t);\n\t    };\n\t  },\n\t  reflect: function (f) {\n\t    return function (t) {\n\t      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n\t    };\n\t  },\n\t  clamp: function (f, n, x) {\n\t    n = n || 0;\n\t    x = x || 1;\n\t    return function (t) {\n\t      var r = f(t);\n\t      return r < n ? n : r > x ? x : r;\n\t    };\n\t  },\n\t  back: function (s) {\n\t    if (!s) s = 1.70158;\n\t    return function (t) {\n\t      return t * t * ((s + 1) * t - s);\n\t    };\n\t  },\n\t  elastic: function (x) {\n\t    if (!x) x = 1.5;\n\t    return function (t) {\n\t      return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n\t    };\n\t  }\n\t};\n\tconst interpolate = {\n\t  number: function (a, b) {\n\t    var d = b - a;\n\t    return function (t) {\n\t      return a + d * t;\n\t    };\n\t  },\n\t  object: function (a, b) {\n\t    var s = Object.keys(a);\n\t    return function (t) {\n\t      var i, p;\n\t      var r = {};\n\t      for (i = s.length - 1; i != -1; i--) {\n\t        p = s[i];\n\t        r[p] = a[p] + (b[p] - a[p]) * t;\n\t      }\n\t      return r;\n\t    };\n\t  },\n\t  hexColor: function (a, b) {\n\t    var ca = parseInt(a.slice(1), 16);\n\t    var cb = parseInt(b.slice(1), 16);\n\t    var ra = ca & 0x0000ff;\n\t    var rd = (cb & 0x0000ff) - ra;\n\t    var ga = ca & 0x00ff00;\n\t    var gd = (cb & 0x00ff00) - ga;\n\t    var ba = ca & 0xff0000;\n\t    var bd = (cb & 0xff0000) - ba;\n\t    return function (t) {\n\t      var r = ra + rd * t & 0x000000ff;\n\t      var g = ga + gd * t & 0x0000ff00;\n\t      var b = ba + bd * t & 0x00ff0000;\n\t      return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n\t    };\n\t  },\n\t  unit: function (a, b) {\n\t    var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n\t    var ma = r.exec(a);\n\t    var mb = r.exec(b);\n\t    var p = mb[1].indexOf('.');\n\t    var f = p > 0 ? mb[1].length - p - 1 : 0;\n\t    a = +ma[1];\n\t    var d = +mb[1] - a;\n\t    var u = ma[2];\n\t    return function (t) {\n\t      return (a + d * t).toFixed(f) + u;\n\t    };\n\t  }\n\t};\n\n\t// SVG filters.\n\t// (values in parentheses are default values)\n\tconst filter = {\n\t  // `color` ... outline color ('blue')\n\t  // `width`... outline width (1)\n\t  // `opacity` ... outline opacity (1)\n\t  // `margin` ... gap between outline and the element (2)\n\t  outline: function (args) {\n\t    var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\t    var margin = Number.isFinite(args.margin) ? args.margin : 2;\n\t    var width = Number.isFinite(args.width) ? args.width : 1;\n\t    return template(tpl)({\n\t      color: args.color || 'blue',\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t      outerRadius: margin + width,\n\t      innerRadius: margin\n\t    });\n\t  },\n\t  // `color` ... color ('red')\n\t  // `width`... width (1)\n\t  // `blur` ... blur (0)\n\t  // `opacity` ... opacity (1)\n\t  highlight: function (args) {\n\t    var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\t    return template(tpl)({\n\t      color: args.color || 'red',\n\t      width: Number.isFinite(args.width) ? args.width : 1,\n\t      blur: Number.isFinite(args.blur) ? args.blur : 0,\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n\t    });\n\t  },\n\t  // `x` ... horizontal blur (2)\n\t  // `y` ... vertical blur (optional)\n\t  blur: function (args) {\n\t    var x = Number.isFinite(args.x) ? args.x : 2;\n\t    return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n\t      stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n\t    });\n\t  },\n\t  // `dx` ... horizontal shift (0)\n\t  // `dy` ... vertical shift (0)\n\t  // `blur` ... blur (4)\n\t  // `color` ... color ('black')\n\t  // `opacity` ... opacity (1)\n\t  dropShadow: function (args) {\n\t    var tpl = 'SVGFEDropShadowElement' in window ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>' : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\t    return template(tpl)({\n\t      dx: args.dx || 0,\n\t      dy: args.dy || 0,\n\t      opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t      color: args.color || 'black',\n\t      blur: Number.isFinite(args.blur) ? args.blur : 4\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n\t  grayscale: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n\t      a: 0.2126 + 0.7874 * (1 - amount),\n\t      b: 0.7152 - 0.7152 * (1 - amount),\n\t      c: 0.0722 - 0.0722 * (1 - amount),\n\t      d: 0.2126 - 0.2126 * (1 - amount),\n\t      e: 0.7152 + 0.2848 * (1 - amount),\n\t      f: 0.0722 - 0.0722 * (1 - amount),\n\t      g: 0.2126 - 0.2126 * (1 - amount),\n\t      h: 0.0722 + 0.9278 * (1 - amount)\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n\t  sepia: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n\t      a: 0.393 + 0.607 * (1 - amount),\n\t      b: 0.769 - 0.769 * (1 - amount),\n\t      c: 0.189 - 0.189 * (1 - amount),\n\t      d: 0.349 - 0.349 * (1 - amount),\n\t      e: 0.686 + 0.314 * (1 - amount),\n\t      f: 0.168 - 0.168 * (1 - amount),\n\t      g: 0.272 - 0.272 * (1 - amount),\n\t      h: 0.534 - 0.534 * (1 - amount),\n\t      i: 0.131 + 0.869 * (1 - amount)\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n\t  saturate: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n\t      amount: 1 - amount\n\t    });\n\t  },\n\t  // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n\t  hueRotate: function (args) {\n\t    return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n\t      angle: args.angle || 0\n\t    });\n\t  },\n\t  // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n\t  invert: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n\t      amount: amount,\n\t      amount2: 1 - amount\n\t    });\n\t  },\n\t  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t  brightness: function (args) {\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n\t      amount: Number.isFinite(args.amount) ? args.amount : 1\n\t    });\n\t  },\n\t  // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t  contrast: function (args) {\n\t    var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\t    return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n\t      amount: amount,\n\t      amount2: .5 - amount / 2\n\t    });\n\t  }\n\t};\n\tconst format$1 = {\n\t  // Formatting numbers via the Python Format Specification Mini-language.\n\t  // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t  // Heavilly inspired by the D3.js library implementation.\n\t  number: function (specifier, value, locale) {\n\t    locale = locale || {\n\t      currency: ['$', ''],\n\t      decimal: '.',\n\t      thousands: ',',\n\t      grouping: [3]\n\t    };\n\n\t    // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t    // [[fill]align][sign][symbol][0][width][,][.precision][type]\n\t    var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\t    var match = re.exec(specifier);\n\t    var fill = match[1] || ' ';\n\t    var align = match[2] || '>';\n\t    var sign = match[3] || '';\n\t    var symbol = match[4] || '';\n\t    var zfill = match[5];\n\t    var width = +match[6];\n\t    var comma = match[7];\n\t    var precision = match[8];\n\t    var type = match[9];\n\t    var scale = 1;\n\t    var prefix = '';\n\t    var suffix = '';\n\t    var integer = false;\n\t    if (precision) precision = +precision.substring(1);\n\t    if (zfill || fill === '0' && align === '=') {\n\t      zfill = fill = '0';\n\t      align = '=';\n\t      if (comma) width -= Math.floor((width - 1) / 4);\n\t    }\n\t    switch (type) {\n\t      case 'n':\n\t        comma = true;\n\t        type = 'g';\n\t        break;\n\t      case '%':\n\t        scale = 100;\n\t        suffix = '%';\n\t        type = 'f';\n\t        break;\n\t      case 'p':\n\t        scale = 100;\n\t        suffix = '%';\n\t        type = 'r';\n\t        break;\n\t      case 'b':\n\t      case 'o':\n\t      case 'x':\n\t      case 'X':\n\t        if (symbol === '#') prefix = '0' + type.toLowerCase();\n\t        break;\n\t      case 'c':\n\t      case 'd':\n\t        integer = true;\n\t        precision = 0;\n\t        break;\n\t      case 's':\n\t        scale = -1;\n\t        type = 'r';\n\t        break;\n\t    }\n\t    if (symbol === '$') {\n\t      prefix = locale.currency[0];\n\t      suffix = locale.currency[1];\n\t    }\n\n\t    // If no precision is specified for `'r'`, fallback to general notation.\n\t    if (type == 'r' && !precision) type = 'g';\n\n\t    // Ensure that the requested precision is in the supported range.\n\t    if (precision != null) {\n\t      if (type == 'g') precision = Math.max(1, Math.min(21, precision));else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n\t    }\n\t    var zcomma = zfill && comma;\n\n\t    // Return the empty string for floats formatted as ints.\n\t    if (integer && value % 1) return '';\n\n\t    // Convert negative to positive, and record the sign prefix.\n\t    var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\t    var fullSuffix = suffix;\n\n\t    // Apply the scale, computing it from the value's exponent for si format.\n\t    // Preserve the existing suffix, if any, such as the currency symbol.\n\t    if (scale < 0) {\n\t      var unit = this.prefix(value, precision);\n\t      value = unit.scale(value);\n\t      fullSuffix = unit.symbol + suffix;\n\t    } else {\n\t      value *= scale;\n\t    }\n\n\t    // Convert to the desired precision.\n\t    value = this.convert(type, value, precision);\n\n\t    // Break the value into the integer part (before) and decimal part (after).\n\t    var i = value.lastIndexOf('.');\n\t    var before = i < 0 ? value : value.substring(0, i);\n\t    var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\t    function formatGroup(value) {\n\t      var i = value.length;\n\t      var t = [];\n\t      var j = 0;\n\t      var g = locale.grouping[0];\n\t      while (i > 0 && g > 0) {\n\t        t.push(value.substring(i -= g, i + g));\n\t        g = locale.grouping[j = (j + 1) % locale.grouping.length];\n\t      }\n\t      return t.reverse().join(locale.thousands);\n\t    }\n\n\t    // If the fill character is not `'0'`, grouping is applied before padding.\n\t    if (!zfill && comma && locale.grouping) {\n\t      before = formatGroup(before);\n\t    }\n\t    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n\t    var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n\t    // If the fill character is `'0'`, grouping is applied after padding.\n\t    if (zcomma) before = formatGroup(padding + before);\n\n\t    // Apply prefix.\n\t    negative += prefix;\n\n\t    // Rejoin integer and decimal parts.\n\t    value = before + after;\n\t    return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n\t  },\n\t  // Formatting string via the Python Format string.\n\t  // See https://docs.python.org/2/library/string.html#format-string-syntax)\n\t  string: function (formatString, value) {\n\t    var fieldDelimiterIndex;\n\t    var fieldDelimiter = '{';\n\t    var endPlaceholder = false;\n\t    var formattedStringArray = [];\n\t    while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\t      var pieceFormattedString, formatSpec, fieldName;\n\t      pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\t      if (endPlaceholder) {\n\t        formatSpec = pieceFormattedString.split(':');\n\t        fieldName = formatSpec.shift().split('.');\n\t        pieceFormattedString = value;\n\t        for (var i = 0; i < fieldName.length; i++) pieceFormattedString = pieceFormattedString[fieldName[i]];\n\t        if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n\t      }\n\t      formattedStringArray.push(pieceFormattedString);\n\t      formatString = formatString.slice(fieldDelimiterIndex + 1);\n\t      endPlaceholder = !endPlaceholder;\n\t      fieldDelimiter = endPlaceholder ? '}' : '{';\n\t    }\n\t    formattedStringArray.push(formatString);\n\t    return formattedStringArray.join('');\n\t  },\n\t  convert: function (type, value, precision) {\n\t    switch (type) {\n\t      case 'b':\n\t        return value.toString(2);\n\t      case 'c':\n\t        return String.fromCharCode(value);\n\t      case 'o':\n\t        return value.toString(8);\n\t      case 'x':\n\t        return value.toString(16);\n\t      case 'X':\n\t        return value.toString(16).toUpperCase();\n\t      case 'g':\n\t        return value.toPrecision(precision);\n\t      case 'e':\n\t        return value.toExponential(precision);\n\t      case 'f':\n\t        return value.toFixed(precision);\n\t      case 'r':\n\t        return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n\t      default:\n\t        return value + '';\n\t    }\n\t  },\n\t  round: function (value, precision) {\n\t    return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);\n\t  },\n\t  precision: function (value, precision) {\n\t    return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n\t  },\n\t  prefix: function (value, precision) {\n\t    var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function (d, i) {\n\t      var k = Math.pow(10, Math.abs(8 - i) * 3);\n\t      return {\n\t        scale: i > 8 ? function (d) {\n\t          return d / k;\n\t        } : function (d) {\n\t          return d * k;\n\t        },\n\t        symbol: d\n\t      };\n\t    });\n\t    var i = 0;\n\t    if (value) {\n\t      if (value < 0) value *= -1;\n\t      if (precision) value = this.round(value, this.precision(value, precision));\n\t      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n\t      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n\t    }\n\t    return prefixes[8 + i / 3];\n\t  }\n\t};\n\n\t/*\n\t    Pre-compile the HTML to be used as a template.\n\t*/\n\tconst template = function (html) {\n\t  /*\n\t      Must support the variation in templating syntax found here:\n\t      https://lodash.com/docs#template\n\t  */\n\t  var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\t  return function (data) {\n\t    data = data || {};\n\t    return html.replace(regex, function (match) {\n\t      var args = Array.from(arguments);\n\t      var attr = args.slice(1, 4).find(function (_attr) {\n\t        return !!_attr;\n\t      });\n\t      var attrArray = attr.split('.');\n\t      var value = data[attrArray.shift()];\n\t      while (value !== undefined && attrArray.length) {\n\t        value = value[attrArray.shift()];\n\t      }\n\t      return value !== undefined ? value : '';\n\t    });\n\t  };\n\t};\n\n\t/**\n\t * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n\t */\n\tconst toggleFullScreen = function (el) {\n\t  var topDocument = window.top.document;\n\t  el = el || topDocument.body;\n\t  function prefixedResult(el, prop) {\n\t    var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n\t    for (var i = 0; i < prefixes.length; i++) {\n\t      var prefix = prefixes[i];\n\t      var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);\n\t      if (el[propName] !== undefined) {\n\t        return isFunction(el[propName]) ? el[propName]() : el[propName];\n\t      }\n\t    }\n\t  }\n\t  if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n\t    prefixedResult(topDocument, 'ExitFullscreen') ||\n\t    // Spec.\n\t    prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n\t  } else {\n\t    prefixedResult(el, 'RequestFullscreen') ||\n\t    // Spec.\n\t    prefixedResult(el, 'RequestFullScreen'); // Firefox\n\t  }\n\t};\n\tfunction findDifference(obj, baseObj, currentDepth, maxDepth) {\n\t  if (currentDepth === maxDepth) {\n\t    return {};\n\t  }\n\t  const diff = {};\n\t  Object.keys(obj).forEach(key => {\n\t    const objValue = obj[key];\n\t    const baseValue = baseObj[key];\n\t    if (!Array.isArray(objValue) && !Array.isArray(baseValue) && isObject(objValue) && isObject(baseValue)) {\n\t      const nestedDepth = currentDepth + 1;\n\t      const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);\n\t      if (Object.keys(nestedDiff).length > 0) {\n\t        diff[key] = nestedDiff;\n\t      } else if (currentDepth === 0 || nestedDepth === maxDepth) {\n\t        diff[key] = {};\n\t      }\n\t    } else if (!isEqual(objValue, baseValue)) {\n\t      diff[key] = objValue;\n\t    }\n\t  });\n\t  return diff;\n\t}\n\tfunction objectDifference(object, base, opt) {\n\t  const {\n\t    maxDepth = Number.POSITIVE_INFINITY\n\t  } = opt || {};\n\t  return findDifference(object, base, 0, maxDepth);\n\t}\n\tconst noop = function () {\n\t  // Do nothing.\n\t};\n\n\t// Events\n\t// ---------------\n\n\t// A module that can be mixed in to *any object* in order to provide it with\n\t// a custom event channel. You may bind a callback to an event with `on` or\n\t// remove with `off`; `trigger`-ing an event fires all callbacks in\n\t// succession.\n\t//\n\t//     const object = {};\n\t//     assign(object, Events);\n\t//     object.on('expand', function(){ alert('expanded'); });\n\t//     object.trigger('expand');\n\t//\n\tvar Events = {};\n\n\t// Regular expression used to split event strings.\n\tvar eventSplitter = /\\s+/;\n\n\t// A private global variable to share between listeners and listenees.\n\tvar _listening;\n\n\t// Iterates over the standard `event, callback` (as well as the fancy multiple\n\t// space-separated events `\"change blur\", callback` and jQuery-style event\n\t// maps `{event: callback}`).\n\tvar eventsApi = function (iteratee, events, name, callback, opts) {\n\t  var i = 0,\n\t    names;\n\t  if (name && typeof name === 'object') {\n\t    // Handle event maps.\n\t    if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n\t    for (names = Object.keys(name); i < names.length; i++) {\n\t      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n\t    }\n\t  } else if (name && eventSplitter.test(name)) {\n\t    // Handle space-separated event names by delegating them individually.\n\t    for (names = name.split(eventSplitter); i < names.length; i++) {\n\t      events = iteratee(events, names[i], callback, opts);\n\t    }\n\t  } else {\n\t    // Finally, standard events.\n\t    events = iteratee(events, name, callback, opts);\n\t  }\n\t  return events;\n\t};\n\n\t// Bind an event to a `callback` function. Passing `\"all\"` will bind\n\t// the callback to all events fired.\n\tEvents.on = function (name, callback, context) {\n\t  this._events = eventsApi(onApi, this._events || {}, name, callback, {\n\t    context: context,\n\t    ctx: this,\n\t    listening: _listening\n\t  });\n\t  if (_listening) {\n\t    var listeners = this._listeners || (this._listeners = {});\n\t    listeners[_listening.id] = _listening;\n\t    // Allow the listening to use a counter, instead of tracking\n\t    // callbacks for library interop\n\t    _listening.interop = false;\n\t  }\n\t  return this;\n\t};\n\n\t// Inversion-of-control versions of `on`. Tell *this* object to listen to\n\t// an event in another object... keeping track of what it's listening to\n\t// for easier unbinding later.\n\tEvents.listenTo = function (obj, name, callback) {\n\t  if (!obj) return this;\n\t  var id = obj._listenId || (obj._listenId = uniqueId('l'));\n\t  var listeningTo = this._listeningTo || (this._listeningTo = {});\n\t  var listening = _listening = listeningTo[id];\n\n\t  // This object is not listening to any other events on `obj` yet.\n\t  // Setup the necessary references to track the listening callbacks.\n\t  if (!listening) {\n\t    this._listenId || (this._listenId = uniqueId('l'));\n\t    listening = _listening = listeningTo[id] = new Listening(this, obj);\n\t  }\n\n\t  // Bind callbacks on obj.\n\t  var error = tryCatchOn(obj, name, callback, this);\n\t  _listening = void 0;\n\t  if (error) throw error;\n\t  // If the target obj is not Events, track events manually.\n\t  if (listening.interop) listening.on(name, callback);\n\t  return this;\n\t};\n\n\t// The reducing API that adds a callback to the `events` object.\n\tvar onApi = function (events, name, callback, options) {\n\t  if (callback) {\n\t    var handlers = events[name] || (events[name] = []);\n\t    var context = options.context,\n\t      ctx = options.ctx,\n\t      listening = options.listening;\n\t    if (listening) listening.count++;\n\t    handlers.push({\n\t      callback: callback,\n\t      context: context,\n\t      ctx: context || ctx,\n\t      listening: listening\n\t    });\n\t  }\n\t  return events;\n\t};\n\n\t// An try-catch guarded #on function, to prevent poisoning the global\n\t// `_listening` variable.\n\tvar tryCatchOn = function (obj, name, callback, context) {\n\t  try {\n\t    obj.on(name, callback, context);\n\t  } catch (e) {\n\t    return e;\n\t  }\n\t};\n\n\t// Remove one or many callbacks. If `context` is null, removes all\n\t// callbacks with that function. If `callback` is null, removes all\n\t// callbacks for the event. If `name` is null, removes all bound\n\t// callbacks for all events.\n\tEvents.off = function (name, callback, context) {\n\t  if (!this._events) return this;\n\t  this._events = eventsApi(offApi, this._events, name, callback, {\n\t    context: context,\n\t    listeners: this._listeners\n\t  });\n\t  return this;\n\t};\n\n\t// Tell this object to stop listening to either specific events ... or\n\t// to every object it's currently listening to.\n\tEvents.stopListening = function (obj, name, callback) {\n\t  var listeningTo = this._listeningTo;\n\t  if (!listeningTo) return this;\n\t  var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n\t  for (var i = 0; i < ids.length; i++) {\n\t    var listening = listeningTo[ids[i]];\n\n\t    // If listening doesn't exist, this object is not currently\n\t    // listening to obj. Break out early.\n\t    if (!listening) break;\n\t    listening.obj.off(name, callback, this);\n\t    if (listening.interop) listening.off(name, callback);\n\t  }\n\t  if (isEmpty(listeningTo)) this._listeningTo = void 0;\n\t  return this;\n\t};\n\n\t// The reducing API that removes a callback from the `events` object.\n\tvar offApi = function (events, name, callback, options) {\n\t  if (!events) return;\n\t  var context = options.context,\n\t    listeners = options.listeners;\n\t  var i = 0,\n\t    names;\n\n\t  // Delete all event listeners and \"drop\" events.\n\t  if (!name && !context && !callback) {\n\t    if (listeners != null) {\n\t      for (names = Object.keys(listeners); i < names.length; i++) {\n\t        listeners[names[i]].cleanup();\n\t      }\n\t    }\n\t    return;\n\t  }\n\t  names = name ? [name] : Object.keys(events);\n\t  for (; i < names.length; i++) {\n\t    name = names[i];\n\t    var handlers = events[name];\n\n\t    // Bail out if there are no events stored.\n\t    if (!handlers) break;\n\n\t    // Find any remaining events.\n\t    var remaining = [];\n\t    for (var j = 0; j < handlers.length; j++) {\n\t      var handler = handlers[j];\n\t      if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {\n\t        remaining.push(handler);\n\t      } else {\n\t        var listening = handler.listening;\n\t        if (listening) listening.off(name, callback);\n\t      }\n\t    }\n\n\t    // Replace events if there are any remaining.  Otherwise, clean up.\n\t    if (remaining.length) {\n\t      events[name] = remaining;\n\t    } else {\n\t      delete events[name];\n\t    }\n\t  }\n\t  return events;\n\t};\n\n\t// Bind an event to only be triggered a single time. After the first time\n\t// the callback is invoked, its listener will be removed. If multiple events\n\t// are passed in using the space-separated syntax, the handler will fire\n\t// once for each event, not once for a combination of all events.\n\tEvents.once = function (name, callback, context) {\n\t  // Map the event into a `{event: once}` object.\n\t  var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n\t  if (typeof name === 'string' && context == null) callback = void 0;\n\t  return this.on(events, callback, context);\n\t};\n\n\t// Inversion-of-control versions of `once`.\n\tEvents.listenToOnce = function (obj, name, callback) {\n\t  // Map the event into a `{event: once}` object.\n\t  var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n\t  return this.listenTo(obj, events);\n\t};\n\n\t// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n\t// `offer` unbinds the `onceWrapper` after it has been called.\n\tvar onceMap = function (map, name, callback, offer) {\n\t  if (callback) {\n\t    var once = map[name] = onceInvoke(function () {\n\t      offer(name, once);\n\t      callback.apply(this, arguments);\n\t    });\n\t    once._callback = callback;\n\t  }\n\t  return map;\n\t};\n\n\t// Creates a function that is restricted to invoking 'func' once.\n\t// Repeat calls to the function return the value of the first invocation.\n\tvar onceInvoke = function (func) {\n\t  var result;\n\t  if (typeof func != 'function') {\n\t    throw new TypeError('Expected a function');\n\t  }\n\t  var n = 2;\n\t  return function () {\n\t    if (--n > 0) {\n\t      result = func.apply(this, arguments);\n\t    }\n\t    if (n <= 1) {\n\t      func = undefined;\n\t    }\n\t    return result;\n\t  };\n\t};\n\n\t// Trigger one or many events, firing all bound callbacks. Callbacks are\n\t// passed the same arguments as `trigger` is, apart from the event name\n\t// (unless you're listening on `\"all\"`, which will cause your callback to\n\t// receive the true name of the event as the first argument).\n\tEvents.trigger = function (name) {\n\t  if (!this._events) return this;\n\t  var length = Math.max(0, arguments.length - 1);\n\t  var args = Array(length);\n\t  for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\t  eventsApi(triggerApi, this._events, name, void 0, args);\n\t  return this;\n\t};\n\n\t// Handles triggering the appropriate event callbacks.\n\tvar triggerApi = function (objEvents, name, callback, args) {\n\t  if (objEvents) {\n\t    var events = objEvents[name];\n\t    var allEvents = objEvents.all;\n\t    if (events && allEvents) allEvents = allEvents.slice();\n\t    if (events) triggerEvents(events, args);\n\t    if (allEvents) triggerEvents(allEvents, [name].concat(args));\n\t  }\n\t  return objEvents;\n\t};\n\n\t// A difficult-to-believe, but optimized internal dispatch function for\n\t// triggering events. Tries to keep the usual cases speedy (most internal\n\t// events have 3 arguments).\n\tvar triggerEvents = function (events, args) {\n\t  var ev,\n\t    i = -1,\n\t    l = events.length,\n\t    a1 = args[0],\n\t    a2 = args[1],\n\t    a3 = args[2];\n\t  switch (args.length) {\n\t    case 0:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n\t      return;\n\t    case 1:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);\n\t      return;\n\t    case 2:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\t      return;\n\t    case 3:\n\t      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\t      return;\n\t    default:\n\t      while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n\t      return;\n\t  }\n\t};\n\n\t// A listening class that tracks and cleans up memory bindings\n\t// when all callbacks have been offed.\n\tvar Listening = function (listener, obj) {\n\t  this.id = listener._listenId;\n\t  this.listener = listener;\n\t  this.obj = obj;\n\t  this.interop = true;\n\t  this.count = 0;\n\t  this._events = void 0;\n\t};\n\tListening.prototype.on = Events.on;\n\n\t// Offs a callback (or several).\n\t// Uses an optimized counter if the listenee uses Events.\n\t// Otherwise, falls back to manual tracking to support events\n\t// library interop.\n\tListening.prototype.off = function (name, callback) {\n\t  var cleanup;\n\t  if (this.interop) {\n\t    this._events = eventsApi(offApi, this._events, name, callback, {\n\t      context: void 0,\n\t      listeners: void 0\n\t    });\n\t    cleanup = !this._events;\n\t  } else {\n\t    this.count--;\n\t    cleanup = this.count === 0;\n\t  }\n\t  if (cleanup) this.cleanup();\n\t};\n\n\t// Cleans up memory bindings between the listener and the listenee.\n\tListening.prototype.cleanup = function () {\n\t  delete this.listener._listeningTo[this.obj._listenId];\n\t  if (!this.interop) delete this.obj._listeners[this.id];\n\t};\n\n\t// Aliases for backwards compatibility.\n\tEvents.bind = Events.on;\n\tEvents.unbind = Events.off;\n\n\t// Helpers\n\t// -------\n\n\t// Helper function to correctly set up the prototype chain for subclasses.\n\t// Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t// class properties to be extended.\n\tvar extend = function (protoProps, staticProps) {\n\t  var parent = this;\n\t  var child;\n\n\t  // The constructor function for the new subclass is either defined by you\n\t  // (the \"constructor\" property in your `extend` definition), or defaulted\n\t  // by us to simply call the parent constructor.\n\t  if (protoProps && has(protoProps, 'constructor')) {\n\t    child = protoProps.constructor;\n\t  } else {\n\t    child = function () {\n\t      return parent.apply(this, arguments);\n\t    };\n\t  }\n\n\t  // Add static properties to the constructor function, if supplied.\n\t  assign(child, parent, staticProps);\n\n\t  // Set the prototype chain to inherit from `parent`, without calling\n\t  // `parent`'s constructor function and add the prototype properties.\n\t  child.prototype = Object.assign(Object.create(parent.prototype), protoProps);\n\t  child.prototype.constructor = child;\n\n\t  // Set a convenience property in case the parent's prototype is needed\n\t  // later.\n\t  child.__super__ = parent.prototype;\n\t  return child;\n\t};\n\n\t// Proxy class methods to functions, wrapping the model's\n\t// `attributes` object or collection's `models` array behind the scenes.\n\t//\n\t// `Function#apply` can be slow so we use the method's arg count, if we know it.\n\tvar addMethod = function (base, length, method, attribute) {\n\t  switch (length) {\n\t    case 1:\n\t      return function () {\n\t        return base[method](this[attribute]);\n\t      };\n\t    case 2:\n\t      return function (value) {\n\t        return base[method](this[attribute], value);\n\t      };\n\t    case 3:\n\t      return function (iteratee, context) {\n\t        return base[method](this[attribute], cb(iteratee, this), context);\n\t      };\n\t    case 4:\n\t      return function (iteratee, defaultVal, context) {\n\t        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n\t      };\n\t    default:\n\t      return function () {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        args.unshift(this[attribute]);\n\t        return base[method].apply(base, args);\n\t      };\n\t  }\n\t};\n\tvar addMethodsUtil = function (Class, base, methods, attribute) {\n\t  forIn(methods, function (length, method) {\n\t    if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n\t  });\n\t};\n\n\t// Support `collection.sortBy('attr')`.\n\tvar cb = function (iteratee, instance) {\n\t  if (isFunction(iteratee)) return iteratee;\n\t  if (isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n\t  if (isString(iteratee)) return function (model) {\n\t    return model.get(iteratee);\n\t  };\n\t  return iteratee;\n\t};\n\tvar modelMatcher = function (attrs) {\n\t  var matcher = matches(attrs);\n\t  return function (model) {\n\t    return matcher(model.attributes);\n\t  };\n\t};\n\n\t// Model\n\t// --------------\n\n\t// **Models** are the basic data object in the framework --\n\t// frequently representing a row in a table in a database on your server.\n\t// A discrete chunk of data and a bunch of useful, related methods for\n\t// performing computations and transformations on that data.\n\n\t// Create a new model with the specified attributes. A client id (`cid`)\n\t// is automatically generated and assigned for you.\n\n\tvar Model = function (attributes, options) {\n\t  var attrs = attributes || {};\n\t  options || (options = {});\n\t  this.eventPrefix = options.eventPrefix || '';\n\t  this.preinitialize.apply(this, arguments);\n\t  this.cid = uniqueId(this.cidPrefix);\n\t  this.attributes = {};\n\t  if (options.collection) this.collection = options.collection;\n\t  this._setDefaults(attrs, options);\n\t  this.changed = {};\n\t  this.initialize.apply(this, arguments);\n\t};\n\n\t// Attach all inheritable methods to the Model prototype.\n\tassign(Model.prototype, Events, {\n\t  // A hash of attributes whose current and previous value differ.\n\t  changed: null,\n\t  // The value returned during the last failed validation.\n\t  validationError: null,\n\t  // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n\t  // CouchDB users may want to set this to `\"_id\"`.\n\t  idAttribute: 'id',\n\t  // The prefix is used to create the client id which is used to identify models locally.\n\t  // You may want to override this if you're experiencing name clashes with model ids.\n\t  cidPrefix: 'c',\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the Model.\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Return a copy of the model's `attributes` object.\n\t  toJSON: function (options) {\n\t    return clone$1(this.attributes);\n\t  },\n\t  // Get the value of an attribute.\n\t  get: function (attr) {\n\t    return this.attributes[attr];\n\t  },\n\t  // Returns `true` if the attribute contains a value that is not null\n\t  // or undefined.\n\t  has: function (attr) {\n\t    return this.get(attr) != null;\n\t  },\n\t  // Set a hash of model attributes on the object, firing `\"change\"`. This is\n\t  // the core primitive operation of a model, updating the data and notifying\n\t  // anyone who needs to know about the change in state. The heart of the beast.\n\t  set: function (key, val, options) {\n\t    if (key == null) return this;\n\n\t    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\t    var attrs;\n\t    if (typeof key === 'object') {\n\t      attrs = key;\n\t      options = val;\n\t    } else {\n\t      (attrs = {})[key] = val;\n\t    }\n\t    options || (options = {});\n\n\t    // Run validation.\n\t    if (!this._validate(attrs, options)) return false;\n\n\t    // Extract attributes and options.\n\t    var unset = options.unset;\n\t    var silent = options.silent;\n\t    var changes = [];\n\t    var changing = this._changing;\n\t    this._changing = true;\n\t    if (!changing) {\n\t      this._previousAttributes = clone$1(this.attributes);\n\t      this.changed = {};\n\t    }\n\t    var current = this.attributes;\n\t    var changed = this.changed;\n\t    var prev = this._previousAttributes;\n\n\t    // For each `set` attribute, update or delete the current value.\n\t    for (var attr in attrs) {\n\t      val = attrs[attr];\n\t      if (!isEqual(current[attr], val)) changes.push(attr);\n\t      if (!isEqual(prev[attr], val)) {\n\t        changed[attr] = val;\n\t      } else {\n\t        delete changed[attr];\n\t      }\n\t      unset ? delete current[attr] : current[attr] = val;\n\t    }\n\n\t    // Update the `id`.\n\t    if (this.idAttribute in attrs) {\n\t      var prevId = this.id;\n\t      this.id = this.get(this.idAttribute);\n\t      this.trigger(this.eventPrefix + 'changeId', this, prevId, options);\n\t    }\n\n\t    // Trigger all relevant attribute changes.\n\t    if (!silent) {\n\t      if (changes.length) this._pending = options;\n\t      for (var i = 0; i < changes.length; i++) {\n\t        this.trigger(this.eventPrefix + 'change:' + changes[i], this, current[changes[i]], options);\n\t      }\n\t    }\n\n\t    // You might be wondering why there's a `while` loop here. Changes can\n\t    // be recursively nested within `\"change\"` events.\n\t    if (changing) return this;\n\t    if (!silent) {\n\t      while (this._pending) {\n\t        options = this._pending;\n\t        this._pending = false;\n\t        this.trigger(this.eventPrefix + 'change', this, options);\n\t      }\n\t    }\n\t    this._pending = false;\n\t    this._changing = false;\n\t    return this;\n\t  },\n\t  // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n\t  // if the attribute doesn't exist.\n\t  unset: function (attr, options) {\n\t    return this.set(attr, void 0, assign({}, options, {\n\t      unset: true\n\t    }));\n\t  },\n\t  // Clear all attributes on the model, firing `\"change\"`.\n\t  clear: function (options) {\n\t    var attrs = {};\n\t    for (var key in this.attributes) attrs[key] = void 0;\n\t    return this.set(attrs, assign({}, options, {\n\t      unset: true\n\t    }));\n\t  },\n\t  // Determine if the model has changed since the last `\"change\"` event.\n\t  // If you specify an attribute name, determine if that attribute has changed.\n\t  hasChanged: function (attr) {\n\t    if (attr == null) return !isEmpty(this.changed);\n\t    return has(this.changed, attr);\n\t  },\n\t  // Return an object containing all the attributes that have changed, or\n\t  // false if there are no changed attributes. Useful for determining what\n\t  // parts of a view need to be updated and/or what attributes need to be\n\t  // persisted to the server. Unset attributes will be set to undefined.\n\t  // You can also pass an attributes object to diff against the model,\n\t  // determining if there *would be* a change.\n\t  changedAttributes: function (diff) {\n\t    if (!diff) return this.hasChanged() ? clone$1(this.changed) : false;\n\t    var old = this._changing ? this._previousAttributes : this.attributes;\n\t    var changed = {};\n\t    var hasChanged;\n\t    for (var attr in diff) {\n\t      var val = diff[attr];\n\t      if (isEqual(old[attr], val)) continue;\n\t      changed[attr] = val;\n\t      hasChanged = true;\n\t    }\n\t    return hasChanged ? changed : false;\n\t  },\n\t  // Get the previous value of an attribute, recorded at the time the last\n\t  // `\"change\"` event was fired.\n\t  previous: function (attr) {\n\t    if (attr == null || !this._previousAttributes) return null;\n\t    return this._previousAttributes[attr];\n\t  },\n\t  // Get all of the attributes of the model at the time of the previous\n\t  // `\"change\"` event.\n\t  previousAttributes: function () {\n\t    return clone$1(this._previousAttributes);\n\t  },\n\t  // Create a new model with identical attributes to this one.\n\t  clone: function () {\n\t    return new this.constructor(this.attributes);\n\t  },\n\t  // Check if the model is currently in a valid state.\n\t  isValid: function (options) {\n\t    return this._validate({}, assign({}, options, {\n\t      validate: true\n\t    }));\n\t  },\n\t  // Run validation against the next complete set of model attributes,\n\t  // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n\t  _validate: function (attrs, options) {\n\t    if (!options.validate || !this.validate) return true;\n\t    attrs = assign({}, this.attributes, attrs);\n\t    var error = this.validationError = this.validate(attrs, options) || null;\n\t    if (!error) return true;\n\t    this.trigger('invalid', this, error, assign(options, {\n\t      validationError: error\n\t    }));\n\t    return false;\n\t  },\n\t  _setDefaults: function (ctorAttributes, options) {\n\t    const attributeDefaults = result(this, 'defaults');\n\t    // Just _.defaults would work fine, but the additional _.extends\n\t    // is in there for historical reasons. See #3843.\n\t    const attributes = defaults(assign({}, attributeDefaults, ctorAttributes), attributeDefaults);\n\t    this.set(attributes, options);\n\t  }\n\t});\n\n\t// Set up inheritance for the model.\n\tModel.extend = extend;\n\n\t// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n\t// of clones is exactly the same as the `cells.length`.\n\t// This function simply clones all the `cells`. However, it also reconstructs\n\t// all the `source/target` and `parent/embed` references within the `cells`.\n\t// This is the main difference from the `cell.clone()` method. The\n\t// `cell.clone()` method works on one single cell only.\n\t// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n\t// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n\t// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\tfunction cloneCells(cells) {\n\t  cells = uniq(cells);\n\n\t  // A map of the form [original cell ID] -> [clone] helping\n\t  // us to reconstruct references for source/target and parent/embeds.\n\t  // This is also the returned value.\n\t  const cloneMap = toArray$1(cells).reduce(function (map, cell) {\n\t    map[cell.id] = cell.clone();\n\t    return map;\n\t  }, {});\n\t  toArray$1(cells).forEach(function (cell) {\n\t    const clone = cloneMap[cell.id];\n\t    // assert(clone exists)\n\n\t    if (clone.isLink()) {\n\t      const source = clone.source();\n\t      const target = clone.target();\n\t      if (source.id && cloneMap[source.id]) {\n\t        // Source points to an element and the element is among the clones.\n\t        // => Update the source of the cloned link.\n\t        clone.prop('source/id', cloneMap[source.id].id);\n\t      }\n\t      if (target.id && cloneMap[target.id]) {\n\t        // Target points to an element and the element is among the clones.\n\t        // => Update the target of the cloned link.\n\t        clone.prop('target/id', cloneMap[target.id].id);\n\t      }\n\t    }\n\n\t    // Find the parent of the original cell\n\t    const parent = cell.get('parent');\n\t    if (parent && cloneMap[parent]) {\n\t      clone.set('parent', cloneMap[parent].id);\n\t    }\n\n\t    // Find the embeds of the original cell\n\t    const embeds = toArray$1(cell.get('embeds')).reduce(function (newEmbeds, embed) {\n\t      // Embedded cells that are not being cloned can not be carried\n\t      // over with other embedded cells.\n\t      if (cloneMap[embed]) {\n\t        newEmbeds.push(cloneMap[embed].id);\n\t      }\n\t      return newEmbeds;\n\t    }, []);\n\t    if (!isEmpty(embeds)) {\n\t      clone.set('embeds', embeds);\n\t    }\n\t  });\n\t  return cloneMap;\n\t}\n\n\tconst validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\tconst validProperties = validPropertiesList.reduce((acc, key) => {\n\t  acc[key] = true;\n\t  return acc;\n\t}, {});\n\tconst props$1 = {\n\t  qualify: function (properties) {\n\t    return isPlainObject(properties);\n\t  },\n\t  set: function (properties, _, node) {\n\t    Object.keys(properties).forEach(function (key) {\n\t      if (validProperties[key] && key in node) {\n\t        const value = properties[key];\n\t        if (node.tagName === 'SELECT' && Array.isArray(value)) {\n\t          Array.from(node.options).forEach(function (option, index) {\n\t            option.selected = value.includes(option.value);\n\t          });\n\t        } else {\n\t          node[key] = value;\n\t        }\n\t      }\n\t    });\n\t  }\n\t};\n\n\tfunction positionWrapper(axis, dimension, origin) {\n\t  return function (value, refBBox) {\n\t    var valuePercentage = isPercentage(value);\n\t    value = parseFloat(value);\n\t    if (valuePercentage) {\n\t      value /= 100;\n\t    }\n\t    var delta;\n\t    if (isFinite(value)) {\n\t      var refOrigin = refBBox[origin]();\n\t      if (valuePercentage || value > 0 && value < 1) {\n\t        delta = refOrigin[axis] + refBBox[dimension] * value;\n\t      } else {\n\t        delta = refOrigin[axis] + value;\n\t      }\n\t    }\n\t    var point = Point();\n\t    point[axis] = delta || 0;\n\t    return point;\n\t  };\n\t}\n\tfunction setWrapper(attrName, dimension) {\n\t  return function (value, refBBox) {\n\t    var isValuePercentage = isPercentage(value);\n\t    value = parseFloat(value);\n\t    if (isValuePercentage) {\n\t      value /= 100;\n\t    }\n\t    var attrs = {};\n\t    if (isFinite(value)) {\n\t      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n\t      attrs[attrName] = attrValue;\n\t    }\n\t    return attrs;\n\t  };\n\t}\n\tconst legacyAttributesNS = {\n\t  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n\t  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n\t  // otherwise, `refX` is the left coordinate of the bounding box\n\t  'ref-x': {\n\t    position: positionWrapper('x', 'width', 'origin')\n\t  },\n\t  'ref-y': {\n\t    position: positionWrapper('y', 'height', 'origin')\n\t  },\n\t  // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom\n\t  // coordinate of the reference element.\n\n\t  'ref-dx': {\n\t    position: positionWrapper('x', 'width', 'corner')\n\t  },\n\t  'ref-dy': {\n\t    position: positionWrapper('y', 'height', 'corner')\n\t  },\n\t  // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to\n\t  // the reference element size\n\t  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n\t  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n\t  'ref-width': {\n\t    set: setWrapper('width', 'width')\n\t  },\n\t  'ref-height': {\n\t    set: setWrapper('height', 'height')\n\t  },\n\t  'ref-rx': {\n\t    set: setWrapper('rx', 'width')\n\t  },\n\t  'ref-ry': {\n\t    set: setWrapper('ry', 'height')\n\t  },\n\t  'ref-cx': {\n\t    set: setWrapper('cx', 'width')\n\t  },\n\t  'ref-cy': {\n\t    set: setWrapper('cy', 'height')\n\t  },\n\t  'ref-r-inscribed': {\n\t    set: function (attrName) {\n\t      var widthFn = setWrapper(attrName, 'width');\n\t      var heightFn = setWrapper(attrName, 'height');\n\t      return function (value, refBBox) {\n\t        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n\t        return fn(value, refBBox);\n\t      };\n\t    }('r')\n\t  },\n\t  'ref-r-circumscribed': {\n\t    set: function (value, refBBox) {\n\t      var isValuePercentage = isPercentage(value);\n\t      value = parseFloat(value);\n\t      if (isValuePercentage) {\n\t        value /= 100;\n\t      }\n\t      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n\t      var rValue;\n\t      if (isFinite(value)) {\n\t        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);\n\t      }\n\t      return {\n\t        r: rValue\n\t      };\n\t    }\n\t  }\n\t};\n\n\t// NOTE: refX & refY are SVG attributes that define the reference point of the marker.\n\t// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).\n\tlegacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];\n\tlegacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];\n\n\t// This allows to combine both absolute and relative positioning\n\t// refX: 50%, refX2: 20\n\tlegacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];\n\tlegacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];\n\tlegacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];\n\tlegacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];\n\n\t// Aliases\n\tlegacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];\n\n\tconst props = {\n\t  x: 'x',\n\t  y: 'y',\n\t  width: 'w',\n\t  height: 'h',\n\t  minimum: 's',\n\t  maximum: 'l',\n\t  diagonal: 'd'\n\t};\n\tconst propsList = Object.keys(props).map(key => props[key]).join('');\n\tconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\n\tconst findSpacesRegex = /\\s/g;\n\tconst parseFormulaRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\tfunction throwInvalid(expression) {\n\t  throw new Error(`Invalid calc() expression: ${expression}`);\n\t}\n\n\t/*\n\t* Evaluate the given calc formula.\n\t* e.g. 'w + 10' in a rect 100x100 -> 110\n\t*/\n\tfunction evalCalcFormula(formula, rect) {\n\t  const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));\n\t  if (!match) throwInvalid(formula);\n\t  parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run\n\t  const [, multiply, property, divide, add] = match;\n\t  const {\n\t    x,\n\t    y,\n\t    width,\n\t    height\n\t  } = rect;\n\t  let value = 0;\n\t  switch (property) {\n\t    case props.width:\n\t      {\n\t        value = width;\n\t        break;\n\t      }\n\t    case props.height:\n\t      {\n\t        value = height;\n\t        break;\n\t      }\n\t    case props.x:\n\t      {\n\t        value = x;\n\t        break;\n\t      }\n\t    case props.y:\n\t      {\n\t        value = y;\n\t        break;\n\t      }\n\t    case props.minimum:\n\t      {\n\t        value = Math.min(height, width);\n\t        break;\n\t      }\n\t    case props.maximum:\n\t      {\n\t        value = Math.max(height, width);\n\t        break;\n\t      }\n\t    case props.diagonal:\n\t      {\n\t        value = Math.sqrt(height * height + width * width);\n\t        break;\n\t      }\n\t  }\n\t  if (multiply) {\n\t    // e.g \"2*\"\n\t    value *= parseFloat(multiply);\n\t  }\n\t  if (divide) {\n\t    // e.g \"/2\"\n\t    value /= parseFloat(divide.slice(1));\n\t  }\n\t  if (add) {\n\t    value += evalAddExpression(add);\n\t  }\n\t  return value;\n\t}\n\tfunction evalAddExpression(addExpression) {\n\t  if (!addExpression) return 0;\n\t  const [sign] = addExpression;\n\t  switch (sign) {\n\t    case '+':\n\t      {\n\t        return parseFloat(addExpression.substr(1));\n\t      }\n\t    case '-':\n\t      {\n\t        return -parseFloat(addExpression.substr(1));\n\t      }\n\t  }\n\t  return parseFloat(addExpression);\n\t}\n\n\t/*\n\t* Check if the given value is a calc expression.\n\t* e.g. 'calc(10 + 100)' -> true\n\t*/\n\tfunction isCalcExpression(value) {\n\t  return typeof value === 'string' && value.includes('calc');\n\t}\n\tconst calcStart = 'calc(';\n\tconst calcStartOffset = calcStart.length;\n\n\t/*\n\t* Evaluate all calc formulas in the given expression.\n\t* e.g. 'calc(w + 10)' in rect 100x100 -> '110'\n\t*/\n\tfunction evalCalcExpression(expression, rect) {\n\t  let value = expression;\n\t  let startSearchIndex = 0;\n\t  do {\n\t    let calcIndex = value.indexOf(calcStart, startSearchIndex);\n\t    if (calcIndex === -1) return value;\n\t    let calcEndIndex = calcIndex + calcStartOffset;\n\t    let brackets = 1;\n\t    findClosingBracket: do {\n\t      switch (value[calcEndIndex]) {\n\t        case '(':\n\t          {\n\t            brackets++;\n\t            break;\n\t          }\n\t        case ')':\n\t          {\n\t            brackets--;\n\t            if (brackets === 0) break findClosingBracket;\n\t            break;\n\t          }\n\t        case undefined:\n\t          {\n\t            // Could not find the closing bracket.\n\t            throwInvalid(value);\n\t          }\n\t      }\n\t      calcEndIndex++;\n\t    } while (true);\n\t    // Get the calc() expression without nested calcs (recursion)\n\t    let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n\t    if (isCalcExpression(expression)) {\n\t      expression = evalCalcExpression(expression, rect);\n\t    }\n\t    // Eval the calc() expression without nested calcs.\n\t    const calcValue = String(evalCalcFormula(expression, rect));\n\t    // Replace the calc() expression and continue search\n\t    value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n\t    startSearchIndex = calcIndex + calcValue.length;\n\t  } while (true);\n\t}\n\n\tfunction isTextInUse(_value, _node, attrs) {\n\t  return attrs.text !== undefined;\n\t}\n\tconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\tconst textAttributesNS = {\n\t  'line-height': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text-vertical-anchor': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text-path': {\n\t    qualify: isTextInUse\n\t  },\n\t  'annotations': {\n\t    qualify: isTextInUse\n\t  },\n\t  'eol': {\n\t    qualify: isTextInUse\n\t  },\n\t  'display-empty': {\n\t    qualify: isTextInUse\n\t  },\n\t  'text': {\n\t    qualify: function (_text, _node, attrs) {\n\t      const textWrap = attrs['text-wrap'];\n\t      return !textWrap || !isPlainObject(textWrap);\n\t    },\n\t    unset: function (node) {\n\t      node.textContent = '';\n\t    },\n\t    set: function (text, refBBox, node, attrs) {\n\t      const cacheName = 'joint-text';\n\t      const cache = $.data.get(node, cacheName);\n\t      const lineHeight = attrs['line-height'];\n\t      const textVerticalAnchor = attrs['text-vertical-anchor'];\n\t      const displayEmpty = attrs['display-empty'];\n\t      const fontSize = attrs['font-size'];\n\t      const annotations = attrs.annotations;\n\t      const eol = attrs.eol;\n\t      const x = attrs.x;\n\t      let textPath = attrs['text-path'];\n\t      const useNoBreakSpace = attrs['use-no-break-space'] === true;\n\t      // Update the text only if there was a change in the string\n\t      // or any of its attributes.\n\t      const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize, useNoBreakSpace]);\n\t      if (cache === undefined || cache !== textHash) {\n\t        // Chrome bug:\n\t        // <tspan> positions defined as `em` are not updated\n\t        // when container `font-size` change.\n\t        if (fontSize) node.setAttribute('font-size', fontSize);\n\t        // Text Along Path Selector\n\t        if (isObject(textPath)) {\n\t          const pathSelector = textPath.selector;\n\t          if (typeof pathSelector === 'string') {\n\t            const pathNode = this.findNode(pathSelector);\n\t            if (pathNode instanceof SVGPathElement) {\n\t              textPath = assign({\n\t                'xlink:href': '#' + pathNode.id\n\t              }, textPath);\n\t            }\n\t          }\n\t        }\n\t        V(node).text('' + text, {\n\t          lineHeight,\n\t          annotations,\n\t          textPath,\n\t          x,\n\t          textVerticalAnchor,\n\t          eol,\n\t          displayEmpty,\n\t          useNoBreakSpace\n\t        });\n\t        $.data.set(node, cacheName, textHash);\n\t      }\n\t    }\n\t  },\n\t  'text-wrap': {\n\t    qualify: isPlainObject,\n\t    set: function (value, refBBox, node, attrs) {\n\t      var size = {};\n\t      // option `width`\n\t      var width = value.width || 0;\n\t      if (isPercentage(width)) {\n\t        size.width = refBBox.width * parseFloat(width) / 100;\n\t      } else if (isCalcExpression(width)) {\n\t        size.width = Number(evalCalcExpression(width, refBBox));\n\t      } else {\n\t        if (value.width === null) {\n\t          // breakText() requires width to be specified.\n\t          size.width = Infinity;\n\t        } else if (width <= 0) {\n\t          size.width = refBBox.width + width;\n\t        } else {\n\t          size.width = width;\n\t        }\n\t      }\n\t      // option `height`\n\t      var height = value.height || 0;\n\t      if (isPercentage(height)) {\n\t        size.height = refBBox.height * parseFloat(height) / 100;\n\t      } else if (isCalcExpression(height)) {\n\t        size.height = Number(evalCalcExpression(height, refBBox));\n\t      } else {\n\t        if (value.height === null) {\n\t          // if height is not specified breakText() does not\n\t          // restrict the height of the text.\n\t        } else if (height <= 0) {\n\t          size.height = refBBox.height + height;\n\t        } else {\n\t          size.height = height;\n\t        }\n\t      }\n\t      // option `text`\n\t      var wrappedText;\n\t      var text = value.text;\n\t      if (text === undefined) text = attrs.text;\n\t      if (text !== undefined) {\n\t        const breakTextFn = value.breakText || breakText;\n\t        const computedStyles = getComputedStyle(node);\n\t        const wrapFontAttributes = {};\n\t        // The font size attributes must be set on the node\n\t        // to get the correct text wrapping.\n\t        // TODO: set the native SVG attributes before special attributes\n\t        for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n\t          const name = FONT_ATTRIBUTES[i];\n\t          if (name in attrs) {\n\t            node.setAttribute(name, attrs[name]);\n\t          }\n\t          // Note: computedStyles is a live object\n\t          // i.e. the properties are evaluated when accessed.\n\t          wrapFontAttributes[name] = computedStyles[name];\n\t        }\n\n\t        // The `line-height` attribute in SVG is JoinJS specific.\n\t        // TODO: change the `lineHeight` to breakText option.\n\t        wrapFontAttributes.lineHeight = attrs['line-height'];\n\t        let svgDocument = this.paper.svg;\n\t        if (!svgDocument.checkVisibility()) {\n\t          // If the paper is visible, we can utilize\n\t          // its SVG element to measure the text size\n\t          // when breaking the text.\n\t          // Otherwise, we need to create a temporary\n\t          // SVG document and append it to the DOM,\n\t          // (the default behavior of `breakText`).\n\t          svgDocument = null;\n\t        }\n\t        wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n\t          svgDocument,\n\t          ellipsis: value.ellipsis,\n\t          hyphen: value.hyphen,\n\t          separator: value.separator,\n\t          maxLineCount: value.maxLineCount,\n\t          preserveSpaces: value.preserveSpaces\n\t        });\n\t      } else {\n\t        wrappedText = '';\n\t      }\n\t      textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n\t    },\n\t    // We expose the font attributes list to allow\n\t    // the user to take other custom font attributes into account\n\t    // when wrapping the text.\n\t    FONT_ATTRIBUTES\n\t  },\n\t  'title': {\n\t    qualify: function (title, node) {\n\t      // HTMLElement title is specified via an attribute (i.e. not an element)\n\t      return node instanceof SVGElement;\n\t    },\n\t    unset: function (node) {\n\t      $.data.remove(node, 'joint-title');\n\t      const titleNode = node.firstElementChild;\n\t      if (titleNode) {\n\t        titleNode.remove();\n\t      }\n\t    },\n\t    set: function (title, refBBox, node) {\n\t      var cacheName = 'joint-title';\n\t      var cache = $.data.get(node, cacheName);\n\t      if (cache === undefined || cache !== title) {\n\t        $.data.set(node, cacheName, title);\n\t        if (node.tagName === 'title') {\n\t          // The target node is a <title> element.\n\t          node.textContent = title;\n\t          return;\n\t        }\n\t        // Generally <title> element should be the first child element of its parent.\n\t        var firstChild = node.firstElementChild;\n\t        if (firstChild && firstChild.tagName === 'title') {\n\t          // Update an existing title\n\t          firstChild.textContent = title;\n\t        } else {\n\t          // Create a new title\n\t          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n\t          titleNode.textContent = title;\n\t          node.insertBefore(titleNode, firstChild);\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\n\tfunction atConnectionWrapper(method, opt) {\n\t  var zeroVector = new Point(1, 0);\n\t  return function (value) {\n\t    var p, angle;\n\t    var tangent = this[method](value);\n\t    if (tangent) {\n\t      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n\t      p = tangent.start;\n\t    } else {\n\t      p = this.path.start;\n\t      angle = 0;\n\t    }\n\t    if (angle === 0) return {\n\t      transform: 'translate(' + p.x + ',' + p.y + ')'\n\t    };\n\t    return {\n\t      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n\t    };\n\t  };\n\t}\n\tfunction isLinkView() {\n\t  return this.model.isLink();\n\t}\n\tconst connectionAttributesNS = {\n\t  'connection': {\n\t    qualify: isLinkView,\n\t    unset: 'd',\n\t    set: function ({\n\t      stubs = 0\n\t    }) {\n\t      let d;\n\t      if (isFinite(stubs) && stubs !== 0) {\n\t        let offset;\n\t        if (stubs < 0) {\n\t          offset = (this.getConnectionLength() + stubs) / 2;\n\t        } else {\n\t          offset = stubs;\n\t        }\n\t        const path = this.getConnection();\n\t        const segmentSubdivisions = this.getConnectionSubdivisions();\n\t        const sourceParts = path.divideAtLength(offset, {\n\t          segmentSubdivisions\n\t        });\n\t        const targetParts = path.divideAtLength(-offset, {\n\t          segmentSubdivisions\n\t        });\n\t        if (sourceParts && targetParts) {\n\t          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n\t        }\n\t      }\n\t      return {\n\t        d: d || this.getSerializedConnection()\n\t      };\n\t    }\n\t  },\n\t  'at-connection-length-keep-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtLength', {\n\t      rotate: true\n\t    })\n\t  },\n\t  'at-connection-length-ignore-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtLength', {\n\t      rotate: false\n\t    })\n\t  },\n\t  'at-connection-ratio-keep-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtRatio', {\n\t      rotate: true\n\t    })\n\t  },\n\t  'at-connection-ratio-ignore-gradient': {\n\t    qualify: isLinkView,\n\t    unset: 'transform',\n\t    set: atConnectionWrapper('getTangentAtRatio', {\n\t      rotate: false\n\t    })\n\t  }\n\t};\n\tconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\n\tconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\n\tfunction shapeWrapper(shapeConstructor, opt) {\n\t  var cacheName = 'joint-shape';\n\t  var resetOffset = opt && opt.resetOffset;\n\t  return function (value, refBBox, node) {\n\t    var cache = $.data.get(node, cacheName);\n\t    if (!cache || cache.value !== value) {\n\t      // only recalculate if value has changed\n\t      var cachedShape = shapeConstructor(value);\n\t      cache = {\n\t        value: value,\n\t        shape: cachedShape,\n\t        shapeBBox: cachedShape.bbox()\n\t      };\n\t      $.data.set(node, cacheName, cache);\n\t    }\n\t    var shape = cache.shape.clone();\n\t    var shapeBBox = cache.shapeBBox.clone();\n\t    var shapeOrigin = shapeBBox.origin();\n\t    var refOrigin = refBBox.origin();\n\t    shapeBBox.x = refOrigin.x;\n\t    shapeBBox.y = refOrigin.y;\n\t    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n\t    // `maxRectScaleToFit` can give Infinity if width or height is 0\n\t    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n\t    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n\t    shape.scale(sx, sy, shapeOrigin);\n\t    if (resetOffset) {\n\t      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n\t    }\n\t    return shape;\n\t  };\n\t}\n\n\t// `d` attribute for SVGPaths\n\tfunction dWrapper(opt) {\n\t  function pathConstructor(value) {\n\t    return new Path$1(V.normalizePathData(value));\n\t  }\n\t  var shape = shapeWrapper(pathConstructor, opt);\n\t  return function (value, refBBox, node) {\n\t    var path = shape(value, refBBox, node);\n\t    return {\n\t      d: path.serialize()\n\t    };\n\t  };\n\t}\n\n\t// `points` attribute for SVGPolylines and SVGPolygons\n\tfunction pointsWrapper(opt) {\n\t  var shape = shapeWrapper(Polyline$1, opt);\n\t  return function (value, refBBox, node) {\n\t    var polyline = shape(value, refBBox, node);\n\t    return {\n\t      points: polyline.serialize()\n\t    };\n\t  };\n\t}\n\tconst shapeAttributesNS = {\n\t  'ref-d-reset-offset': {\n\t    unset: 'd',\n\t    set: dWrapper({\n\t      resetOffset: true\n\t    })\n\t  },\n\t  'ref-d-keep-offset': {\n\t    unset: 'd',\n\t    set: dWrapper({\n\t      resetOffset: false\n\t    })\n\t  },\n\t  'ref-points-reset-offset': {\n\t    unset: 'points',\n\t    set: pointsWrapper({\n\t      resetOffset: true\n\t    })\n\t  },\n\t  'ref-points-keep-offset': {\n\t    unset: 'points',\n\t    set: pointsWrapper({\n\t      resetOffset: false\n\t    })\n\t  }\n\t};\n\n\t// Aliases\n\tshapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];\n\tshapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];\n\n\tfunction contextMarker(context) {\n\t  var marker = {};\n\t  // Stroke\n\t  // The context 'fill' is disregarded here. The usual case is to use the marker with a connection\n\t  // (for which 'fill' attribute is set to 'none').\n\t  var stroke = context.stroke;\n\t  if (typeof stroke === 'string') {\n\t    marker['stroke'] = stroke;\n\t    marker['fill'] = stroke;\n\t  }\n\t  // Opacity\n\t  // Again the context 'fill-opacity' is ignored.\n\t  var strokeOpacity = context['stroke-opacity'];\n\t  if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n\t  if (strokeOpacity !== undefined) {\n\t    marker['stroke-opacity'] = strokeOpacity;\n\t    marker['fill-opacity'] = strokeOpacity;\n\t  }\n\t  return marker;\n\t}\n\tfunction setPaintURL(def) {\n\t  const {\n\t    paper\n\t  } = this;\n\t  const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);\n\t  return `url(#${url})`;\n\t}\n\tconst defsAttributesNS = {\n\t  'source-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-start',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), marker);\n\t      return {\n\t        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'target-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-end',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), {\n\t        'transform': 'rotate(180)'\n\t      }, marker);\n\t      return {\n\t        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'vertex-marker': {\n\t    qualify: isPlainObject,\n\t    unset: 'marker-mid',\n\t    set: function (marker, refBBox, node, attrs) {\n\t      marker = assign(contextMarker(attrs), marker);\n\t      return {\n\t        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'\n\t      };\n\t    }\n\t  },\n\t  'fill': {\n\t    qualify: isPlainObject,\n\t    set: setPaintURL\n\t  },\n\t  'stroke': {\n\t    qualify: isPlainObject,\n\t    set: setPaintURL\n\t  },\n\t  'filter': {\n\t    qualify: isPlainObject,\n\t    set: function (filter) {\n\t      return 'url(#' + this.paper.defineFilter(filter) + ')';\n\t    }\n\t  }\n\t};\n\n\t// Offset attributes require the cell view to be rendered before they can be applied\n\t// (they must be appended to the DOM).\n\n\tfunction offsetWrapper(axis, dimension, corner) {\n\t  return function (value, nodeBBox) {\n\t    var delta;\n\t    if (value === 'middle') {\n\t      delta = nodeBBox[dimension] / 2;\n\t    } else if (value === corner) {\n\t      delta = nodeBBox[dimension];\n\t    } else if (isFinite(value)) {\n\t      // TODO: or not to do a breaking change?\n\t      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n\t    } else if (isPercentage(value)) {\n\t      delta = nodeBBox[dimension] * parseFloat(value) / 100;\n\t    } else {\n\t      delta = 0;\n\t    }\n\t    var point = new Point();\n\t    point[axis] = -(nodeBBox[axis] + delta);\n\t    return point;\n\t  };\n\t}\n\tconst offsetAttributesNS = {\n\t  // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.\n\t  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\t  'x-alignment': {\n\t    offset: offsetWrapper('x', 'width', 'right')\n\t  },\n\t  // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.\n\t  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\t  'y-alignment': {\n\t    offset: offsetWrapper('y', 'height', 'bottom')\n\t  },\n\t  'reset-offset': {\n\t    offset: function (val, nodeBBox) {\n\t      return val ? {\n\t        x: -nodeBBox.x,\n\t        y: -nodeBBox.y\n\t      } : {\n\t        x: 0,\n\t        y: 0\n\t      };\n\t    }\n\t  }\n\t};\n\n\tfunction setIfChangedWrapper(attribute) {\n\t  return function setIfChanged(value, _, node) {\n\t    const vel = V(node);\n\t    if (vel.attr(attribute) === value) return;\n\t    vel.attr(attribute, value);\n\t  };\n\t}\n\tconst attributesNS = {\n\t  'ref': {\n\t    // We do not set `ref` attribute directly on an element.\n\t    // The attribute itself does not qualify for relative positioning.\n\t  },\n\t  'href': {\n\t    set: setIfChangedWrapper('href')\n\t  },\n\t  'xlink:href': {\n\t    set: setIfChangedWrapper('xlink:href')\n\t  },\n\t  // `port` attribute contains the `id` of the port that the underlying magnet represents.\n\t  'port': {\n\t    set: function (port) {\n\t      return port === null || port.id === undefined ? port : port.id;\n\t    }\n\t  },\n\t  // `style` attribute is special in the sense that it sets the CSS style of the sub-element.\n\t  'style': {\n\t    qualify: isPlainObject,\n\t    set: function (styles, refBBox, node) {\n\t      $(node).css(styles);\n\t    }\n\t  },\n\t  'html': {\n\t    unset: function (node) {\n\t      $(node).empty();\n\t    },\n\t    set: function (html, refBBox, node) {\n\t      $(node).html(html + '');\n\t    }\n\t  },\n\t  // Properties setter (set various properties on the node)\n\t  props: props$1\n\t};\n\tassign(attributesNS, legacyAttributesNS);\n\tassign(attributesNS, textAttributesNS);\n\tassign(attributesNS, connectionAttributesNS);\n\tassign(attributesNS, shapeAttributesNS);\n\tassign(attributesNS, defsAttributesNS);\n\tassign(attributesNS, offsetAttributesNS);\n\tconst attributes = attributesNS;\n\n\t// Internal tags to identify objects as specific JointJS types.\n\t// Used instead of `instanceof` for performance and cross-frame safety.\n\n\t// dia.Cell\n\tconst CELL_MARKER = Symbol('joint.cellMarker');\n\n\t// dia.CellCollection\n\tconst CELL_COLLECTION_MARKER = Symbol('joint.cellCollectionMarker');\n\n\t// dia.GraphLayer\n\tconst GRAPH_LAYER_MARKER = Symbol('joint.graphLayerMarker');\n\n\t// dia.GraphLayerCollection\n\tconst GRAPH_LAYER_COLLECTION_MARKER = Symbol('joint.graphLayerCollectionMarker');\n\n\t// dia.CellView\n\tconst CELL_VIEW_MARKER = Symbol('joint.cellViewMarker');\n\n\t// dia.LayerView\n\tconst LAYER_VIEW_MARKER = Symbol('joint.layerViewMarker');\n\n\t// dia.GraphLayerView\n\tconst GRAPH_LAYER_VIEW_MARKER = Symbol('joint.graphLayerViewMarker');\n\n\t// Cell base model.\n\t// --------------------------\n\n\tconst attributesMerger = function (a, b) {\n\t  if (Array.isArray(a)) {\n\t    return cloneDeep(b);\n\t  }\n\t};\n\tfunction removeEmptyAttributes(obj) {\n\t  // Remove toplevel empty attributes\n\t  for (const key in obj) {\n\t    const objValue = obj[key];\n\t    const isRealObject = isObject(objValue) && !Array.isArray(objValue);\n\t    if (!isRealObject) continue;\n\t    if (isEmpty(objValue)) {\n\t      delete obj[key];\n\t    }\n\t  }\n\t}\n\tconst Cell = Model.extend({\n\t  cidPrefix: 'c',\n\t  // Default attributes are merged deeply instead of shallowly.\n\t  _setDefaults: function (ctorAttributes, options) {\n\t    let attributes;\n\t    const attributeDefaults = result(this, 'defaults');\n\t    if (attributeDefaults) {\n\t      const customizer = options && options.mergeArrays === true ? false : config$3.cellDefaultsMergeStrategy || attributesMerger;\n\t      attributes = merge({}, attributeDefaults, ctorAttributes, customizer);\n\t    } else {\n\t      attributes = ctorAttributes;\n\t    }\n\t    this.set(attributes, options);\n\t  },\n\t  translate: function (dx, dy, opt) {\n\t    throw new Error('Must define a translate() method.');\n\t  },\n\t  toJSON: function (opt) {\n\t    const {\n\t      ignoreDefaults,\n\t      ignoreEmptyAttributes = false\n\t    } = opt || {};\n\t    const defaults = result(this.constructor.prototype, 'defaults');\n\t    if (ignoreDefaults === false) {\n\t      // Return all attributes without omitting the defaults\n\t      const finalAttributes = cloneDeep(this.attributes);\n\t      if (!ignoreEmptyAttributes) return finalAttributes;\n\t      removeEmptyAttributes(finalAttributes);\n\t      return finalAttributes;\n\t    }\n\t    let defaultAttributes = {};\n\t    let attributes = cloneDeep(this.attributes);\n\t    if (ignoreDefaults === true) {\n\t      // Compare all attributes with the defaults\n\t      defaultAttributes = defaults;\n\t    } else {\n\t      // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified\n\t      const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];\n\t      differentiateKeys.forEach(key => {\n\t        defaultAttributes[key] = defaults[key] || {};\n\t      });\n\t    }\n\n\t    // Omit `id` and `type` attribute from the defaults since it should be always present\n\t    const finalAttributes = objectDifference(attributes, omit(defaultAttributes, 'id', 'type'), {\n\t      maxDepth: 4\n\t    });\n\t    if (ignoreEmptyAttributes) {\n\t      removeEmptyAttributes(finalAttributes);\n\t    }\n\t    return finalAttributes;\n\t  },\n\t  initialize: function (attributes) {\n\t    const idAttribute = this.getIdAttribute();\n\t    if (!attributes || attributes[idAttribute] === undefined) {\n\t      this.set(idAttribute, this.generateId(), {\n\t        silent: true\n\t      });\n\t    }\n\t    this._transitionIds = {};\n\t    this._scheduledTransitionIds = {};\n\n\t    // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\t    this.processPorts();\n\t    this.on('change:attrs', this.processPorts, this);\n\t  },\n\t  getIdAttribute: function () {\n\t    return this.idAttribute || 'id';\n\t  },\n\t  generateId: function () {\n\t    return uuid();\n\t  },\n\t  /**\n\t   * @deprecated\n\t   */\n\t  processPorts: function () {\n\t    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n\t    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n\t    // set to that port, we remove those links as well (to follow the same behaviour as\n\t    // with a removed element).\n\n\t    var previousPorts = this.ports;\n\n\t    // Collect ports from the `attrs` object.\n\t    var ports = {};\n\t    forIn(this.get('attrs'), function (attrs, selector) {\n\t      if (attrs && attrs.port) {\n\t        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n\t        if (attrs.port.id !== undefined) {\n\t          ports[attrs.port.id] = attrs.port;\n\t        } else {\n\t          ports[attrs.port] = {\n\t            id: attrs.port\n\t          };\n\t        }\n\t      }\n\t    });\n\n\t    // Collect ports that have been removed (compared to the previous ports) - if any.\n\t    // Use hash table for quick lookup.\n\t    var removedPorts = {};\n\t    forIn(previousPorts, function (port, id) {\n\t      if (!ports[id]) removedPorts[id] = true;\n\t    });\n\n\t    // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\t    if (this.graph && !isEmpty(removedPorts)) {\n\t      var inboundLinks = this.graph.getConnectedLinks(this, {\n\t        inbound: true\n\t      });\n\t      inboundLinks.forEach(function (link) {\n\t        if (removedPorts[link.get('target').port]) link.remove();\n\t      });\n\t      var outboundLinks = this.graph.getConnectedLinks(this, {\n\t        outbound: true\n\t      });\n\t      outboundLinks.forEach(function (link) {\n\t        if (removedPorts[link.get('source').port]) link.remove();\n\t      });\n\t    }\n\n\t    // Update the `ports` object.\n\t    this.ports = ports;\n\t  },\n\t  remove: function (opt = {}) {\n\t    const {\n\t      graph,\n\t      collection\n\t    } = this;\n\t    // If the cell is part of a graph, remove it using the graph API.\n\t    // To make sure the cell is removed in a batch operation.\n\t    if (graph) {\n\t      graph.removeCell(this, opt);\n\t    } else {\n\t      // The collection is a common mvc collection (not the graph collection).\n\t      if (collection) collection.remove(this, opt);\n\t    }\n\t    return this;\n\t  },\n\t  toFront: function (opt) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (graph) {\n\t      opt = defaults(opt || {}, {\n\t        foregroundEmbeds: true\n\t      });\n\t      let cells;\n\t      if (opt.deep) {\n\t        cells = this.getEmbeddedCells({\n\t          deep: true,\n\t          breadthFirst: opt.breadthFirst !== false,\n\t          sortSiblings: opt.foregroundEmbeds\n\t        });\n\t        cells.unshift(this);\n\t      } else {\n\t        cells = [this];\n\t      }\n\t      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\t      const layerId = graph.getCellLayerId(this);\n\t      const maxZ = graph.maxZIndex(layerId);\n\t      let z = maxZ - cells.length + 1;\n\t      const layerCells = graph.getLayer(layerId).cellCollection.toArray();\n\t      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== layerCells.length - cells.length;\n\t      if (!shouldUpdate) {\n\t        shouldUpdate = sortedCells.some(function (cell, index) {\n\t          return cell.z() !== z + index;\n\t        });\n\t      }\n\t      if (shouldUpdate) {\n\t        this.startBatch('to-front');\n\t        z = z + cells.length;\n\t        sortedCells.forEach(function (cell, index) {\n\t          cell.set('z', z + index, opt);\n\t        });\n\t        this.stopBatch('to-front');\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  toBack: function (opt) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (graph) {\n\t      opt = defaults(opt || {}, {\n\t        foregroundEmbeds: true\n\t      });\n\t      let cells;\n\t      if (opt.deep) {\n\t        cells = this.getEmbeddedCells({\n\t          deep: true,\n\t          breadthFirst: opt.breadthFirst !== false,\n\t          sortSiblings: opt.foregroundEmbeds\n\t        });\n\t        cells.unshift(this);\n\t      } else {\n\t        cells = [this];\n\t      }\n\t      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\t      const layerId = graph.getCellLayerId(this);\n\t      let z = graph.minZIndex(layerId);\n\t      const layerCells = graph.getLayer(layerId).cellCollection.toArray();\n\t      let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== 0;\n\t      if (!shouldUpdate) {\n\t        shouldUpdate = sortedCells.some(function (cell, index) {\n\t          return cell.z() !== z + index;\n\t        });\n\t      }\n\t      if (shouldUpdate) {\n\t        this.startBatch('to-back');\n\t        z -= cells.length;\n\t        sortedCells.forEach(function (cell, index) {\n\t          cell.set('z', z + index, opt);\n\t        });\n\t        this.stopBatch('to-back');\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  parent: function (parent, opt) {\n\t    // getter\n\t    if (parent === undefined) return this.get('parent');\n\t    // setter\n\t    return this.set('parent', parent, opt);\n\t  },\n\t  embed: function (cell, opt = {}) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    if (!this.canEmbed(cells)) {\n\t      throw new Error('Recursive embedding not allowed.');\n\t    }\n\t    if (opt.reparent) {\n\t      const parents = uniq(cells.map(c => c.getParentCell()));\n\n\t      // Unembed cells from their current parents.\n\t      parents.forEach(parent => {\n\t        // Cell doesn't have to be embedded.\n\t        if (!parent) return;\n\n\t        // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases\n\t        // where not all elements of `cells` are embedded in the same parent.\n\t        parent._unembedCells(cells, opt);\n\t      });\n\t    } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n\t      throw new Error('Embedding of already embedded cells is not allowed.');\n\t    }\n\t    this._embedCells(cells, opt);\n\t    return this;\n\t  },\n\t  unembed: function (cell, opt) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    this._unembedCells(cells, opt);\n\t    return this;\n\t  },\n\t  canEmbed: function (cell) {\n\t    const cells = Array.isArray(cell) ? cell : [cell];\n\t    return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n\t  },\n\t  _embedCells: function (cells, opt) {\n\t    const batchName = 'embed';\n\t    this.startBatch(batchName);\n\t    const embeds = assign([], this.get('embeds'));\n\t    cells.forEach(cell => {\n\t      // We keep all element ids after link ids.\n\t      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n\t      cell.parent(this.id, opt);\n\t    });\n\t    this.set('embeds', uniq(embeds), opt);\n\t    this.stopBatch(batchName);\n\t  },\n\t  _unembedCells: function (cells, opt) {\n\t    const batchName = 'unembed';\n\t    this.startBatch(batchName);\n\t    cells.forEach(cell => cell.unset('parent', opt));\n\t    this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n\t    this.stopBatch(batchName);\n\t  },\n\t  getParentCell: function () {\n\t    // unlike link.source/target, cell.parent stores id directly as a string\n\t    var parentId = this.parent();\n\t    var graph = this.graph;\n\t    return parentId && graph && graph.getCell(parentId) || null;\n\t  },\n\t  // Return an array of ancestor cells.\n\t  // The array is ordered from the parent of the cell\n\t  // to the most distant ancestor.\n\t  getAncestors: function () {\n\t    var ancestors = [];\n\t    if (!this.graph) {\n\t      return ancestors;\n\t    }\n\t    var parentCell = this.getParentCell();\n\t    while (parentCell) {\n\t      ancestors.push(parentCell);\n\t      parentCell = parentCell.getParentCell();\n\t    }\n\t    return ancestors;\n\t  },\n\t  getEmbeddedCells: function (opt) {\n\t    opt = opt || {};\n\n\t    // Cell models can only be retrieved when this element is part of a collection.\n\t    // There is no way this element knows about other cells otherwise.\n\t    // This also means that calling e.g. `translate()` on an element with embeds before\n\t    // adding it to a graph does not translate its embeds.\n\t    if (!this.graph) {\n\t      return [];\n\t    }\n\t    if (opt.deep) {\n\t      if (opt.breadthFirst) {\n\t        return this._getEmbeddedCellsBfs(opt.sortSiblings);\n\t      } else {\n\t        return this._getEmbeddedCellsDfs(opt.sortSiblings);\n\t      }\n\t    }\n\t    const embeddedIds = this.get('embeds');\n\t    if (isEmpty(embeddedIds)) {\n\t      return [];\n\t    }\n\t    let cells = embeddedIds.map(this.graph.getCell, this.graph);\n\t    if (opt.sortSiblings) {\n\t      cells = sortBy(cells, cell => cell.z());\n\t    }\n\t    return cells;\n\t  },\n\t  _getEmbeddedCellsBfs: function (sortSiblings) {\n\t    const cells = [];\n\t    const queue = [];\n\t    queue.push(this);\n\t    while (queue.length > 0) {\n\t      const current = queue.shift();\n\t      cells.push(current);\n\t      const embeddedCells = current.getEmbeddedCells({\n\t        sortSiblings: sortSiblings\n\t      });\n\t      queue.push(...embeddedCells);\n\t    }\n\t    cells.shift();\n\t    return cells;\n\t  },\n\t  _getEmbeddedCellsDfs: function (sortSiblings) {\n\t    const cells = [];\n\t    const stack = [];\n\t    stack.push(this);\n\t    while (stack.length > 0) {\n\t      const current = stack.pop();\n\t      cells.push(current);\n\t      const embeddedCells = current.getEmbeddedCells({\n\t        sortSiblings: sortSiblings\n\t      });\n\n\t      // When using the stack, cells that are embedded last are processed first.\n\t      // To maintain the original order, we need to push the cells in reverse order\n\t      for (let i = embeddedCells.length - 1; i >= 0; --i) {\n\t        stack.push(embeddedCells[i]);\n\t      }\n\t    }\n\t    cells.shift();\n\t    return cells;\n\t  },\n\t  isEmbeddedIn: function (cell, opt) {\n\t    var cellId = isString(cell) ? cell : cell.id;\n\t    var parentId = this.parent();\n\t    opt = assign({\n\t      deep: true\n\t    }, opt);\n\n\t    // See getEmbeddedCells().\n\t    if (this.graph && opt.deep) {\n\t      while (parentId) {\n\t        if (parentId === cellId) {\n\t          return true;\n\t        }\n\t        parentId = this.graph.getCell(parentId).parent();\n\t      }\n\t      return false;\n\t    } else {\n\t      // When this cell is not part of a collection check\n\t      // at least whether it's a direct child of given cell.\n\t      return parentId === cellId;\n\t    }\n\t  },\n\t  // Whether or not the cell is embedded in any other cell.\n\t  isEmbedded: function () {\n\t    return !!this.parent();\n\t  },\n\t  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n\t  // Shallow cloning simply clones the cell and returns a new cell with different ID.\n\t  // Deep cloning clones the cell and all its embedded cells recursively.\n\t  clone: function (opt) {\n\t    opt = opt || {};\n\t    if (!opt.deep) {\n\t      // Shallow cloning.\n\n\t      // Preserve the original's `portLayoutNamespace` and `portLabelLayoutNamespace`.\n\t      const clone = new this.constructor(this.attributes, {\n\t        portLayoutNamespace: this.portLayoutNamespace,\n\t        portLabelLayoutNamespace: this.portLabelLayoutNamespace\n\t      });\n\t      // We don't want the clone to have the same ID as the original.\n\t      clone.set(this.getIdAttribute(), this.generateId());\n\t      // A shallow cloned element does not carry over the original embeds.\n\t      clone.unset('embeds');\n\t      // And can not be embedded in any cell\n\t      // as the clone is not part of the graph.\n\t      clone.unset('parent');\n\t      return clone;\n\t    } else {\n\t      // Deep cloning.\n\n\t      // For a deep clone, simply call `util.cloneCells()` with the cell and all its embedded cells.\n\t      return toArray$1(cloneCells([this].concat(this.getEmbeddedCells({\n\t        deep: true\n\t      }))));\n\t    }\n\t  },\n\t  // A convenient way to set nested properties.\n\t  // This method merges the properties you'd like to set with the ones\n\t  // stored in the cell and makes sure change events are properly triggered.\n\t  // You can either set a nested property with one object\n\t  // or use a property path.\n\t  // The most simple use case is:\n\t  // `cell.prop('name/first', 'John')` or\n\t  // `cell.prop({ name: { first: 'John' } })`.\n\t  // Nested arrays are supported too:\n\t  // `cell.prop('series/0/data/0/degree', 50)` or\n\t  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n\t  prop: function (props, value, opt) {\n\t    var delim = '/';\n\t    var _isString = isString(props);\n\t    if (_isString || Array.isArray(props)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\n\t      if (arguments.length > 1) {\n\t        var path;\n\t        var pathArray;\n\t        if (_isString) {\n\t          path = props;\n\t          pathArray = path.split('/');\n\t        } else {\n\t          path = props.join(delim);\n\t          pathArray = props.slice();\n\t        }\n\t        var property = pathArray[0];\n\t        var pathArrayLength = pathArray.length;\n\t        const options = opt || {};\n\t        options.propertyPath = path;\n\t        options.propertyValue = value;\n\t        options.propertyPathArray = pathArray;\n\t        if (!('rewrite' in options)) {\n\t          options.rewrite = false;\n\t        }\n\t        var update = {};\n\t        // Initialize the nested object. Sub-objects are either arrays or objects.\n\t        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n\t        // Note that this imposes a limitation on object keys one can use with Inspector.\n\t        // Pure integer keys will cause issues and are therefore not allowed.\n\t        var initializer = update;\n\t        var prevProperty = property;\n\t        for (var i = 1; i < pathArrayLength; i++) {\n\t          var pathItem = pathArray[i];\n\t          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n\t          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n\t          prevProperty = pathItem;\n\t        }\n\n\t        // Fill update with the `value` on `path`.\n\t        update = setByPath(update, pathArray, value, '/');\n\t        var baseAttributes = merge({}, this.attributes);\n\t        // if rewrite mode enabled, we replace value referenced by path with\n\t        // the new one (we don't merge).\n\t        options.rewrite && unsetByPath(baseAttributes, path, '/');\n\n\t        // Merge update with the model attributes.\n\t        var attributes = merge(baseAttributes, update, config$3.cellMergeStrategy);\n\t        // Finally, set the property to the updated attributes.\n\t        return this.set(property, attributes[property], options);\n\t      } else {\n\t        return getByPath(this.attributes, props, delim);\n\t      }\n\t    }\n\t    const options = value || {};\n\t    // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n\t    options.propertyPath = null;\n\t    options.propertyValue = props;\n\t    options.propertyPathArray = [];\n\t    if (!('rewrite' in options)) {\n\t      options.rewrite = false;\n\t    }\n\n\t    // Create a new object containing only the changed attributes.\n\t    const changedAttributes = {};\n\t    for (const key in props) {\n\t      // Merging the values of changed attributes with the current ones.\n\t      const {\n\t        changedValue\n\t      } = merge(merge({}, {\n\t        changedValue: this.attributes[key]\n\t      }), {\n\t        changedValue: props[key]\n\t      }, config$3.cellMergeStrategy);\n\t      changedAttributes[key] = changedValue;\n\t    }\n\t    return this.set(changedAttributes, options);\n\t  },\n\t  // A convenient way to unset nested properties\n\t  removeProp: function (path, opt) {\n\t    opt = opt || {};\n\t    var pathArray = Array.isArray(path) ? path : path.split('/');\n\n\t    // Once a property is removed from the `attrs` attribute\n\t    // the cellView will recognize a `dirty` flag and re-render itself\n\t    // in order to remove the attribute from SVG element.\n\t    var property = pathArray[0];\n\t    if (property === 'attrs') opt.dirty = true;\n\t    if (pathArray.length === 1) {\n\t      // A top level property\n\t      return this.unset(path, opt);\n\t    }\n\n\t    // A nested property\n\t    var nestedPath = pathArray.slice(1);\n\t    var propertyValue = this.get(property);\n\t    if (propertyValue === undefined || propertyValue === null) return this;\n\t    propertyValue = cloneDeep(propertyValue);\n\t    unsetByPath(propertyValue, nestedPath, '/');\n\t    return this.set(property, propertyValue, opt);\n\t  },\n\t  // A convenient way to set nested attributes.\n\t  attr: function (attrs, value, opt) {\n\t    var args = Array.from(arguments);\n\t    if (args.length === 0) {\n\t      return this.get('attrs');\n\t    }\n\t    if (Array.isArray(attrs)) {\n\t      args[0] = ['attrs'].concat(attrs);\n\t    } else if (isString(attrs)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\t      args[0] = 'attrs/' + attrs;\n\t    } else {\n\t      args[0] = {\n\t        'attrs': attrs\n\t      };\n\t    }\n\t    return this.prop.apply(this, args);\n\t  },\n\t  // A convenient way to unset nested attributes\n\t  removeAttr: function (path, opt) {\n\t    if (Array.isArray(path)) {\n\t      return this.removeProp(['attrs'].concat(path));\n\t    }\n\t    return this.removeProp('attrs/' + path, opt);\n\t  },\n\t  transition: function (path, value, opt, delim) {\n\t    delim = delim || '/';\n\t    var defaults = {\n\t      duration: 100,\n\t      delay: 10,\n\t      timingFunction: timing.linear,\n\t      valueFunction: interpolate.number\n\t    };\n\t    opt = assign(defaults, opt);\n\t    var firstFrameTime = 0;\n\t    var interpolatingFunction;\n\t    const transitionKey = Array.isArray(path) ? path.join(delim) : path;\n\t    var setter = function (runtime) {\n\t      var id, progress, propertyValue;\n\t      firstFrameTime = firstFrameTime || runtime;\n\t      runtime -= firstFrameTime;\n\t      progress = runtime / opt.duration;\n\t      if (progress < 1) {\n\t        this._transitionIds[transitionKey] = id = nextFrame(setter);\n\t      } else {\n\t        progress = 1;\n\t        delete this._transitionIds[transitionKey];\n\t      }\n\t      propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\t      opt.transitionId = id;\n\t      this.prop(path, propertyValue, opt);\n\t      if (!id) this.trigger('transition:end', this, transitionKey);\n\t    }.bind(this);\n\t    const {\n\t      _scheduledTransitionIds\n\t    } = this;\n\t    let initialId;\n\t    var initiator = callback => {\n\t      if (_scheduledTransitionIds[transitionKey]) {\n\t        _scheduledTransitionIds[transitionKey] = without(_scheduledTransitionIds[transitionKey], initialId);\n\t        if (_scheduledTransitionIds[transitionKey].length === 0) {\n\t          delete _scheduledTransitionIds[transitionKey];\n\t        }\n\t      }\n\t      this.stopPendingTransitions(path, delim);\n\t      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\t      this._transitionIds[transitionKey] = nextFrame(callback);\n\t      this.trigger('transition:start', this, transitionKey);\n\t    };\n\t    initialId = setTimeout(initiator, opt.delay, setter);\n\t    _scheduledTransitionIds[transitionKey] || (_scheduledTransitionIds[transitionKey] = []);\n\t    _scheduledTransitionIds[transitionKey].push(initialId);\n\t    return initialId;\n\t  },\n\t  getTransitions: function () {\n\t    return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n\t  },\n\t  stopScheduledTransitions: function (path, delim = '/') {\n\t    const {\n\t      _scheduledTransitionIds = {}\n\t    } = this;\n\t    let transitions = Object.keys(_scheduledTransitionIds);\n\t    if (path) {\n\t      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values\n\t      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);\n\t      transitions = transitions.filter(key => {\n\t        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t      });\n\t    }\n\t    transitions.forEach(key => {\n\t      const transitionIds = _scheduledTransitionIds[key];\n\t      // stop the initiator\n\t      transitionIds.forEach(transitionId => clearTimeout(transitionId));\n\t      delete _scheduledTransitionIds[key];\n\t      // Note: we could trigger transition:cancel` event here\n\t    });\n\t    return this;\n\t  },\n\t  stopPendingTransitions(path, delim = '/') {\n\t    const {\n\t      _transitionIds = {}\n\t    } = this;\n\t    let transitions = Object.keys(_transitionIds);\n\t    if (path) {\n\t      // Ensure all path segments are strings for `isEqual` comparison, since it strictly compares values\n\t      const pathArray = Array.isArray(path) ? path.map(item => String(item)) : path.split(delim);\n\t      transitions = transitions.filter(key => {\n\t        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t      });\n\t    }\n\t    transitions.forEach(key => {\n\t      const transitionId = _transitionIds[key];\n\t      // stop the setter\n\t      cancelFrame(transitionId);\n\t      delete _transitionIds[key];\n\t      this.trigger('transition:end', this, key);\n\t    });\n\t  },\n\t  stopTransitions: function (path, delim = '/') {\n\t    this.stopScheduledTransitions(path, delim);\n\t    this.stopPendingTransitions(path, delim);\n\t    return this;\n\t  },\n\t  // A shortcut making it easy to create constructs like the following:\n\t  // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n\t  addTo: function (graph, opt) {\n\t    graph.addCell(this, opt);\n\t    return this;\n\t  },\n\t  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n\t  // making it easy to create constructs like the following:\n\t  // `cell.findView(paper).highlight()`\n\t  findView: function (paper) {\n\t    return paper.findViewByModel(this);\n\t  },\n\t  isElement: function () {\n\t    return false;\n\t  },\n\t  isLink: function () {\n\t    return false;\n\t  },\n\t  startBatch: function (name, opt) {\n\t    if (this.graph) {\n\t      this.graph.startBatch(name, assign({}, opt, {\n\t        cell: this\n\t      }));\n\t    }\n\t    return this;\n\t  },\n\t  stopBatch: function (name, opt) {\n\t    if (this.graph) {\n\t      this.graph.stopBatch(name, assign({}, opt, {\n\t        cell: this\n\t      }));\n\t    }\n\t    return this;\n\t  },\n\t  getChangeFlag: function (attributes) {\n\t    var flag = 0;\n\t    if (!attributes) return flag;\n\t    for (var key in attributes) {\n\t      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n\t      flag |= attributes[key];\n\t    }\n\t    return flag;\n\t  },\n\t  angle: function () {\n\t    // To be overridden.\n\t    return 0;\n\t  },\n\t  position: function () {\n\t    // To be overridden.\n\t    return new Point(0, 0);\n\t  },\n\t  z: function () {\n\t    return this.get('z') || 0;\n\t  },\n\t  getPointFromConnectedLink: function () {\n\t    // To be overridden\n\t    return new Point();\n\t  },\n\t  getBBox: function () {\n\t    // To be overridden\n\t    return new Rect(0, 0, 0, 0);\n\t  },\n\t  getCenter: function () {\n\t    return this.getBBox().center();\n\t  },\n\t  getPointRotatedAroundCenter(angle, x, y) {\n\t    const point = new Point(x, y);\n\t    if (angle) point.rotate(this.getCenter(), angle);\n\t    return point;\n\t  },\n\t  getAbsolutePointFromRelative(x, y) {\n\t    // Rotate the position to take the model angle into account\n\t    return this.getPointRotatedAroundCenter(-this.angle(),\n\t    // Transform the relative position to absolute\n\t    this.position().offset(x, y));\n\t  },\n\t  getRelativePointFromAbsolute(x, y) {\n\t    return this\n\t    // Rotate the coordinates to mitigate the element's rotation.\n\t    .getPointRotatedAroundCenter(this.angle(), x, y)\n\t    // Transform the absolute position into relative\n\t    .difference(this.position());\n\t  },\n\t  layer: function (layerId, opt) {\n\t    const layerAttribute = config$3.layerAttribute;\n\n\t    // Getter:\n\n\t    // If `undefined` return the current layer ID\n\t    if (layerId === undefined) {\n\t      return this.get(layerAttribute) || null;\n\t    }\n\n\t    // Setter:\n\n\t    // If strictly `null` unset the layer\n\t    if (layerId === null) {\n\t      return this.unset(layerAttribute, opt);\n\t    }\n\n\t    // Otherwise set the layer ID\n\t    if (!isString(layerId)) {\n\t      throw new Error('dia.Cell: Layer id must be a string.');\n\t    }\n\t    return this.set(layerAttribute, layerId, opt);\n\t  }\n\t}, {\n\t  getAttributeDefinition: function (attrName) {\n\t    const defNS = this.attributes;\n\t    const globalDefNS = attributes;\n\t    const definition = defNS && defNS[attrName] || globalDefNS[attrName];\n\t    return definition !== undefined ? definition : null;\n\t  },\n\t  define: function (type, defaults, protoProps, staticProps) {\n\t    protoProps = assign({\n\t      defaults: defaultsDeep({\n\t        type: type\n\t      }, defaults, this.prototype.defaults)\n\t    }, protoProps);\n\t    var Cell = this.extend(protoProps, staticProps);\n\t    // es5 backward compatibility\n\t    /* eslint-disable no-undef */\n\t    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n\t      setByPath(joint.shapes, type, Cell, '.');\n\t    }\n\t    /* eslint-enable no-undef */\n\t    return Cell;\n\t  }\n\t});\n\tObject.defineProperty(Cell.prototype, CELL_MARKER, {\n\t  value: true\n\t});\n\n\tconst wrapWith = function (object, methods, wrapper) {\n\t  if (isString(wrapper)) {\n\t    if (!wrappers[wrapper]) {\n\t      throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n\t    }\n\t    wrapper = wrappers[wrapper];\n\t  }\n\t  if (!isFunction(wrapper)) {\n\t    throw new Error('Wrapper must be a function.');\n\t  }\n\t  toArray$1(methods).forEach(function (method) {\n\t    object[method] = wrapper(object[method]);\n\t  });\n\t};\n\tconst wrappers = {\n\t  cells: function (fn) {\n\t    return function () {\n\t      var args = Array.from(arguments);\n\t      var n = args.length;\n\t      var cells = n > 0 && args[0] || [];\n\t      var opt = n > 1 && args[n - 1] || {};\n\t      if (!Array.isArray(cells)) {\n\t        if (opt instanceof Cell) {\n\t          cells = args;\n\t        } else if (cells instanceof Cell) {\n\t          if (args.length > 1) {\n\t            args.pop();\n\t          }\n\t          cells = args;\n\t        }\n\t      }\n\t      if (opt instanceof Cell) {\n\t        opt = {};\n\t      }\n\t      return fn.call(this, cells, opt);\n\t    };\n\t  }\n\t};\n\n\tfunction svg(strings, ...expressions) {\n\t  const svgParts = [];\n\t  strings.forEach((part, index) => {\n\t    svgParts.push(part);\n\t    if (index in expressions) {\n\t      svgParts.push(expressions[index]);\n\t    }\n\t  });\n\t  const markup = parseFromSVGString(svgParts.join(''));\n\t  return markup;\n\t}\n\tfunction parseFromSVGString(str) {\n\t  const parser = new DOMParser();\n\t  const markupString = `<svg>${str.trim()}</svg>`;\n\t  const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n\t  if (xmldocument.getElementsByTagName('parsererror')[0]) {\n\t    throw new Error('Invalid SVG markup');\n\t  }\n\t  const document = parser.parseFromString(markupString, 'text/html');\n\t  const svg = document.querySelector('svg');\n\t  return build(svg);\n\t}\n\tfunction buildNode(node) {\n\t  const markupNode = {};\n\t  const {\n\t    tagName,\n\t    attributes,\n\t    namespaceURI,\n\t    style,\n\t    childNodes\n\t  } = node;\n\t  markupNode.namespaceURI = namespaceURI;\n\t  markupNode.tagName = namespaceURI === V.namespace.xhtml\n\t  // XHTML documents must use lower case for all HTML element and attribute names.\n\t  // The tagName property returns upper case value for HTML elements.\n\t  // e.g. <DIV> vs.<div/>\n\t  ? tagName.toLowerCase() : tagName;\n\t  const stylesObject = {};\n\t  for (var i = style.length; i--;) {\n\t    var nameString = style[i];\n\t    stylesObject[nameString] = style.getPropertyValue(nameString);\n\t  }\n\t  markupNode.style = stylesObject;\n\n\t  // selector fallbacks to tagName\n\t  const selectorAttribute = attributes.getNamedItem('@selector');\n\t  if (selectorAttribute) {\n\t    markupNode.selector = selectorAttribute.value;\n\t    attributes.removeNamedItem('@selector');\n\t  }\n\t  const groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n\t  if (groupSelectorAttribute) {\n\t    const groupSelectors = groupSelectorAttribute.value.split(',');\n\t    markupNode.groupSelector = groupSelectors.map(s => s.trim());\n\t    attributes.removeNamedItem('@group-selector');\n\t  }\n\t  const className = attributes.getNamedItem('class');\n\t  if (className) {\n\t    markupNode.className = className.value;\n\t  }\n\t  const children = [];\n\t  childNodes.forEach(node => {\n\t    switch (node.nodeType) {\n\t      case Node.TEXT_NODE:\n\t        {\n\t          const trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n\t          if (trimmedText.trim()) {\n\t            children.push(trimmedText);\n\t          }\n\t          break;\n\t        }\n\t      case Node.ELEMENT_NODE:\n\t        {\n\t          children.push(buildNode(node));\n\t          break;\n\t        }\n\t      default:\n\t        break;\n\t    }\n\t  });\n\t  if (children.length) {\n\t    markupNode.children = children;\n\t  }\n\t  const nodeAttrs = {};\n\t  Array.from(attributes).forEach(nodeAttribute => {\n\t    const {\n\t      name,\n\t      value\n\t    } = nodeAttribute;\n\t    nodeAttrs[name] = value;\n\t  });\n\t  if (Object.keys(nodeAttrs).length > 0) {\n\t    markupNode.attributes = nodeAttrs;\n\t  }\n\t  return markupNode;\n\t}\n\tfunction build(root) {\n\t  const markup = [];\n\t  Array.from(root.children).forEach(node => {\n\t    markup.push(buildNode(node));\n\t  });\n\t  return markup;\n\t}\n\n\tconst Positions = {\n\t  TOP: 'top',\n\t  RIGHT: 'right',\n\t  BOTTOM: 'bottom',\n\t  LEFT: 'left',\n\t  TOP_LEFT: 'top-left',\n\t  TOP_RIGHT: 'top-right',\n\t  BOTTOM_LEFT: 'bottom-left',\n\t  BOTTOM_RIGHT: 'bottom-right',\n\t  CENTER: 'center'\n\t};\n\tfunction getRectPoint(rect, position) {\n\t  const r = new Rect(rect);\n\t  switch (position) {\n\t    case undefined:\n\t      throw new Error('Position required');\n\n\t    // Middle Points\n\t    case Positions.LEFT:\n\t    case 'leftMiddle':\n\t      return r.leftMiddle();\n\t    case Positions.RIGHT:\n\t    case 'rightMiddle':\n\t      return r.rightMiddle();\n\t    case Positions.TOP:\n\t    case 'topMiddle':\n\t      return r.topMiddle();\n\t    case Positions.BOTTOM:\n\t    case 'bottomMiddle':\n\t      return r.bottomMiddle();\n\n\t    // Corners\n\t    case Positions.TOP_LEFT:\n\t    case 'topLeft':\n\t    case 'origin':\n\t      return r.topLeft();\n\t    case Positions.TOP_RIGHT:\n\t    case 'topRight':\n\t      return r.topRight();\n\t    case Positions.BOTTOM_LEFT:\n\t    case 'bottomLeft':\n\t      return r.bottomLeft();\n\t    case Positions.BOTTOM_RIGHT:\n\t    case 'bottomRight':\n\t    case 'corner':\n\t      return r.bottomRight();\n\n\t    // Center\n\t    case Positions.CENTER:\n\t      return r.center();\n\n\t    // TODO: calc(), percentage etc.\n\t    default:\n\t      throw new Error(`Unknown position: ${position}`);\n\t  }\n\t}\n\n\tvar index$6 = {\n\t\t__proto__: null,\n\t\taddClassNamePrefix: addClassNamePrefix,\n\t\tassign: assign,\n\t\tbindAll: bindAll,\n\t\tbreakText: breakText,\n\t\tcamelCase: camelCase,\n\t\tcancelFrame: cancelFrame,\n\t\tcap: cap,\n\t\tclone: clone$1,\n\t\tcloneCells: cloneCells,\n\t\tcloneDeep: cloneDeep,\n\t\tdataUriToBlob: dataUriToBlob,\n\t\tdebounce: debounce,\n\t\tdeepMixin: deepMixin,\n\t\tdeepSupplement: deepSupplement,\n\t\tdefaults: defaults,\n\t\tdefaultsDeep: defaultsDeep,\n\t\tdifference: difference,\n\t\tdownloadBlob: downloadBlob,\n\t\tdownloadDataUri: downloadDataUri,\n\t\tevalCalcExpression: evalCalcExpression,\n\t\tevalCalcFormula: evalCalcFormula,\n\t\tfilter: filter,\n\t\tflattenDeep: flattenDeep,\n\t\tflattenObject: flattenObject,\n\t\tforIn: forIn,\n\t\tformat: format$1,\n\t\tgetByPath: getByPath,\n\t\tgetElementBBox: getElementBBox,\n\t\tgetRectPoint: getRectPoint,\n\t\tgroupBy: groupBy,\n\t\tguid: guid,\n\t\thas: has,\n\t\thashCode: hashCode,\n\t\timageToDataUri: imageToDataUri,\n\t\tinterpolate: interpolate,\n\t\tintersection: intersection,\n\t\tinvoke: invoke,\n\t\tinvokeProperty: invokeProperty,\n\t\tisBoolean: isBoolean,\n\t\tisCalcExpression: isCalcExpression,\n\t\tisEmpty: isEmpty,\n\t\tisEqual: isEqual,\n\t\tisFunction: isFunction,\n\t\tisNumber: isNumber,\n\t\tisObject: isObject,\n\t\tisPercentage: isPercentage,\n\t\tisPlainObject: isPlainObject,\n\t\tisString: isString,\n\t\tmerge: merge,\n\t\tmixin: mixin,\n\t\tnextFrame: nextFrame,\n\t\tnoop: noop,\n\t\tnormalizeEvent: normalizeEvent,\n\t\tnormalizeSides: normalizeSides,\n\t\tnormalizeWheel: normalizeWheel,\n\t\tobjectDifference: objectDifference,\n\t\tomit: omit,\n\t\tparseCssNumeric: parseCssNumeric,\n\t\tparseDOMJSON: parseDOMJSON,\n\t\tpick: pick,\n\t\tremoveClassNamePrefix: removeClassNamePrefix,\n\t\tresult: result,\n\t\tsanitizeHTML: sanitizeHTML,\n\t\tsetAttributesBySelector: setAttributesBySelector,\n\t\tsetByPath: setByPath,\n\t\tsortBy: sortBy,\n\t\tsortElements: sortElements,\n\t\tsortedIndex: sortedIndex,\n\t\tsupplement: supplement,\n\t\tsvg: svg,\n\t\ttemplate: template,\n\t\ttiming: timing,\n\t\ttoArray: toArray$1,\n\t\ttoKebabCase: toKebabCase,\n\t\ttoggleFullScreen: toggleFullScreen,\n\t\tunion: union,\n\t\tuniq: uniq,\n\t\tuniqueId: uniqueId,\n\t\tunsetByPath: unsetByPath,\n\t\tuuid: uuid,\n\t\twithout: without,\n\t\twrapWith: wrapWith,\n\t\twrappers: wrappers\n\t};\n\n\tfunction parseCoordinate(coordinate, dimension, bbox, value) {\n\t  if (isPercentage(value)) {\n\t    return parseFloat(value) / 100 * bbox[dimension];\n\t  }\n\t  if (isCalcExpression(value)) {\n\t    return Number(evalCalcExpression(value, bbox));\n\t  }\n\t  if (typeof value === 'string') {\n\t    const num = Number(value);\n\t    if (isNaN(num)) {\n\t      throw new TypeError(`Cannot convert port coordinate ${coordinate}: \"${value}\" to a number`);\n\t    }\n\t    return num;\n\t  }\n\t  return value;\n\t}\n\tfunction portTransformAttrs(point, angle, opt) {\n\t  var trans = point.toJSON();\n\t  trans.angle = angle || 0;\n\t  return defaults({}, opt, trans);\n\t}\n\tfunction lineLayout(ports, p1, p2, elBBox) {\n\t  return ports.map(function (port, index, ports) {\n\t    var p = this.pointAt((index + 0.5) / ports.length);\n\t    // `dx`,`dy` per port offset option\n\t    if (port.dx || port.dy) {\n\t      p.offset(port.dx || 0, port.dy || 0);\n\t    }\n\t    return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n\t  }, line$1(p1, p2));\n\t}\n\tfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\t  var center = elBBox.center();\n\t  var ratio = elBBox.width / elBBox.height;\n\t  var p1 = elBBox.topMiddle();\n\t  var ellipse = Ellipse$1.fromRect(elBBox);\n\t  return ports.map(function (port, index, ports) {\n\t    var angle = startAngle + stepFn(index, ports.length);\n\t    var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);\n\t    var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n\t    // `dx`,`dy` per port offset option\n\t    if (port.dx || port.dy) {\n\t      p2.offset(port.dx || 0, port.dy || 0);\n\t    }\n\n\t    // `dr` delta radius option\n\t    if (port.dr) {\n\t      p2.move(center, port.dr);\n\t    }\n\t    return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n\t  });\n\t}\n\tfunction argTransform(bbox, args) {\n\t  let {\n\t    x,\n\t    y,\n\t    angle\n\t  } = args;\n\t  return {\n\t    x: parseCoordinate('x', 'width', bbox, x),\n\t    y: parseCoordinate('y', 'height', bbox, y),\n\t    angle\n\t  };\n\t}\n\n\t// Creates a point stored in arguments\n\tfunction argPoint(bbox, args) {\n\t  const {\n\t    x,\n\t    y\n\t  } = argTransform(bbox, args);\n\t  return new Point(x || 0, y || 0);\n\t}\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst absolute = function (ports, elBBox, opt) {\n\t  return ports.map(port => {\n\t    const transformation = argPoint(elBBox, port).round().toJSON();\n\t    transformation.angle = port.angle || 0;\n\t    return transformation;\n\t  });\n\t};\n\n\t/**\n\t * @deprecated\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst fn = function (ports, elBBox, opt) {\n\t  return opt.fn(ports, elBBox, opt);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst line = function (ports, elBBox, opt) {\n\t  var start = argPoint(elBBox, opt.start || elBBox.origin());\n\t  var end = argPoint(elBBox, opt.end || elBBox.corner());\n\t  return lineLayout(ports, start, end, elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst left$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst right$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst top$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst bottom$2 = function (ports, elBBox, opt) {\n\t  return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst ellipseSpread = function (ports, elBBox, opt) {\n\t  var startAngle = opt.startAngle || 0;\n\t  var stepAngle = opt.step || 360 / ports.length;\n\t  return ellipseLayout(ports, elBBox, startAngle, function (index) {\n\t    return index * stepAngle;\n\t  });\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tconst ellipse = function (ports, elBBox, opt) {\n\t  var startAngle = opt.startAngle || 0;\n\t  var stepAngle = opt.step || 20;\n\t  return ellipseLayout(ports, elBBox, startAngle, function (index, count) {\n\t    return (index + 0.5 - count / 2) * stepAngle;\n\t  });\n\t};\n\n\tvar Port = {\n\t\t__proto__: null,\n\t\tabsolute: absolute,\n\t\tbottom: bottom$2,\n\t\tellipse: ellipse,\n\t\tellipseSpread: ellipseSpread,\n\t\tfn: fn,\n\t\tleft: left$2,\n\t\tline: line,\n\t\tright: right$2,\n\t\ttop: top$2\n\t};\n\n\tfunction labelAttributes(opt1, opt2) {\n\t  // use value from `opt2` if it is missing in `opt1`\n\t  // use value from this object if it is missing in `opt2` as well\n\t  return defaultsDeep({}, opt1, opt2, {\n\t    x: 0,\n\t    y: 0,\n\t    angle: 0,\n\t    attrs: {}\n\t  });\n\t}\n\tfunction getBBoxAngles(elBBox) {\n\t  var center = elBBox.center();\n\t  var tl = center.theta(elBBox.origin());\n\t  var bl = center.theta(elBBox.bottomLeft());\n\t  var br = center.theta(elBBox.corner());\n\t  var tr = center.theta(elBBox.topRight());\n\t  return [tl, tr, br, bl];\n\t}\n\tfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 15\n\t  });\n\t  var angle = elBBox.center().theta(portPosition);\n\t  var tx, ty, y, textAnchor;\n\t  var offset = opt.offset;\n\t  var orientAngle = 0;\n\t  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n\t  if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n\t    y = '.3em';\n\t    tx = offset;\n\t    ty = 0;\n\t    textAnchor = 'start';\n\t  } else if (angle < topLeftAngle) {\n\t    tx = 0;\n\t    ty = -offset;\n\t    if (autoOrient) {\n\t      orientAngle = -90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '0';\n\t    }\n\t  } else if (angle < topRightAngle) {\n\t    y = '.3em';\n\t    tx = -offset;\n\t    ty = 0;\n\t    textAnchor = 'end';\n\t  } else {\n\t    tx = 0;\n\t    ty = offset;\n\t    if (autoOrient) {\n\t      orientAngle = 90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '.6em';\n\t    }\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(tx),\n\t    y: round(ty),\n\t    angle: orientAngle,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 15\n\t  });\n\t  var angle = elBBox.center().theta(portPosition);\n\t  var tx, ty, y, textAnchor;\n\t  var offset = opt.offset;\n\t  var orientAngle = 0;\n\t  const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n\t  if (angle < bottomLeftAngle || angle > bottomRightAngle) {\n\t    y = '.3em';\n\t    tx = -offset;\n\t    ty = 0;\n\t    textAnchor = 'end';\n\t  } else if (angle < topLeftAngle) {\n\t    tx = 0;\n\t    ty = offset;\n\t    if (autoOrient) {\n\t      orientAngle = 90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '.6em';\n\t    }\n\t  } else if (angle < topRightAngle) {\n\t    y = '.3em';\n\t    tx = offset;\n\t    ty = 0;\n\t    textAnchor = 'start';\n\t  } else {\n\t    tx = 0;\n\t    ty = -offset;\n\t    if (autoOrient) {\n\t      orientAngle = -90;\n\t      textAnchor = 'start';\n\t      y = '.3em';\n\t    } else {\n\t      textAnchor = 'middle';\n\t      y = '0';\n\t    }\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(tx),\n\t    y: round(ty),\n\t    angle: orientAngle,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\t  opt = defaults({}, opt, {\n\t    offset: 20\n\t  });\n\t  var origin = point(0, 0);\n\t  var angle = -portCenterOffset.theta(origin);\n\t  var orientAngle = angle;\n\t  var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();\n\t  var y = '.3em';\n\t  var textAnchor;\n\t  if ((angle + 90) % 180 === 0) {\n\t    textAnchor = autoOrient ? 'end' : 'middle';\n\t    if (!autoOrient && angle === -270) {\n\t      y = '0em';\n\t    }\n\t  } else if (angle > -270 && angle < -90) {\n\t    textAnchor = 'start';\n\t    orientAngle = angle - 180;\n\t  } else {\n\t    textAnchor = 'end';\n\t  }\n\t  var round = Math.round;\n\t  return labelAttributes(opt, {\n\t    x: round(offset.x),\n\t    y: round(offset.y),\n\t    angle: autoOrient ? orientAngle : 0,\n\t    attrs: {\n\t      labelText: {\n\t        y,\n\t        textAnchor\n\t      }\n\t    }\n\t  });\n\t}\n\tconst manual = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt);\n\t};\n\tconst left$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    x: -15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.3em',\n\t        textAnchor: 'end'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst right$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    x: 15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.3em',\n\t        textAnchor: 'start'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst top$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    y: -15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '0',\n\t        textAnchor: 'middle'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst bottom$1 = function (portPosition, elBBox, opt) {\n\t  return labelAttributes(opt, {\n\t    y: 15,\n\t    attrs: {\n\t      labelText: {\n\t        y: '.6em',\n\t        textAnchor: 'middle'\n\t      }\n\t    }\n\t  });\n\t};\n\tconst outsideOriented = function (portPosition, elBBox, opt) {\n\t  return outsideLayout(portPosition, elBBox, true, opt);\n\t};\n\tconst outside = function (portPosition, elBBox, opt) {\n\t  return outsideLayout(portPosition, elBBox, false, opt);\n\t};\n\tconst insideOriented = function (portPosition, elBBox, opt) {\n\t  return insideLayout(portPosition, elBBox, true, opt);\n\t};\n\tconst inside = function (portPosition, elBBox, opt) {\n\t  return insideLayout(portPosition, elBBox, false, opt);\n\t};\n\tconst radial = function (portPosition, elBBox, opt) {\n\t  return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n\t};\n\tconst radialOriented = function (portPosition, elBBox, opt) {\n\t  return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n\t};\n\n\tvar PortLabel = {\n\t\t__proto__: null,\n\t\tbottom: bottom$1,\n\t\tinside: inside,\n\t\tinsideOriented: insideOriented,\n\t\tleft: left$1,\n\t\tmanual: manual,\n\t\toutside: outside,\n\t\toutsideOriented: outsideOriented,\n\t\tradial: radial,\n\t\tradialOriented: radialOriented,\n\t\tright: right$1,\n\t\ttop: top$1\n\t};\n\n\tconst DEFAULT_PORT_POSITION_NAME = 'left';\n\tconst DEFAULT_ABSOLUTE_PORT_POSITION_NAME = 'absolute';\n\tconst DEFAULT_PORT_LABEL_POSITION_NAME = 'left';\n\tconst PortData = function (model) {\n\t  const {\n\t    portLayoutNamespace = Port,\n\t    portLabelLayoutNamespace = PortLabel\n\t  } = model;\n\t  const clonedData = cloneDeep(model.get('ports')) || {};\n\t  this.ports = [];\n\t  this.portsMap = {};\n\t  this.groups = {};\n\t  this.portLayoutNamespace = portLayoutNamespace;\n\t  this.portLabelLayoutNamespace = portLabelLayoutNamespace;\n\t  this.metrics = {};\n\t  this.metricsKey = null;\n\t  this._init(clonedData);\n\t};\n\tPortData.prototype = {\n\t  hasPort: function (id) {\n\t    return id in this.portsMap;\n\t  },\n\t  getPort: function (id) {\n\t    const port = this.portsMap[id];\n\t    if (port) return port;\n\t    throw new Error('Element: unable to find port with id ' + id);\n\t  },\n\t  getPorts: function () {\n\t    return this.ports;\n\t  },\n\t  getGroup: function (name) {\n\t    return this.groups[name] || {};\n\t  },\n\t  getPortsByGroup: function (groupName) {\n\t    return this.ports.filter(function (port) {\n\t      return port.group === groupName;\n\t    });\n\t  },\n\t  // Calculate SVG transformations based on evaluated group + port data\n\t  // NOTE: This function is also called for ports without a group (groupName = undefined)\n\t  getGroupPortsMetrics: function (groupName, rect) {\n\t    const {\n\t      x = 0,\n\t      y = 0,\n\t      width = 0,\n\t      height = 0\n\t    } = rect;\n\t    const metricsKey = `${x}:${y}:${width}:${height}`;\n\t    if (this.metricsKey !== metricsKey) {\n\t      // Clear the cache (the element size has changed)\n\t      this.metrics = {};\n\t      this.metricsKey = metricsKey;\n\t    }\n\t    let groupPortsMetrics = this.metrics[groupName];\n\t    if (groupPortsMetrics) {\n\t      // Return cached metrics\n\t      return groupPortsMetrics;\n\t    }\n\n\t    // Calculate the metrics\n\t    groupPortsMetrics = this.resolveGroupPortsMetrics(groupName, new Rect(x, y, width, height));\n\t    this.metrics[groupName] = groupPortsMetrics;\n\t    return groupPortsMetrics;\n\t  },\n\t  resolveGroupPortsMetrics: function (groupName, elBBox) {\n\t    // `groupName` of `undefined` (= not a string) means \"the group of ports which do not have the `group` property\".\n\t    const isNoGroup = groupName === undefined;\n\t    const group = this.getGroup(groupName);\n\t    const ports = this.getPortsByGroup(groupName);\n\t    const portsArgs = ports.map(function (port) {\n\t      return port && port.position && port.position.args;\n\t    });\n\n\t    // Get an array of transformations of individual ports according to the group's port layout function:\n\t    let groupPortTransformations;\n\t    if (isNoGroup) {\n\t      // Apply default port layout function to the set of ports without `group` property.\n\t      const noGroup = this._evaluateGroup({});\n\t      groupPortTransformations = this._getGroupPortTransformations(noGroup, portsArgs, elBBox);\n\t    } else {\n\t      groupPortTransformations = this._getGroupPortTransformations(group, portsArgs, elBBox);\n\t    }\n\t    let accumulator = {\n\t      ports: ports,\n\t      result: {}\n\t    };\n\n\t    // For each individual port transformation, find the information necessary to calculate SVG transformations:\n\t    toArray$1(groupPortTransformations).reduce((res, portTransformation, index) => {\n\t      const port = res.ports[index];\n\t      const portId = port.id;\n\t      res.result[portId] = {\n\t        index,\n\t        portId,\n\t        portTransformation: portTransformation,\n\t        labelTransformation: this._getPortLabelTransformation(port, Point(portTransformation), elBBox),\n\t        portAttrs: port.attrs,\n\t        portSize: port.size,\n\t        labelSize: port.label.size\n\t      };\n\t      return res;\n\t    }, accumulator);\n\t    return accumulator.result;\n\t  },\n\t  _getGroupPortTransformations: function (group, portsArgs, elBBox) {\n\t    const groupPosition = group.position || {};\n\t    const groupPositionArgs = groupPosition.args || {};\n\t    const groupPositionLayoutCallback = groupPosition.layoutCallback;\n\t    return groupPositionLayoutCallback(portsArgs, elBBox, groupPositionArgs);\n\t  },\n\t  _getPortLabelTransformation: function (port, portPosition, elBBox) {\n\t    const portLabelPosition = port.label.position || {};\n\t    const portLabelPositionArgs = portLabelPosition.args || {};\n\t    const portLabelPositionLayoutCallback = portLabelPosition.layoutCallback;\n\t    if (portLabelPositionLayoutCallback) {\n\t      return portLabelPositionLayoutCallback(portPosition, elBBox, portLabelPositionArgs);\n\t    }\n\t    return null;\n\t  },\n\t  _init: function (data) {\n\t    // Prepare groups:\n\t    // NOTE: This overwrites passed group properties with evaluated group properties.\n\t    if (isObject(data.groups)) {\n\t      var groups = Object.keys(data.groups);\n\t      for (var i = 0, n = groups.length; i < n; i++) {\n\t        var key = groups[i];\n\t        this.groups[key] = this._evaluateGroup(data.groups[key]);\n\t      }\n\t    }\n\n\t    // Prepare ports:\n\t    // NOTE: This overwrites passed port properties with evaluated port properties, plus mixed-in evaluated group properties (see above).\n\t    var ports = toArray$1(data.items);\n\t    for (var j = 0, m = ports.length; j < m; j++) {\n\t      const resolvedPort = this._evaluatePort(ports[j]);\n\t      this.ports.push(resolvedPort);\n\t      this.portsMap[resolvedPort.id] = resolvedPort;\n\t    }\n\t  },\n\t  _evaluateGroup: function (group) {\n\t    return merge({}, group, {\n\t      position: this._evaluateGroupPositionProperty(group),\n\t      label: this._evaluateGroupLabelProperty(group)\n\t    });\n\t  },\n\t  _evaluateGroupPositionProperty: function (group) {\n\t    const namespace = this.portLayoutNamespace;\n\t    const groupPosition = group.position;\n\t    if (groupPosition === undefined) {\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (isFunction(groupPosition)) {\n\t      return {\n\t        layoutCallback: groupPosition\n\t      };\n\t    } else if (isObject(groupPosition)) {\n\t      if (groupPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition.name, 'Provided port group');\n\t        return {\n\t          layoutCallback,\n\t          args: groupPosition.args\n\t        };\n\t      } else {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, 'Default port group');\n\t        return {\n\t          layoutCallback,\n\t          args: groupPosition.args\n\t        };\n\t      }\n\t    } else if (isString(groupPosition)) {\n\t      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition, 'Provided port group');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (Array.isArray(groupPosition)) {\n\t      // TODO: Remove legacy signature (see `this._evaluateGroupLabelPositionProperty()`).\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_ABSOLUTE_PORT_POSITION_NAME, 'Default absolute port group');\n\t      return {\n\t        layoutCallback,\n\t        args: {\n\t          x: groupPosition[0],\n\t          y: groupPosition[1]\n\t        }\n\t      };\n\t    } else {\n\t      throw new Error('dia.Element: Provided port group position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluateGroupLabelProperty: function (group) {\n\t    const groupLabel = group.label;\n\t    if (!groupLabel) {\n\t      return {\n\t        position: this._evaluateGroupLabelPositionProperty({})\n\t      };\n\t    }\n\t    return merge({}, groupLabel, {\n\t      position: this._evaluateGroupLabelPositionProperty(groupLabel)\n\t    });\n\t  },\n\t  _evaluateGroupLabelPositionProperty: function (groupLabel) {\n\t    const namespace = this.portLabelLayoutNamespace;\n\t    const groupLabelPosition = groupLabel.position;\n\t    if (groupLabelPosition === undefined) {\n\t      const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');\n\t      return {\n\t        layoutCallback\n\t      };\n\t    } else if (isFunction(groupLabelPosition)) {\n\t      return {\n\t        layoutCallback: groupLabelPosition\n\t      };\n\t    } else if (isObject(groupLabelPosition)) {\n\t      if (groupLabelPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupLabelPosition.name, 'Provided port group label');\n\t        return {\n\t          layoutCallback,\n\t          args: groupLabelPosition.args\n\t        };\n\t      } else {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, 'Default port group label');\n\t        return {\n\t          layoutCallback,\n\t          args: groupLabelPosition.args\n\t        };\n\t      }\n\t    } else {\n\t      throw new Error('dia.Element: Provided port group label position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluatePort: function (port) {\n\t    const group = this.getGroup(port.group);\n\t    const evaluated = assign({}, port);\n\t    evaluated.markup = evaluated.markup || group.markup;\n\t    evaluated.attrs = merge({}, group.attrs, evaluated.attrs);\n\t    evaluated.position = this._evaluatePortPositionProperty(group, evaluated);\n\t    evaluated.label = this._evaluatePortLabelProperty(group, evaluated);\n\t    evaluated.z = this._evaluatePortZProperty(group, evaluated);\n\t    evaluated.size = assign({}, group.size, evaluated.size);\n\t    return evaluated;\n\t  },\n\t  _evaluatePortPositionProperty: function (group, port) {\n\t    return {\n\t      args: merge({},\n\t      // NOTE: `x != null` is equivalent to `x !== null && x !== undefined`.\n\t      group.position != null ? group.position.args : {},\n\t      // Port can overwrite `group.position.args` via `port.position.args` or `port.args`.\n\t      // TODO: Remove `port.args` backwards compatibility.\n\t      port.position != null && port.position.args != null ? port.position.args : port.args)\n\t    };\n\t  },\n\t  _evaluatePortLabelProperty: function (group, port) {\n\t    const groupLabel = group.label;\n\t    const portLabel = port.label;\n\t    if (!portLabel) {\n\t      return assign({}, groupLabel);\n\t    }\n\t    return merge({}, groupLabel, merge({}, portLabel, {\n\t      position: this._evaluatePortLabelPositionProperty(portLabel)\n\t    }));\n\t  },\n\t  _evaluatePortLabelPositionProperty: function (portLabel) {\n\t    const namespace = this.portLabelLayoutNamespace;\n\t    const portLabelPosition = portLabel.position;\n\t    if (portLabelPosition === undefined) {\n\t      return {};\n\t    } else if (isFunction(portLabelPosition)) {\n\t      return {\n\t        layoutCallback: portLabelPosition\n\t      };\n\t    } else if (isObject(portLabelPosition)) {\n\t      if (portLabelPosition.name) {\n\t        const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, portLabelPosition.name, 'Provided port label');\n\t        return {\n\t          layoutCallback,\n\t          args: portLabelPosition.args\n\t        };\n\t      } else {\n\t        return {\n\t          args: portLabelPosition.args\n\t        };\n\t      }\n\t    } else {\n\t      throw new Error('dia.Element: Provided port label position value has an invalid type.');\n\t    }\n\t  },\n\t  _evaluatePortZProperty: function (group, port) {\n\t    if (isNumber(port.z)) {\n\t      return port.z;\n\t    }\n\t    if (isNumber(group.z) || group.z === 'auto') {\n\t      return group.z;\n\t    }\n\t    return 'auto';\n\t  },\n\t  _resolveLayoutCallbackOrThrow: function (namespace, name, errorSubstring) {\n\t    const layoutCallback = namespace[name];\n\t    if (!layoutCallback) {\n\t      throw new Error(`dia.Element: ${errorSubstring} layout name is not recognized.`);\n\t    }\n\t    return layoutCallback;\n\t  }\n\t};\n\tconst elementPortPrototype = {\n\t  _initializePorts: function (options) {\n\t    if (options) {\n\t      // Override port layout namespaces if provided in options\n\t      if (options.portLayoutNamespace) {\n\t        this.portLayoutNamespace = options.portLayoutNamespace;\n\t      }\n\t      // Override port label layout namespaces if provided in options\n\t      if (options.portLabelLayoutNamespace) {\n\t        this.portLabelLayoutNamespace = options.portLabelLayoutNamespace;\n\t      }\n\t    }\n\t    this._createPortData();\n\t    this.on('change:ports', function () {\n\t      this._processRemovedPort();\n\t      this._createPortData();\n\t    }, this);\n\t  },\n\t  /**\n\t   * remove links tied wiht just removed element\n\t   * @private\n\t   */\n\t  _processRemovedPort: function () {\n\t    var current = this.get('ports') || {};\n\t    var currentItemsMap = {};\n\t    toArray$1(current.items).forEach(function (item) {\n\t      currentItemsMap[item.id] = true;\n\t    });\n\t    var previous = this.previous('ports') || {};\n\t    var removed = {};\n\t    toArray$1(previous.items).forEach(function (item) {\n\t      if (!currentItemsMap[item.id]) {\n\t        removed[item.id] = true;\n\t      }\n\t    });\n\t    var graph = this.graph;\n\t    if (graph && !isEmpty(removed)) {\n\t      var inboundLinks = graph.getConnectedLinks(this, {\n\t        inbound: true\n\t      });\n\t      inboundLinks.forEach(function (link) {\n\t        if (removed[link.get('target').port]) link.remove();\n\t      });\n\t      var outboundLinks = graph.getConnectedLinks(this, {\n\t        outbound: true\n\t      });\n\t      outboundLinks.forEach(function (link) {\n\t        if (removed[link.get('source').port]) link.remove();\n\t      });\n\t    }\n\t  },\n\t  /**\n\t   * @returns {boolean}\n\t   */\n\t  hasPorts: function () {\n\t    return this._portSettingsData.getPorts().length > 0;\n\t  },\n\t  /**\n\t   * @param {string} id\n\t   * @returns {boolean}\n\t   */\n\t  hasPort: function (id) {\n\t    return this._portSettingsData.hasPort(id);\n\t  },\n\t  /**\n\t   * @returns {Array<object>}\n\t   */\n\t  getPorts: function () {\n\t    return cloneDeep(this.prop('ports/items')) || [];\n\t  },\n\t  /**\n\t   * @returns {Array<object>}\n\t   */\n\t  getGroupPorts: function (groupName) {\n\t    const groupPorts = toArray$1(this.prop(['ports', 'items'])).filter(port => port.group === groupName);\n\t    return cloneDeep(groupPorts);\n\t  },\n\t  /**\n\t   * @param {string} id\n\t   * @returns {object}\n\t   */\n\t  getPort: function (id) {\n\t    const port = toArray$1(this.prop('ports/items')).find(port => port.id && port.id === id);\n\t    return cloneDeep(port);\n\t  },\n\t  getPortGroupNames: function () {\n\t    return Object.keys(this._portSettingsData.groups);\n\t  },\n\t  /**\n\t   * @param {string} groupName\n\t   * @returns {Object<portId, {x: number, y: number, angle: number}>}\n\t   */\n\t  getPortsPositions: function (groupName) {\n\t    const portsMetrics = this.getGroupPortsMetrics(groupName);\n\t    const portsPosition = {};\n\t    for (const portId in portsMetrics) {\n\t      const {\n\t        portTransformation: {\n\t          x,\n\t          y,\n\t          angle\n\t        }\n\t      } = portsMetrics[portId];\n\t      portsPosition[portId] = {\n\t        x: x,\n\t        y: y,\n\t        angle\n\t      };\n\t    }\n\t    return portsPosition;\n\t  },\n\t  getPortMetrics: function (portId) {\n\t    const port = this._portSettingsData.getPort(portId);\n\t    return this.getGroupPortsMetrics(port.group)[portId];\n\t  },\n\t  getGroupPortsMetrics: function (groupName) {\n\t    return this._portSettingsData.getGroupPortsMetrics(groupName, this.size());\n\t  },\n\t  getPortRelativePosition: function (portId) {\n\t    const {\n\t      portTransformation: {\n\t        x,\n\t        y,\n\t        angle\n\t      }\n\t    } = this.getPortMetrics(portId);\n\t    return {\n\t      x,\n\t      y,\n\t      angle\n\t    };\n\t  },\n\t  getPortRelativeRect(portId) {\n\t    const {\n\t      portTransformation: {\n\t        x,\n\t        y,\n\t        angle\n\t      },\n\t      portSize: {\n\t        width,\n\t        height\n\t      }\n\t    } = this.getPortMetrics(portId);\n\t    const portRect = {\n\t      x: x - width / 2,\n\t      y: y - height / 2,\n\t      width,\n\t      height,\n\t      angle\n\t    };\n\t    return portRect;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @returns {Point}\n\t   * @description Returns the port center in the graph coordinate system.\n\t   * The port center is in the graph coordinate system, and the position\n\t   * already takes into account the element rotation.\n\t   **/\n\t  getPortCenter(portId) {\n\t    const elementBBox = this.getBBox();\n\t    const portPosition = this.getPortRelativePosition(portId);\n\t    const portCenter = new Point(portPosition).offset(elementBBox.x, elementBBox.y);\n\t    const angle = this.angle();\n\t    if (angle) portCenter.rotate(elementBBox.center(), -angle);\n\t    return portCenter;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @param {object} [opt]\n\t   * @param {boolean} [opt.rotate] - If true, the port bounding box is rotated\n\t   * around the port center.\n\t   * @returns {Rect}\n\t   * @description Returns the bounding box of the port in the graph coordinate system.\n\t   * The port center is rotated around the element center, but the port bounding box\n\t   * is not rotated (unless `opt.rotate` is set to true).\n\t   */\n\t  getPortBBox: function (portId, opt) {\n\t    const portRect = this.getPortRelativeRect(portId);\n\t    const elementBBox = this.getBBox();\n\t    // Note: the `angle` property of the `port` is ignore here for now\n\t    const portBBox = new Rect(portRect);\n\t    portBBox.offset(elementBBox.x, elementBBox.y);\n\t    const angle = this.angle();\n\t    if (angle) {\n\t      portBBox.moveAroundPoint(elementBBox.center(), -angle);\n\t    }\n\t    if (opt && opt.rotate) {\n\t      portBBox.rotateAroundCenter(angle);\n\t    }\n\t    return portBBox;\n\t  },\n\t  /**\n\t   * @param {string|Port} port port id or port\n\t   * @returns {number} port index\n\t   */\n\t  getPortIndex: function (port) {\n\t    var id = isObject(port) ? port.id : port;\n\t    if (!this._isValidPortId(id)) {\n\t      return -1;\n\t    }\n\t    return toArray$1(this.prop('ports/items')).findIndex(function (item) {\n\t      return item.id === id;\n\t    });\n\t  },\n\t  /**\n\t   * @param {object} port\n\t   * @param {object} [opt]\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  addPort: function (port, opt) {\n\t    if (!isObject(port) || Array.isArray(port)) {\n\t      throw new Error('Element: addPort requires an object.');\n\t    }\n\t    var ports = assign([], this.prop('ports/items'));\n\t    ports.push(port);\n\t    this.prop('ports/items', ports, opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @param {string|Port|number} before\n\t   * @param {object} port\n\t   * @param {object} [opt]\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  insertPort: function (before, port, opt) {\n\t    const index = typeof before === 'number' ? before : this.getPortIndex(before);\n\t    if (!isObject(port) || Array.isArray(port)) {\n\t      throw new Error('dia.Element: insertPort requires an object.');\n\t    }\n\t    const ports = assign([], this.prop('ports/items'));\n\t    ports.splice(index, 0, port);\n\t    this.prop('ports/items', ports, opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @param {string} portId\n\t   * @param {string|object=} path\n\t   * @param {*=} value\n\t   * @param {object=} opt\n\t   * @returns {joint.dia.Element}\n\t   */\n\t  portProp: function (portId, path, value, opt) {\n\t    var index = this.getPortIndex(portId);\n\t    if (index === -1) {\n\t      throw new Error('Element: unable to find port with id ' + portId);\n\t    }\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    if (Array.isArray(path)) {\n\t      args[0] = ['ports', 'items', index].concat(path);\n\t    } else if (isString(path)) {\n\t      // Get/set an attribute by a special path syntax that delimits\n\t      // nested objects by the colon character.\n\t      args[0] = ['ports/items/', index, '/', path].join('');\n\t    } else {\n\t      args = ['ports/items/' + index];\n\t      if (isPlainObject(path)) {\n\t        args.push(path);\n\t        args.push(value);\n\t      }\n\t    }\n\t    return this.prop.apply(this, args);\n\t  },\n\t  _validatePorts: function () {\n\t    var portsAttr = this.get('ports') || {};\n\t    var errorMessages = [];\n\t    portsAttr = portsAttr || {};\n\t    var ports = toArray$1(portsAttr.items);\n\t    ports.forEach(function (p) {\n\t      if (typeof p !== 'object') {\n\t        errorMessages.push('Element: invalid port ', p);\n\t      }\n\t      if (!this._isValidPortId(p.id)) {\n\t        p.id = this.generatePortId();\n\t      }\n\t    }, this);\n\t    if (uniq(ports, 'id').length !== ports.length) {\n\t      errorMessages.push('Element: found id duplicities in ports.');\n\t    }\n\t    return errorMessages;\n\t  },\n\t  generatePortId: function () {\n\t    return this.generateId();\n\t  },\n\t  /**\n\t   * @param {string} id port id\n\t   * @returns {boolean}\n\t   * @private\n\t   */\n\t  _isValidPortId: function (id) {\n\t    return id !== null && id !== undefined && !isObject(id);\n\t  },\n\t  addPorts: function (ports, opt) {\n\t    if (ports.length) {\n\t      this.prop('ports/items', assign([], this.prop('ports/items')).concat(ports), opt);\n\t    }\n\t    return this;\n\t  },\n\t  removePort: function (port, opt) {\n\t    const options = opt || {};\n\t    const index = this.getPortIndex(port);\n\t    if (index !== -1) {\n\t      const ports = assign([], this.prop(['ports', 'items']));\n\t      ports.splice(index, 1);\n\t      options.rewrite = true;\n\t      this.startBatch('port-remove');\n\t      this.prop(['ports', 'items'], ports, options);\n\t      this.stopBatch('port-remove');\n\t    }\n\t    return this;\n\t  },\n\t  removePorts: function (portsForRemoval, opt) {\n\t    let options, newPorts;\n\t    if (Array.isArray(portsForRemoval)) {\n\t      options = opt || {};\n\t      if (portsForRemoval.length === 0) return this.this;\n\t      const currentPorts = assign([], this.prop(['ports', 'items']));\n\t      newPorts = currentPorts.filter(function (cp) {\n\t        return !portsForRemoval.some(function (rp) {\n\t          const rpId = isObject(rp) ? rp.id : rp;\n\t          return cp.id === rpId;\n\t        });\n\t      });\n\t    } else {\n\t      options = portsForRemoval || {};\n\t      newPorts = [];\n\t    }\n\t    this.startBatch('port-remove');\n\t    options.rewrite = true;\n\t    this.prop(['ports', 'items'], newPorts, options);\n\t    this.stopBatch('port-remove');\n\t    return this;\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _createPortData: function () {\n\t    var err = this._validatePorts();\n\t    if (err.length > 0) {\n\t      this.set('ports', this.previous('ports'));\n\t      throw new Error(err.join(' '));\n\t    }\n\t    var prevPortData;\n\t    if (this._portSettingsData) {\n\t      prevPortData = this._portSettingsData.getPorts();\n\t    }\n\t    this._portSettingsData = new PortData(this);\n\t    var curPortData = this._portSettingsData.getPorts();\n\t    if (prevPortData) {\n\t      var added = curPortData.filter(function (item) {\n\t        if (!prevPortData.find(function (prevPort) {\n\t          return prevPort.id === item.id;\n\t        })) {\n\t          return item;\n\t        }\n\t      });\n\t      var removed = prevPortData.filter(function (item) {\n\t        if (!curPortData.find(function (curPort) {\n\t          return curPort.id === item.id;\n\t        })) {\n\t          return item;\n\t        }\n\t      });\n\t      if (removed.length > 0) {\n\t        this.trigger('ports:remove', this, removed);\n\t      }\n\t      if (added.length > 0) {\n\t        this.trigger('ports:add', this, added);\n\t      }\n\t    }\n\t  }\n\t};\n\tconst elementViewPortPrototype = {\n\t  portContainerMarkup: 'g',\n\t  portMarkup: [{\n\t    tagName: 'circle',\n\t    selector: 'circle',\n\t    attributes: {\n\t      'r': 10,\n\t      'fill': '#FFFFFF',\n\t      'stroke': '#000000'\n\t    }\n\t  }],\n\t  portLabelMarkup: [{\n\t    tagName: 'text',\n\t    selector: 'text',\n\t    attributes: {\n\t      'fill': '#000000'\n\t    }\n\t  }],\n\t  /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n\t  _portElementsCache: null,\n\t  /**\n\t   * @private\n\t   */\n\t  _initializePorts: function () {\n\t    this._cleanPortsCache();\n\t  },\n\t  /**\n\t   * @typedef {Object} Port\n\t   *\n\t   * @property {string} id\n\t   * @property {Object} position\n\t   * @property {Object} label\n\t   * @property {Object} attrs\n\t   * @property {string} markup\n\t   * @property {string} group\n\t   */\n\n\t  /**\n\t   * @private\n\t   */\n\t  _refreshPorts: function () {\n\t    this._removePorts();\n\t    this._cleanPortsCache();\n\t    this._renderPorts();\n\t  },\n\t  _cleanPortsCache: function () {\n\t    this._portElementsCache = {};\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _renderPorts: function () {\n\t    // references to rendered elements without z-index\n\t    var elementReferences = [];\n\t    var elem = this._getContainerElement();\n\t    for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n\t      elementReferences.push(elem.node.childNodes[i]);\n\t    }\n\t    var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), 'z');\n\t    var withoutZKey = 'auto';\n\n\t    // render non-z first\n\t    toArray$1(portsGropsByZ[withoutZKey]).forEach(function (port) {\n\t      var portElement = this._getPortElement(port);\n\t      elem.append(portElement);\n\t      elementReferences.push(portElement);\n\t    }, this);\n\t    var groupNames = Object.keys(portsGropsByZ);\n\t    for (var k = 0; k < groupNames.length; k++) {\n\t      var groupName = groupNames[k];\n\t      if (groupName !== withoutZKey) {\n\t        var z = parseInt(groupName, 10);\n\t        this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n\t      }\n\t    }\n\t    this._updatePorts();\n\t  },\n\t  /**\n\t   * @returns {V}\n\t   * @private\n\t   */\n\t  _getContainerElement: function () {\n\t    return this.rotatableNode || this.vel;\n\t  },\n\t  /**\n\t   * @param {Array<Port>}ports\n\t   * @param {number} z\n\t   * @param refs\n\t   * @private\n\t   */\n\t  _appendPorts: function (ports, z, refs) {\n\t    var containerElement = this._getContainerElement();\n\t    var portElements = toArray$1(ports).map(this._getPortElement, this);\n\t    if (refs[z] || z < 0) {\n\t      V(refs[Math.max(z, 0)]).before(portElements);\n\t    } else {\n\t      containerElement.append(portElements);\n\t    }\n\t  },\n\t  /**\n\t   * Try to get element from cache,\n\t   * @param port\n\t   * @returns {*}\n\t   * @private\n\t   */\n\t  _getPortElement: function (port) {\n\t    if (this._portElementsCache[port.id]) {\n\t      return this._portElementsCache[port.id].portElement;\n\t    }\n\t    return this._createPortElement(port);\n\t  },\n\t  findPortNodes: function (portId, selector) {\n\t    const portCache = this._portElementsCache[portId];\n\t    if (!portCache) return [];\n\t    if (!selector) return [portCache.portContentElement.node];\n\t    const portRoot = portCache.portElement.node;\n\t    const portSelectors = portCache.portSelectors;\n\t    return this.findBySelector(selector, portRoot, portSelectors);\n\t  },\n\t  findPortNode: function (portId, selector) {\n\t    const [node = null] = this.findPortNodes(portId, selector);\n\t    return node;\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _updatePorts: function () {\n\t    // layout ports without group\n\t    this._updatePortGroup(undefined);\n\t    // layout ports with explicit group\n\t    var groupsNames = Object.keys(this.model._portSettingsData.groups);\n\t    groupsNames.forEach(this._updatePortGroup, this);\n\t  },\n\t  /**\n\t   * @private\n\t   */\n\t  _removePorts: function () {\n\t    invoke(this._portElementsCache, 'portElement.remove');\n\t  },\n\t  /**\n\t   * @param {Port} port\n\t   * @returns {V}\n\t   * @private\n\t   */\n\t  _createPortElement: function (port) {\n\t    let portElement;\n\t    let labelElement;\n\t    let labelSelectors;\n\t    let portSelectors;\n\t    var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\t    var portMarkup = this._getPortMarkup(port);\n\t    if (Array.isArray(portMarkup)) {\n\t      var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n\t      var portFragment = portDoc.fragment;\n\t      if (portFragment.childNodes.length > 1) {\n\t        portElement = V('g').append(portFragment);\n\t      } else {\n\t        portElement = V(portFragment.firstChild);\n\t      }\n\t      portSelectors = portDoc.selectors;\n\t    } else {\n\t      portElement = V(portMarkup);\n\t      if (Array.isArray(portElement)) {\n\t        portElement = V('g').append(portElement);\n\t      }\n\t    }\n\t    if (!portElement) {\n\t      throw new Error('ElementView: Invalid port markup.');\n\t    }\n\t    portElement.attr({\n\t      'port': port.id,\n\t      'port-group': port.group\n\t    });\n\n\t    // If the port ID is a number, we need to add\n\t    // extra information to the port element to distinguish\n\t    // between ports with the same ID but different types.\n\t    if (isNumber(port.id)) {\n\t      portElement.attr('port-id-type', 'number');\n\t    }\n\t    const labelMarkupDef = this._getPortLabelMarkup(port.label);\n\t    if (Array.isArray(labelMarkupDef)) {\n\t      // JSON Markup\n\t      const {\n\t        fragment,\n\t        selectors\n\t      } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n\t      const childCount = fragment.childNodes.length;\n\t      if (childCount > 0) {\n\t        labelSelectors = selectors;\n\t        labelElement = childCount === 1 ? V(fragment.firstChild) : V('g').append(fragment);\n\t      }\n\t    } else {\n\t      // String Markup\n\t      labelElement = V(labelMarkupDef);\n\t      if (Array.isArray(labelElement)) {\n\t        labelElement = V('g').append(labelElement);\n\t      }\n\t    }\n\t    var portContainerSelectors;\n\t    if (portSelectors && labelSelectors) {\n\t      for (var key in labelSelectors) {\n\t        if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n\t      }\n\t      portContainerSelectors = assign({}, portSelectors, labelSelectors);\n\t    } else {\n\t      portContainerSelectors = portSelectors || labelSelectors || {};\n\t    }\n\n\t    // The `portRootSelector` points to the root SVGNode of the port.\n\t    // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n\t    // Or the single SVGNode of the port.\n\t    const portRootSelector = 'portRoot';\n\t    // The `labelRootSelector` points to the root SVGNode of the label.\n\t    const labelRootSelector = 'labelRoot';\n\t    // The `labelTextSelector` points to all text SVGNodes of the label.\n\t    const labelTextSelector = 'labelText';\n\t    if (!(portRootSelector in portContainerSelectors)) {\n\t      portContainerSelectors[portRootSelector] = portElement.node;\n\t    }\n\t    if (labelElement) {\n\t      const labelNode = labelElement.node;\n\t      if (!(labelRootSelector in portContainerSelectors)) {\n\t        portContainerSelectors[labelRootSelector] = labelNode;\n\t      }\n\t      if (!(labelTextSelector in portContainerSelectors)) {\n\t        // If the label is a <text> element, we can use it directly.\n\t        // Otherwise, we need to find the <text> element within the label.\n\t        const labelTextNode = labelElement.tagName() === 'TEXT' ? labelNode : Array.from(labelNode.querySelectorAll('text'));\n\t        portContainerSelectors[labelTextSelector] = labelTextNode;\n\t        if (!labelSelectors) labelSelectors = {};\n\t        labelSelectors[labelTextSelector] = labelTextNode;\n\t      }\n\t    }\n\t    portContainerElement.append(portElement.addClass('joint-port-body'));\n\t    if (labelElement) {\n\t      portContainerElement.append(labelElement.addClass('joint-port-label'));\n\t    }\n\t    this._portElementsCache[port.id] = {\n\t      portElement: portContainerElement,\n\t      portLabelElement: labelElement,\n\t      portSelectors: portContainerSelectors,\n\t      portLabelSelectors: labelSelectors,\n\t      portContentElement: portElement,\n\t      portContentSelectors: portSelectors\n\t    };\n\t    return portContainerElement;\n\t  },\n\t  /**\n\t   * @param {string=} groupName\n\t   * @private\n\t   */\n\t  _updatePortGroup: function (groupName) {\n\t    const portsMetrics = this.model.getGroupPortsMetrics(groupName);\n\t    const portsIds = Object.keys(portsMetrics);\n\t    for (let i = 0, n = portsIds.length; i < n; i++) {\n\t      const portId = portsIds[i];\n\t      const metrics = portsMetrics[portId];\n\t      const cached = this._portElementsCache[portId] || {};\n\t      const portTransformation = metrics.portTransformation;\n\t      const labelTransformation = metrics.labelTransformation;\n\t      if (labelTransformation && cached.portLabelElement) {\n\t        this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n\t          rootBBox: new Rect(metrics.labelSize),\n\t          selectors: cached.portLabelSelectors\n\t        });\n\t        this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);\n\t      }\n\t      this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n\t        rootBBox: new Rect(metrics.portSize),\n\t        selectors: cached.portSelectors\n\t      });\n\t      this.applyPortTransform(cached.portElement, portTransformation);\n\t    }\n\t  },\n\t  /**\n\t   * @param {Vectorizer} element\n\t   * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n\t   * @param {number=} initialAngle\n\t   * @constructor\n\t   */\n\t  applyPortTransform: function (element, transformData, initialAngle) {\n\t    var matrix = V.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);\n\t    element.transform(matrix, {\n\t      absolute: true\n\t    });\n\t  },\n\t  /**\n\t   * @param {Port} port\n\t   * @returns {string}\n\t   * @private\n\t   */\n\t  _getPortMarkup: function (port) {\n\t    return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n\t  },\n\t  /**\n\t   * @param {Object} label\n\t   * @returns {string}\n\t   * @private\n\t   */\n\t  _getPortLabelMarkup: function (label) {\n\t    return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n\t  }\n\t};\n\n\t// Element base model.\n\t// -----------------------------\n\n\tconst Element$1 = Cell.extend({\n\t  defaults: {\n\t    position: {\n\t      x: 0,\n\t      y: 0\n\t    },\n\t    size: {\n\t      width: 1,\n\t      height: 1\n\t    },\n\t    angle: 0\n\t  },\n\t  initialize: function (attributes, options) {\n\t    this._initializePorts(options);\n\t    Cell.prototype.initialize.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @abstract\n\t   */\n\t  _initializePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  _refreshPorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  isElement: function () {\n\t    return true;\n\t  },\n\t  position: function (x, y, opt) {\n\t    const isSetter = isNumber(y);\n\t    opt = (isSetter ? opt : x) || {};\n\t    const {\n\t      parentRelative,\n\t      deep,\n\t      restrictedArea\n\t    } = opt;\n\n\t    // option `parentRelative` for setting the position relative to the element's parent.\n\t    let parentPosition;\n\t    if (parentRelative) {\n\t      // Getting the parent's position requires the collection.\n\t      // Cell.parent() holds cell id only.\n\t      if (!this.graph) throw new Error('Element must be part of a graph.');\n\t      const parent = this.getParentCell();\n\t      if (parent && !parent.isLink()) {\n\t        parentPosition = parent.get('position');\n\t      }\n\t    }\n\t    if (isSetter) {\n\t      if (parentPosition) {\n\t        x += parentPosition.x;\n\t        y += parentPosition.y;\n\t      }\n\t      if (deep || restrictedArea) {\n\t        const {\n\t          x: x0,\n\t          y: y0\n\t        } = this.get('position');\n\t        this.translate(x - x0, y - y0, opt);\n\t      } else {\n\t        this.set('position', {\n\t          x,\n\t          y\n\t        }, opt);\n\t      }\n\t      return this;\n\t    } else {\n\t      // Getter returns a geometry point.\n\n\t      const elementPosition = Point(this.get('position'));\n\t      return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n\t    }\n\t  },\n\t  translate: function (tx, ty, opt) {\n\t    tx = tx || 0;\n\t    ty = ty || 0;\n\t    if (tx === 0 && ty === 0) {\n\t      // Like nothing has happened.\n\t      return this;\n\t    }\n\t    opt = opt || {};\n\t    // Pass the initiator of the translation.\n\t    opt.translateBy = opt.translateBy || this.id;\n\t    var position = this.get('position') || {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t    var ra = opt.restrictedArea;\n\t    if (ra && opt.translateBy === this.id) {\n\t      if (typeof ra === 'function') {\n\t        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\t        tx = newPosition.x - position.x;\n\t        ty = newPosition.y - position.y;\n\t      } else {\n\t        // We are restricting the translation for the element itself only. We get\n\t        // the bounding box of the element including all its embeds.\n\t        // All embeds have to be translated the exact same way as the element.\n\t        var bbox = this.getBBox({\n\t          deep: true\n\t        });\n\t        //- - - - - - - - - - - - -> ra.x + ra.width\n\t        // - - - -> position.x      |\n\t        // -> bbox.x\n\t        //                   |\n\t        //         \n\t        //                 |\n\t        //   \n\t        //                  |\n\t        //   <-dx->                     | restricted area right border\n\t        //         <-width->        |    translated element\n\t        //   <- - bbox.width - ->        embedded element\n\t        var dx = position.x - bbox.x;\n\t        var dy = position.y - bbox.y;\n\t        // Find the maximal/minimal coordinates that the element can be translated\n\t        // while complies the restrictions.\n\t        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n\t        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n\t        // recalculate the translation taking the restrictions into account.\n\t        tx = x - position.x;\n\t        ty = y - position.y;\n\t      }\n\t    }\n\t    var translatedPosition = {\n\t      x: position.x + tx,\n\t      y: position.y + ty\n\t    };\n\n\t    // To find out by how much an element was translated in event 'change:position' handlers.\n\t    opt.tx = tx;\n\t    opt.ty = ty;\n\t    if (opt.transition) {\n\t      if (!isObject(opt.transition)) opt.transition = {};\n\t      this.transition('position', translatedPosition, assign({}, opt.transition, {\n\t        valueFunction: interpolate.object\n\t      }));\n\n\t      // Recursively call `translate()` on all the embeds cells.\n\t      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t    } else {\n\t      this.startBatch('translate', opt);\n\t      this.set('position', translatedPosition, opt);\n\t      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t      this.stopBatch('translate', opt);\n\t    }\n\t    return this;\n\t  },\n\t  size: function (width, height, opt) {\n\t    var currentSize = this.get('size');\n\t    // Getter\n\t    // () signature\n\t    if (width === undefined) {\n\t      return {\n\t        width: currentSize.width,\n\t        height: currentSize.height\n\t      };\n\t    }\n\t    // Setter\n\t    // (size, opt) signature\n\t    if (isObject(width)) {\n\t      opt = height;\n\t      height = isNumber(width.height) ? width.height : currentSize.height;\n\t      width = isNumber(width.width) ? width.width : currentSize.width;\n\t    }\n\t    return this.resize(width, height, opt);\n\t  },\n\t  resize: function (width, height, opt) {\n\t    opt = opt || {};\n\t    this.startBatch('resize', opt);\n\t    if (opt.direction) {\n\t      var currentSize = this.get('size');\n\t      switch (opt.direction) {\n\t        case 'left':\n\t        case 'right':\n\t          // Don't change height when resizing horizontally.\n\t          height = currentSize.height;\n\t          break;\n\t        case 'top':\n\t        case 'bottom':\n\t          // Don't change width when resizing vertically.\n\t          width = currentSize.width;\n\t          break;\n\t      }\n\n\t      // Get the angle and clamp its value between 0 and 360 degrees.\n\t      var angle = normalizeAngle(this.get('angle') || 0);\n\n\t      // This is a rectangle in size of the un-rotated element.\n\t      var bbox = this.getBBox();\n\t      var origin;\n\t      if (angle) {\n\t        var quadrant = {\n\t          'top-right': 0,\n\t          'right': 0,\n\t          'top-left': 1,\n\t          'top': 1,\n\t          'bottom-left': 2,\n\t          'left': 2,\n\t          'bottom-right': 3,\n\t          'bottom': 3\n\t        }[opt.direction];\n\t        if (opt.absolute) {\n\t          // We are taking the element's rotation into account\n\t          quadrant += Math.floor((angle + 45) / 90);\n\t          quadrant %= 4;\n\t        }\n\n\t        // Pick the corner point on the element, which meant to stay on its place before and\n\t        // after the rotation.\n\t        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n\t        // Find  an image of the previous indent point. This is the position, where is the\n\t        // point actually located on the screen.\n\t        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n\t        // Every point on the element rotates around a circle with the centre of rotation\n\t        // in the middle of the element while the whole element is being rotated. That means\n\t        // that the distance from a point in the corner of the element (supposed its always rect) to\n\t        // the center of the element doesn't change during the rotation and therefore it equals\n\t        // to a distance on un-rotated element.\n\t        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\t        var radius = Math.sqrt(width * width + height * height) / 2;\n\n\t        // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n\t        // and ending at the center of the element. We call this angle `alpha`.\n\n\t        // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n\t        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n\t        //\n\t        // 3 | 2\n\t        // --c-- Quadrant positions around the element's center `c`\n\t        // 0 | 1\n\t        //\n\t        var alpha = quadrant * Math.PI / 2;\n\n\t        // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n\t        // going through the center of the element) and line crossing the indent of the fixed point and the center\n\t        // of the element. This is the angle we need but on the un-rotated element.\n\t        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n\t        // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\t        alpha -= toRad(angle);\n\n\t        // With this angle and distance we can easily calculate the centre of the un-rotated element.\n\t        // Note that fromPolar constructor accepts an angle in radians.\n\t        var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n\t        // The top left corner on the un-rotated element has to be half a width on the left\n\t        // and half a height to the top from the center. This will be the origin of rectangle\n\t        // we were looking for.\n\t        origin = Point(center).offset(width / -2, height / -2);\n\t      } else {\n\t        // calculation for the origin Point when there is no rotation of the element\n\t        origin = bbox.topLeft();\n\t        switch (opt.direction) {\n\t          case 'top':\n\t          case 'top-right':\n\t            origin.offset(0, bbox.height - height);\n\t            break;\n\t          case 'left':\n\t          case 'bottom-left':\n\t            origin.offset(bbox.width - width, 0);\n\t            break;\n\t          case 'top-left':\n\t            origin.offset(bbox.width - width, bbox.height - height);\n\t            break;\n\t        }\n\t      }\n\n\t      // Resize the element (before re-positioning it).\n\t      this.set('size', {\n\t        width: width,\n\t        height: height\n\t      }, opt);\n\n\t      // Finally, re-position the element.\n\t      this.position(origin.x, origin.y, opt);\n\t    } else {\n\t      // Resize the element.\n\t      this.set('size', {\n\t        width: width,\n\t        height: height\n\t      }, opt);\n\t    }\n\t    this.stopBatch('resize', opt);\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, origin, opt) {\n\t    var scaledBBox = this.getBBox().scale(sx, sy, origin);\n\t    this.startBatch('scale', opt);\n\t    this.position(scaledBBox.x, scaledBBox.y, opt);\n\t    this.resize(scaledBBox.width, scaledBBox.height, opt);\n\t    this.stopBatch('scale');\n\t    return this;\n\t  },\n\t  fitEmbeds: function (opt) {\n\t    return this.fitToChildren(opt);\n\t  },\n\t  fitToChildren: function (opt = {}) {\n\t    // Getting the children's size and position requires the collection.\n\t    // Cell.get('embeds') holds an array of cell ids only.\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (!graph) throw new Error('Element must be part of a graph.');\n\n\t    // Get element children, optionally filtered according to `opt.filter`.\n\t    const filteredChildElements = this._getFilteredChildElements(opt.filter);\n\t    this.startBatch('fit-embeds', opt);\n\t    if (opt.deep) {\n\t      // `opt.deep = true` means \"fit to all descendants\".\n\t      // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n\t      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element)\n\t      // - omit `opt.minRect` - it only makes sense for the first level of recursion if there are no filtered children, but in this case we do have filtered children\n\t      invoke(filteredChildElements, 'fitToChildren', omit(opt, 'minRect'));\n\t    }\n\n\t    // Set new size and position of this element, based on:\n\t    // - union of bboxes of filtered element children\n\t    // - inflated by given `opt.padding`\n\t    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered children)\n\t    this._fitToElements(Object.assign({\n\t      elements: filteredChildElements\n\t    }, opt));\n\t    this.stopBatch('fit-embeds');\n\t    return this;\n\t  },\n\t  fitParent: function (opt = {}) {\n\t    const {\n\t      graph\n\t    } = this;\n\t    if (!graph) throw new Error('Element must be part of a graph.');\n\n\t    // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n\t    // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n\t    if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;\n\n\t    // If this element has no parent, there is nothing for us to do.\n\t    const parentElement = this.getParentCell();\n\t    if (!parentElement || !parentElement.isElement()) return this;\n\n\t    // Get element children of parent element (i.e. this element + any sibling elements), optionally filtered according to `opt.filter`.\n\t    const filteredSiblingElements = parentElement._getFilteredChildElements(opt.filter);\n\t    this.startBatch('fit-parent', opt);\n\n\t    // Set new size and position of parent element, based on:\n\t    // - union of bboxes of filtered element children of parent element (i.e. this element + any sibling elements)\n\t    // - inflated by given `opt.padding`\n\t    // - containing at least `opt.minRect` (if this is the first level of recursion and there are no filtered siblings)\n\t    parentElement._fitToElements(Object.assign({\n\t      elements: filteredSiblingElements\n\t    }, opt));\n\t    if (opt.deep) {\n\t      // `opt.deep = true` means \"fit all ancestors to their respective children\".\n\t      // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n\t      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up\n\t      // - omit `opt.minRect` - `minRect` is not relevant for the parent of parent element (and upwards)\n\t      parentElement.fitParent(omit(opt, 'minRect'));\n\t    }\n\t    this.stopBatch('fit-parent');\n\t    return this;\n\t  },\n\t  _getFilteredChildElements: function (filter) {\n\t    let filterFn;\n\t    if (typeof filter === 'function') {\n\t      filterFn = cell => cell.isElement() && filter(cell);\n\t    } else {\n\t      filterFn = cell => cell.isElement();\n\t    }\n\t    return this.getEmbeddedCells().filter(filterFn);\n\t  },\n\t  // Assumption: This element is part of a graph.\n\t  _fitToElements: function (opt = {}) {\n\t    let minBBox = null;\n\t    if (opt.minRect) {\n\t      // Coerce `opt.minRect` to g.Rect\n\t      // (missing properties are taken from this element's current bbox).\n\t      const minRect = assign(this.getBBox(), opt.minRect);\n\t      minBBox = new Rect(minRect);\n\t    }\n\t    const elementsBBox = this.graph.getCellsBBox(opt.elements);\n\t    // If no `opt.elements` were provided, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t    if (!elementsBBox) {\n\t      this._setBBox(minBBox, opt);\n\t      return;\n\t    }\n\t    const {\n\t      expandOnly,\n\t      shrinkOnly\n\t    } = opt;\n\t    // This combination is meaningless, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t    if (expandOnly && shrinkOnly) {\n\t      this._setBBox(minBBox, opt);\n\t      return;\n\t    }\n\n\t    // Calculate new size and position of this element based on:\n\t    // - union of bboxes of `opt.elements`\n\t    // - inflated by normalized `opt.padding` (missing sides = 0)\n\t    let {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = elementsBBox;\n\t    const {\n\t      left,\n\t      right,\n\t      top,\n\t      bottom\n\t    } = normalizeSides(opt.padding);\n\t    x -= left;\n\t    y -= top;\n\t    width += left + right;\n\t    height += bottom + top;\n\t    let contentBBox = new Rect(x, y, width, height);\n\t    if (expandOnly) {\n\t      // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n\t      contentBBox = this.getBBox().union(contentBBox);\n\t    } else if (shrinkOnly) {\n\t      // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n\t      const intersectionBBox = this.getBBox().intersect(contentBBox);\n\t      // If all children are outside this element's current bbox, then `intersectionBBox` is `null`.\n\t      // That does not make sense, do nothing (but if `opt.minRect` was provided, set that as this element's bbox instead).\n\t      if (!intersectionBBox) {\n\t        this._setBBox(minBBox, opt);\n\t        return;\n\t      }\n\t      contentBBox = intersectionBBox;\n\t    }\n\n\t    // Set the new size and position of this element.\n\t    // - if `opt.minRect` was provided, add it via union to calculated bbox\n\t    let resultBBox = contentBBox;\n\t    if (minBBox) {\n\t      resultBBox = resultBBox.union(minBBox);\n\t    }\n\t    this._setBBox(resultBBox, opt);\n\t  },\n\t  _setBBox: function (bbox, opt) {\n\t    if (!bbox) return;\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = bbox;\n\t    this.set({\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    }, opt);\n\t  },\n\t  // Rotate element by `angle` degrees, optionally around `origin` point.\n\t  // If `origin` is not provided, it is considered to be the center of the element.\n\t  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n\t  // the difference from the previous angle.\n\t  rotate: function (angle, absolute, origin, opt) {\n\t    if (origin) {\n\t      var center = this.getCenter();\n\t      var size = this.get('size');\n\t      var position = this.get('position');\n\t      center.rotate(origin, this.get('angle') - angle);\n\t      var dx = center.x - size.width / 2 - position.x;\n\t      var dy = center.y - size.height / 2 - position.y;\n\t      this.startBatch('rotate', {\n\t        angle: angle,\n\t        absolute: absolute,\n\t        origin: origin\n\t      });\n\t      this.position(position.x + dx, position.y + dy, opt);\n\t      this.rotate(angle, absolute, null, opt);\n\t      this.stopBatch('rotate');\n\t    } else {\n\t      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n\t    }\n\t    return this;\n\t  },\n\t  angle: function () {\n\t    return normalizeAngle(this.get('angle') || 0);\n\t  },\n\t  getBBox: function (opt = {}) {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    const {\n\t      deep,\n\t      rotate\n\t    } = opt;\n\t    if (deep && graph) {\n\t      // Get all the embedded elements using breadth first algorithm.\n\t      const elements = this.getEmbeddedCells({\n\t        deep: true,\n\t        breadthFirst: true\n\t      });\n\t      // Add the model itself.\n\t      elements.push(this);\n\t      // Note: the default of getCellsBBox() is rotate=true and can't be\n\t      // changed without a breaking change\n\t      return graph.getCellsBBox(elements, opt);\n\t    }\n\t    const {\n\t      angle = 0,\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    } = attributes;\n\t    const bbox = new Rect(x, y, width, height);\n\t    if (rotate) {\n\t      bbox.rotateAroundCenter(angle);\n\t    }\n\t    return bbox;\n\t  },\n\t  getCenter: function () {\n\t    const {\n\t      position: {\n\t        x,\n\t        y\n\t      },\n\t      size: {\n\t        width,\n\t        height\n\t      }\n\t    } = this.attributes;\n\t    return new Point(x + width / 2, y + height / 2);\n\t  },\n\t  getPointFromConnectedLink: function (link, endType) {\n\t    // Center of the model\n\t    var bbox = this.getBBox();\n\t    var center = bbox.center();\n\t    // Center of a port\n\t    var endDef = link.get(endType);\n\t    if (!endDef) return center;\n\t    var portId = endDef.port;\n\t    if (!portId || !this.hasPort(portId)) return center;\n\t    return this.getPortCenter(portId);\n\t  }\n\t});\n\tassign(Element$1.prototype, elementPortPrototype);\n\n\t// Link base model.\n\t// --------------------------\n\n\tconst Link$1 = Cell.extend({\n\t  // may be overwritten by user to change default label (its markup, size, attrs, position)\n\t  defaultLabel: undefined,\n\t  // deprecated\n\t  // may be overwritten by user to change default label markup\n\t  // lower priority than defaultLabel.markup\n\t  labelMarkup: undefined,\n\t  // private\n\t  _builtins: {\n\t    defaultLabel: {\n\t      // builtin default markup:\n\t      // used if neither defaultLabel.markup\n\t      // nor label.markup is set\n\t      markup: [{\n\t        tagName: 'rect',\n\t        selector: 'rect' // faster than tagName CSS selector\n\t      }, {\n\t        tagName: 'text',\n\t        selector: 'text' // faster than tagName CSS selector\n\t      }],\n\t      // builtin default attributes:\n\t      // applied only if builtin default markup is used\n\t      attrs: {\n\t        text: {\n\t          fill: '#000000',\n\t          fontSize: 14,\n\t          textAnchor: 'middle',\n\t          textVerticalAnchor: 'middle',\n\t          pointerEvents: 'none'\n\t        },\n\t        rect: {\n\t          ref: 'text',\n\t          fill: '#ffffff',\n\t          rx: 3,\n\t          ry: 3,\n\t          x: 'calc(x)',\n\t          y: 'calc(y)',\n\t          width: 'calc(w)',\n\t          height: 'calc(h)'\n\t        }\n\t      },\n\t      // builtin default position:\n\t      // used if neither defaultLabel.position\n\t      // nor label.position is set\n\t      position: {\n\t        distance: 0.5\n\t      }\n\t    }\n\t  },\n\t  defaults: {\n\t    source: {},\n\t    target: {}\n\t  },\n\t  isLink: function () {\n\t    return true;\n\t  },\n\t  disconnect: function (opt) {\n\t    return this.set({\n\t      source: {\n\t        x: 0,\n\t        y: 0\n\t      },\n\t      target: {\n\t        x: 0,\n\t        y: 0\n\t      }\n\t    }, opt);\n\t  },\n\t  source: function (source, args, opt) {\n\t    // getter\n\t    if (source === undefined) {\n\t      return clone$1(this.get('source'));\n\t    }\n\n\t    // setter\n\t    var setSource;\n\t    var setOpt;\n\n\t    // `source` is a cell\n\t    // take only its `id` and combine with `args`\n\t    var isCellProvided = source instanceof Cell;\n\t    if (isCellProvided) {\n\t      // three arguments\n\t      setSource = clone$1(args) || {};\n\t      setSource.id = source.id;\n\t      setOpt = opt;\n\t      return this.set('source', setSource, setOpt);\n\t    }\n\n\t    // `source` is a point-like object\n\t    // for example, a g.Point\n\t    // take only its `x` and `y` and combine with `args`\n\t    var isPointProvided = !isPlainObject(source);\n\t    if (isPointProvided) {\n\t      // three arguments\n\t      setSource = clone$1(args) || {};\n\t      setSource.x = source.x;\n\t      setSource.y = source.y;\n\t      setOpt = opt;\n\t      return this.set('source', setSource, setOpt);\n\t    }\n\n\t    // `source` is an object\n\t    // no checking\n\t    // two arguments\n\t    setSource = source;\n\t    setOpt = args;\n\t    return this.set('source', setSource, setOpt);\n\t  },\n\t  target: function (target, args, opt) {\n\t    // getter\n\t    if (target === undefined) {\n\t      return clone$1(this.get('target'));\n\t    }\n\n\t    // setter\n\t    var setTarget;\n\t    var setOpt;\n\n\t    // `target` is a cell\n\t    // take only its `id` argument and combine with `args`\n\t    var isCellProvided = target instanceof Cell;\n\t    if (isCellProvided) {\n\t      // three arguments\n\t      setTarget = clone$1(args) || {};\n\t      setTarget.id = target.id;\n\t      setOpt = opt;\n\t      return this.set('target', setTarget, setOpt);\n\t    }\n\n\t    // `target` is a point-like object\n\t    // for example, a g.Point\n\t    // take only its `x` and `y` and combine with `args`\n\t    var isPointProvided = !isPlainObject(target);\n\t    if (isPointProvided) {\n\t      // three arguments\n\t      setTarget = clone$1(args) || {};\n\t      setTarget.x = target.x;\n\t      setTarget.y = target.y;\n\t      setOpt = opt;\n\t      return this.set('target', setTarget, setOpt);\n\t    }\n\n\t    // `target` is an object\n\t    // no checking\n\t    // two arguments\n\t    setTarget = target;\n\t    setOpt = args;\n\t    return this.set('target', setTarget, setOpt);\n\t  },\n\t  router: function (name, args, opt) {\n\t    // getter\n\t    if (name === undefined) {\n\t      var router = this.get('router');\n\t      if (!router) {\n\t        return null;\n\t      }\n\t      if (typeof router === 'object') return clone$1(router);\n\t      return router; // e.g. a function\n\t    }\n\n\t    // setter\n\t    var isRouterProvided = typeof name === 'object' || typeof name === 'function';\n\t    var localRouter = isRouterProvided ? name : {\n\t      name: name,\n\t      args: args\n\t    };\n\t    var localOpt = isRouterProvided ? args : opt;\n\t    return this.set('router', localRouter, localOpt);\n\t  },\n\t  connector: function (name, args, opt) {\n\t    // getter\n\t    if (name === undefined) {\n\t      var connector = this.get('connector');\n\t      if (!connector) {\n\t        return null;\n\t      }\n\t      if (typeof connector === 'object') return clone$1(connector);\n\t      return connector; // e.g. a function\n\t    }\n\n\t    // setter\n\t    var isConnectorProvided = typeof name === 'object' || typeof name === 'function';\n\t    var localConnector = isConnectorProvided ? name : {\n\t      name: name,\n\t      args: args\n\t    };\n\t    var localOpt = isConnectorProvided ? args : opt;\n\t    return this.set('connector', localConnector, localOpt);\n\t  },\n\t  // Labels API\n\n\t  // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n\t  label: function (idx, label, opt) {\n\t    var labels = this.labels();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n\t    if (idx < 0) idx = labels.length + idx;\n\n\t    // getter\n\t    if (arguments.length <= 1) return this.prop(['labels', idx]);\n\t    // setter\n\t    return this.prop(['labels', idx], label, opt);\n\t  },\n\t  labels: function (labels, opt) {\n\t    // getter\n\t    if (arguments.length === 0) {\n\t      labels = this.get('labels');\n\t      if (!Array.isArray(labels)) return [];\n\t      return labels.slice();\n\t    }\n\t    // setter\n\t    if (!Array.isArray(labels)) labels = [];\n\t    return this.set('labels', labels, opt);\n\t  },\n\t  hasLabels: function () {\n\t    const {\n\t      labels\n\t    } = this.attributes;\n\t    return Array.isArray(labels) && labels.length > 0;\n\t  },\n\t  insertLabel: function (idx, label, opt) {\n\t    if (!label) throw new Error('dia.Link: no label provided');\n\t    var labels = this.labels();\n\t    var n = labels.length;\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n\t    if (idx < 0) idx = n + idx + 1;\n\t    labels.splice(idx, 0, label);\n\t    return this.labels(labels, opt);\n\t  },\n\t  // convenience function\n\t  // add label to end of labels array\n\t  appendLabel: function (label, opt) {\n\t    return this.insertLabel(-1, label, opt);\n\t  },\n\t  removeLabel: function (idx, opt) {\n\t    var labels = this.labels();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n\t    labels.splice(idx, 1);\n\t    return this.labels(labels, opt);\n\t  },\n\t  // Vertices API\n\n\t  vertex: function (idx, vertex, opt) {\n\t    var vertices = this.vertices();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n\t    if (idx < 0) idx = vertices.length + idx;\n\n\t    // getter\n\t    if (arguments.length <= 1) return this.prop(['vertices', idx]);\n\n\t    // setter\n\t    var setVertex = this._normalizeVertex(vertex);\n\t    return this.prop(['vertices', idx], setVertex, opt);\n\t  },\n\t  vertices: function (vertices, opt) {\n\t    // getter\n\t    if (arguments.length === 0) {\n\t      vertices = this.get('vertices');\n\t      if (!Array.isArray(vertices)) return [];\n\t      return vertices.slice();\n\t    }\n\n\t    // setter\n\t    if (!Array.isArray(vertices)) vertices = [];\n\t    var setVertices = [];\n\t    for (var i = 0; i < vertices.length; i++) {\n\t      var vertex = vertices[i];\n\t      var setVertex = this._normalizeVertex(vertex);\n\t      setVertices.push(setVertex);\n\t    }\n\t    return this.set('vertices', setVertices, opt);\n\t  },\n\t  insertVertex: function (idx, vertex, opt) {\n\t    if (!vertex) throw new Error('dia.Link: no vertex provided');\n\t    var vertices = this.vertices();\n\t    var n = vertices.length;\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n\t    if (idx < 0) idx = n + idx + 1;\n\t    var setVertex = this._normalizeVertex(vertex);\n\t    vertices.splice(idx, 0, setVertex);\n\t    return this.vertices(vertices, opt);\n\t  },\n\t  removeVertex: function (idx, opt) {\n\t    var vertices = this.vertices();\n\t    idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n\t    vertices.splice(idx, 1);\n\t    return this.vertices(vertices, opt);\n\t  },\n\t  _normalizeVertex: function (vertex) {\n\t    // is vertex a point-like object?\n\t    // for example, a g.Point\n\t    var isPointProvided = !isPlainObject(vertex);\n\t    if (isPointProvided) return {\n\t      x: vertex.x,\n\t      y: vertex.y\n\t    };\n\n\t    // else: return vertex unchanged\n\t    return vertex;\n\t  },\n\t  // Transformations\n\n\t  translate: function (tx, ty, opt) {\n\t    // enrich the option object\n\t    opt = opt || {};\n\t    opt.translateBy = opt.translateBy || this.id;\n\t    opt.tx = tx;\n\t    opt.ty = ty;\n\t    return this.applyToPoints(function (p) {\n\t      return {\n\t        x: (p.x || 0) + tx,\n\t        y: (p.y || 0) + ty\n\t      };\n\t    }, opt);\n\t  },\n\t  scale: function (sx, sy, origin, opt) {\n\t    return this.applyToPoints(function (p) {\n\t      return Point(p).scale(sx, sy, origin).toJSON();\n\t    }, opt);\n\t  },\n\t  applyToPoints: function (fn, opt) {\n\t    if (!isFunction(fn)) {\n\t      throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n\t    }\n\t    var attrs = {};\n\t    var {\n\t      source,\n\t      target\n\t    } = this.attributes;\n\t    if (!source.id) {\n\t      attrs.source = fn(source);\n\t    }\n\t    if (!target.id) {\n\t      attrs.target = fn(target);\n\t    }\n\t    var vertices = this.vertices();\n\t    if (vertices.length > 0) {\n\t      attrs.vertices = vertices.map(fn);\n\t    }\n\t    return this.set(attrs, opt);\n\t  },\n\t  getSourcePoint: function () {\n\t    var sourceCell = this.getSourceCell();\n\t    if (!sourceCell) return new Point(this.source());\n\t    return sourceCell.getPointFromConnectedLink(this, 'source');\n\t  },\n\t  getTargetPoint: function () {\n\t    var targetCell = this.getTargetCell();\n\t    if (!targetCell) return new Point(this.target());\n\t    return targetCell.getPointFromConnectedLink(this, 'target');\n\t  },\n\t  getPointFromConnectedLink: function /* link, endType */\n\t  () {\n\t    return this.getPolyline().pointAt(0.5);\n\t  },\n\t  getPolyline: function () {\n\t    const points = [this.getSourcePoint(), ...this.vertices().map(Point), this.getTargetPoint()];\n\t    return new Polyline$1(points);\n\t  },\n\t  getBBox: function () {\n\t    return this.getPolyline().bbox();\n\t  },\n\t  reparent: function (opt) {\n\t    var newParent;\n\t    if (this.graph) {\n\t      var source = this.getSourceElement();\n\t      var target = this.getTargetElement();\n\t      var prevParent = this.getParentCell();\n\t      if (source && target) {\n\t        if (source === target || source.isEmbeddedIn(target)) {\n\t          newParent = target;\n\t        } else if (target.isEmbeddedIn(source)) {\n\t          newParent = source;\n\t        } else {\n\t          newParent = this.graph.getCommonAncestor(source, target);\n\t        }\n\t      }\n\t      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n\t        // Unembed the link if source and target has no common ancestor\n\t        // or common ancestor changed\n\t        prevParent.unembed(this, opt);\n\t      }\n\t      if (newParent) {\n\t        newParent.embed(this, opt);\n\t      }\n\t    }\n\t    return newParent;\n\t  },\n\t  hasLoop: function (opt) {\n\t    opt = opt || {};\n\t    var {\n\t      source,\n\t      target\n\t    } = this.attributes;\n\t    var sourceId = source.id;\n\t    var targetId = target.id;\n\t    if (!sourceId || !targetId) {\n\t      // Link \"pinned\" to the paper does not have a loop.\n\t      return false;\n\t    }\n\t    var loop = sourceId === targetId;\n\n\t    // Note that there in the deep mode a link can have a loop,\n\t    // even if it connects only a parent and its embed.\n\t    // A loop \"target equals source\" is valid in both shallow and deep mode.\n\t    if (!loop && opt.deep && this.graph) {\n\t      var sourceElement = this.getSourceCell();\n\t      var targetElement = this.getTargetCell();\n\t      loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n\t    }\n\t    return loop;\n\t  },\n\t  // unlike source(), this method returns null if source is a point\n\t  getSourceCell: function () {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    var source = attributes.source;\n\t    return source && source.id && graph && graph.getCell(source.id) || null;\n\t  },\n\t  getSourceElement: function () {\n\t    var cell = this;\n\t    var visited = {};\n\t    do {\n\t      if (visited[cell.id]) return null;\n\t      visited[cell.id] = true;\n\t      cell = cell.getSourceCell();\n\t    } while (cell && cell.isLink());\n\t    return cell;\n\t  },\n\t  // unlike target(), this method returns null if target is a point\n\t  getTargetCell: function () {\n\t    const {\n\t      graph,\n\t      attributes\n\t    } = this;\n\t    var target = attributes.target;\n\t    return target && target.id && graph && graph.getCell(target.id) || null;\n\t  },\n\t  getTargetElement: function () {\n\t    var cell = this;\n\t    var visited = {};\n\t    do {\n\t      if (visited[cell.id]) return null;\n\t      visited[cell.id] = true;\n\t      cell = cell.getTargetCell();\n\t    } while (cell && cell.isLink());\n\t    return cell;\n\t  },\n\t  // Returns the common ancestor for the source element,\n\t  // target element and the link itself.\n\t  getRelationshipAncestor: function () {\n\t    var connectionAncestor;\n\t    if (this.graph) {\n\t      var cells = [this, this.getSourceElement(),\n\t      // null if source is a point\n\t      this.getTargetElement() // null if target is a point\n\t      ].filter(function (item) {\n\t        return !!item;\n\t      });\n\t      connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n\t    }\n\t    return connectionAncestor || null;\n\t  },\n\t  // Is source, target and the link itself embedded in a given cell?\n\t  isRelationshipEmbeddedIn: function (cell) {\n\t    var cellId = isString(cell) || isNumber(cell) ? cell : cell.id;\n\t    var ancestor = this.getRelationshipAncestor();\n\t    return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n\t  },\n\t  // Get resolved default label.\n\t  _getDefaultLabel: function () {\n\t    var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\t    var label = {};\n\t    label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n\t    label.position = defaultLabel.position;\n\t    label.attrs = defaultLabel.attrs;\n\t    label.size = defaultLabel.size;\n\t    return label;\n\t  }\n\t}, {\n\t  endsEqual: function (a, b) {\n\t    var portsEqual = a.port === b.port || !a.port && !b.port;\n\t    return a.id === b.id && portsEqual;\n\t  }\n\t});\n\n\tconst env = {\n\t  _results: {},\n\t  _tests: {\n\t    svgforeignobject: function () {\n\t      return !!document.createElementNS && /SVGForeignObject/.test({}.toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n\t    },\n\t    // works for: (1) macOS Safari, (2) any WKWebView, (3) any iOS browser (including Safari, CriOS, EdgiOS, OPR, FxiOS)\n\t    isAppleWebKit: function () {\n\t      const userAgent = navigator.userAgent;\n\t      const isAppleWebKit = /applewebkit/i.test(userAgent);\n\t      const isChromium = /chrome/i.test(userAgent); // e.g. Chrome, Edge, Opera, SamsungBrowser\n\t      return isAppleWebKit && !isChromium;\n\t    }\n\t  },\n\t  addTest: function (name, fn) {\n\t    return this._tests[name] = fn;\n\t  },\n\t  test: function (name) {\n\t    var fn = this._tests[name];\n\t    if (!fn) {\n\t      throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n\t    }\n\t    var result = this._results[name];\n\t    if (typeof result !== 'undefined') {\n\t      return result;\n\t    }\n\t    try {\n\t      result = fn();\n\t    } catch {\n\t      result = false;\n\t    }\n\n\t    // Cache the test result.\n\t    this._results[name] = result;\n\t    return result;\n\t  }\n\t};\n\n\t// ELEMENTS\n\n\tconst Rectangle = Element$1.define('standard.Rectangle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Circle = Element$1.define('standard.Circle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      cx: 'calc(s/2)',\n\t      cy: 'calc(s/2)',\n\t      r: 'calc(s/2)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'circle',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Ellipse = Element$1.define('standard.Ellipse', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'ellipse',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Path = Element$1.define('standard.Path', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Polygon = Element$1.define('standard.Polygon', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'polygon',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Polyline = Element$1.define('standard.Polyline', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'polyline',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst Image = Element$1.define('standard.Image', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    image: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)'\n\t      // xlinkHref: '[URL]'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst BorderedImage = Element$1.define('standard.BorderedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    border: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    background: {\n\t      width: 'calc(w-1)',\n\t      height: 'calc(h-1)',\n\t      x: 0.5,\n\t      y: 0.5,\n\t      fill: '#FFFFFF'\n\t    },\n\t    image: {\n\t      // xlinkHref: '[URL]'\n\t      width: 'calc(w-1)',\n\t      height: 'calc(h-1)',\n\t      x: 0.5,\n\t      y: 0.5\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'background',\n\t    attributes: {\n\t      'stroke': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'border',\n\t    attributes: {\n\t      'fill': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst EmbeddedImage = Element$1.define('standard.EmbeddedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      fill: '#FFFFFF',\n\t      strokeWidth: 2\n\t    },\n\t    image: {\n\t      // xlinkHref: '[URL]'\n\t      width: 'calc(0.3*w)',\n\t      height: 'calc(h-20)',\n\t      x: 10,\n\t      y: 10,\n\t      preserveAspectRatio: 'xMidYMin'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'left',\n\t      x: 'calc(0.3*w+20)',\n\t      // 10 + 10\n\t      y: 10,\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst InscribedImage = Element$1.define('standard.InscribedImage', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    border: {\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    background: {\n\t      rx: 'calc(w/2)',\n\t      ry: 'calc(h/2)',\n\t      cx: 'calc(w/2)',\n\t      cy: 'calc(h/2)',\n\t      fill: '#FFFFFF'\n\t    },\n\t    image: {\n\t      // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n\t      width: 'calc(0.68*w)',\n\t      height: 'calc(0.68*h)',\n\t      // The image offset is calculated as (100% - 68%) / 2\n\t      x: 'calc(0.16*w)',\n\t      y: 'calc(0.16*h)',\n\t      preserveAspectRatio: 'xMidYMid'\n\t      // xlinkHref: '[URL]'\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'top',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+10)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'ellipse',\n\t    selector: 'background'\n\t  }, {\n\t    tagName: 'image',\n\t    selector: 'image'\n\t  }, {\n\t    tagName: 'ellipse',\n\t    selector: 'border',\n\t    attributes: {\n\t      'fill': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }]\n\t});\n\tconst HeaderedRectangle = Element$1.define('standard.HeaderedRectangle', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    header: {\n\t      width: 'calc(w)',\n\t      height: 30,\n\t      strokeWidth: 2,\n\t      stroke: '#000000',\n\t      fill: '#FFFFFF'\n\t    },\n\t    headerText: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 15,\n\t      fontSize: 16,\n\t      fill: '#333333'\n\t    },\n\t    bodyText: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h/2+15)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'header'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'headerText'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'bodyText'\n\t  }]\n\t});\n\tvar CYLINDER_TILT = 10;\n\tconst Cylinder = Element$1.define('standard.Cylinder', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      lateralArea: CYLINDER_TILT,\n\t      fill: '#FFFFFF',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    top: {\n\t      cx: 'calc(w/2)',\n\t      cy: CYLINDER_TILT,\n\t      rx: 'calc(w/2)',\n\t      ry: CYLINDER_TILT,\n\t      fill: '#FFFFFF',\n\t      stroke: '#333333',\n\t      strokeWidth: 2\n\t    },\n\t    label: {\n\t      textVerticalAnchor: 'middle',\n\t      textAnchor: 'middle',\n\t      x: 'calc(w/2)',\n\t      y: 'calc(h+15)',\n\t      fontSize: 14,\n\t      fill: '#333333'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'body'\n\t  }, {\n\t    tagName: 'ellipse',\n\t    selector: 'top'\n\t  }, {\n\t    tagName: 'text',\n\t    selector: 'label'\n\t  }],\n\t  topRy: function (t, opt) {\n\t    // getter\n\t    if (t === undefined) return this.attr('body/lateralArea');\n\n\t    // setter\n\t    var bodyAttrs = {\n\t      lateralArea: t\n\t    };\n\t    var isPercentageSetter = isPercentage(t);\n\t    var ty = isPercentageSetter ? `calc(${parseFloat(t) / 100}*h)` : t;\n\t    var topAttrs = {\n\t      cy: ty,\n\t      ry: ty\n\t    };\n\t    return this.attr({\n\t      body: bodyAttrs,\n\t      top: topAttrs\n\t    }, opt);\n\t  }\n\t}, {\n\t  attributes: {\n\t    'lateral-area': {\n\t      set: function (t, refBBox) {\n\t        var isPercentageSetter = isPercentage(t);\n\t        if (isPercentageSetter) t = parseFloat(t) / 100;\n\t        var x = refBBox.x;\n\t        var y = refBBox.y;\n\t        var w = refBBox.width;\n\t        var h = refBBox.height;\n\n\t        // curve control point variables\n\t        var rx = w / 2;\n\t        var ry = isPercentageSetter ? h * t : t;\n\t        var kappa = V.KAPPA;\n\t        var cx = kappa * rx;\n\t        var cy = kappa * (isPercentageSetter ? h * t : t);\n\n\t        // shape variables\n\t        var xLeft = x;\n\t        var xCenter = x + w / 2;\n\t        var xRight = x + w;\n\t        var ySideTop = y + ry;\n\t        var yCurveTop = ySideTop - ry;\n\t        var ySideBottom = y + h - ry;\n\t        var yCurveBottom = y + h;\n\n\t        // return calculated shape\n\t        var data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];\n\t        return {\n\t          d: data.join(' ')\n\t        };\n\t      },\n\t      unset: 'd'\n\t    }\n\t  }\n\t});\n\tvar foLabelMarkup = {\n\t  tagName: 'foreignObject',\n\t  selector: 'foreignObject',\n\t  attributes: {\n\t    'overflow': 'hidden'\n\t  },\n\t  children: [{\n\t    tagName: 'div',\n\t    namespaceURI: 'http://www.w3.org/1999/xhtml',\n\t    selector: 'label',\n\t    style: {\n\t      width: '100%',\n\t      height: '100%',\n\t      position: 'static',\n\t      backgroundColor: 'transparent',\n\t      textAlign: 'center',\n\t      margin: 0,\n\t      padding: '0px 5px',\n\t      boxSizing: 'border-box',\n\t      display: 'flex',\n\t      alignItems: 'center',\n\t      justifyContent: 'center'\n\t    }\n\t  }]\n\t};\n\tvar svgLabelMarkup = {\n\t  tagName: 'text',\n\t  selector: 'label',\n\t  attributes: {\n\t    'text-anchor': 'middle'\n\t  }\n\t};\n\tvar labelMarkup = env.test('svgforeignobject') ? foLabelMarkup : svgLabelMarkup;\n\tconst TextBlock = Element$1.define('standard.TextBlock', {\n\t  attrs: {\n\t    root: {\n\t      cursor: 'move'\n\t    },\n\t    body: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)',\n\t      stroke: '#333333',\n\t      fill: '#ffffff',\n\t      strokeWidth: 2\n\t    },\n\t    foreignObject: {\n\t      width: 'calc(w)',\n\t      height: 'calc(h)'\n\t    },\n\t    label: {\n\t      style: {\n\t        fontSize: 14\n\t      }\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'rect',\n\t    selector: 'body'\n\t  }, labelMarkup]\n\t}, {\n\t  attributes: {\n\t    text: {\n\t      set: function (text, refBBox, node, attrs) {\n\t        if (node instanceof HTMLElement) {\n\t          node.textContent = text;\n\t        } else {\n\t          // No foreign object\n\t          var style = attrs['style'] || {};\n\t          var wrapValue = {\n\t            text,\n\t            width: -5,\n\t            height: '100%'\n\t          };\n\t          var wrapAttrs = assign({\n\t            'text-vertical-anchor': 'middle'\n\t          }, style);\n\t          attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n\t          return {\n\t            fill: style.color || null\n\t          };\n\t        }\n\t      },\n\t      unset: function (node) {\n\t        node.textContent = '';\n\t        if (node instanceof SVGElement) {\n\t          return 'fill';\n\t        }\n\t      },\n\t      position: function (text, refBBox, node) {\n\t        // No foreign object\n\t        if (node instanceof SVGElement) return refBBox.center();\n\t      }\n\t    }\n\t  }\n\t});\n\n\t// LINKS\n\n\tconst Link = Link$1.define('standard.Link', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#333333',\n\t      strokeWidth: 2,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'd': 'M 10 -5 0 0 10 5 z'\n\t      }\n\t    },\n\t    wrapper: {\n\t      connection: true,\n\t      strokeWidth: 10,\n\t      strokeLinejoin: 'round'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'wrapper',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer',\n\t      'stroke': 'transparent',\n\t      'stroke-linecap': 'round'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }]\n\t});\n\tconst DoubleLink = Link$1.define('standard.DoubleLink', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#DDDDDD',\n\t      strokeWidth: 4,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        type: 'path',\n\t        stroke: '#000000',\n\t        d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n\t      }\n\t    },\n\t    outline: {\n\t      connection: true,\n\t      stroke: '#000000',\n\t      strokeWidth: 6,\n\t      strokeLinejoin: 'round'\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'outline',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }]\n\t});\n\tconst ShadowLink = Link$1.define('standard.ShadowLink', {\n\t  attrs: {\n\t    line: {\n\t      connection: true,\n\t      stroke: '#FF0000',\n\t      strokeWidth: 20,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M 0 -10 -10 0 0 10 z'\n\t      },\n\t      sourceMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t      }\n\t    },\n\t    shadow: {\n\t      connection: true,\n\t      transform: 'translate(3,6)',\n\t      stroke: '#000000',\n\t      strokeOpacity: 0.2,\n\t      strokeWidth: 20,\n\t      strokeLinejoin: 'round',\n\t      targetMarker: {\n\t        'type': 'path',\n\t        'd': 'M 0 -10 -10 0 0 10 z',\n\t        'stroke': 'none'\n\t      },\n\t      sourceMarker: {\n\t        'type': 'path',\n\t        'stroke': 'none',\n\t        'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t      }\n\t    }\n\t  }\n\t}, {\n\t  markup: [{\n\t    tagName: 'path',\n\t    selector: 'shadow',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'line',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'cursor': 'pointer'\n\t    }\n\t  }]\n\t});\n\n\tvar standard = {\n\t\t__proto__: null,\n\t\tBorderedImage: BorderedImage,\n\t\tCircle: Circle,\n\t\tCylinder: Cylinder,\n\t\tDoubleLink: DoubleLink,\n\t\tEllipse: Ellipse,\n\t\tEmbeddedImage: EmbeddedImage,\n\t\tHeaderedRectangle: HeaderedRectangle,\n\t\tImage: Image,\n\t\tInscribedImage: InscribedImage,\n\t\tLink: Link,\n\t\tPath: Path,\n\t\tPolygon: Polygon,\n\t\tPolyline: Polyline,\n\t\tRectangle: Rectangle,\n\t\tShadowLink: ShadowLink,\n\t\tTextBlock: TextBlock\n\t};\n\n\tvar index$5 = {\n\t\t__proto__: null,\n\t\tstandard: standard\n\t};\n\n\tconst CornerTypes = {\n\t  POINT: 'point',\n\t  CUBIC: 'cubic',\n\t  LINE: 'line',\n\t  GAP: 'gap'\n\t};\n\tconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\tconst CORNER_RADIUS$1 = 10;\n\tconst PRECISION$1 = 1;\n\tconst straight = function (sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\t  const {\n\t    cornerType = CornerTypes.POINT,\n\t    cornerRadius = CORNER_RADIUS$1,\n\t    cornerPreserveAspectRatio = false,\n\t    precision = PRECISION$1,\n\t    raw = false\n\t  } = opt;\n\t  if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n\t    // unknown `cornerType` provided => error\n\t    throw new Error('Invalid `cornerType` provided to `straight` connector.');\n\t  }\n\t  let path;\n\t  if (cornerType === CornerTypes.POINT || !cornerRadius) {\n\t    // default option => normal connector\n\t    // simply connect all points with straight lines\n\t    const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n\t    const polyline = new Polyline$1(points);\n\t    path = new Path$1(polyline);\n\t  } else {\n\t    // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n\t    path = new Path$1();\n\n\t    // add initial gap segment = to source point\n\t    path.appendSegment(Path$1.createSegment('M', sourcePoint));\n\t    let nextDistance;\n\t    const routePointsLength = routePoints.length;\n\t    for (let i = 0; i < routePointsLength; i++) {\n\t      const curr = new Point(routePoints[i]);\n\t      const prev = routePoints[i - 1] || sourcePoint;\n\t      const next = routePoints[i + 1] || targetPoint;\n\t      const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`\n\t      nextDistance = curr.distance(next) / 2;\n\t      let startMove, endMove;\n\t      if (!cornerPreserveAspectRatio) {\n\t        // `startMove` and `endMove` may be different\n\t        // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n\t        startMove = -Math.min(cornerRadius, prevDistance);\n\t        endMove = -Math.min(cornerRadius, nextDistance);\n\t      } else {\n\t        // force `startMove` and `endMove` to be the same\n\t        startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n\t      }\n\n\t      // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n\t      // - find a point lying on the line `prev - startMove` such that...\n\t      // - ...the point lies `abs(startMove)` distance away from `curr`...\n\t      // - ...and its coordinates are rounded to whole numbers\n\t      const cornerStart = curr.clone().move(prev, startMove).round(precision);\n\t      const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n\t      // add in-between straight segment = from previous route point to corner start point\n\t      // (may have zero length)\n\t      path.appendSegment(Path$1.createSegment('L', cornerStart));\n\n\t      // add corner segment = from corner start point to corner end point\n\t      switch (cornerType) {\n\t        case CornerTypes.CUBIC:\n\t          {\n\t            // corner is rounded\n\t            const _13 = 1 / 3;\n\t            const _23 = 2 / 3;\n\t            const control1 = new Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);\n\t            const control2 = new Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);\n\t            path.appendSegment(Path$1.createSegment('C', control1, control2, cornerEnd));\n\t            break;\n\t          }\n\t        case CornerTypes.LINE:\n\t          {\n\t            // corner has bevel\n\t            path.appendSegment(Path$1.createSegment('L', cornerEnd));\n\t            break;\n\t          }\n\t        case CornerTypes.GAP:\n\t          {\n\t            // corner has empty space\n\t            path.appendSegment(Path$1.createSegment('M', cornerEnd));\n\t            break;\n\t          }\n\t        // default: no segment is created\n\t      }\n\t    }\n\n\t    // add final straight segment = from last corner end point to target point\n\t    // (= or from start point to end point, if there are no route points)\n\t    // (may have zero length)\n\t    path.appendSegment(Path$1.createSegment('L', targetPoint));\n\t  }\n\t  return raw ? path : path.serialize();\n\t};\n\n\t// default size of jump if not specified in options\n\tvar JUMP_SIZE = 5;\n\n\t// available jump types\n\t// first one taken as default\n\tvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n\t// default radius\n\tvar RADIUS = 0;\n\n\t// takes care of math. error for case when jump is too close to end of line\n\tvar CLOSE_PROXIMITY_PADDING = 1;\n\n\t// list of connector types not to jump over.\n\tvar IGNORED_CONNECTORS = ['smooth'];\n\n\t// internal constants for round segment\n\tvar _13 = 1 / 3;\n\tvar _23 = 2 / 3;\n\tfunction sortPointsAscending(p1, p2) {\n\t  let {\n\t    x: x1,\n\t    y: y1\n\t  } = p1;\n\t  let {\n\t    x: x2,\n\t    y: y2\n\t  } = p2;\n\t  if (x1 > x2) {\n\t    let swap = x1;\n\t    x1 = x2;\n\t    x2 = swap;\n\t    swap = y1;\n\t    y1 = y2;\n\t    y2 = swap;\n\t  }\n\t  if (y1 > y2) {\n\t    let swap = x1;\n\t    x1 = x2;\n\t    x2 = swap;\n\t    swap = y1;\n\t    y1 = y2;\n\t    y2 = swap;\n\t  }\n\t  return [new Point(x1, y1), new Point(x2, y2)];\n\t}\n\tfunction overlapExists(line1, line2) {\n\t  const [{\n\t    x: x1,\n\t    y: y1\n\t  }, {\n\t    x: x2,\n\t    y: y2\n\t  }] = sortPointsAscending(line1.start, line1.end);\n\t  const [{\n\t    x: x3,\n\t    y: y3\n\t  }, {\n\t    x: x4,\n\t    y: y4\n\t  }] = sortPointsAscending(line2.start, line2.end);\n\t  const xMatch = x1 <= x4 && x3 <= x2;\n\t  const yMatch = y1 <= y4 && y3 <= y2;\n\t  return xMatch && yMatch;\n\t}\n\n\t/**\n\t * Transform start/end and route into series of lines\n\t * @param {g.point} sourcePoint start point\n\t * @param {g.point} targetPoint end point\n\t * @param {g.point[]} route optional list of route\n\t * @return {g.line[]} [description]\n\t */\n\tfunction createLines(sourcePoint, targetPoint, route) {\n\t  // make a flattened array of all points\n\t  var points = [].concat(sourcePoint, route, targetPoint);\n\t  return points.reduce(function (resultLines, point, idx) {\n\t    // if there is a next point, make a line with it\n\t    var nextPoint = points[idx + 1];\n\t    if (nextPoint != null) {\n\t      resultLines[idx] = line$1(point, nextPoint);\n\t    }\n\t    return resultLines;\n\t  }, []);\n\t}\n\tfunction setupUpdating(jumpOverLinkView) {\n\t  var paper = jumpOverLinkView.paper;\n\t  var updateList = paper._jumpOverUpdateList;\n\n\t  // first time setup for this paper\n\t  if (updateList == null) {\n\t    updateList = paper._jumpOverUpdateList = [];\n\t    var graph = paper.model;\n\t    graph.on('batch:stop', function () {\n\t      if (this.hasActiveBatch()) return;\n\t      updateJumpOver(paper);\n\t    });\n\t    graph.on('reset', function () {\n\t      updateList = paper._jumpOverUpdateList = [];\n\t    });\n\t  }\n\n\t  // add this link to a list so it can be updated when some other link is updated\n\t  if (updateList.indexOf(jumpOverLinkView) < 0) {\n\t    updateList.push(jumpOverLinkView);\n\n\t    // watch for change of connector type or removal of link itself\n\t    // to remove the link from a list of jump over connectors\n\t    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n\t      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n\t    });\n\t  }\n\t}\n\n\t/**\n\t * Handler for a batch:stop event to force\n\t * update of all registered links with jump over connector\n\t * @param {object} batchEvent optional object with info about batch\n\t */\n\tfunction updateJumpOver(paper) {\n\t  var updateList = paper._jumpOverUpdateList;\n\t  for (var i = 0; i < updateList.length; i++) {\n\t    const linkView = updateList[i];\n\t    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n\t    linkView.requestUpdate(updateFlag);\n\t  }\n\t}\n\n\t/**\n\t * Utility function to collect all intersection points of a single\n\t * line against group of other lines.\n\t * @param {g.line} line where to find points\n\t * @param {g.line[]} crossCheckLines lines to cross\n\t * @return {g.point[]} list of intersection points\n\t */\n\tfunction findLineIntersections(line, crossCheckLines) {\n\t  return toArray$1(crossCheckLines).reduce(function (res, crossCheckLine) {\n\t    var intersection = line.intersection(crossCheckLine);\n\t    if (intersection) {\n\t      res.push(intersection);\n\t    }\n\t    return res;\n\t  }, []);\n\t}\n\n\t/**\n\t * Sorting function for list of points by their distance.\n\t * @param {g.point} p1 first point\n\t * @param {g.point} p2 second point\n\t * @return {number} squared distance between points\n\t */\n\tfunction sortPoints(p1, p2) {\n\t  return line$1(p1, p2).squaredLength();\n\t}\n\n\t/**\n\t * Split input line into multiple based on intersection points.\n\t * @param {g.line} line input line to split\n\t * @param {g.point[]} intersections points where to split the line\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @return {g.line[]} list of lines being split\n\t */\n\tfunction createJumps(line, intersections, jumpSize) {\n\t  return intersections.reduce(function (resultLines, point$1, idx) {\n\t    // skipping points that were merged with the previous line\n\t    // to make bigger arc over multiple lines that are close to each other\n\t    if (point$1.skip === true) {\n\t      return resultLines;\n\t    }\n\n\t    // always grab the last line from buffer and modify it\n\t    var lastLine = resultLines.pop() || line;\n\n\t    // calculate start and end of jump by moving by a given size of jump\n\t    var jumpStart = point(point$1).move(lastLine.start, -jumpSize);\n\t    var jumpEnd = point(point$1).move(lastLine.start, +jumpSize);\n\n\t    // now try to look at the next intersection point\n\t    var nextPoint = intersections[idx + 1];\n\t    if (nextPoint != null) {\n\t      var distance = jumpEnd.distance(nextPoint);\n\t      if (distance <= jumpSize) {\n\t        // next point is close enough, move the jump end by this\n\t        // difference and mark the next point to be skipped\n\t        jumpEnd = nextPoint.move(lastLine.start, distance);\n\t        nextPoint.skip = true;\n\t      }\n\t    } else {\n\t      // this block is inside of `else` as an optimization so the distance is\n\t      // not calculated when we know there are no other intersection points\n\t      var endDistance = jumpStart.distance(lastLine.end);\n\t      // if the end is too close to possible jump, draw remaining line instead of a jump\n\t      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t        resultLines.push(lastLine);\n\t        return resultLines;\n\t      }\n\t    }\n\t    var startDistance = jumpEnd.distance(lastLine.start);\n\t    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t      // if the start of line is too close to jump, draw that line instead of a jump\n\t      resultLines.push(lastLine);\n\t      return resultLines;\n\t    }\n\n\t    // finally create a jump line\n\t    var jumpLine = line$1(jumpStart, jumpEnd);\n\t    // it's just simple line but with a `isJump` property\n\t    jumpLine.isJump = true;\n\t    resultLines.push(line$1(lastLine.start, jumpStart), jumpLine, line$1(jumpEnd, lastLine.end));\n\t    return resultLines;\n\t  }, []);\n\t}\n\n\t/**\n\t * Assemble `D` attribute of a SVG path by iterating given lines.\n\t * @param {g.line[]} lines source lines to use\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @param {number} radius the radius\n\t * @return {string}\n\t */\n\tfunction buildPath(lines, jumpSize, jumpType, radius) {\n\t  var path = new Path$1();\n\t  var segment;\n\n\t  // first move to the start of a first line\n\t  segment = Path$1.createSegment('M', lines[0].start);\n\t  path.appendSegment(segment);\n\n\t  // make a paths from lines\n\t  toArray$1(lines).forEach(function (line, index) {\n\t    if (line.isJump) {\n\t      var angle, diff;\n\t      var control1, control2;\n\t      if (jumpType === 'arc') {\n\t        // approximates semicircle with 2 curves\n\t        angle = -90;\n\t        // determine rotation of arc based on difference between points\n\t        diff = line.start.difference(line.end);\n\t        // make sure the arc always points up (or right)\n\t        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n\t        if (xAxisRotate) angle += 180;\n\t        var midpoint = line.midpoint();\n\t        var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);\n\t        var halfLine;\n\n\t        // first half\n\t        halfLine = new Line(line.start, midpoint);\n\t        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n\t        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\t        segment = Path$1.createSegment('C', control1, control2, centerLine.end);\n\t        path.appendSegment(segment);\n\n\t        // second half\n\t        halfLine = new Line(midpoint, line.end);\n\t        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n\t        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\t        segment = Path$1.createSegment('C', control1, control2, line.end);\n\t        path.appendSegment(segment);\n\t      } else if (jumpType === 'gap') {\n\t        segment = Path$1.createSegment('M', line.end);\n\t        path.appendSegment(segment);\n\t      } else if (jumpType === 'cubic') {\n\t        // approximates semicircle with 1 curve\n\t        angle = line.start.theta(line.end);\n\t        var xOffset = jumpSize * 0.6;\n\t        var yOffset = jumpSize * 1.35;\n\n\t        // determine rotation of arc based on difference between points\n\t        diff = line.start.difference(line.end);\n\t        // make sure the arc always points up (or right)\n\t        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n\t        if (xAxisRotate) yOffset *= -1;\n\t        control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n\t        control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\t        segment = Path$1.createSegment('C', control1, control2, line.end);\n\t        path.appendSegment(segment);\n\t      }\n\t    } else {\n\t      var nextLine = lines[index + 1];\n\t      if (radius == 0 || !nextLine || nextLine.isJump) {\n\t        segment = Path$1.createSegment('L', line.end);\n\t        path.appendSegment(segment);\n\t      } else {\n\t        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n\t      }\n\t    }\n\t  });\n\t  return path;\n\t}\n\tfunction buildRoundedSegment(offset, path, curr, prev, next) {\n\t  var prevDistance = curr.distance(prev) / 2;\n\t  var nextDistance = curr.distance(next) / 2;\n\t  var startMove = -Math.min(offset, prevDistance);\n\t  var endMove = -Math.min(offset, nextDistance);\n\t  var roundedStart = curr.clone().move(prev, startMove).round();\n\t  var roundedEnd = curr.clone().move(next, endMove).round();\n\t  var control1 = new Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n\t  var control2 = new Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n\t  var segment;\n\t  segment = Path$1.createSegment('L', roundedStart);\n\t  path.appendSegment(segment);\n\t  segment = Path$1.createSegment('C', control1, control2, roundedEnd);\n\t  path.appendSegment(segment);\n\t}\n\n\t/**\n\t * Actual connector function that will be run on every update.\n\t * @param {g.point} sourcePoint start point of this link\n\t * @param {g.point} targetPoint end point of this link\n\t * @param {g.point[]} route of this link\n\t * @param {object} opt options\n\t * @property {number} size optional size of a jump arc\n\t * @return {string} created `D` attribute of SVG path\n\t */\n\tconst jumpover = function (sourcePoint, targetPoint, route, opt) {\n\t  setupUpdating(this);\n\t  var raw = opt.raw;\n\t  var jumpSize = opt.size || JUMP_SIZE;\n\t  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n\t  var radius = opt.radius || RADIUS;\n\t  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n\t  // grab the first jump type as a default if specified one is invalid\n\t  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n\t    jumpType = JUMP_TYPES[0];\n\t  }\n\t  var paper = this.paper;\n\t  var graph = paper.model;\n\t  var allLinks = graph.getLinks();\n\n\t  // there is just one link, draw it directly\n\t  if (allLinks.length === 1) {\n\t    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n\t  }\n\t  var thisModel = this.model;\n\t  var thisIndex = allLinks.indexOf(thisModel);\n\t  var defaultConnector = paper.options.defaultConnector || {};\n\n\t  // not all links are meant to be jumped over.\n\t  var links = allLinks.filter(function (link, idx) {\n\t    var connector = link.get('connector') || defaultConnector;\n\n\t    // avoid jumping over links with connector type listed in `ignored connectors`.\n\t    if (toArray$1(ignoreConnectors).includes(connector.name)) {\n\t      return false;\n\t    }\n\t    // filter out links that are above this one and  have the same connector type\n\t    // otherwise there would double hoops for each intersection\n\t    if (idx > thisIndex) {\n\t      return connector.name !== 'jumpover';\n\t    }\n\t    return true;\n\t  });\n\n\t  // find views for all links\n\t  var linkViews = links.map(function (link) {\n\t    return paper.findViewByModel(link);\n\t  });\n\n\t  // create lines for this link\n\t  var thisLines = createLines(sourcePoint, targetPoint, route);\n\n\t  // create lines for all other links\n\t  var linkLines = linkViews.map(function (linkView) {\n\t    if (linkView == null) {\n\t      return [];\n\t    }\n\t    if (linkView === this) {\n\t      return thisLines;\n\t    }\n\t    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n\t  }, this);\n\n\t  // transform lines for this link by splitting with jump lines at\n\t  // points of intersection with other links\n\t  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n\t    // iterate all links and grab the intersections with this line\n\t    // these are then sorted by distance so the line can be split more easily\n\t    var intersections = links.reduce(function (res, link, i) {\n\t      // don't intersection with itself\n\t      if (link !== thisModel) {\n\t        const linkLinesToTest = linkLines[i].slice();\n\t        const overlapIndex = linkLinesToTest.findIndex(line => overlapExists(thisLine, line));\n\n\t        // Overlap occurs and the end point of one segment lies on thisLine\n\t        if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n\t          // Remove the next segment because there will never be a jump\n\t          linkLinesToTest.splice(overlapIndex + 1, 1);\n\t        }\n\t        const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n\t        res.push.apply(res, lineIntersections);\n\t      }\n\t      return res;\n\t    }, []).sort(function (a, b) {\n\t      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n\t    });\n\t    if (intersections.length > 0) {\n\t      // split the line based on found intersection points\n\t      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n\t    } else {\n\t      // without any intersection the line goes uninterrupted\n\t      resultLines.push(thisLine);\n\t    }\n\t    return resultLines;\n\t  }, []);\n\t  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n\t  return raw ? path : path.serialize();\n\t};\n\n\tconst normal$1 = function (sourcePoint, targetPoint, route = [], opt = {}) {\n\t  const {\n\t    raw\n\t  } = opt;\n\t  const localOpt = {\n\t    cornerType: 'point',\n\t    raw\n\t  };\n\t  return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tconst CORNER_RADIUS = 10;\n\tconst PRECISION = 0;\n\tconst rounded = function (sourcePoint, targetPoint, route = [], opt = {}) {\n\t  const {\n\t    radius = CORNER_RADIUS,\n\t    raw\n\t  } = opt;\n\t  const localOpt = {\n\t    cornerType: 'cubic',\n\t    cornerRadius: radius,\n\t    precision: PRECISION,\n\t    raw\n\t  };\n\t  return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tconst smooth = function (sourcePoint, targetPoint, route, opt) {\n\t  var raw = opt && opt.raw;\n\t  var path;\n\t  if (route && route.length !== 0) {\n\t    var points = [sourcePoint].concat(route).concat([targetPoint]);\n\t    var curves = Curve.throughPoints(points);\n\t    path = new Path$1(curves);\n\t  } else {\n\t    // if we have no route, use a default cubic bezier curve\n\t    // cubic bezier requires two control points\n\t    // the control points have `x` midway between source and target\n\t    // this produces an S-like curve\n\n\t    path = new Path$1();\n\t    var segment;\n\t    segment = Path$1.createSegment('M', sourcePoint);\n\t    path.appendSegment(segment);\n\t    if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {\n\t      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\t      segment = Path$1.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n\t      path.appendSegment(segment);\n\t    } else {\n\t      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\t      segment = Path$1.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n\t      path.appendSegment(segment);\n\t    }\n\t  }\n\t  return raw ? path : path.serialize();\n\t};\n\n\tconst Directions$2 = {\n\t  AUTO: 'auto',\n\t  HORIZONTAL: 'horizontal',\n\t  VERTICAL: 'vertical',\n\t  CLOSEST_POINT: 'closest-point',\n\t  OUTWARDS: 'outwards'\n\t};\n\tconst TangentDirections = {\n\t  UP: 'up',\n\t  DOWN: 'down',\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  AUTO: 'auto',\n\t  CLOSEST_POINT: 'closest-point',\n\t  OUTWARDS: 'outwards'\n\t};\n\tconst curve = function (sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n\t  const raw = Boolean(opt.raw);\n\t  // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n\t  // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n\t  // tension - a Catmull-Rom curve tension parameter.\n\t  // sourceTangent - a tangent vector along the curve at the sourcePoint.\n\t  // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n\t  // targetTangent - a tangent vector along the curve at the targetPoint.\n\t  // targetDirection - a unit direction vector along the curve at the targetPoint.\n\t  // precision - a rounding precision for path values.\n\t  const {\n\t    direction = Directions$2.AUTO,\n\t    precision = 3\n\t  } = opt;\n\t  const options = {\n\t    coeff: opt.distanceCoefficient || 0.6,\n\t    angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n\t    tau: opt.tension || 0.5,\n\t    sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n\t    targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n\t    rotate: Boolean(opt.rotate)\n\t  };\n\t  if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\t  if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;else if (typeof opt.targetDirection === 'number') options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\t  const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n\t  // The calculation of a sourceTangent\n\t  let sourceTangent;\n\t  if (options.sourceTangent) {\n\t    sourceTangent = options.sourceTangent;\n\t  } else {\n\t    const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n\t    const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n\t    const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n\t    const angle = angleBetweenVectors(sourceDirection, pointsVector);\n\t    if (angle > Math.PI / 4) {\n\t      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n\t      sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n\t    } else {\n\t      sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n\t    }\n\t  }\n\n\t  // The calculation of a targetTangent\n\t  let targetTangent;\n\t  if (options.targetTangent) {\n\t    targetTangent = options.targetTangent;\n\t  } else {\n\t    const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n\t    const last = completeRoute.length - 1;\n\t    const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n\t    const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n\t    const angle = angleBetweenVectors(targetDirection, pointsVector);\n\t    if (angle > Math.PI / 4) {\n\t      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n\t      targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n\t    } else {\n\t      targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n\t    }\n\t  }\n\t  const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n\t  const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n\t  const path = new Path$1(bezierCurves).round(precision);\n\t  return raw ? path : path.serialize();\n\t};\n\tcurve.Directions = Directions$2;\n\tcurve.TangentDirections = TangentDirections;\n\tfunction getHorizontalSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    if (sourceBBox.x > route[1].x) sourceSide = 'right';else sourceSide = 'left';\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t    case 'right':\n\t    default:\n\t      direction = new Point(1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getHorizontalTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';else targetSide = 'right';\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t    case 'right':\n\t    default:\n\t      direction = new Point(1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getVerticalSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    if (sourceBBox.y > route[1].y) sourceSide = 'bottom';else sourceSide = 'top';\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t    default:\n\t      direction = new Point(0, 1);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getVerticalTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';else targetSide = 'bottom';\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t    default:\n\t      direction = new Point(0, 1);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getAutoSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  let sourceSide;\n\t  let rotation;\n\t  if (!linkView.sourceView) {\n\t    sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n\t  } else {\n\t    rotation = linkView.sourceView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t      const sourcePoint = route[0].clone();\n\t      sourcePoint.rotate(sourceBBox.center(), rotation);\n\t      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t    } else {\n\t      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (sourceSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t      direction = new Point(0, 1);\n\t      break;\n\t    case 'right':\n\t      direction = new Point(1, 0);\n\t      break;\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getAutoTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  let targetSide;\n\t  let rotation;\n\t  if (!linkView.targetView) {\n\t    targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n\t  } else {\n\t    rotation = linkView.targetView.model.angle();\n\t    if (options.rotate && rotation) {\n\t      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t      const targetPoint = route[route.length - 1].clone();\n\t      targetPoint.rotate(targetBBox.center(), rotation);\n\t      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t    } else {\n\t      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t    }\n\t  }\n\t  let direction;\n\t  switch (targetSide) {\n\t    case 'top':\n\t      direction = new Point(0, -1);\n\t      break;\n\t    case 'bottom':\n\t      direction = new Point(0, 1);\n\t      break;\n\t    case 'right':\n\t      direction = new Point(1, 0);\n\t      break;\n\t    case 'left':\n\t      direction = new Point(-1, 0);\n\t      break;\n\t  }\n\t  if (options.rotate && rotation) {\n\t    direction.rotate(null, -rotation);\n\t  }\n\t  return direction;\n\t}\n\tfunction getClosestPointSourceDirection(linkView, route, options) {\n\t  return route[1].difference(route[0]).normalize();\n\t}\n\tfunction getClosestPointTargetDirection(linkView, route, options) {\n\t  const last = route.length - 1;\n\t  return route[last - 1].difference(route[last]).normalize();\n\t}\n\tfunction getOutwardsSourceDirection(linkView, route, options) {\n\t  const {\n\t    sourceBBox\n\t  } = linkView;\n\t  const sourceCenter = sourceBBox.center();\n\t  return route[0].difference(sourceCenter).normalize();\n\t}\n\tfunction getOutwardsTargetDirection(linkView, route, options) {\n\t  const {\n\t    targetBBox\n\t  } = linkView;\n\t  const targetCenter = targetBBox.center();\n\t  return route[route.length - 1].difference(targetCenter).normalize();\n\t}\n\tfunction getSourceTangentDirection(linkView, route, direction, options) {\n\t  if (options.sourceDirection) {\n\t    switch (options.sourceDirection) {\n\t      case TangentDirections.UP:\n\t        return new Point(0, -1);\n\t      case TangentDirections.DOWN:\n\t        return new Point(0, 1);\n\t      case TangentDirections.LEFT:\n\t        return new Point(-1, 0);\n\t      case TangentDirections.RIGHT:\n\t        return new Point(1, 0);\n\t      case TangentDirections.AUTO:\n\t        return getAutoSourceDirection(linkView, route, options);\n\t      case TangentDirections.CLOSEST_POINT:\n\t        return getClosestPointSourceDirection(linkView, route, options);\n\t      case TangentDirections.OUTWARDS:\n\t        return getOutwardsSourceDirection(linkView, route, options);\n\t      default:\n\t        return options.sourceDirection;\n\t    }\n\t  }\n\t  switch (direction) {\n\t    case Directions$2.HORIZONTAL:\n\t      return getHorizontalSourceDirection(linkView, route, options);\n\t    case Directions$2.VERTICAL:\n\t      return getVerticalSourceDirection(linkView, route, options);\n\t    case Directions$2.CLOSEST_POINT:\n\t      return getClosestPointSourceDirection(linkView, route, options);\n\t    case Directions$2.OUTWARDS:\n\t      return getOutwardsSourceDirection(linkView, route, options);\n\t    case Directions$2.AUTO:\n\t    default:\n\t      return getAutoSourceDirection(linkView, route, options);\n\t  }\n\t}\n\tfunction getTargetTangentDirection(linkView, route, direction, options) {\n\t  if (options.targetDirection) {\n\t    switch (options.targetDirection) {\n\t      case TangentDirections.UP:\n\t        return new Point(0, -1);\n\t      case TangentDirections.DOWN:\n\t        return new Point(0, 1);\n\t      case TangentDirections.LEFT:\n\t        return new Point(-1, 0);\n\t      case TangentDirections.RIGHT:\n\t        return new Point(1, 0);\n\t      case TangentDirections.AUTO:\n\t        return getAutoTargetDirection(linkView, route, options);\n\t      case TangentDirections.CLOSEST_POINT:\n\t        return getClosestPointTargetDirection(linkView, route, options);\n\t      case TangentDirections.OUTWARDS:\n\t        return getOutwardsTargetDirection(linkView, route, options);\n\t      default:\n\t        return options.targetDirection;\n\t    }\n\t  }\n\t  switch (direction) {\n\t    case Directions$2.HORIZONTAL:\n\t      return getHorizontalTargetDirection(linkView, route, options);\n\t    case Directions$2.VERTICAL:\n\t      return getVerticalTargetDirection(linkView, route, options);\n\t    case Directions$2.CLOSEST_POINT:\n\t      return getClosestPointTargetDirection(linkView, route, options);\n\t    case Directions$2.OUTWARDS:\n\t      return getOutwardsTargetDirection(linkView, route, options);\n\t    case Directions$2.AUTO:\n\t    default:\n\t      return getAutoTargetDirection(linkView, route, options);\n\t  }\n\t}\n\tfunction rotateVector(vector, angle) {\n\t  const cos = Math.cos(angle);\n\t  const sin = Math.sin(angle);\n\t  const x = cos * vector.x - sin * vector.y;\n\t  const y = sin * vector.x + cos * vector.y;\n\t  vector.x = x;\n\t  vector.y = y;\n\t}\n\tfunction angleBetweenVectors(v1, v2) {\n\t  let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n\t  if (cos < -1) cos = -1;\n\t  if (cos > 1) cos = 1;\n\t  return Math.acos(cos);\n\t}\n\tfunction determinant(v1, v2) {\n\t  return v1.x * v2.y - v1.y * v2.x;\n\t}\n\tfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n\t  const {\n\t    tau,\n\t    coeff\n\t  } = options;\n\t  const distances = [];\n\t  const tangents = [];\n\t  const catmullRomCurves = [];\n\t  const n = points.length - 1;\n\t  for (let i = 0; i < n; i++) {\n\t    distances[i] = points[i].distance(points[i + 1]);\n\t  }\n\t  tangents[0] = sourceTangent;\n\t  tangents[n] = targetTangent;\n\n\t  // The calculation of tangents of vertices\n\t  for (let i = 1; i < n; i++) {\n\t    let tpPrev;\n\t    let tpNext;\n\t    if (i === 1) {\n\t      tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n\t    } else {\n\t      tpPrev = points[i - 1].clone();\n\t    }\n\t    if (i === n - 1) {\n\t      tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n\t    } else {\n\t      tpNext = points[i + 1].clone();\n\t    }\n\t    const v1 = tpPrev.difference(points[i]).normalize();\n\t    const v2 = tpNext.difference(points[i]).normalize();\n\t    const vAngle = angleBetweenVectors(v1, v2);\n\t    let rot = (Math.PI - vAngle) / 2;\n\t    let t;\n\t    const vectorDeterminant = determinant(v1, v2);\n\t    let pointsDeterminant;\n\t    pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n\t    if (vectorDeterminant < 0) {\n\t      rot = -rot;\n\t    }\n\t    if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {\n\t      rot = rot - Math.PI;\n\t    }\n\t    t = v2.clone();\n\t    rotateVector(t, rot);\n\t    const t1 = t.clone();\n\t    const t2 = t.clone();\n\t    const scaleFactor1 = distances[i - 1] * coeff;\n\t    const scaleFactor2 = distances[i] * coeff;\n\t    t1.scale(scaleFactor1, scaleFactor1);\n\t    t2.scale(scaleFactor2, scaleFactor2);\n\t    tangents[i] = [t1, t2];\n\t  }\n\n\t  // The building of a Catmull-Rom curve based of tangents of points\n\t  for (let i = 0; i < n; i++) {\n\t    let p0;\n\t    let p3;\n\t    if (i === 0) {\n\t      p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n\t    } else {\n\t      p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n\t    }\n\t    if (i === n - 1) {\n\t      p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n\t    } else {\n\t      p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n\t    }\n\t    catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n\t  }\n\t  return catmullRomCurves;\n\t}\n\n\t// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\n\tfunction catmullRomToBezier(points, options) {\n\t  const {\n\t    tau\n\t  } = options;\n\t  const bcp1 = new Point();\n\t  bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n\t  bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\t  const bcp2 = new Point();\n\t  bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n\t  bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n\t  return new Curve(points[1], bcp1, bcp2, points[2]);\n\t}\n\n\tvar connectors = {\n\t\t__proto__: null,\n\t\tcurve: curve,\n\t\tjumpover: jumpover,\n\t\tnormal: normal$1,\n\t\trounded: rounded,\n\t\tsmooth: smooth,\n\t\tstraight: straight\n\t};\n\n\t// ViewBase\n\t// -------------\n\n\t// ViewBases are almost more convention than they are actual code. A View\n\t// is simply a JavaScript object that represents a logical chunk of UI in the\n\t// DOM. This might be a single item, an entire list, a sidebar or panel, or\n\t// even the surrounding frame which wraps your whole app. Defining a chunk of\n\t// UI as a **View** allows you to define your DOM events declaratively, without\n\t// having to worry about render order ... and makes it easy for the view to\n\t// react to specific changes in the state of your models.\n\n\t// Creating a ViewBase creates its initial element outside of the DOM,\n\t// if an existing element is not provided...\n\tvar ViewBase = function (options) {\n\t  this.cid = options && options.cid || uniqueId('view');\n\t  this.preinitialize.apply(this, arguments);\n\t  assign(this, pick(options, viewOptions));\n\t  this._ensureElement();\n\t  this.initialize.apply(this, arguments);\n\t};\n\n\t// Cached regex to split keys for `delegate`.\n\tvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n\t// List of view options to be set as properties.\n\t// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.\n\tvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];\n\n\t// Set up all inheritable **ViewBase** properties and methods.\n\tassign(ViewBase.prototype, Events, {\n\t  // The default `tagName` of a View's element is `\"div\"`.\n\t  tagName: 'div',\n\t  // mvc.$ delegate for element lookup, scoped to DOM elements within the\n\t  // current view. This should be preferred to global lookups where possible.\n\t  $: function (selector) {\n\t    return this.$el.find(selector);\n\t  },\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the View\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // **render** is the core function that your view should override, in order\n\t  // to populate its element (`this.el`), with the appropriate HTML. The\n\t  // convention is for **render** to always return `this`.\n\t  render: function () {\n\t    return this;\n\t  },\n\t  // Remove this view by taking the element out of the DOM, and removing any\n\t  // applicable Events listeners.\n\t  remove: function () {\n\t    this._removeElement();\n\t    this.stopListening();\n\t    return this;\n\t  },\n\t  // Remove this view's element from the document and all event listeners\n\t  // attached to it. Exposed for subclasses using an alternative DOM\n\t  // manipulation API.\n\t  _removeElement: function () {\n\t    this.$el.remove();\n\t  },\n\t  // Change the view's element (`this.el` property) and re-delegate the\n\t  // view's events on the new element.\n\t  setElement: function (element) {\n\t    this.undelegateEvents();\n\t    this._setElement(element);\n\t    this.delegateEvents();\n\t    return this;\n\t  },\n\t  // Creates the `this.el` and `this.$el` references for this view using the\n\t  // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$\n\t  // context or an element. Subclasses can override this to utilize an\n\t  // alternative DOM manipulation API and are only required to set the\n\t  // `this.el` property.\n\t  _setElement: function (el) {\n\t    this.$el = el instanceof $ ? el : $(el);\n\t    this.el = this.$el[0];\n\t  },\n\t  // Set callbacks, where `this.events` is a hash of\n\t  //\n\t  // *{\"event selector\": \"callback\"}*\n\t  //\n\t  //     {\n\t  //       'mousedown .title':  'edit',\n\t  //       'click .button':     'save',\n\t  //       'click .open':       function(e) { ... }\n\t  //     }\n\t  //\n\t  // pairs. Callbacks will be bound to the view, with `this` set properly.\n\t  // Uses event delegation for efficiency.\n\t  // Omitting the selector binds the event to `this.el`.\n\t  delegateEvents: function (events) {\n\t    events || (events = result(this, 'events'));\n\t    if (!events) return this;\n\t    this.undelegateEvents();\n\t    for (var key in events) {\n\t      var method = events[key];\n\t      if (!isFunction(method)) method = this[method];\n\t      if (!method) continue;\n\t      var match = key.match(delegateEventSplitter);\n\t      this.delegate(match[1], match[2], method.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  // Add a single event listener to the view's element (or a child element\n\t  // using `selector`). This only works for delegate-able events: not `focus`,\n\t  // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n\t  delegate: function (eventName, selector, listener) {\n\t    this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n\t    return this;\n\t  },\n\t  // Clears all callbacks previously bound to the view by `delegateEvents`.\n\t  // You usually don't need to use this, but may wish to if you have multiple\n\t  // viewbases attached to the same DOM element.\n\t  undelegateEvents: function () {\n\t    if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n\t    return this;\n\t  },\n\t  // A finer-grained `undelegateEvents` for removing a single delegated event.\n\t  // `selector` and `listener` are both optional.\n\t  undelegate: function (eventName, selector, listener) {\n\t    this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n\t    return this;\n\t  },\n\t  // Produces a DOM element to be assigned to your view. Exposed for\n\t  // subclasses using an alternative DOM manipulation API.\n\t  _createElement: function (tagName) {\n\t    return document.createElement(tagName);\n\t  },\n\t  // Ensure that the View has a DOM element to render into.\n\t  // If `this.el` is a string, pass it through `$()`, take the first\n\t  // matching element, and re-assign it to `el`. Otherwise, create\n\t  // an element from the `id`, `className` and `tagName` properties.\n\t  _ensureElement: function () {\n\t    if (!this.el) {\n\t      var attrs = assign({}, result(this, 'attributes'));\n\t      if (this.id) attrs.id = result(this, 'id');\n\t      if (this.className) attrs['class'] = result(this, 'className');\n\t      this.setElement(this._createElement(result(this, 'tagName')));\n\t      this._setAttributes(attrs);\n\t    } else {\n\t      this.setElement(result(this, 'el'));\n\t    }\n\t  },\n\t  // Set attributes from a hash on this view's element.  Exposed for\n\t  // subclasses using an alternative DOM manipulation API.\n\t  _setAttributes: function (attributes) {\n\t    this.$el.attr(attributes);\n\t  }\n\t});\n\n\t// Set up inheritance for the view.\n\tViewBase.extend = extend;\n\n\tconst views = {};\n\tconst View = ViewBase.extend({\n\t  options: {},\n\t  theme: null,\n\t  themeClassNamePrefix: addClassNamePrefix('theme-'),\n\t  requireSetThemeOverride: false,\n\t  defaultTheme: config$3.defaultTheme,\n\t  children: null,\n\t  childNodes: null,\n\t  DETACHABLE: true,\n\t  UPDATE_PRIORITY: 2,\n\t  /** @deprecated is no longer used (moved to Paper) */\n\t  FLAG_INSERT: 1 << 30,\n\t  /** @deprecated is no longer used */\n\t  FLAG_REMOVE: 1 << 29,\n\t  /** @deprecated is no longer used */\n\t  FLAG_INIT: 1 << 28,\n\t  constructor: function (options) {\n\t    this.requireSetThemeOverride = options && !!options.theme;\n\t    this.options = assign({}, this.options, options);\n\t    ViewBase.call(this, options);\n\t  },\n\t  initialize: function () {\n\t    views[this.cid] = this;\n\t    this.setTheme(this.options.theme || this.defaultTheme);\n\t    this.init();\n\t  },\n\t  unmount: function () {\n\t    if (this.svgElement) {\n\t      this.vel.remove();\n\t    } else {\n\t      this.$el.remove();\n\t    }\n\t  },\n\t  isMounted: function () {\n\t    return this.el.parentNode !== null;\n\t  },\n\t  renderChildren: function (children) {\n\t    children || (children = result(this, 'children'));\n\t    if (children) {\n\t      var isSVG = this.svgElement;\n\t      var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];\n\t      var doc = parseDOMJSON(children, namespace);\n\t      (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n\t      this.childNodes = doc.selectors;\n\t    }\n\t    return this;\n\t  },\n\t  findAttributeNode: function (attributeName, node) {\n\t    let currentNode = node;\n\t    while (currentNode && currentNode.nodeType === 1) {\n\t      // attribute found\n\t      // (empty value does not count as attribute found)\n\t      if (currentNode.getAttribute(attributeName)) return currentNode;\n\t      // do not climb up the DOM\n\t      if (currentNode === this.el) return null;\n\t      // try parent node\n\t      currentNode = currentNode.parentNode;\n\t    }\n\t    return null;\n\t  },\n\t  findAttribute: function (attributeName, node) {\n\t    const matchedNode = this.findAttributeNode(attributeName, node);\n\t    return matchedNode && matchedNode.getAttribute(attributeName);\n\t  },\n\t  // Override the mvc ViewBase `_ensureElement()` method in order to create an\n\t  // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n\t  // Expose class name setter as a separate method.\n\t  _ensureElement: function () {\n\t    if (!this.el) {\n\t      var tagName = result(this, 'tagName');\n\t      var attrs = assign({}, result(this, 'attributes'));\n\t      var style = assign({}, result(this, 'style'));\n\t      if (this.id) attrs.id = result(this, 'id');\n\t      this.setElement(this._createElement(tagName));\n\t      this._setAttributes(attrs);\n\t      this._setStyle(style);\n\t    } else {\n\t      this.setElement(result(this, 'el'));\n\t    }\n\t    this._ensureElClassName();\n\t  },\n\t  _setAttributes: function (attrs) {\n\t    if (this.svgElement) {\n\t      this.vel.attr(attrs);\n\t    } else {\n\t      this.$el.attr(attrs);\n\t    }\n\t  },\n\t  _setStyle: function (style) {\n\t    this.$el.css(style);\n\t  },\n\t  _createElement: function (tagName) {\n\t    if (this.svgElement) {\n\t      return document.createElementNS(V.namespace.svg, tagName);\n\t    } else {\n\t      return document.createElement(tagName);\n\t    }\n\t  },\n\t  // Utilize an alternative DOM manipulation API by\n\t  // adding an element reference wrapped in Vectorizer.\n\t  _setElement: function (el) {\n\t    this.$el = el instanceof $ ? el : $(el);\n\t    this.el = this.$el[0];\n\t    if (this.svgElement) this.vel = V(this.el);\n\t  },\n\t  _ensureElClassName: function () {\n\t    var className = result(this, 'className');\n\t    if (!className) return;\n\t    var prefixedClassName = addClassNamePrefix(className);\n\t    // Note: className removal here kept for backwards compatibility only\n\t    if (this.svgElement) {\n\t      this.vel.removeClass(className).addClass(prefixedClassName);\n\t    } else {\n\t      this.$el.removeClass(className).addClass(prefixedClassName);\n\t    }\n\t  },\n\t  init: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  onRender: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  confirmUpdate: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t    return 0;\n\t  },\n\t  setTheme: function (theme, opt) {\n\t    opt = opt || {};\n\n\t    // Theme is already set, override is required, and override has not been set.\n\t    // Don't set the theme.\n\t    if (this.theme && this.requireSetThemeOverride && !opt.override) {\n\t      return this;\n\t    }\n\t    this.removeThemeClassName();\n\t    this.addThemeClassName(theme);\n\t    this.onSetTheme(this.theme /* oldTheme */, theme /* newTheme */);\n\t    this.theme = theme;\n\t    return this;\n\t  },\n\t  addThemeClassName: function (theme) {\n\t    theme = theme || this.theme;\n\t    if (!theme) return this;\n\t    var className = this.themeClassNamePrefix + theme;\n\t    if (this.svgElement) {\n\t      this.vel.addClass(className);\n\t    } else {\n\t      this.$el.addClass(className);\n\t    }\n\t    return this;\n\t  },\n\t  removeThemeClassName: function (theme) {\n\t    theme = theme || this.theme;\n\t    var className = this.themeClassNamePrefix + theme;\n\t    if (this.svgElement) {\n\t      this.vel.removeClass(className);\n\t    } else {\n\t      this.$el.removeClass(className);\n\t    }\n\t    return this;\n\t  },\n\t  onSetTheme: function (oldTheme, newTheme) {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  remove: function () {\n\t    this.onRemove();\n\t    this.undelegateDocumentEvents();\n\t    views[this.cid] = null;\n\t    ViewBase.prototype.remove.apply(this, arguments);\n\t    return this;\n\t  },\n\t  onRemove: function () {\n\t    // Intentionally empty.\n\t    // This method is meant to be overridden.\n\t  },\n\t  getEventNamespace: function () {\n\t    // Returns a per-session unique namespace\n\t    return '.joint-event-ns-' + this.cid;\n\t  },\n\t  delegateElementEvents: function (element, events, data) {\n\t    if (!events) return this;\n\t    data || (data = {});\n\t    var eventNS = this.getEventNamespace();\n\t    for (var eventName in events) {\n\t      var method = events[eventName];\n\t      if (typeof method !== 'function') method = this[method];\n\t      if (!method) continue;\n\t      $(element).on(eventName + eventNS, data, method.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  undelegateElementEvents: function (element) {\n\t    $(element).off(this.getEventNamespace());\n\t    return this;\n\t  },\n\t  delegateDocumentEvents: function (events, data) {\n\t    events || (events = result(this, 'documentEvents'));\n\t    return this.delegateElementEvents(document, events, data);\n\t  },\n\t  undelegateDocumentEvents: function () {\n\t    return this.undelegateElementEvents(document);\n\t  },\n\t  eventData: function (evt, data) {\n\t    if (!evt) throw new Error('eventData(): event object required.');\n\t    var currentData = evt.data;\n\t    var key = '__' + this.cid + '__';\n\t    if (data === undefined) {\n\t      if (!currentData) return {};\n\t      return currentData[key] || {};\n\t    }\n\t    currentData || (currentData = evt.data = {});\n\t    currentData[key] || (currentData[key] = {});\n\t    assign(currentData[key], data);\n\t    return this;\n\t  },\n\t  stopPropagation: function (evt) {\n\t    this.eventData(evt, {\n\t      propagationStopped: true\n\t    });\n\t    return this;\n\t  },\n\t  isPropagationStopped: function (evt) {\n\t    return !!this.eventData(evt).propagationStopped;\n\t  }\n\t}, {\n\t  extend: function () {\n\t    var args = Array.from(arguments);\n\n\t    // Deep clone the prototype and static properties objects.\n\t    // This prevents unexpected behavior where some properties are overwritten outside of this function.\n\t    var protoProps = args[0] && assign({}, args[0]) || {};\n\t    var staticProps = args[1] && assign({}, args[1]) || {};\n\n\t    // Need the real render method so that we can wrap it and call it later.\n\t    var renderFn = protoProps.render || this.prototype && this.prototype.render || null;\n\n\t    /*\n\t        Wrap the real render method so that:\n\t            .. `onRender` is always called.\n\t            .. `this` is always returned.\n\t    */\n\t    protoProps.render = function () {\n\t      if (typeof renderFn === 'function') {\n\t        // Call the original render method.\n\t        renderFn.apply(this, arguments);\n\t      }\n\t      if (this.render.__render__ === renderFn) {\n\t        // Should always call onRender() method.\n\t        // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n\t        this.onRender();\n\t      }\n\n\t      // Should always return itself.\n\t      return this;\n\t    };\n\t    protoProps.render.__render__ = renderFn;\n\t    return ViewBase.extend.call(this, protoProps, staticProps);\n\t  }\n\t});\n\n\tclass Listener {\n\t  constructor(...callbackArguments) {\n\t    this.callbackArguments = callbackArguments;\n\t  }\n\t  listenTo(object, evt, ...args) {\n\t    const {\n\t      callbackArguments\n\t    } = this;\n\t    // signature 1 - (object, eventHashMap, context)\n\t    if (evt && typeof evt === 'object') {\n\t      const [context = null] = args;\n\t      Object.entries(evt).forEach(([eventName, cb]) => {\n\t        if (typeof cb !== 'function') return;\n\t        // Invoke the callback with callbackArguments passed first\n\t        if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n\t        Events.listenTo.call(this, object, eventName, cb);\n\t      });\n\t    }\n\t    // signature 2 - (object, event, callback, context)\n\t    else if (typeof evt === 'string' && typeof args[0] === 'function') {\n\t      let [cb, context = null] = args;\n\t      // Invoke the callback with callbackArguments passed first\n\t      if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n\t      Events.listenTo.call(this, object, evt, cb);\n\t    }\n\t  }\n\t  stopListening() {\n\t    Events.stopListening.call(this);\n\t  }\n\t}\n\n\t// Collection\n\t// -------------------\n\n\t// If models tend to represent a single row of data, a Collection is\n\t// more analogous to a table full of data ... or a small slice or page of that\n\t// table, or a collection of rows that belong together for a particular reason\n\t// -- all of the messages in this particular folder, all of the documents\n\t// belonging to this particular author, and so on. Collections maintain\n\t// indexes of their models, both in order, and for lookup by `id`.\n\n\t// Create a new **Collection**, perhaps to contain a specific type of `model`.\n\t// If a `comparator` is specified, the Collection will maintain\n\t// its models in sort order, as they're added and removed.\n\tvar Collection = function (models, options) {\n\t  options || (options = {});\n\t  this.preinitialize.apply(this, arguments);\n\t  if (options.model) this.model = options.model;\n\t  if (options.comparator !== void 0) this.comparator = options.comparator;\n\t  this._reset();\n\t  this.initialize.apply(this, arguments);\n\t  if (models) this.reset(models, assign({\n\t    silent: true\n\t  }, options));\n\t};\n\n\t// Default options for `Collection#set`.\n\tvar setOptions = {\n\t  add: true,\n\t  remove: true,\n\t  merge: true\n\t};\n\tvar addOptions = {\n\t  add: true,\n\t  remove: false\n\t};\n\n\t// Splices `insert` into `array` at index `at`.\n\tvar splice = function (array, insert, at) {\n\t  at = Math.min(Math.max(at, 0), array.length);\n\t  var tail = Array(array.length - at);\n\t  var length = insert.length;\n\t  var i;\n\t  for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n\t  for (i = 0; i < length; i++) array[i + at] = insert[i];\n\t  for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n\t};\n\n\t// Define the Collection's inheritable methods.\n\tassign(Collection.prototype, Events, {\n\t  // The default model for a collection is just a **Model**.\n\t  // This should be overridden in most cases.\n\t  model: Model,\n\t  // preinitialize is an empty function by default. You can override it with a function\n\t  // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n\t  preinitialize: function () {\n\t    // No implementation.\n\t  },\n\t  // Initialize is an empty function by default. Override it with your own\n\t  // initialization logic.\n\t  initialize: function () {\n\t    // No implementation.\n\t  },\n\t  // The JSON representation of a Collection is an array of the\n\t  // models' attributes.\n\t  toJSON: function (options) {\n\t    return this.map(function (model) {\n\t      return model.toJSON(options);\n\t    });\n\t  },\n\t  // Add a model, or list of models to the set. `models` may be\n\t  // Models or raw JavaScript objects to be converted to Models, or any\n\t  // combination of the two.\n\t  add: function (models, options) {\n\t    return this.set(models, assign({\n\t      merge: false\n\t    }, options, addOptions));\n\t  },\n\t  // Remove a model, or a list of models from the set.\n\t  remove: function (models, options) {\n\t    options = assign({}, options);\n\t    var singular = !Array.isArray(models);\n\t    models = singular ? [models] : models.slice();\n\t    var removed = this._removeModels(models, options);\n\t    if (!options.silent && removed.length) {\n\t      options.changes = {\n\t        added: [],\n\t        merged: [],\n\t        removed: removed\n\t      };\n\t      this.trigger('update', this, options);\n\t    }\n\t    return singular ? removed[0] : removed;\n\t  },\n\t  // Update a collection by `set`-ing a new list of models, adding new ones,\n\t  // removing models that are no longer present, and merging models that\n\t  // already exist in the collection, as necessary. Similar to **Model#set**,\n\t  // the core operation for updating the data contained by the collection.\n\t  set: function (models, options) {\n\t    if (models == null) return;\n\t    options = assign({}, setOptions, options);\n\t    var singular = !Array.isArray(models);\n\t    models = singular ? [models] : models.slice();\n\t    var at = options.at;\n\t    if (at != null) at = +at;\n\t    if (at > this.length) at = this.length;\n\t    if (at < 0) at += this.length + 1;\n\t    var set = [];\n\t    var toAdd = [];\n\t    var toMerge = [];\n\t    var toRemove = [];\n\t    var modelMap = {};\n\t    var add = options.add;\n\t    var merge = options.merge;\n\t    var remove = options.remove;\n\t    var sort = false;\n\t    var sortable = this.comparator && at == null && options.sort !== false;\n\t    var sortAttr = isString(this.comparator) ? this.comparator : null;\n\n\t    // Turn bare objects into model references, and prevent invalid models\n\t    // from being added.\n\t    var model, i;\n\t    for (i = 0; i < models.length; i++) {\n\t      model = models[i];\n\n\t      // If a duplicate is found, prevent it from being added and\n\t      // optionally merge it into the existing model.\n\t      var existing = this.get(model);\n\t      if (existing) {\n\t        if (merge && model !== existing) {\n\t          var attrs = this._isModel(model) ? model.attributes : model;\n\t          existing.set(attrs, options);\n\t          toMerge.push(existing);\n\t          if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n\t        }\n\t        if (!modelMap[existing.cid]) {\n\t          modelMap[existing.cid] = true;\n\t          set.push(existing);\n\t        }\n\t        models[i] = existing;\n\n\t        // If this is a new, valid model, push it to the `toAdd` list.\n\t      } else if (add) {\n\t        model = models[i] = this._prepareModel(model, options);\n\t        if (model) {\n\t          toAdd.push(model);\n\t          this._addReference(model, options);\n\t          modelMap[model.cid] = true;\n\t          set.push(model);\n\t        }\n\t      }\n\t    }\n\n\t    // Remove stale models.\n\t    if (remove) {\n\t      for (i = 0; i < this.length; i++) {\n\t        model = this.models[i];\n\t        if (!modelMap[model.cid]) toRemove.push(model);\n\t      }\n\t      if (toRemove.length) this._removeModels(toRemove, options);\n\t    }\n\n\t    // See if sorting is needed, update `length` and splice in new models.\n\t    var orderChanged = false;\n\t    var replace = !sortable && add && remove;\n\t    if (set.length && replace) {\n\t      orderChanged = this.length !== set.length || this.models.some(function (m, index) {\n\t        return m !== set[index];\n\t      });\n\t      this.models.length = 0;\n\t      splice(this.models, set, 0);\n\t      this.length = this.models.length;\n\t    } else if (toAdd.length) {\n\t      if (sortable) sort = true;\n\t      splice(this.models, toAdd, at == null ? this.length : at);\n\t      this.length = this.models.length;\n\t    }\n\n\t    // Silently sort the collection if appropriate.\n\t    if (sort) this.sort({\n\t      silent: true\n\t    });\n\n\t    // Unless silenced, it's time to fire all appropriate add/sort/update events.\n\t    if (!options.silent) {\n\t      for (i = 0; i < toAdd.length; i++) {\n\t        if (at != null) options.index = at + i;\n\t        model = toAdd[i];\n\t        model.trigger(model.eventPrefix + 'add', model, this, options);\n\t      }\n\t      if (sort || orderChanged) this.trigger('sort', this, options);\n\t      if (toAdd.length || toRemove.length || toMerge.length) {\n\t        options.changes = {\n\t          added: toAdd,\n\t          removed: toRemove,\n\t          merged: toMerge\n\t        };\n\t        this.trigger('update', this, options);\n\t      }\n\t    }\n\n\t    // Return the added (or merged) model (or models).\n\t    return singular ? models[0] : models;\n\t  },\n\t  // When you have more items than you want to add or remove individually,\n\t  // you can reset the entire set with a new list of models, without firing\n\t  // any granular `add` or `remove` events. Fires `reset` when finished.\n\t  // Useful for bulk operations and optimizations.\n\t  reset: function (models, options) {\n\t    options = options ? clone$1(options) : {};\n\t    for (var i = 0; i < this.models.length; i++) {\n\t      this._removeReference(this.models[i], options);\n\t    }\n\t    options.previousModels = this.models;\n\t    this._reset();\n\t    models = this.add(models, assign({\n\t      silent: true\n\t    }, options));\n\t    if (!options.silent) this.trigger('reset', this, options);\n\t    return models;\n\t  },\n\t  // Add a model to the end of the collection.\n\t  push: function (model, options) {\n\t    return this.add(model, assign({\n\t      at: this.length\n\t    }, options));\n\t  },\n\t  // Remove a model from the end of the collection.\n\t  pop: function (options) {\n\t    var model = this.at(this.length - 1);\n\t    return this.remove(model, options);\n\t  },\n\t  // Add a model to the beginning of the collection.\n\t  unshift: function (model, options) {\n\t    return this.add(model, assign({\n\t      at: 0\n\t    }, options));\n\t  },\n\t  // Remove a model from the beginning of the collection.\n\t  shift: function (options) {\n\t    var model = this.at(0);\n\t    return this.remove(model, options);\n\t  },\n\t  // Slice out a sub-array of models from the collection.\n\t  slice: function () {\n\t    return Array.prototype.slice.apply(this.models, arguments);\n\t  },\n\t  // Get a model from the set by id, cid, model object with id or cid\n\t  // properties, or an attributes object that is transformed through modelId.\n\t  get: function (obj) {\n\t    if (obj == null) return void 0;\n\t    return this._byId.get(obj) || this._byId.get(this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)) || obj.cid && this._byId.get(obj.cid);\n\t  },\n\t  // Returns `true` if the model is in the collection.\n\t  has: function (obj) {\n\t    return this.get(obj) != null;\n\t  },\n\t  // Get the model at the given index.\n\t  at: function (index) {\n\t    if (index < 0) index += this.length;\n\t    return this.models[index];\n\t  },\n\t  // Force the collection to re-sort itself. You don't need to call this under\n\t  // normal circumstances, as the set will maintain sort order as each item\n\t  // is added.\n\t  sort: function (options) {\n\t    var comparator = this.comparator;\n\t    if (!comparator) throw new Error('Cannot sort a set without a comparator');\n\t    options || (options = {});\n\t    var length = comparator.length;\n\t    if (isFunction(comparator)) comparator = comparator.bind(this);\n\n\t    // Run sort based on type of `comparator`.\n\t    if (length === 1 || isString(comparator)) {\n\t      this.models = this.sortBy(comparator);\n\t    } else {\n\t      this.models.sort(comparator);\n\t    }\n\t    if (!options.silent) this.trigger('sort', this, options);\n\t    return this;\n\t  },\n\t  // Create a new collection with an identical list of models as this one.\n\t  clone: function () {\n\t    return new this.constructor(this.models, {\n\t      model: this.model,\n\t      comparator: this.comparator\n\t    });\n\t  },\n\t  // Define how to uniquely identify models in the collection.\n\t  modelId: function (attrs, idAttribute) {\n\t    var _this$model$prototype;\n\t    return attrs[idAttribute || ((_this$model$prototype = this.model.prototype) === null || _this$model$prototype === void 0 ? void 0 : _this$model$prototype.idAttribute) || 'id'];\n\t  },\n\t  // Get an iterator of all models in this collection.\n\t  values: function () {\n\t    return new CollectionIterator(this, ITERATOR_VALUES);\n\t  },\n\t  // Get an iterator of all model IDs in this collection.\n\t  keys: function () {\n\t    return new CollectionIterator(this, ITERATOR_KEYS);\n\t  },\n\t  // Get an iterator of all [ID, model] tuples in this collection.\n\t  entries: function () {\n\t    return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n\t  },\n\t  // Iterate over elements of the collection, and invoke fn for each element\n\t  each: function (fn, context) {\n\t    this.models.forEach(fn, context);\n\t  },\n\t  // Iterate over elements of collection, and return an array of all elements fn returns truthy for\n\t  filter: function (fn, context) {\n\t    return this.models.filter(fn, context);\n\t  },\n\t  find: function (fn, context) {\n\t    return this.models.find(fn, context);\n\t  },\n\t  findIndex: function (fn, context) {\n\t    return this.models.findIndex(fn, context);\n\t  },\n\t  // Return the first model of the collection\n\t  first: function () {\n\t    return this.models[0];\n\t  },\n\t  // Return true if value is in the collection\n\t  includes: function (value) {\n\t    return this.models.includes(value);\n\t  },\n\t  // Return the last model of the collection\n\t  last: function () {\n\t    return this.models[this.models.length - 1];\n\t  },\n\t  // Return true if collection has no elements\n\t  isEmpty: function () {\n\t    return !this.models.length;\n\t  },\n\t  // Create an array of values by running each element in the collection through fn\n\t  map: function (fn, context) {\n\t    return this.models.map(fn, context);\n\t  },\n\t  // Runs \"reducer\" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value\n\t  reduce: function (fn, initAcc = this.first()) {\n\t    return this.models.reduce(fn, initAcc);\n\t  },\n\t  // Private method to reset all internal state. Called when the collection\n\t  // is first initialized or reset.\n\t  _reset: function () {\n\t    this.length = 0;\n\t    this.models = [];\n\t    this._byId = new Map();\n\t  },\n\t  // Prepare a hash of attributes (or other model) to be added to this\n\t  // collection.\n\t  _prepareModel: function (attrs, options) {\n\t    if (this._isModel(attrs)) {\n\t      if (!options.dry && !attrs.collection) attrs.collection = this;\n\t      return attrs;\n\t    }\n\t    options = options ? clone$1(options) : {};\n\t    if (!options.dry) options.collection = this;\n\t    var model;\n\t    if (this.model.prototype) {\n\t      model = new this.model(attrs, options);\n\t    } else {\n\t      // ES class methods didn't have prototype\n\t      model = this.model(attrs, options);\n\t    }\n\t    if (!model.validationError) return model;\n\t    this.trigger('invalid', this, model.validationError, options);\n\t    return false;\n\t  },\n\t  // Internal method called by both remove and set.\n\t  _removeModels: function (models, options) {\n\t    var removed = [];\n\t    for (var i = 0; i < models.length; i++) {\n\t      var model = this.get(models[i]);\n\t      if (!model) continue;\n\t      var index = this.models.indexOf(model);\n\t      this.models.splice(index, 1);\n\t      this.length--;\n\n\t      // Remove references before triggering 'remove' event to prevent an\n\t      // infinite loop. #3693\n\t      this._byId.delete(model.cid);\n\t      var id = this.modelId(model.attributes, model.idAttribute);\n\t      if (id != null) this._byId.delete(id);\n\t      if (!options.silent) {\n\t        options.index = index;\n\t        model.trigger(model.eventPrefix + 'remove', model, this, options);\n\t      }\n\t      removed.push(model);\n\t      this._removeReference(model, options);\n\t    }\n\t    if (models.length > 0 && !options.silent) delete options.index;\n\t    return removed;\n\t  },\n\t  // Method for checking whether an object should be considered a model for\n\t  // the purposes of adding to the collection.\n\t  _isModel: function (model) {\n\t    return model instanceof Model;\n\t  },\n\t  // Internal method to create a model's ties to a collection.\n\t  _addReference: function (model, options) {\n\t    this._byId.set(model.cid, model);\n\t    var id = this.modelId(model.attributes, model.idAttribute);\n\t    if (id != null) this._byId.set(id, model);\n\t    model.on('all', this._onModelEvent, this);\n\t  },\n\t  // Internal method to sever a model's ties to a collection.\n\t  _removeReference: function (model, options) {\n\t    this._byId.delete(model.cid);\n\t    var id = this.modelId(model.attributes, model.idAttribute);\n\t    if (id != null) this._byId.delete(id);\n\t    if (!options.dry && this === model.collection) delete model.collection;\n\t    model.off('all', this._onModelEvent, this);\n\t  },\n\t  // Internal method called every time a model in the set fires an event.\n\t  // Sets need to update their indexes when models change ids. All other\n\t  // events simply proxy through. \"add\" and \"remove\" events that originate\n\t  // in other collections are ignored.\n\t  _onModelEvent: function (event, model, collection, options) {\n\t    if (model) {\n\t      if ((event === model.eventPrefix + 'add' || event === model.eventPrefix + 'remove') && collection !== this) return;\n\t      if (event === 'changeId') {\n\t        var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n\t        var id = this.modelId(model.attributes, model.idAttribute);\n\t        if (prevId != null) this._byId.delete(prevId);\n\t        if (id != null) this._byId.set(id, model);\n\t      }\n\t    }\n\t    this.trigger.apply(this, arguments);\n\t  }\n\t});\n\n\t// Defining an @@iterator method implements JavaScript's Iterable protocol.\n\t// In modern ES2015 browsers, this value is found at Symbol.iterator.\n\tvar $$iterator = typeof Symbol === 'function' && Symbol.iterator;\n\tif ($$iterator) {\n\t  Collection.prototype[$$iterator] = Collection.prototype.values;\n\t}\n\n\t// CollectionIterator\n\t// ------------------\n\n\t// A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n\t// use of `for of` loops in modern browsers and interoperation between\n\t// Collection and other JavaScript functions and third-party libraries\n\t// which can operate on Iterables.\n\tvar CollectionIterator = function (collection, kind) {\n\t  this._collection = collection;\n\t  this._kind = kind;\n\t  this._index = 0;\n\t};\n\n\t// This \"enum\" defines the three possible kinds of values which can be emitted\n\t// by a CollectionIterator that correspond to the values(), keys() and entries()\n\t// methods on Collection, respectively.\n\tvar ITERATOR_VALUES = 1;\n\tvar ITERATOR_KEYS = 2;\n\tvar ITERATOR_KEYSVALUES = 3;\n\n\t// All Iterators should themselves be Iterable.\n\tif ($$iterator) {\n\t  CollectionIterator.prototype[$$iterator] = function () {\n\t    return this;\n\t  };\n\t}\n\tCollectionIterator.prototype.next = function () {\n\t  if (this._collection) {\n\t    // Only continue iterating if the iterated collection is long enough.\n\t    if (this._index < this._collection.length) {\n\t      var model = this._collection.at(this._index);\n\t      this._index++;\n\n\t      // Construct a value depending on what kind of values should be iterated.\n\t      var value;\n\t      if (this._kind === ITERATOR_VALUES) {\n\t        value = model;\n\t      } else {\n\t        var id = this._collection.modelId(model.attributes, model.idAttribute);\n\t        if (this._kind === ITERATOR_KEYS) {\n\t          value = id;\n\t        } else {\n\t          // ITERATOR_KEYSVALUES\n\t          value = [id, model];\n\t        }\n\t      }\n\t      return {\n\t        value: value,\n\t        done: false\n\t      };\n\t    }\n\n\t    // Once exhausted, remove the reference to the collection so future\n\t    // calls to the next method always return done.\n\t    this._collection = void 0;\n\t  }\n\t  return {\n\t    value: void 0,\n\t    done: true\n\t  };\n\t};\n\n\t//  Methods that we want to implement on the Collection.\n\tvar collectionMethods = {\n\t  toArray: 1,\n\t  sortBy: 3\n\t};\n\n\t// Mix in each method as a proxy to `Collection#models`.\n\n\tvar config$2 = [Collection, collectionMethods, 'models'];\n\tfunction addMethods(config) {\n\t  var Base = config[0],\n\t    methods = config[1],\n\t    attribute = config[2];\n\t  const methodsToAdd = {\n\t    sortBy,\n\t    toArray: toArray$1\n\t  };\n\t  addMethodsUtil(Base, methodsToAdd, methods, attribute);\n\t}\n\taddMethods(config$2);\n\n\t// Set up inheritance for the collection.\n\tCollection.extend = extend;\n\n\tvar index$4 = {\n\t\t__proto__: null,\n\t\t$: $,\n\t\tCollection: Collection,\n\t\tData: Data,\n\t\tEvent: Event,\n\t\tEvents: Events,\n\t\tListener: Listener,\n\t\tModel: Model,\n\t\tView: View,\n\t\tViewBase: ViewBase,\n\t\tviews: views\n\t};\n\n\tfunction toArray(obj) {\n\t  if (!obj) return [];\n\t  if (Array.isArray(obj)) return obj;\n\t  return [obj];\n\t}\n\tconst HighlighterView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  className: 'highlight',\n\t  HIGHLIGHT_FLAG: 1,\n\t  UPDATE_PRIORITY: 3,\n\t  DETACHABLE: false,\n\t  UPDATABLE: true,\n\t  MOUNTABLE: true,\n\t  cellView: null,\n\t  nodeSelector: null,\n\t  node: null,\n\t  updateRequested: false,\n\t  postponedUpdate: false,\n\t  transformGroup: null,\n\t  detachedTransformGroup: null,\n\t  requestUpdate(cellView, nodeSelector) {\n\t    const {\n\t      paper\n\t    } = cellView;\n\t    this.cellView = cellView;\n\t    this.nodeSelector = nodeSelector;\n\t    if (paper) {\n\t      this.updateRequested = true;\n\t      paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t    }\n\t  },\n\t  confirmUpdate() {\n\t    // The cellView is now rendered/updated since it has a higher update priority.\n\t    this.updateRequested = false;\n\t    const {\n\t      cellView,\n\t      nodeSelector\n\t    } = this;\n\t    if (cellView.isMounted()) {\n\t      this.update(cellView, nodeSelector);\n\t      this.mount();\n\t      this.transform();\n\t    } else {\n\t      this.postponedUpdate = true;\n\t    }\n\t    return 0;\n\t  },\n\t  findNode(cellView, nodeSelector = null) {\n\t    let el;\n\t    if (typeof nodeSelector === 'string') {\n\t      el = cellView.findNode(nodeSelector);\n\t    } else if (isPlainObject(nodeSelector)) {\n\t      const isLink = cellView.model.isLink();\n\t      const {\n\t        label = null,\n\t        port,\n\t        selector\n\t      } = nodeSelector;\n\t      if (isLink && label !== null) {\n\t        // Link Label Selector\n\t        el = cellView.findLabelNode(label, selector);\n\t      } else if (!isLink && port) {\n\t        // Element Port Selector\n\t        el = cellView.findPortNode(port, selector);\n\t      } else {\n\t        // Cell Selector\n\t        el = cellView.findNode(selector);\n\t      }\n\t    } else if (nodeSelector) {\n\t      el = V.toNode(nodeSelector);\n\t      if (!(el instanceof SVGElement) || !cellView.el.contains(el)) el = null;\n\t    }\n\t    return el ? el : null;\n\t  },\n\t  getNodeMatrix(cellView, node) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      layer\n\t    } = options;\n\t    const {\n\t      rotatableNode\n\t    } = cellView;\n\t    const nodeMatrix = cellView.getNodeMatrix(node);\n\t    if (rotatableNode) {\n\t      if (layer) {\n\t        if (rotatableNode.contains(node)) {\n\t          return nodeMatrix;\n\t        }\n\t        // The node is outside of the rotatable group.\n\t        // Compensate the rotation set by transformGroup.\n\t        return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n\t      } else {\n\t        return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n\t      }\n\t    }\n\t    return nodeMatrix;\n\t  },\n\t  mount() {\n\t    const {\n\t      MOUNTABLE,\n\t      cellView,\n\t      el,\n\t      options,\n\t      transformGroup,\n\t      detachedTransformGroup,\n\t      postponedUpdate,\n\t      nodeSelector\n\t    } = this;\n\t    if (!MOUNTABLE || transformGroup) return;\n\t    if (postponedUpdate) {\n\t      // The cellView was not mounted when the update was requested.\n\t      // The update was postponed until the cellView is mounted.\n\t      this.update(cellView, nodeSelector);\n\t      this.transform();\n\t      return;\n\t    }\n\t    const {\n\t      paper\n\t    } = cellView;\n\t    const {\n\t      layer: layerName,\n\t      z\n\t    } = options;\n\t    if (layerName) {\n\t      let vGroup;\n\t      if (detachedTransformGroup) {\n\t        vGroup = detachedTransformGroup;\n\t        this.detachedTransformGroup = null;\n\t      } else {\n\t        vGroup = V('g').addClass('highlight-transform').append(el);\n\t      }\n\t      this.transformGroup = vGroup;\n\t      paper.getLayerView(layerName).insertSortedNode(vGroup.node, z);\n\t    } else {\n\t      const children = cellView.el.children;\n\t      const index = Math.max(z, 0);\n\t      const beforeChild = children[index];\n\n\t      // If the provided `z` is a number and there is an element on the index,\n\t      // we need to insert the highlighter before the element on the index.\n\t      // Otherwise, the highlighter will be appended as the last child.\n\t      const toBeInserted = isNumber(z) && beforeChild;\n\t      const isElementAtTargetPosition = toBeInserted\n\t      // If the element is being inserted, check if it is not already at the correct position.\n\t      ? el === beforeChild\n\t      // If the element is being appended, check if it is not already last child.\n\t      : !el.nextElementSibling;\n\n\t      // If the element is already mounted and does not require repositioning, do nothing.\n\t      if (el.parentNode && isElementAtTargetPosition) return;\n\t      if (toBeInserted) {\n\t        cellView.el.insertBefore(el, beforeChild);\n\t      } else {\n\t        cellView.el.appendChild(el);\n\t      }\n\t    }\n\t  },\n\t  unmount() {\n\t    const {\n\t      MOUNTABLE,\n\t      transformGroup,\n\t      vel,\n\t      options\n\t    } = this;\n\t    if (!MOUNTABLE) return;\n\t    if (options.layer) {\n\t      if (!transformGroup) return;\n\t      // else: if `transformGroup` is not null, it means the highlighter\n\t      // has not been mounted yet\n\t      this.transformGroup = null;\n\t      this.detachedTransformGroup = transformGroup;\n\t      transformGroup.remove();\n\t    } else {\n\t      vel.remove();\n\t    }\n\t  },\n\t  transform() {\n\t    const {\n\t      transformGroup,\n\t      cellView,\n\t      updateRequested\n\t    } = this;\n\t    if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n\t    const translateMatrix = cellView.getRootTranslateMatrix();\n\t    const rotateMatrix = cellView.getRootRotateMatrix();\n\t    const transformMatrix = translateMatrix.multiply(rotateMatrix);\n\t    transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));\n\t  },\n\t  update() {\n\t    const {\n\t      node: prevNode,\n\t      cellView,\n\t      nodeSelector,\n\t      updateRequested,\n\t      id\n\t    } = this;\n\t    if (updateRequested) return;\n\t    this.postponedUpdate = false;\n\t    const node = this.node = this.findNode(cellView, nodeSelector);\n\t    if (prevNode) {\n\t      this.unhighlight(cellView, prevNode);\n\t    }\n\t    if (node) {\n\t      this.highlight(cellView, node);\n\t      this.mount();\n\t    } else {\n\t      this.unmount();\n\t      cellView.notify('cell:highlight:invalid', id, this);\n\t    }\n\t  },\n\t  onRemove() {\n\t    const {\n\t      node,\n\t      cellView,\n\t      id,\n\t      constructor\n\t    } = this;\n\t    if (node) {\n\t      this.unhighlight(cellView, node);\n\t    }\n\t    this.unmount();\n\t    constructor._removeRef(cellView, id);\n\t  },\n\t  highlight(_cellView, _node) {\n\t    // to be overridden\n\t  },\n\t  unhighlight(_cellView, _node) {\n\t    // to be overridden\n\t  },\n\t  // Update Attributes\n\n\t  listenToUpdateAttributes(cellView) {\n\t    const attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t    if (!Array.isArray(attributes) || attributes.length === 0) return;\n\t    this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n\t  },\n\t  onCellAttributeChange() {\n\t    const {\n\t      cellView\n\t    } = this;\n\t    if (!cellView) return;\n\t    const {\n\t      model,\n\t      paper\n\t    } = cellView;\n\t    const attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t    if (!attributes.some(attribute => model.hasChanged(attribute))) return;\n\t    paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t  }\n\t}, {\n\t  _views: {},\n\t  // Used internally by CellView highlight()\n\t  highlight: function (cellView, node, opt) {\n\t    const id = this.uniqueId(node, opt);\n\t    this.add(cellView, node, id, opt);\n\t  },\n\t  // Used internally by CellView unhighlight()\n\t  unhighlight: function (cellView, node, opt) {\n\t    const id = this.uniqueId(node, opt);\n\t    this.remove(cellView, id);\n\t  },\n\t  get(cellView, id = null) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (id === null) {\n\t      // all highlighters\n\t      const views = [];\n\t      if (!refs) return views;\n\t      for (let hid in refs) {\n\t        const ref = refs[hid];\n\t        if (ref instanceof this) {\n\t          views.push(ref);\n\t        }\n\t      }\n\t      return views;\n\t    } else {\n\t      // single highlighter\n\t      if (!refs) return null;\n\t      if (id in refs) {\n\t        const ref = refs[id];\n\t        if (ref instanceof this) return ref;\n\t      }\n\t      return null;\n\t    }\n\t  },\n\t  // Check if the cellView has a highlighter with the given `id`.\n\t  // If no `id` is provided, it checks if the cellView has any highlighter.\n\t  has(cellView, id = null) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (!refs) return false;\n\t    if (id === null) {\n\t      // any highlighter\n\t      for (let hid in refs) {\n\t        if (refs[hid] instanceof this) return true;\n\t      }\n\t      return false;\n\t    } else {\n\t      // single highlighter\n\t      if (id in refs) {\n\t        if (refs[id] instanceof this) return true;\n\t      }\n\t      return false;\n\t    }\n\t  },\n\t  add(cellView, nodeSelector, id, opt = {}) {\n\t    if (!id) throw new Error('dia.HighlighterView: An ID required.');\n\t    // Search the existing view amongst all the highlighters\n\t    const previousView = HighlighterView.get(cellView, id);\n\t    if (previousView) previousView.remove();\n\t    const view = new this(opt);\n\t    view.id = id;\n\t    this._addRef(cellView, id, view);\n\t    view.requestUpdate(cellView, nodeSelector);\n\t    view.listenToUpdateAttributes(cellView);\n\t    return view;\n\t  },\n\t  _addRef(cellView, id, view) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    let refs = _views[cid];\n\t    if (!refs) refs = _views[cid] = {};\n\t    refs[id] = view;\n\t  },\n\t  _removeRef(cellView, id) {\n\t    const {\n\t      cid\n\t    } = cellView;\n\t    const {\n\t      _views\n\t    } = this;\n\t    const refs = _views[cid];\n\t    if (!refs) return;\n\t    if (id) delete refs[id];\n\t    for (let _ in refs) return;\n\t    delete _views[cid];\n\t  },\n\t  remove(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      view.remove();\n\t    });\n\t  },\n\t  getAll(paper, id = null) {\n\t    const views = [];\n\t    const {\n\t      _views\n\t    } = this;\n\t    for (let cid in _views) {\n\t      for (let hid in _views[cid]) {\n\t        const view = _views[cid][hid];\n\t        if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n\t          views.push(view);\n\t        }\n\t      }\n\t    }\n\t    return views;\n\t  },\n\t  removeAll(paper, id = null) {\n\t    this.getAll(paper, id).forEach(view => view.remove());\n\t  },\n\t  update(cellView, id = null, dirty = false) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      if (dirty || view.UPDATABLE) view.update();\n\t    });\n\t  },\n\t  transform(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => {\n\t      if (view.UPDATABLE) view.transform();\n\t    });\n\t  },\n\t  unmount(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => view.unmount());\n\t  },\n\t  mount(cellView, id = null) {\n\t    toArray(this.get(cellView, id)).forEach(view => view.mount());\n\t  },\n\t  uniqueId(node, opt = '') {\n\t    return V.ensureId(node) + JSON.stringify(opt);\n\t  }\n\t});\n\n\tconst stroke$1 = HighlighterView.extend({\n\t  tagName: 'path',\n\t  className: 'highlight-stroke',\n\t  attributes: {\n\t    'pointer-events': 'none',\n\t    'fill': 'none'\n\t  },\n\t  options: {\n\t    padding: 3,\n\t    rx: 0,\n\t    ry: 0,\n\t    useFirstSubpath: false,\n\t    attrs: {\n\t      'stroke-width': 3,\n\t      'stroke': '#FEB663'\n\t    }\n\t  },\n\t  getPathData(cellView, node) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      useFirstSubpath\n\t    } = options;\n\t    let d;\n\t    try {\n\t      const vNode = V(node);\n\t      d = vNode.convertToPathData().trim();\n\t      if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n\t        const secondSubpathIndex = d.search(/.M/i) + 1;\n\t        if (secondSubpathIndex > 0) {\n\t          d = d.substr(0, secondSubpathIndex);\n\t        }\n\t      }\n\t    } catch {\n\t      // Failed to get path data from magnet element.\n\t      // Draw a rectangle around the node instead.\n\t      const nodeBBox = cellView.getNodeBoundingRect(node);\n\t      d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n\t    }\n\t    return d;\n\t  },\n\t  highlightConnection(cellView) {\n\t    this.vel.attr('d', cellView.getSerializedConnection());\n\t  },\n\t  highlightNode(cellView, node) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      padding,\n\t      layer\n\t    } = options;\n\t    let highlightMatrix = this.getNodeMatrix(cellView, node);\n\t    // Add padding to the highlight element.\n\t    if (padding) {\n\t      if (!layer && node === cellView.el) {\n\t        // If the highlighter is appended to the cellView\n\t        // and we measure the size of the cellView wrapping group\n\t        // it's necessary to remove the highlighter first\n\t        vel.remove();\n\t      }\n\t      let nodeBBox = cellView.getNodeBoundingRect(node);\n\t      const cx = nodeBBox.x + nodeBBox.width / 2;\n\t      const cy = nodeBBox.y + nodeBBox.height / 2;\n\t      nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n\t      const width = Math.max(nodeBBox.width, 1);\n\t      const height = Math.max(nodeBBox.height, 1);\n\t      const sx = (width + padding) / width;\n\t      const sy = (height + padding) / height;\n\t      const paddingMatrix = V.createSVGMatrix({\n\t        a: sx,\n\t        b: 0,\n\t        c: 0,\n\t        d: sy,\n\t        e: cx - sx * cx,\n\t        f: cy - sy * cy\n\t      });\n\t      highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n\t    }\n\t    vel.attr({\n\t      'd': this.getPathData(cellView, node),\n\t      'transform': V.matrixToTransformString(highlightMatrix)\n\t    });\n\t  },\n\t  highlight(cellView, node) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    vel.attr(options.attrs);\n\t    if (options.nonScalingStroke) {\n\t      vel.attr('vector-effect', 'non-scaling-stroke');\n\t    }\n\t    if (cellView.isNodeConnection(node)) {\n\t      this.highlightConnection(cellView);\n\t    } else {\n\t      this.highlightNode(cellView, node);\n\t    }\n\t  }\n\t});\n\n\tconst MASK_CLIP = 20;\n\tfunction forEachDescendant(vel, fn) {\n\t  const descendants = vel.children();\n\t  while (descendants.length > 0) {\n\t    const descendant = descendants.shift();\n\t    if (fn(descendant)) {\n\t      descendants.push(...descendant.children());\n\t    }\n\t  }\n\t}\n\tconst mask = HighlighterView.extend({\n\t  tagName: 'rect',\n\t  className: 'highlight-mask',\n\t  attributes: {\n\t    'pointer-events': 'none'\n\t  },\n\t  options: {\n\t    padding: 3,\n\t    maskClip: MASK_CLIP,\n\t    deep: false,\n\t    attrs: {\n\t      'stroke': '#FEB663',\n\t      'stroke-width': 3,\n\t      'stroke-linecap': 'butt',\n\t      'stroke-linejoin': 'miter'\n\t    }\n\t  },\n\t  VISIBLE: 'white',\n\t  INVISIBLE: 'black',\n\t  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray', 'class'],\n\t  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid', 'class'],\n\t  // TODO: change the list to a function callback\n\t  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],\n\t  // TODO: change the list to a function callback\n\t  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],\n\t  transformMaskChild(cellView, childEl) {\n\t    const {\n\t      MASK_CHILD_ATTRIBUTE_BLACKLIST,\n\t      MASK_REPLACE_TAGS,\n\t      MASK_REMOVE_TAGS\n\t    } = this;\n\t    const childTagName = childEl.tagName();\n\t    // Do not include the element in the mask's image\n\t    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n\t      childEl.remove();\n\t      return false;\n\t    }\n\t    // Replace the element with a rectangle\n\t    if (MASK_REPLACE_TAGS.includes(childTagName)) {\n\t      // Note: clone() method does not change the children ids\n\t      const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n\t      if (originalChild) {\n\t        const {\n\t          node: originalNode\n\t        } = originalChild;\n\t        let childBBox = cellView.getNodeBoundingRect(originalNode);\n\t        if (cellView.model.isElement()) {\n\t          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n\t        }\n\t        const replacement = V('rect', childBBox.toJSON());\n\t        const {\n\t          x: ox,\n\t          y: oy\n\t        } = childBBox.center();\n\t        const {\n\t          angle,\n\t          cx = ox,\n\t          cy = oy\n\t        } = originalChild.rotate();\n\t        if (angle) replacement.rotate(angle, cx, cy);\n\t        // Note: it's not important to keep the same sibling index since all subnodes are filled\n\t        childEl.parent().append(replacement);\n\t      }\n\t      childEl.remove();\n\t      return false;\n\t    }\n\t    // Keep the element, but clean it from certain attributes\n\t    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n\t      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n\t      childEl.removeAttr(attrName);\n\t    });\n\t    return true;\n\t  },\n\t  transformMaskRoot(_cellView, rootEl) {\n\t    const {\n\t      MASK_ROOT_ATTRIBUTE_BLACKLIST\n\t    } = this;\n\t    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n\t      rootEl.removeAttr(attrName);\n\t    });\n\t  },\n\t  getMaskShape(cellView, vel) {\n\t    const {\n\t      options,\n\t      MASK_REPLACE_TAGS\n\t    } = this;\n\t    const {\n\t      deep\n\t    } = options;\n\t    const tagName = vel.tagName();\n\t    let maskRoot;\n\t    if (tagName === 'G') {\n\t      if (!deep) return null;\n\t      maskRoot = vel.clone();\n\t      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n\t    } else {\n\t      if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n\t      maskRoot = vel.clone();\n\t    }\n\t    this.transformMaskRoot(cellView, maskRoot);\n\t    return maskRoot;\n\t  },\n\t  getMaskId() {\n\t    return `highlight-mask-${this.cid}`;\n\t  },\n\t  getMask(cellView, vNode) {\n\t    const {\n\t      VISIBLE,\n\t      INVISIBLE,\n\t      options\n\t    } = this;\n\t    const {\n\t      padding,\n\t      attrs\n\t    } = options;\n\t    // support both `strokeWidth` and `stroke-width` attribute names\n\t    const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n\t    const hasNodeFill = vNode.attr('fill') !== 'none';\n\t    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n\t    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n\t    // stroke of the invisible shape\n\t    const minStrokeWidth = magnetStrokeWidth + padding * 2;\n\t    // stroke of the visible shape\n\t    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n\t    let maskEl = this.getMaskShape(cellView, vNode);\n\t    if (!maskEl) {\n\t      const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n\t      // Make sure the rect is visible\n\t      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n\t      maskEl = V('rect', nodeBBox.toJSON());\n\t    }\n\t    maskEl.attr(attrs);\n\t    return V('mask', {\n\t      'id': this.getMaskId()\n\t    }).append([maskEl.clone().attr({\n\t      'fill': hasNodeFill ? VISIBLE : 'none',\n\t      'stroke': VISIBLE,\n\t      'stroke-width': maxStrokeWidth\n\t    }), maskEl.clone().attr({\n\t      'fill': hasNodeFill ? INVISIBLE : 'none',\n\t      'stroke': INVISIBLE,\n\t      'stroke-width': minStrokeWidth\n\t    })]);\n\t  },\n\t  removeMask(paper) {\n\t    const maskNode = paper.svg.getElementById(this.getMaskId());\n\t    if (maskNode) {\n\t      paper.defs.removeChild(maskNode);\n\t    }\n\t  },\n\t  addMask(paper, maskEl) {\n\t    paper.defs.appendChild(maskEl.node);\n\t  },\n\t  highlight(cellView, node) {\n\t    const {\n\t      options,\n\t      vel\n\t    } = this;\n\t    const {\n\t      padding,\n\t      attrs,\n\t      maskClip = MASK_CLIP,\n\t      layer\n\t    } = options;\n\t    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';\n\t    if (!layer && node === cellView.el) {\n\t      // If the highlighter is appended to the cellView\n\t      // and we measure the size of the cellView wrapping group\n\t      // it's necessary to remove the highlighter first\n\t      vel.remove();\n\t    }\n\t    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n\t    const highlightMatrix = this.getNodeMatrix(cellView, node);\n\t    const maskEl = this.getMask(cellView, V(node));\n\t    this.addMask(cellView.paper, maskEl);\n\t    vel.attr(highlighterBBox.toJSON());\n\t    vel.attr({\n\t      'transform': V.matrixToTransformString(highlightMatrix),\n\t      'mask': `url(#${maskEl.id})`,\n\t      'fill': color\n\t    });\n\t  },\n\t  unhighlight(cellView) {\n\t    this.removeMask(cellView.paper);\n\t  }\n\t});\n\n\tconst opacity = HighlighterView.extend({\n\t  UPDATABLE: false,\n\t  MOUNTABLE: false,\n\t  highlight: function (_cellView, node) {\n\t    const {\n\t      alphaValue = 0.3\n\t    } = this.options;\n\t    node.style.opacity = alphaValue;\n\t  },\n\t  unhighlight: function (_cellView, node) {\n\t    node.style.opacity = '';\n\t  }\n\t});\n\n\tconst className = addClassNamePrefix('highlighted');\n\tconst addClass = HighlighterView.extend({\n\t  UPDATABLE: false,\n\t  MOUNTABLE: false,\n\t  options: {\n\t    className\n\t  },\n\t  highlight: function (_cellView, node) {\n\t    V(node).addClass(this.options.className);\n\t  },\n\t  unhighlight: function (_cellView, node) {\n\t    V(node).removeClass(this.options.className);\n\t  }\n\t}, {\n\t  // Backwards Compatibility\n\t  className\n\t});\n\n\tconst Directions$1 = {\n\t  ROW: 'row',\n\t  COLUMN: 'column'\n\t};\n\tconst list = HighlighterView.extend({\n\t  tagName: 'g',\n\t  MOUNTABLE: true,\n\t  UPDATE_ATTRIBUTES: function () {\n\t    return [this.options.attribute];\n\t  },\n\t  _prevItems: null,\n\t  highlight(elementView, node) {\n\t    const element = elementView.model;\n\t    const {\n\t      attribute,\n\t      size = 20,\n\t      gap = 5,\n\t      direction = Directions$1.ROW\n\t    } = this.options;\n\t    if (!attribute) throw new Error('List: attribute is required');\n\t    const normalizedSize = typeof size === 'number' ? {\n\t      width: size,\n\t      height: size\n\t    } : size;\n\t    const isRowDirection = direction === Directions$1.ROW;\n\t    const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n\t    let items = element.get(attribute);\n\t    if (!Array.isArray(items)) items = [];\n\t    const prevItems = this._prevItems || [];\n\t    const comparison = items.map((item, index) => isEqual(prevItems[index], items[index]));\n\t    if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n\t      const prevEls = this.vel.children();\n\t      const itemsEls = items.map((item, index) => {\n\t        const prevEl = index in prevEls ? prevEls[index].node : null;\n\t        if (comparison[index]) return prevEl;\n\t        const itemEl = this.createListItem(item, normalizedSize, prevEl);\n\t        if (!itemEl) return null;\n\t        if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n\t        itemEl.dataset.index = index;\n\t        itemEl.dataset.attribute = attribute;\n\t        const offset = index * (itemWidth + gap);\n\t        itemEl.setAttribute('transform', isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);\n\t        return itemEl;\n\t      });\n\t      this.vel.empty().append(itemsEls);\n\t      this._prevItems = items;\n\t    }\n\t    const itemsCount = items.length;\n\t    const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;\n\t    const listSize = isRowDirection ? {\n\t      width: length,\n\t      height: normalizedSize.height\n\t    } : {\n\t      width: normalizedSize.width,\n\t      height: length\n\t    };\n\t    this.position(element, listSize);\n\t  },\n\t  position(element, listSize) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      margin = 5,\n\t      position = 'top-left'\n\t    } = options;\n\t    const {\n\t      width,\n\t      height\n\t    } = element.size();\n\t    const {\n\t      left,\n\t      right,\n\t      top,\n\t      bottom\n\t    } = normalizeSides(margin);\n\t    const bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n\t    let {\n\t      x,\n\t      y\n\t    } = getRectPoint(bbox, position);\n\t    // x\n\t    switch (position) {\n\t      case Positions.CENTER:\n\t      case Positions.TOP:\n\t      case Positions.BOTTOM:\n\t        {\n\t          x -= listSize.width / 2;\n\t          break;\n\t        }\n\t      case Positions.RIGHT:\n\t      case Positions.BOTTOM_RIGHT:\n\t      case Positions.TOP_RIGHT:\n\t        {\n\t          x -= listSize.width;\n\t          break;\n\t        }\n\t    }\n\t    // y\n\t    switch (position) {\n\t      case Positions.CENTER:\n\t      case Positions.RIGHT:\n\t      case Positions.LEFT:\n\t        {\n\t          y -= listSize.height / 2;\n\t          break;\n\t        }\n\t      case Positions.BOTTOM:\n\t      case Positions.BOTTOM_RIGHT:\n\t      case Positions.BOTTOM_LEFT:\n\t        {\n\t          y -= listSize.height;\n\t          break;\n\t        }\n\t    }\n\t    vel.attr('transform', `translate(${x}, ${y})`);\n\t  }\n\t}, {\n\t  Directions: Directions$1,\n\t  Positions\n\t});\n\n\tvar highlighters = {\n\t\t__proto__: null,\n\t\taddClass: addClass,\n\t\tlist: list,\n\t\tmask: mask,\n\t\topacity: opacity,\n\t\tstroke: stroke$1\n\t};\n\n\tfunction offsetPoint(p1, p2, offset) {\n\t  if (isPlainObject(offset)) {\n\t    const {\n\t      x,\n\t      y\n\t    } = offset;\n\t    if (isFinite(y)) {\n\t      const line = new Line(p2, p1);\n\t      const {\n\t        start,\n\t        end\n\t      } = line.parallel(y);\n\t      p2 = start;\n\t      p1 = end;\n\t    }\n\t    offset = x;\n\t  }\n\t  if (!isFinite(offset)) return p1;\n\t  var length = p1.distance(p2);\n\t  if (offset === 0 && length > 0) return p1;\n\t  return p1.move(p2, -Math.min(offset, length - 1));\n\t}\n\tfunction stroke(magnet) {\n\t  var stroke = magnet.getAttribute('stroke-width');\n\t  if (stroke === null) return 0;\n\t  return parseFloat(stroke) || 0;\n\t}\n\tfunction alignLine(line, type, offset = 0) {\n\t  let coordinate, a, b, direction;\n\t  const {\n\t    start,\n\t    end\n\t  } = line;\n\t  switch (type) {\n\t    case 'left':\n\t      coordinate = 'x';\n\t      a = end;\n\t      b = start;\n\t      direction = -1;\n\t      break;\n\t    case 'right':\n\t      coordinate = 'x';\n\t      a = start;\n\t      b = end;\n\t      direction = 1;\n\t      break;\n\t    case 'top':\n\t      coordinate = 'y';\n\t      a = end;\n\t      b = start;\n\t      direction = -1;\n\t      break;\n\t    case 'bottom':\n\t      coordinate = 'y';\n\t      a = start;\n\t      b = end;\n\t      direction = 1;\n\t      break;\n\t    default:\n\t      return;\n\t  }\n\t  if (start[coordinate] < end[coordinate]) {\n\t    a[coordinate] = b[coordinate];\n\t  } else {\n\t    b[coordinate] = a[coordinate];\n\t  }\n\t  if (isFinite(offset)) {\n\t    a[coordinate] += direction * offset;\n\t    b[coordinate] += direction * offset;\n\t  }\n\t}\n\n\t// Connection Points\n\n\tfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n\t  let {\n\t    offset,\n\t    alignOffset,\n\t    align\n\t  } = opt;\n\t  if (align) alignLine(line, align, alignOffset);\n\t  return offsetPoint(line.end, line.start, offset);\n\t}\n\tfunction bboxIntersection(line, view, magnet, opt) {\n\t  const bbox = opt.useModelGeometry ? getNodeModelBBox(view, magnet, true) : view.getNodeBBox(magnet);\n\t  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n\t  const intersections = line.intersect(bbox);\n\t  const cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n\t  return offsetPoint(cp, line.start, opt.offset);\n\t}\n\tfunction rectangleIntersection(line, view, magnet, opt) {\n\t  const angle = view.model.angle();\n\t  if (angle === 0) {\n\t    return bboxIntersection(line, view, magnet, opt);\n\t  }\n\t  const bboxWORotation = opt.useModelGeometry ? getNodeModelBBox(view, magnet, false) : view.getNodeUnrotatedBBox(magnet);\n\t  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n\t  const center = bboxWORotation.center();\n\t  const lineWORotation = line.clone().rotate(center, angle);\n\t  const intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n\t  const cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n\t  return offsetPoint(cp, line.start, opt.offset);\n\t}\n\tfunction getNodeModelBBox(elementView, magnet, rotate) {\n\t  const element = elementView.model;\n\t  const portId = elementView.findAttribute('port', magnet);\n\t  if (element.hasPort(portId)) {\n\t    return element.getPortBBox(portId, {\n\t      rotate\n\t    });\n\t  }\n\t  return element.getBBox({\n\t    rotate\n\t  });\n\t}\n\tfunction findShapeNode(magnet) {\n\t  if (!magnet) return null;\n\t  var node = magnet;\n\t  do {\n\t    var tagName = node.tagName;\n\t    if (typeof tagName !== 'string') return null;\n\t    tagName = tagName.toUpperCase();\n\t    if (tagName === 'G') {\n\t      node = node.firstElementChild;\n\t    } else if (tagName === 'TITLE') {\n\t      node = node.nextElementSibling;\n\t    } else break;\n\t  } while (node);\n\t  return node;\n\t}\n\tvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\n\tvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\tfunction boundaryIntersection(line, view, magnet, opt) {\n\t  var node, intersection;\n\t  var selector = opt.selector;\n\t  var anchor = line.end;\n\t  if (typeof selector === 'string') {\n\t    node = view.findNode(selector);\n\t  } else if (selector === false) {\n\t    node = magnet;\n\t  } else if (Array.isArray(selector)) {\n\t    node = getByPath(magnet, selector);\n\t  } else {\n\t    node = findShapeNode(magnet);\n\t  }\n\t  if (!V.isSVGGraphicsElement(node)) {\n\t    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n\t    node = magnet;\n\t  }\n\t  var localShape = view.getNodeShape(node);\n\t  var magnetMatrix = view.getNodeMatrix(node);\n\t  var translateMatrix = view.getRootTranslateMatrix();\n\t  var rotateMatrix = view.getRootRotateMatrix();\n\t  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n\t  var localMatrix = targetMatrix.inverse();\n\t  var localLine = V.transformLine(line, localMatrix);\n\t  var localRef = localLine.start.clone();\n\t  var data = view.getNodeData(node);\n\t  if (opt.insideout === false) {\n\t    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n\t    var localBBox = data[BNDR_SHAPE_BBOX];\n\t    if (localBBox.containsPoint(localRef)) return anchor;\n\t  }\n\n\t  // Caching segment subdivisions for paths\n\t  var pathOpt;\n\t  if (localShape instanceof Path$1) {\n\t    var precision = opt.precision || 2;\n\t    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n\t      precision: precision\n\t    });\n\t    pathOpt = {\n\t      precision: precision,\n\t      segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n\t    };\n\t  }\n\t  if (opt.extrapolate === true) localLine.setLength(1e6);\n\t  intersection = localLine.intersect(localShape, pathOpt);\n\t  if (intersection) {\n\t    // More than one intersection\n\t    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n\t  } else if (opt.sticky === true) {\n\t    // No intersection, find the closest point instead\n\t    if (localShape instanceof Rect) {\n\t      intersection = localShape.pointNearestToPoint(localRef);\n\t    } else if (localShape instanceof Ellipse$1) {\n\t      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n\t    } else {\n\t      intersection = localShape.closestPoint(localRef, pathOpt);\n\t    }\n\t  }\n\t  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n\t  var cpOffset = opt.offset || 0;\n\t  if (opt.stroke) cpOffset += stroke(node) / 2;\n\t  return offsetPoint(cp, line.start, cpOffset);\n\t}\n\tconst anchor = anchorConnectionPoint;\n\tconst bbox = bboxIntersection;\n\tconst rectangle = rectangleIntersection;\n\tconst boundary = boundaryIntersection;\n\n\tvar connectionPoints = {\n\t\t__proto__: null,\n\t\tanchor: anchor,\n\t\tbbox: bbox,\n\t\tboundary: boundary,\n\t\trectangle: rectangle\n\t};\n\n\tfunction abs2rel(absolute, max) {\n\t  if (max === 0) return '0%';\n\t  // round to 3 decimal places\n\t  const dp = 1000;\n\t  const relative = Math.round(absolute / max * 100 * dp) / dp;\n\t  return `${relative}%`;\n\t}\n\tfunction pin(relative) {\n\t  return function (end, view, magnet, coords) {\n\t    var fn = view.isNodeConnection(magnet) ? pinnedLinkEnd : pinnedElementEnd;\n\t    return fn(relative, end, view, magnet, coords);\n\t  };\n\t}\n\tfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\t  var angle = view.model.angle();\n\t  var bbox = view.getNodeUnrotatedBBox(magnet);\n\t  var origin = view.model.getCenter();\n\t  coords.rotate(origin, angle);\n\t  var dx = coords.x - bbox.x;\n\t  var dy = coords.y - bbox.y;\n\t  if (relative) {\n\t    dx = abs2rel(dx, bbox.width);\n\t    dy = abs2rel(dy, bbox.height);\n\t  }\n\t  end.anchor = {\n\t    name: 'topLeft',\n\t    args: {\n\t      dx: dx,\n\t      dy: dy,\n\t      rotate: true\n\t    }\n\t  };\n\t  return end;\n\t}\n\tfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\t  var connection = view.getConnection();\n\t  if (!connection) return end;\n\t  var length = connection.closestPointLength(coords);\n\t  if (relative) {\n\t    var totalLength = connection.length();\n\t    end.anchor = {\n\t      name: 'connectionRatio',\n\t      args: {\n\t        ratio: length / totalLength\n\t      }\n\t    };\n\t  } else {\n\t    end.anchor = {\n\t      name: 'connectionLength',\n\t      args: {\n\t        length: length\n\t      }\n\t    };\n\t  }\n\t  return end;\n\t}\n\tconst useDefaults = noop;\n\tconst pinAbsolute = pin(false);\n\tconst pinRelative = pin(true);\n\n\tvar index$3 = {\n\t\t__proto__: null,\n\t\tpinAbsolute: pinAbsolute,\n\t\tpinRelative: pinRelative,\n\t\tuseDefaults: useDefaults\n\t};\n\n\t// Does not make any changes to vertices.\n\t// Returns the arguments that are passed to it, unchanged.\n\tconst normal = function (vertices, opt, linkView) {\n\t  return vertices;\n\t};\n\n\t// Routes the link always to/from a certain side\n\t//\n\t// Arguments:\n\t//   padding ... gap between the element and the first vertex. :: Default 40.\n\t//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n\t//\n\tconst oneSide = function (vertices, opt, linkView) {\n\t  var side = opt.side || 'bottom';\n\t  var padding = normalizeSides(opt.padding || 40);\n\n\t  // LinkView contains cached source an target bboxes.\n\t  // Note that those are Geometry rectangle objects.\n\t  var sourceBBox = linkView.sourceBBox;\n\t  var targetBBox = linkView.targetBBox;\n\t  var sourcePoint = sourceBBox.center();\n\t  var targetPoint = targetBBox.center();\n\t  var coordinate, dimension, direction;\n\t  switch (side) {\n\t    case 'bottom':\n\t      direction = 1;\n\t      coordinate = 'y';\n\t      dimension = 'height';\n\t      break;\n\t    case 'top':\n\t      direction = -1;\n\t      coordinate = 'y';\n\t      dimension = 'height';\n\t      break;\n\t    case 'left':\n\t      direction = -1;\n\t      coordinate = 'x';\n\t      dimension = 'width';\n\t      break;\n\t    case 'right':\n\t      direction = 1;\n\t      coordinate = 'x';\n\t      dimension = 'width';\n\t      break;\n\t    default:\n\t      throw new Error('Router: invalid side');\n\t  }\n\n\t  // move the points from the center of the element to outside of it.\n\t  sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n\t  targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n\t  // make link orthogonal (at least the first and last vertex).\n\t  if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\n\t    targetPoint[coordinate] = sourcePoint[coordinate];\n\t  } else {\n\t    sourcePoint[coordinate] = targetPoint[coordinate];\n\t  }\n\t  return [sourcePoint].concat(vertices, targetPoint);\n\t};\n\n\t// bearing -> opposite bearing\n\tvar opposites = {\n\t  N: 'S',\n\t  S: 'N',\n\t  E: 'W',\n\t  W: 'E'\n\t};\n\n\t// bearing -> radians\n\tvar radians = {\n\t  N: -Math.PI / 2 * 3,\n\t  S: -Math.PI / 2,\n\t  E: 0,\n\t  W: Math.PI\n\t};\n\n\t// HELPERS //\n\n\t// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n\t// in the given box\n\tfunction freeJoin(p1, p2, bbox) {\n\t  var p = new Point(p1.x, p2.y);\n\t  if (bbox.containsPoint(p)) p = new Point(p2.x, p1.y);\n\t  // kept for reference\n\t  // if (bbox.containsPoint(p)) p = null;\n\n\t  return p;\n\t}\n\n\t// returns either width or height of a bbox based on the given bearing\n\tfunction getBBoxSize(bbox, bearing) {\n\t  return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n\t}\n\n\t// simple bearing method (calculates only orthogonal cardinals)\n\tfunction getBearing(from, to) {\n\t  if (from.x === to.x) return from.y > to.y ? 'N' : 'S';\n\t  if (from.y === to.y) return from.x > to.x ? 'W' : 'E';\n\t  return null;\n\t}\n\n\t// transform point to a rect\n\tfunction getPointBox(p) {\n\t  return new Rect(p.x, p.y, 0, 0);\n\t}\n\tfunction getPaddingBox(opt) {\n\t  // if both provided, opt.padding wins over opt.elementPadding\n\t  var sides = normalizeSides(opt.padding || opt.elementPadding || 20);\n\t  return {\n\t    x: -sides.left,\n\t    y: -sides.top,\n\t    width: sides.left + sides.right,\n\t    height: sides.top + sides.bottom\n\t  };\n\t}\n\n\t// return source bbox\n\tfunction getSourceBBox$1(linkView, opt) {\n\t  return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox$1(linkView, opt) {\n\t  return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor$1(linkView, opt) {\n\t  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n\t  // fallback: center of bbox\n\t  var sourceBBox = getSourceBBox$1(linkView, opt);\n\t  return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor$1(linkView, opt) {\n\t  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n\t  // fallback: center of bbox\n\t  var targetBBox = getTargetBBox$1(linkView, opt);\n\t  return targetBBox.center(); // default\n\t}\n\n\t// PARTIAL ROUTERS //\n\n\tfunction vertexVertex(from, to, bearing) {\n\t  var p1 = new Point(from.x, to.y);\n\t  var p2 = new Point(to.x, from.y);\n\t  var d1 = getBearing(from, p1);\n\t  var d2 = getBearing(from, p2);\n\t  var opposite = opposites[bearing];\n\t  var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n\t  return {\n\t    points: [p],\n\t    direction: getBearing(p, to)\n\t  };\n\t}\n\tfunction elementVertex(from, to, fromBBox) {\n\t  var p = freeJoin(from, to, fromBBox);\n\t  return {\n\t    points: [p],\n\t    direction: getBearing(p, to)\n\t  };\n\t}\n\tfunction vertexElement(from, to, toBBox, bearing) {\n\t  var route = {};\n\t  var points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n\t  var freePoints = points.filter(function (pt) {\n\t    return !toBBox.containsPoint(pt);\n\t  });\n\t  var freeBearingPoints = freePoints.filter(function (pt) {\n\t    return getBearing(pt, from) !== bearing;\n\t  });\n\t  var p;\n\t  if (freeBearingPoints.length > 0) {\n\t    // Try to pick a point which bears the same direction as the previous segment.\n\n\t    p = freeBearingPoints.filter(function (pt) {\n\t      return getBearing(from, pt) === bearing;\n\t    }).pop();\n\t    p = p || freeBearingPoints[0];\n\t    route.points = [p];\n\t    route.direction = getBearing(p, to);\n\t  } else {\n\t    // Here we found only points which are either contained in the element or they would create\n\t    // a link segment going in opposite direction from the previous one.\n\t    // We take the point inside element and move it outside the element in the direction the\n\t    // route is going. Now we can join this point with the current end (using freeJoin).\n\n\t    p = difference(points, freePoints)[0];\n\t    var p2 = new Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n\t    var p1 = freeJoin(p2, from, toBBox);\n\t    route.points = [p1, p2];\n\t    route.direction = getBearing(p2, to);\n\t  }\n\t  return route;\n\t}\n\tfunction elementElement(from, to, fromBBox, toBBox) {\n\t  var route = elementVertex(to, from, toBBox);\n\t  var p1 = route.points[0];\n\t  if (fromBBox.containsPoint(p1)) {\n\t    route = elementVertex(from, to, fromBBox);\n\t    var p2 = route.points[0];\n\t    if (toBBox.containsPoint(p2)) {\n\t      var fromBorder = new Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n\t      var toBorder = new Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n\t      var mid = new Line(fromBorder, toBorder).midpoint();\n\t      var startRoute = elementVertex(from, mid, fromBBox);\n\t      var endRoute = vertexVertex(mid, to, startRoute.direction);\n\t      route.points = [startRoute.points[0], endRoute.points[0]];\n\t      route.direction = endRoute.direction;\n\t    }\n\t  }\n\t  return route;\n\t}\n\n\t// Finds route for situations where one element is inside the other.\n\t// Typically the route is directed outside the outer element first and\n\t// then back towards the inner element.\n\tfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\t  var route = {};\n\t  var boundary = fromBBox.union(toBBox).inflate(1);\n\n\t  // start from the point which is closer to the boundary\n\t  var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n\t  var start = reversed ? to : from;\n\t  var end = reversed ? from : to;\n\t  var p1, p2, p3;\n\t  if (bearing) {\n\t    // Points on circle with radius equals 'W + H` are always outside the rectangle\n\t    // with width W and height H if the center of that circle is the center of that rectangle.\n\t    p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n\t    p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\t  } else {\n\t    p1 = boundary.pointNearestToPoint(start).move(start, 1);\n\t  }\n\t  p2 = freeJoin(p1, end, boundary);\n\t  if (p1.round().equals(p2.round())) {\n\t    p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);\n\t    p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n\t    p3 = freeJoin(p1, p2, boundary);\n\t    route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\t  } else {\n\t    route.points = reversed ? [p2, p1] : [p1, p2];\n\t  }\n\t  route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\t  return route;\n\t}\n\n\t// MAIN ROUTER //\n\n\t// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n\t// routing from source to target going through `vertices`.\n\tfunction orthogonal(vertices, opt, linkView) {\n\t  var sourceBBox = getSourceBBox$1(linkView, opt);\n\t  var targetBBox = getTargetBBox$1(linkView, opt);\n\t  var sourceAnchor = getSourceAnchor$1(linkView, opt);\n\t  var targetAnchor = getTargetAnchor$1(linkView, opt);\n\n\t  // if anchor lies outside of bbox, the bbox expands to include it\n\t  sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n\t  targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\t  vertices = toArray$1(vertices).map(Point);\n\t  vertices.unshift(sourceAnchor);\n\t  vertices.push(targetAnchor);\n\t  var bearing; // bearing of previous route segment\n\n\t  var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n\t  for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\t    var route = null;\n\t    var from = vertices[i];\n\t    var to = vertices[i + 1];\n\t    var isOrthogonal = !!getBearing(from, to);\n\t    if (i === 0) {\n\t      // source\n\n\t      if (i + 1 === max) {\n\t        // route source -> target\n\n\t        // Expand one of the elements by 1px to detect situations when the two\n\t        // elements are positioned next to each other with no gap in between.\n\t        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n\t          route = insideElement(from, to, sourceBBox, targetBBox);\n\t        } else if (!isOrthogonal) {\n\t          route = elementElement(from, to, sourceBBox, targetBBox);\n\t        }\n\t      } else {\n\t        // route source -> vertex\n\n\t        if (sourceBBox.containsPoint(to)) {\n\t          route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\t        } else if (!isOrthogonal) {\n\t          route = elementVertex(from, to, sourceBBox);\n\t        }\n\t      }\n\t    } else if (i + 1 === max) {\n\t      // route vertex -> target\n\n\t      // prevent overlaps with previous line segment\n\t      var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\t      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n\t        route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\t      } else if (!isOrthogonal) {\n\t        route = vertexElement(from, to, targetBBox, bearing);\n\t      }\n\t    } else if (!isOrthogonal) {\n\t      // route vertex -> vertex\n\t      route = vertexVertex(from, to, bearing);\n\t    }\n\n\t    // applicable to all routes:\n\n\t    // set bearing for next iteration\n\t    if (route) {\n\t      Array.prototype.push.apply(orthogonalVertices, route.points);\n\t      bearing = route.direction;\n\t    } else {\n\t      // orthogonal route and not looped\n\t      bearing = getBearing(from, to);\n\t    }\n\n\t    // push `to` point to identified orthogonal vertices array\n\t    if (i + 1 < max) {\n\t      orthogonalVertices.push(to);\n\t    }\n\t  }\n\t  return orthogonalVertices;\n\t}\n\n\tvar config$1 = {\n\t  // size of the step to find a route (the grid of the manhattan pathfinder)\n\t  step: 10,\n\t  // the number of route finding loops that cause the router to abort\n\t  // returns fallback route instead\n\t  maximumLoops: 2000,\n\t  // the number of decimal places to round floating point coordinates\n\t  precision: 1,\n\t  // maximum change of direction\n\t  maxAllowedDirectionChange: 90,\n\t  // should the router use perpendicular linkView option?\n\t  // does not connect anchor of element but rather a point close-by that is orthogonal\n\t  // this looks much better\n\t  perpendicular: true,\n\t  // should the source and/or target not be considered as obstacles?\n\t  excludeEnds: [],\n\t  // 'source', 'target'\n\n\t  // should certain types of elements not be considered as obstacles?\n\t  excludeTypes: [],\n\t  // possible starting directions from an element\n\t  startDirections: ['top', 'right', 'bottom', 'left'],\n\t  // possible ending directions to an element\n\t  endDirections: ['top', 'right', 'bottom', 'left'],\n\t  // specify the directions used above and what they mean\n\t  directionMap: {\n\t    top: {\n\t      x: 0,\n\t      y: -1\n\t    },\n\t    right: {\n\t      x: 1,\n\t      y: 0\n\t    },\n\t    bottom: {\n\t      x: 0,\n\t      y: 1\n\t    },\n\t    left: {\n\t      x: -1,\n\t      y: 0\n\t    }\n\t  },\n\t  // cost of an orthogonal step\n\t  cost: function () {\n\t    return this.step;\n\t  },\n\t  // an array of directions to find next points on the route\n\t  // different from start/end directions\n\t  directions: function () {\n\t    var step = this.step;\n\t    var cost = this.cost();\n\t    return [{\n\t      offsetX: step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: -step,\n\t      cost: cost\n\t    }];\n\t  },\n\t  // a penalty received for direction change\n\t  penalties: function () {\n\t    return {\n\t      0: 0,\n\t      45: this.step / 2,\n\t      90: this.step / 2\n\t    };\n\t  },\n\t  // padding applied on the element bounding boxes\n\t  paddingBox: function () {\n\t    var step = this.step;\n\t    return {\n\t      x: -step,\n\t      y: -step,\n\t      width: 2 * step,\n\t      height: 2 * step\n\t    };\n\t  },\n\t  // A function that determines whether a given point is an obstacle or not.\n\t  // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n\t  // (point: dia.Point) => boolean;\n\t  isPointObstacle: null,\n\t  // a router to use when the manhattan router fails\n\t  // (one of the partial routes returns null)\n\t  fallbackRouter: function (vertices, opt, linkView) {\n\t    if (!isFunction(orthogonal)) {\n\t      throw new Error('Manhattan requires the orthogonal router as default fallback.');\n\t    }\n\t    return orthogonal(vertices, assign({}, config$1, opt), linkView);\n\t  },\n\t  /* Deprecated */\n\t  // a simple route used in situations when main routing method fails\n\t  // (exceed max number of loop iterations, inaccessible)\n\t  fallbackRoute: function (from, to, opt) {\n\t    return null; // null result will trigger the fallbackRouter\n\n\t    // left for reference:\n\t    /*// Find an orthogonal route ignoring obstacles.\n\t     var point = ((opt.previousDirAngle || 0) % 180 === 0)\n\t            ? new g.Point(from.x, to.y)\n\t            : new g.Point(to.x, from.y);\n\t     return [point];*/\n\t  },\n\t  // if a function is provided, it's used to route the link while dragging an end\n\t  // i.e. function(from, to, opt) { return []; }\n\t  draggingRoute: null\n\t};\n\n\t// HELPER CLASSES //\n\n\t// Map of obstacles\n\t// Helper structure to identify whether a point lies inside an obstacle.\n\tfunction ObstacleMap(opt) {\n\t  this.map = {};\n\t  this.options = opt;\n\t  // tells how to divide the paper when creating the elements map\n\t  this.mapGridSize = 100;\n\t}\n\tObstacleMap.prototype.build = function (graph, link) {\n\t  var opt = this.options;\n\n\t  // source or target element could be excluded from set of obstacles\n\t  var excludedEnds = toArray$1(opt.excludeEnds).reduce(function (res, item) {\n\t    var end = link.get(item);\n\t    if (end) {\n\t      var cell = graph.getCell(end.id);\n\t      if (cell) {\n\t        res.push(cell);\n\t      }\n\t    }\n\t    return res;\n\t  }, []);\n\n\t  // Exclude any embedded elements from the source and the target element.\n\t  var excludedAncestors = [];\n\t  var source = graph.getCell(link.get('source').id);\n\t  if (source) {\n\t    excludedAncestors = union(excludedAncestors, source.getAncestors().map(function (cell) {\n\t      return cell.id;\n\t    }));\n\t  }\n\t  var target = graph.getCell(link.get('target').id);\n\t  if (target) {\n\t    excludedAncestors = union(excludedAncestors, target.getAncestors().map(function (cell) {\n\t      return cell.id;\n\t    }));\n\t  }\n\n\t  // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n\t  // in any obstacle?) (a simplified grid search).\n\t  // The paper is divided into smaller cells, where each holds information about which\n\t  // elements belong to it. When we query whether a point lies inside an obstacle we\n\t  // don't need to go through all obstacles, we check only those in a particular cell.\n\t  var mapGridSize = this.mapGridSize;\n\t  graph.getElements().reduce(function (map, element) {\n\t    var isExcludedType = toArray$1(opt.excludeTypes).includes(element.get('type'));\n\t    var isExcludedEnd = excludedEnds.find(function (excluded) {\n\t      return excluded.id === element.id;\n\t    });\n\t    var isExcludedAncestor = excludedAncestors.includes(element.id);\n\t    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\t    if (!isExcluded) {\n\t      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\t      var origin = bbox.origin().snapToGrid(mapGridSize);\n\t      var corner = bbox.corner().snapToGrid(mapGridSize);\n\t      for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n\t        for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n\t          var gridKey = x + '@' + y;\n\t          map[gridKey] = map[gridKey] || [];\n\t          map[gridKey].push(bbox);\n\t        }\n\t      }\n\t    }\n\t    return map;\n\t  }, this.map);\n\t  return this;\n\t};\n\tObstacleMap.prototype.isPointAccessible = function (point) {\n\t  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\t  return toArray$1(this.map[mapKey]).every(function (obstacle) {\n\t    return !obstacle.containsPoint(point);\n\t  });\n\t};\n\n\t// Sorted Set\n\t// Set of items sorted by given value.\n\tfunction SortedSet() {\n\t  this.items = [];\n\t  this.hash = {};\n\t  this.values = {};\n\t  this.OPEN = 1;\n\t  this.CLOSE = 2;\n\t}\n\tSortedSet.prototype.add = function (item, value) {\n\t  if (this.hash[item]) {\n\t    // item removal\n\t    this.items.splice(this.items.indexOf(item), 1);\n\t  } else {\n\t    this.hash[item] = this.OPEN;\n\t  }\n\t  this.values[item] = value;\n\t  var index = sortedIndex(this.items, item, function (i) {\n\t    return this.values[i];\n\t  }.bind(this));\n\t  this.items.splice(index, 0, item);\n\t};\n\tSortedSet.prototype.remove = function (item) {\n\t  this.hash[item] = this.CLOSE;\n\t};\n\tSortedSet.prototype.isOpen = function (item) {\n\t  return this.hash[item] === this.OPEN;\n\t};\n\tSortedSet.prototype.isClose = function (item) {\n\t  return this.hash[item] === this.CLOSE;\n\t};\n\tSortedSet.prototype.isEmpty = function () {\n\t  return this.items.length === 0;\n\t};\n\tSortedSet.prototype.pop = function () {\n\t  var item = this.items.shift();\n\t  this.remove(item);\n\t  return item;\n\t};\n\n\t// HELPERS //\n\n\t// return source bbox\n\tfunction getSourceBBox(linkView, opt) {\n\t  // expand by padding box\n\t  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\t  return linkView.sourceBBox.clone();\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox(linkView, opt) {\n\t  // expand by padding box\n\t  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\t  return linkView.targetBBox.clone();\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor(linkView, opt) {\n\t  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n\t  // fallback: center of bbox\n\t  var sourceBBox = getSourceBBox(linkView, opt);\n\t  return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor(linkView, opt) {\n\t  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n\t  // fallback: center of bbox\n\t  var targetBBox = getTargetBBox(linkView, opt);\n\t  return targetBBox.center(); // default\n\t}\n\n\t// returns a direction index from start point to end point\n\t// corrects for grid deformation between start and end\n\tfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\t  var quadrant = 360 / numDirections;\n\t  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n\t  var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n\t  return quadrant * Math.floor(normalizedAngle / quadrant);\n\t}\n\n\t// helper function for getDirectionAngle()\n\t// corrects for grid deformation\n\t// (if a point is one grid steps away from another in both dimensions,\n\t// it is considered to be 45 degrees away, even if the real angle is different)\n\t// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\tfunction fixAngleEnd(start, end, grid, opt) {\n\t  var step = opt.step;\n\t  var diffX = end.x - start.x;\n\t  var diffY = end.y - start.y;\n\t  var gridStepsX = diffX / grid.x;\n\t  var gridStepsY = diffY / grid.y;\n\t  var distanceX = gridStepsX * step;\n\t  var distanceY = gridStepsY * step;\n\t  return new Point(start.x + distanceX, start.y + distanceY);\n\t}\n\n\t// return the change in direction between two direction angles\n\tfunction getDirectionChange(angle1, angle2) {\n\t  var directionChange = Math.abs(angle1 - angle2);\n\t  return directionChange > 180 ? 360 - directionChange : directionChange;\n\t}\n\n\t// fix direction offsets according to current grid\n\tfunction getGridOffsets(directions, grid, opt) {\n\t  var step = opt.step;\n\t  toArray$1(opt.directions).forEach(function (direction) {\n\t    direction.gridOffsetX = direction.offsetX / step * grid.x;\n\t    direction.gridOffsetY = direction.offsetY / step * grid.y;\n\t  });\n\t}\n\n\t// get grid size in x and y dimensions, adapted to source and target positions\n\tfunction getGrid(step, source, target) {\n\t  return {\n\t    source: source.clone(),\n\t    x: getGridDimension(target.x - source.x, step),\n\t    y: getGridDimension(target.y - source.y, step)\n\t  };\n\t}\n\n\t// helper function for getGrid()\n\tfunction getGridDimension(diff, step) {\n\t  // return step if diff = 0\n\t  if (!diff) return step;\n\t  var absDiff = Math.abs(diff);\n\t  var numSteps = Math.round(absDiff / step);\n\n\t  // return absDiff if less than one step apart\n\t  if (!numSteps) return absDiff;\n\n\t  // otherwise, return corrected step\n\t  var roundedDiff = numSteps * step;\n\t  var remainder = absDiff - roundedDiff;\n\t  var stepCorrection = remainder / numSteps;\n\t  return step + stepCorrection;\n\t}\n\n\t// return a clone of point snapped to grid\n\tfunction snapToGrid(point, grid) {\n\t  var source = grid.source;\n\t  var snappedX = snapToGrid$1(point.x - source.x, grid.x) + source.x;\n\t  var snappedY = snapToGrid$1(point.y - source.y, grid.y) + source.y;\n\t  return new Point(snappedX, snappedY);\n\t}\n\n\t// round the point to opt.precision\n\tfunction round(point, precision) {\n\t  return point.round(precision);\n\t}\n\n\t// snap to grid and then round the point\n\tfunction align(point, grid, precision) {\n\t  return round(snapToGrid(point.clone(), grid), precision);\n\t}\n\n\t// return a string representing the point\n\t// string is rounded in both dimensions\n\tfunction getKey(point) {\n\t  return point.clone().toString();\n\t}\n\n\t// return a normalized vector from given point\n\t// used to determine the direction of a difference of two points\n\tfunction normalizePoint(point) {\n\t  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n\t}\n\n\t// PATHFINDING //\n\n\t// reconstructs a route by concatenating points with their parents\n\tfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\t  var route = [];\n\t  var prevDiff = normalizePoint(to.difference(tailPoint));\n\n\t  // tailPoint is assumed to be aligned already\n\t  var currentKey = getKey(tailPoint);\n\t  var parent = parents[currentKey];\n\t  var point;\n\t  while (parent) {\n\t    // point is assumed to be aligned already\n\t    point = points[currentKey];\n\t    var diff = normalizePoint(point.difference(parent));\n\t    if (!diff.equals(prevDiff)) {\n\t      route.unshift(point);\n\t      prevDiff = diff;\n\t    }\n\n\t    // parent is assumed to be aligned already\n\t    currentKey = getKey(parent);\n\t    parent = parents[currentKey];\n\t  }\n\n\t  // leadPoint is assumed to be aligned already\n\t  var leadPoint = points[currentKey];\n\t  var fromDiff = normalizePoint(leadPoint.difference(from));\n\t  if (!fromDiff.equals(prevDiff)) {\n\t    route.unshift(leadPoint);\n\t  }\n\t  return route;\n\t}\n\n\t// heuristic method to determine the distance between two points\n\tfunction estimateCost(from, endPoints) {\n\t  var min = Infinity;\n\t  for (var i = 0, len = endPoints.length; i < len; i++) {\n\t    var cost = from.manhattanDistance(endPoints[i]);\n\t    if (cost < min) min = cost;\n\t  }\n\t  return min;\n\t}\n\n\t// find points around the bbox taking given directions into account\n\t// lines are drawn from anchor in given directions, intersections recorded\n\t// if anchor is outside bbox, only those directions that intersect get a rect point\n\t// the anchor itself is returned as rect point (representing some directions)\n\t// (since those directions are unobstructed by the bbox)\n\tfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\t  var precision = opt.precision;\n\t  var directionMap = opt.directionMap;\n\t  var anchorCenterVector = anchor.difference(bbox.center());\n\t  var keys = isObject(directionMap) ? Object.keys(directionMap) : [];\n\t  var dirList = toArray$1(directionList);\n\t  var rectPoints = keys.reduce(function (res, key) {\n\t    if (dirList.includes(key)) {\n\t      var direction = directionMap[key];\n\n\t      // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n\t      // even if anchor lies outside of bbox\n\t      var endpoint = new Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n\t      var intersectionLine = new Line(anchor, endpoint);\n\n\t      // get the farther intersection, in case there are two\n\t      // (that happens if anchor lies next to bbox)\n\t      var intersections = intersectionLine.intersect(bbox) || [];\n\t      var numIntersections = intersections.length;\n\t      var farthestIntersectionDistance;\n\t      var farthestIntersection = null;\n\t      for (var i = 0; i < numIntersections; i++) {\n\t        var currentIntersection = intersections[i];\n\t        var distance = anchor.squaredDistance(currentIntersection);\n\t        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n\t          farthestIntersectionDistance = distance;\n\t          farthestIntersection = currentIntersection;\n\t        }\n\t      }\n\n\t      // if an intersection was found in this direction, it is our rectPoint\n\t      if (farthestIntersection) {\n\t        var point = align(farthestIntersection, grid, precision);\n\n\t        // if the rectPoint lies inside the bbox, offset it by one more step\n\t        if (bbox.containsPoint(point)) {\n\t          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n\t        }\n\n\t        // then add the point to the result array\n\t        // aligned\n\t        res.push(point);\n\t      }\n\t    }\n\t    return res;\n\t  }, []);\n\n\t  // if anchor lies outside of bbox, add it to the array of points\n\t  if (!bbox.containsPoint(anchor)) {\n\t    // aligned\n\t    rectPoints.push(align(anchor, grid, precision));\n\t  }\n\t  return rectPoints;\n\t}\n\n\t// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n\t// rectangles get rect points assigned by getRectPoints()\n\tfunction findRoute(from, to, isPointObstacle, opt) {\n\t  var precision = opt.precision;\n\n\t  // Get grid for this route.\n\n\t  var sourceAnchor, targetAnchor;\n\t  if (from instanceof Rect) {\n\t    // `from` is sourceBBox\n\t    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n\t  } else {\n\t    sourceAnchor = round(from.clone(), precision);\n\t  }\n\t  if (to instanceof Rect) {\n\t    // `to` is targetBBox\n\t    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n\t  } else {\n\t    targetAnchor = round(to.clone(), precision);\n\t  }\n\t  var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n\t  // Get pathfinding points.\n\n\t  var start, end; // aligned with grid by definition\n\t  var startPoints, endPoints; // assumed to be aligned with grid already\n\n\t  // set of points we start pathfinding from\n\t  if (from instanceof Rect) {\n\t    // `from` is sourceBBox\n\t    start = sourceAnchor;\n\t    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\t  } else {\n\t    start = sourceAnchor;\n\t    startPoints = [start];\n\t  }\n\n\t  // set of points we want the pathfinding to finish at\n\t  if (to instanceof Rect) {\n\t    // `to` is targetBBox\n\t    end = targetAnchor;\n\t    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\t  } else {\n\t    end = targetAnchor;\n\t    endPoints = [end];\n\t  }\n\n\t  // take into account only accessible rect points (those not under obstacles)\n\t  startPoints = startPoints.filter(p => !isPointObstacle(p));\n\t  endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n\t  // Check that there is an accessible route point on both sides.\n\t  // Otherwise, use fallbackRoute().\n\t  if (startPoints.length > 0 && endPoints.length > 0) {\n\t    // The set of tentative points to be evaluated, initially containing the start points.\n\t    // Rounded to nearest integer for simplicity.\n\t    var openSet = new SortedSet();\n\t    // Keeps reference to actual points for given elements of the open set.\n\t    var points = {};\n\t    // Keeps reference to a point that is immediate predecessor of given element.\n\t    var parents = {};\n\t    // Cost from start to a point along best known path.\n\t    var costs = {};\n\t    for (var i = 0, n = startPoints.length; i < n; i++) {\n\t      // startPoint is assumed to be aligned already\n\t      var startPoint = startPoints[i];\n\t      var key = getKey(startPoint);\n\t      openSet.add(key, estimateCost(startPoint, endPoints));\n\t      points[key] = startPoint;\n\t      costs[key] = 0;\n\t    }\n\t    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\t    var isPathBeginning = previousRouteDirectionAngle === undefined;\n\n\t    // directions\n\t    var direction, directionChange;\n\t    var directions = opt.directions;\n\t    getGridOffsets(directions, grid, opt);\n\t    var numDirections = directions.length;\n\t    var endPointsKeys = toArray$1(endPoints).reduce(function (res, endPoint) {\n\t      // endPoint is assumed to be aligned already\n\n\t      var key = getKey(endPoint);\n\t      res.push(key);\n\t      return res;\n\t    }, []);\n\n\t    // main route finding loop\n\t    var loopsRemaining = opt.maximumLoops;\n\t    while (!openSet.isEmpty() && loopsRemaining > 0) {\n\t      // remove current from the open list\n\t      var currentKey = openSet.pop();\n\t      var currentPoint = points[currentKey];\n\t      var currentParent = parents[currentKey];\n\t      var currentCost = costs[currentKey];\n\t      var isRouteBeginning = currentParent === undefined; // undefined for route starts\n\t      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n\t      var previousDirectionAngle;\n\t      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n\t      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n\t      else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n\t      else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n\t      // check if we reached any endpoint\n\t      var samePoints = startPoints.length === endPoints.length;\n\t      if (samePoints) {\n\t        for (var j = 0; j < startPoints.length; j++) {\n\t          if (!startPoints[j].equals(endPoints[j])) {\n\t            samePoints = false;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      var skipEndCheck = isRouteBeginning && samePoints;\n\t      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n\t        opt.previousDirectionAngle = previousDirectionAngle;\n\t        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n\t      }\n\n\t      // go over all possible directions and find neighbors\n\t      for (i = 0; i < numDirections; i++) {\n\t        direction = directions[i];\n\t        var directionAngle = direction.angle;\n\t        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n\t        // if the direction changed rapidly, don't use this point\n\t        // any direction is allowed for starting points\n\t        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\t        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n\t        var neighborKey = getKey(neighborPoint);\n\n\t        // Closed points from the openSet were already evaluated.\n\t        if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n\t        // We can only enter end points at an acceptable angle.\n\t        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n\t          // neighbor is an end point\n\n\t          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n\t          if (!isNeighborEnd) {\n\t            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n\t            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\t            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n\t          }\n\t        }\n\n\t        // The current direction is ok.\n\n\t        var neighborCost = direction.cost;\n\t        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\t        var costFromStart = currentCost + neighborCost + neighborPenalty;\n\t        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n\t          // neighbor point has not been processed yet\n\t          // or the cost of the path from start is lower than previously calculated\n\n\t          points[neighborKey] = neighborPoint;\n\t          parents[neighborKey] = currentPoint;\n\t          costs[neighborKey] = costFromStart;\n\t          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n\t        }\n\t      }\n\t      loopsRemaining--;\n\t    }\n\t  }\n\n\t  // no route found (`to` point either wasn't accessible or finding route took\n\t  // way too much calculation)\n\t  return opt.fallbackRoute.call(this, start, end, opt);\n\t}\n\n\t// resolve some of the options\n\tfunction resolveOptions(opt) {\n\t  opt.directions = result(opt, 'directions');\n\t  opt.penalties = result(opt, 'penalties');\n\t  opt.paddingBox = result(opt, 'paddingBox');\n\t  opt.padding = result(opt, 'padding');\n\t  if (opt.padding) {\n\t    // if both provided, opt.padding wins over opt.paddingBox\n\t    var sides = normalizeSides(opt.padding);\n\t    opt.paddingBox = {\n\t      x: -sides.left,\n\t      y: -sides.top,\n\t      width: sides.left + sides.right,\n\t      height: sides.top + sides.bottom\n\t    };\n\t  }\n\t  toArray$1(opt.directions).forEach(function (direction) {\n\t    var point1 = new Point(0, 0);\n\t    var point2 = new Point(direction.offsetX, direction.offsetY);\n\t    direction.angle = normalizeAngle(point1.theta(point2));\n\t  });\n\t}\n\n\t// initialization of the route finding\n\tfunction router(vertices, opt, linkView) {\n\t  resolveOptions(opt);\n\n\t  // enable/disable linkView perpendicular option\n\t  linkView.options.perpendicular = !!opt.perpendicular;\n\t  var sourceBBox = getSourceBBox(linkView, opt);\n\t  var targetBBox = getTargetBBox(linkView, opt);\n\t  var sourceAnchor = getSourceAnchor(linkView, opt);\n\t  //var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t  // pathfinding\n\t  let isPointObstacle;\n\t  if (typeof opt.isPointObstacle === 'function') {\n\t    isPointObstacle = opt.isPointObstacle;\n\t  } else {\n\t    const map = new ObstacleMap(opt);\n\t    map.build(linkView.paper.model, linkView.model);\n\t    isPointObstacle = point => !map.isPointAccessible(point);\n\t  }\n\t  var oldVertices = toArray$1(vertices).map(Point);\n\t  var newVertices = [];\n\t  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n\t  // find a route by concatenating all partial routes (routes need to pass through vertices)\n\t  // source -> vertex[1] -> ... -> vertex[n] -> target\n\t  var to, from;\n\t  for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\t    var partialRoute = null;\n\t    from = to || sourceBBox;\n\t    to = oldVertices[i];\n\t    if (!to) {\n\t      // this is the last iteration\n\t      // we ran through all vertices in oldVertices\n\t      // 'to' is not a vertex.\n\n\t      to = targetBBox;\n\n\t      // If the target is a point (i.e. it's not an element), we\n\t      // should use dragging route instead of main routing method if it has been provided.\n\t      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\t      if (isEndingAtPoint && isFunction(opt.draggingRoute)) {\n\t        // Make sure we are passing points only (not rects).\n\t        var dragFrom = from === sourceBBox ? sourceAnchor : from;\n\t        var dragTo = to.origin();\n\t        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n\t      }\n\t    }\n\n\t    // if partial route has not been calculated yet use the main routing method to find one\n\t    partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\t    if (partialRoute === null) {\n\t      // the partial route cannot be found\n\t      return opt.fallbackRouter(vertices, opt, linkView);\n\t    }\n\t    var leadPoint = partialRoute[0];\n\n\t    // remove the first point if the previous partial route had the same point as last\n\t    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n\t    // save tailPoint for next iteration\n\t    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\t    Array.prototype.push.apply(newVertices, partialRoute);\n\t  }\n\t  return newVertices;\n\t}\n\n\t// public function\n\tconst manhattan = function (vertices, opt, linkView) {\n\t  return router(vertices, assign({}, config$1, opt), linkView);\n\t};\n\n\tvar config = {\n\t  maxAllowedDirectionChange: 45,\n\t  // cost of a diagonal step\n\t  diagonalCost: function () {\n\t    var step = this.step;\n\t    return Math.ceil(Math.sqrt(step * step << 1));\n\t  },\n\t  // an array of directions to find next points on the route\n\t  // different from start/end directions\n\t  directions: function () {\n\t    var step = this.step;\n\t    var cost = this.cost();\n\t    var diagonalCost = this.diagonalCost();\n\t    return [{\n\t      offsetX: step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: step,\n\t      offsetY: step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: 0,\n\t      cost: cost\n\t    }, {\n\t      offsetX: -step,\n\t      offsetY: -step,\n\t      cost: diagonalCost\n\t    }, {\n\t      offsetX: 0,\n\t      offsetY: -step,\n\t      cost: cost\n\t    }, {\n\t      offsetX: step,\n\t      offsetY: -step,\n\t      cost: diagonalCost\n\t    }];\n\t  },\n\t  // a simple route used in situations when main routing method fails\n\t  // (exceed max number of loop iterations, inaccessible)\n\t  fallbackRoute: function (from, to, opt) {\n\t    // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n\t    var theta = from.theta(to);\n\t    var route = [];\n\t    var a = {\n\t      x: to.x,\n\t      y: from.y\n\t    };\n\t    var b = {\n\t      x: from.x,\n\t      y: to.y\n\t    };\n\t    if (theta % 180 > 90) {\n\t      var t = a;\n\t      a = b;\n\t      b = t;\n\t    }\n\t    var p1 = theta % 90 < 45 ? a : b;\n\t    var l1 = new Line(from, p1);\n\t    var alpha = 90 * Math.ceil(theta / 90);\n\t    var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);\n\t    var l2 = new Line(to, p2);\n\t    var intersectionPoint = l1.intersection(l2);\n\t    var point = intersectionPoint ? intersectionPoint : to;\n\t    var directionFrom = intersectionPoint ? point : from;\n\t    var quadrant = 360 / opt.directions.length;\n\t    var angleTheta = directionFrom.theta(to);\n\t    var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n\t    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\t    opt.previousDirectionAngle = directionAngle;\n\t    if (point) route.push(point.round());\n\t    route.push(to);\n\t    return route;\n\t  }\n\t};\n\n\t// public function\n\tconst metro = function (vertices, opt, linkView) {\n\t  if (!isFunction(manhattan)) {\n\t    throw new Error('Metro requires the manhattan router.');\n\t  }\n\t  return manhattan(vertices, assign({}, config, opt), linkView);\n\t};\n\n\tconst Directions = {\n\t  AUTO: 'auto',\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  TOP: 'top',\n\t  BOTTOM: 'bottom',\n\t  ANCHOR_SIDE: 'anchor-side',\n\t  MAGNET_SIDE: 'magnet-side'\n\t};\n\tconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\tconst OPPOSITE_DIRECTIONS = {\n\t  [Directions.LEFT]: Directions.RIGHT,\n\t  [Directions.RIGHT]: Directions.LEFT,\n\t  [Directions.TOP]: Directions.BOTTOM,\n\t  [Directions.BOTTOM]: Directions.TOP\n\t};\n\tconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\tconst ANGLE_DIRECTION_MAP = {\n\t  0: Directions.RIGHT,\n\t  180: Directions.LEFT,\n\t  270: Directions.TOP,\n\t  90: Directions.BOTTOM\n\t};\n\tfunction getSegmentAngle(line) {\n\t  // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n\t  return line.angle();\n\t}\n\tfunction simplifyPoints(points) {\n\t  // TODO: use own more efficient implementation (filter points that do not change direction).\n\t  // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n\t  return new Polyline$1(points).simplify({\n\t    threshold: 1\n\t  }).points;\n\t}\n\tfunction resolveSides(source, target) {\n\t  const {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    view: sourceView,\n\t    bbox: sourceBBox,\n\t    direction: sourceDirection\n\t  } = source;\n\t  const {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    view: targetView,\n\t    bbox: targetBBox,\n\t    direction: targetDirection\n\t  } = target;\n\t  let sourceSide;\n\t  if (!sourceView) {\n\t    const sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);\n\t    sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n\t  } else if (sourceView.model.isLink()) {\n\t    sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n\t  } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n\t    sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n\t  } else if (sourceDirection === Directions.MAGNET_SIDE) {\n\t    sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n\t  } else {\n\t    sourceSide = sourceDirection;\n\t  }\n\t  let targetSide;\n\t  if (!targetView) {\n\t    const targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);\n\t    targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n\t  } else if (targetView.model.isLink()) {\n\t    targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n\t  } else if (targetDirection === Directions.ANCHOR_SIDE) {\n\t    targetSide = targetBBox.sideNearestToPoint(targetPoint);\n\t  } else if (targetDirection === Directions.MAGNET_SIDE) {\n\t    targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n\t  } else {\n\t    targetSide = targetDirection;\n\t  }\n\t  return [sourceSide, targetSide];\n\t}\n\tfunction resolveForTopSourceSide(source, target, nextInLine) {\n\t  const {\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smx1 = sx1 + margin;\n\t  const smy0 = sy0 - margin;\n\t  const {\n\t    x: ax\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx === ax && ty < sy0) return Directions.BOTTOM;\n\t  if (tx < ax && ty < smy0) {\n\t    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n\t    return Directions.RIGHT;\n\t  }\n\t  if (tx > ax && ty < smy0) {\n\t    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx < smx0 && ty > smy0) return Directions.TOP;\n\t  if (tx > smx1 && ty > smy0) return Directions.TOP;\n\t  if (tx >= smx0 && tx <= ax && ty > sy1) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx <= smx1 && tx >= ax && ty > sy1) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  return Directions.BOTTOM;\n\t}\n\tfunction resolveForBottomSourceSide(source, target, nextInLine) {\n\t  const {\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smx1 = sx1 + margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx === ax && ty > sy1) return Directions.TOP;\n\t  if (tx < ax && ty > smy1) {\n\t    if (nextInLine.point.x === ax) return Directions.TOP;\n\t    return Directions.RIGHT;\n\t  }\n\t  if (tx > ax && ty > smy1) {\n\t    if (nextInLine.point.x === ax) return Directions.TOP;\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n\t  if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n\t  if (tx >= smx0 && tx <= ax && ty < sy0) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  if (tx <= smx1 && tx >= ax && ty < sy0) {\n\t    if (nextInLine.point.x < tx) {\n\t      return Directions.RIGHT;\n\t    }\n\t    return Directions.LEFT;\n\t  }\n\t  return Directions.TOP;\n\t}\n\tfunction resolveForLeftSourceSide(source, target, nextInLine) {\n\t  const {\n\t    y0: sy0,\n\t    x0: sx0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx0 = sx0 - margin;\n\t  const smy0 = sy0 - margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax,\n\t    y: ay\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx < ax && ty === ay) return Directions.RIGHT;\n\t  if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n\t  if (tx <= smx0 && ty > ay) return Directions.TOP;\n\t  if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n\t  if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n\t  if (tx > sx1 && ty >= smy0 && ty <= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  if (tx > sx1 && ty <= smy1 && ty >= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  return Directions.RIGHT;\n\t}\n\tfunction resolveForRightSourceSide(source, target, nextInLine) {\n\t  const {\n\t    y0: sy0,\n\t    x0: sx0,\n\t    width,\n\t    height,\n\t    point: anchor,\n\t    margin\n\t  } = source;\n\t  const sx1 = sx0 + width;\n\t  const sy1 = sy0 + height;\n\t  const smx1 = sx1 + margin;\n\t  const smy0 = sy0 - margin;\n\t  const smy1 = sy1 + margin;\n\t  const {\n\t    x: ax,\n\t    y: ay\n\t  } = anchor;\n\t  const {\n\t    x0: tx,\n\t    y0: ty\n\t  } = target;\n\t  if (tx > ax && ty === ay) return Directions.LEFT;\n\t  if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n\t  if (tx >= smx1 && ty > ay) return Directions.TOP;\n\t  if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n\t  if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n\t  if (tx < sx0 && ty >= smy0 && ty <= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  if (tx < sx0 && ty <= smy1 && ty >= ay) {\n\t    if (nextInLine.point.y < ty) {\n\t      return Directions.BOTTOM;\n\t    }\n\t    return Directions.TOP;\n\t  }\n\t  return Directions.LEFT;\n\t}\n\tfunction resolveInitialDirection(source, target, nextInLine) {\n\t  const [sourceSide] = resolveSides(source, target);\n\t  switch (sourceSide) {\n\t    case Directions.TOP:\n\t      return resolveForTopSourceSide(source, target, nextInLine);\n\t    case Directions.RIGHT:\n\t      return resolveForRightSourceSide(source, target, nextInLine);\n\t    case Directions.BOTTOM:\n\t      return resolveForBottomSourceSide(source, target, nextInLine);\n\t    case Directions.LEFT:\n\t      return resolveForLeftSourceSide(source, target, nextInLine);\n\t  }\n\t}\n\tfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n\t  const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n\t  const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\t  if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n\t    return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t  } else if (linkOrigin.x === connectionPoint.x) {\n\t    return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t  }\n\t  switch (roundedAngle) {\n\t    case 0:\n\t    case 180:\n\t    case 360:\n\t      return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t    case 90:\n\t    case 270:\n\t      return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t  }\n\t}\n\tfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n\t  if (direction === Directions.AUTO) {\n\t    direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n\t  }\n\t  const isElement = view && view.model.isElement();\n\t  const {\n\t    x: x0,\n\t    y: y0,\n\t    width = 0,\n\t    height = 0\n\t  } = isElement ? Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\t  return {\n\t    point,\n\t    x0,\n\t    y0,\n\t    view,\n\t    bbox,\n\t    width,\n\t    height,\n\t    direction,\n\t    margin: isElement ? margin : 0\n\t  };\n\t}\n\tfunction pointDataFromVertex({\n\t  x,\n\t  y\n\t}) {\n\t  const point = new Point(x, y);\n\t  return {\n\t    point,\n\t    x0: point.x,\n\t    y0: point.y,\n\t    view: null,\n\t    bbox: new Rect(x, y, 0, 0),\n\t    width: 0,\n\t    height: 0,\n\t    direction: null,\n\t    margin: 0\n\t  };\n\t}\n\tfunction getOutsidePoint(side, pointData, margin) {\n\t  const outsidePoint = pointData.point.clone();\n\t  const {\n\t    x0,\n\t    y0,\n\t    width,\n\t    height\n\t  } = pointData;\n\t  switch (side) {\n\t    case 'left':\n\t      outsidePoint.x = x0 - margin;\n\t      break;\n\t    case 'right':\n\t      outsidePoint.x = x0 + width + margin;\n\t      break;\n\t    case 'top':\n\t      outsidePoint.y = y0 - margin;\n\t      break;\n\t    case 'bottom':\n\t      outsidePoint.y = y0 + height + margin;\n\t      break;\n\t  }\n\t  return outsidePoint;\n\t}\n\tfunction createLoop(from, to, {\n\t  dx = 0,\n\t  dy = 0\n\t}) {\n\t  const p1 = {\n\t    x: from.point.x + dx,\n\t    y: from.point.y + dy\n\t  };\n\t  const p2 = {\n\t    x: to.point.x + dx,\n\t    y: to.point.y + dy\n\t  };\n\t  return [from.point, p1, p2, to.point];\n\t}\n\tfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n\t  // Find out the loop coordinates.\n\t  const angle = normalizeAngle(connectionSegmentAngle - 90);\n\t  let dx = 0;\n\t  let dy = 0;\n\t  if (angle === 90) {\n\t    dy = -margin;\n\t  } else if (angle === 180) {\n\t    dx = -margin;\n\t  } else if (angle === 270) {\n\t    dy = margin;\n\t  } else if (angle === 0) {\n\t    dx = margin;\n\t  }\n\t  const loopRoute = createLoop(from, to, {\n\t    dx,\n\t    dy\n\t  });\n\t  const secondCreatedPoint = loopRoute[2];\n\t  const loopEndSegment = new Line(to.point, secondCreatedPoint);\n\t  // The direction in which the loop should continue.\n\t  const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\t  return {\n\t    loopRoute,\n\t    continueDirection\n\t  };\n\t}\n\n\t// Calculates the distances along the horizontal axis for the left and right route.\n\tfunction getHorizontalDistance(source, target) {\n\t  const {\n\t    x0: sx0,\n\t    x1: sx1,\n\t    outsidePoint: sourcePoint\n\t  } = source;\n\t  const {\n\t    x0: tx0,\n\t    x1: tx1,\n\t    outsidePoint: targetPoint\n\t  } = target;\n\n\t  // Furthest left boundary\n\t  let leftBoundary = Math.min(sx0, tx0);\n\t  // Furthest right boundary\n\t  let rightBoundary = Math.max(sx1, tx1);\n\n\t  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n\t  if (source.direction === target.direction) {\n\t    const aboveShape = source.y0 < target.y0 ? source : target;\n\t    const belowShape = aboveShape === source ? target : source;\n\n\t    // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n\t    // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n\t    const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\t    leftBoundary = boundaryDefiningShape.x0;\n\t    rightBoundary = boundaryDefiningShape.x1;\n\t  }\n\t  const {\n\t    x: sox\n\t  } = sourcePoint;\n\t  const {\n\t    x: tox\n\t  } = targetPoint;\n\n\t  // Calculate the distances for the left route\n\t  const leftDistance1 = Math.abs(sox - leftBoundary);\n\t  const leftDistance2 = Math.abs(tox - leftBoundary);\n\t  const leftD = leftDistance1 + leftDistance2;\n\n\t  // Calculate the distances for the right route\n\t  const rightDistance1 = Math.abs(sox - rightBoundary);\n\t  const rightDistance2 = Math.abs(tox - rightBoundary);\n\t  const rightD = rightDistance1 + rightDistance2;\n\t  return [leftD, rightD];\n\t}\n\n\t// Calculates the distances along the vertical axis for the top and bottom route.\n\tfunction getVerticalDistance(source, target) {\n\t  const {\n\t    y0: sy0,\n\t    y1: sy1,\n\t    outsidePoint: sourcePoint\n\t  } = source;\n\t  const {\n\t    y0: ty0,\n\t    y1: ty1,\n\t    outsidePoint: targetPoint\n\t  } = target;\n\n\t  // Furthest top boundary\n\t  let topBoundary = Math.min(sy0, ty0);\n\t  // Furthest bottom boundary\n\t  let bottomBoundary = Math.max(sy1, ty1);\n\n\t  // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n\t  if (source.direction === target.direction) {\n\t    const leftShape = source.x0 < target.x0 ? source : target;\n\t    const rightShape = leftShape === source ? target : source;\n\n\t    // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n\t    // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n\t    const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\t    topBoundary = boundaryDefiningShape.y0;\n\t    bottomBoundary = boundaryDefiningShape.y1;\n\t  }\n\t  const {\n\t    y: soy\n\t  } = sourcePoint;\n\t  const {\n\t    y: toy\n\t  } = targetPoint;\n\n\t  // Calculate the distances for the top route\n\t  const topDistance1 = Math.abs(soy - topBoundary);\n\t  const topDistance2 = Math.abs(toy - topBoundary);\n\t  const topD = topDistance1 + topDistance2;\n\n\t  // Calculate the distances for the bottom route\n\t  const bottomDistance1 = Math.abs(soy - bottomBoundary);\n\t  const bottomDistance2 = Math.abs(toy - bottomBoundary);\n\t  const bottomD = bottomDistance1 + bottomDistance2;\n\t  return [topD, bottomD];\n\t}\n\n\t// Inflate bbox in 3 directions depending on the direction of the anchor\n\t// don't inflate in the opposite direction of the anchor\n\tfunction moveAndExpandBBox(bbox, direction, margin) {\n\t  switch (direction) {\n\t    case Directions.LEFT:\n\t      bbox.inflate(0, margin).moveAndExpand({\n\t        x: -margin,\n\t        width: margin\n\t      });\n\t      break;\n\t    case Directions.RIGHT:\n\t      bbox.inflate(0, margin).moveAndExpand({\n\t        width: margin\n\t      });\n\t      break;\n\t    case Directions.TOP:\n\t      bbox.inflate(margin, 0).moveAndExpand({\n\t        y: -margin,\n\t        height: margin\n\t      });\n\t      break;\n\t    case Directions.BOTTOM:\n\t      bbox.inflate(margin, 0).moveAndExpand({\n\t        height: margin\n\t      });\n\t      break;\n\t  }\n\t  return bbox;\n\t}\n\tfunction routeBetweenPoints(source, target, opt = {}) {\n\t  const {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width: sourceWidth,\n\t    height: sourceHeight,\n\t    margin: sourceMargin\n\t  } = source;\n\t  const {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    width: targetWidth,\n\t    height: targetHeight,\n\t    margin: targetMargin\n\t  } = target;\n\t  const {\n\t    targetInSourceBBox = false\n\t  } = opt;\n\t  const tx1 = tx0 + targetWidth;\n\t  const ty1 = ty0 + targetHeight;\n\t  const sx1 = sx0 + sourceWidth;\n\t  const sy1 = sy0 + sourceHeight;\n\n\t  // Key coordinates including the margin\n\t  const smx0 = sx0 - sourceMargin;\n\t  const smx1 = sx1 + sourceMargin;\n\t  const smy0 = sy0 - sourceMargin;\n\t  const smy1 = sy1 + sourceMargin;\n\t  const tmx0 = tx0 - targetMargin;\n\t  const tmx1 = tx1 + targetMargin;\n\t  const tmy0 = ty0 - targetMargin;\n\t  const tmy1 = ty1 + targetMargin;\n\t  const [sourceSide, targetSide] = resolveSides(source, target);\n\t  const sourceOutsidePoint = getOutsidePoint(sourceSide, {\n\t    point: sourcePoint,\n\t    x0: sx0,\n\t    y0: sy0,\n\t    width: sourceWidth,\n\t    height: sourceHeight\n\t  }, sourceMargin);\n\t  const targetOutsidePoint = getOutsidePoint(targetSide, {\n\t    point: targetPoint,\n\t    x0: tx0,\n\t    y0: ty0,\n\t    width: targetWidth,\n\t    height: targetHeight\n\t  }, targetMargin);\n\t  const {\n\t    x: sox,\n\t    y: soy\n\t  } = sourceOutsidePoint;\n\t  const {\n\t    x: tox,\n\t    y: toy\n\t  } = targetOutsidePoint;\n\t  const tcx = (tx0 + tx1) / 2;\n\t  const tcy = (ty0 + ty1) / 2;\n\t  const scx = (sx0 + sx1) / 2;\n\t  const scy = (sy0 + sy1) / 2;\n\t  const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n\t  const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n\t  const sourceBBox = new Rect(sx0, sy0, sourceWidth, sourceHeight);\n\t  const targetBBox = new Rect(tx0, ty0, targetWidth, targetHeight);\n\t  const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n\t  const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\t  const sourceForDistance = Object.assign({}, source, {\n\t    x1: sx1,\n\t    y1: sy1,\n\t    outsidePoint: sourceOutsidePoint,\n\t    direction: sourceSide\n\t  });\n\t  const targetForDistance = Object.assign({}, target, {\n\t    x1: tx1,\n\t    y1: ty1,\n\t    outsidePoint: targetOutsidePoint,\n\t    direction: targetSide\n\t  });\n\n\t  // Distances used to determine the shortest route along the connections on horizontal sides for\n\t  // bottom => bottom\n\t  // top => bottom\n\t  // bottom => top\n\t  // top => top\n\t  const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n\t  // Distances used to determine the shortest route along the connection on vertical sides for\n\t  // left => left\n\t  // left => right\n\t  // right => right\n\t  // right => left\n\t  const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n\t  // All possible combinations of source and target sides\n\t  if (sourceSide === 'left' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (soy + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smx0 < tox) {\n\t      let y = middleOfHorizontalSides;\n\t      let x1 = sox;\n\t      let x2 = tox;\n\t      const isUpwardsShorter = topD < bottomD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {\n\t        if (smy1 >= tmy0 && isUpwardsShorter) {\n\t          y = Math.min(tmy0, smy0);\n\t        } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n\t          y = Math.max(tmy1, smy1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        x1 = Math.min(sox, tmx0);\n\t        x2 = Math.max(tox, smx1);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {\n\t          // the path should no longer rely on minimal x boundary in `x1`\n\t          x1 = sox;\n\t        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {\n\t          // the path should no longer rely on maximal x boundary in `x2`\n\t          x2 = tox;\n\t        }\n\t      }\n\t      return [{\n\t        x: x1,\n\t        y: soy\n\t      }, {\n\t        x: x1,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = (sox + tox) / 2;\n\t    return [{\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (soy + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: middleOfAnchors\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smx1 > tox) {\n\t      let y = middleOfHorizontalSides;\n\t      let x1 = sox;\n\t      let x2 = tox;\n\t      const isUpwardsShorter = topD < bottomD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {\n\t        if (smy1 >= tmy0 && isUpwardsShorter) {\n\t          y = Math.min(tmy0, smy0);\n\t        } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n\t          y = Math.max(tmy1, smy1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        x1 = Math.max(sox, tmx1);\n\t        x2 = Math.min(tox, smx0);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {\n\t          // the path should no longer rely on maximal x boundary in `x1`\n\t          x1 = sox;\n\t        } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {\n\t          // the path should no longer rely on minimal x boundary in `x2`\n\t          x2 = tox;\n\t        }\n\t      }\n\t      return [{\n\t        x: x1,\n\t        y: soy\n\t      }, {\n\t        x: x1,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y\n\t      }, {\n\t        x: x2,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = (sox + tox) / 2;\n\t    return [{\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (sox + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: toy\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 < toy) {\n\t      let x = middleOfVerticalSides;\n\t      let y1 = soy;\n\t      let y2 = toy;\n\t      const isLeftShorter = leftD < rightD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {\n\t        if (smx1 >= tmx0 && isLeftShorter) {\n\t          x = Math.min(tmx0, smx0);\n\t        } else if (smx0 <= tmx1 && !isLeftShorter) {\n\t          x = Math.max(tmx1, smx1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        y1 = Math.min(soy, tmy0);\n\t        y2 = Math.max(toy, smy1);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {\n\t          // the path should no longer rely on minimal y boundary in `y1`\n\t          y1 = soy;\n\t        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {\n\t          // the path should no longer rely on maximal y boundary in `y2`\n\t          y2 = toy;\n\t        }\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y2\n\t      }, {\n\t        x: tox,\n\t        y: y2\n\t      }];\n\t    }\n\t    const y = (soy + toy) / 2;\n\t    return [{\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n\t    const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n\t    // Use S-shaped connection\n\t    if (isPointInsideSource || isPointInsideTarget) {\n\t      const middleOfAnchors = (sox + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: soy\n\t      }, {\n\t        x: middleOfAnchors,\n\t        y: toy\n\t      }, {\n\t        x: tox,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 > toy) {\n\t      let x = middleOfVerticalSides;\n\t      let y1 = soy;\n\t      let y2 = toy;\n\t      const isLeftShorter = leftD < rightD;\n\n\t      // If the source and target elements overlap, we need to make sure the connection\n\t      // goes around the target element.\n\t      if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {\n\t        if (smx1 >= tmx0 && isLeftShorter) {\n\t          x = Math.min(tmx0, smx0);\n\t        } else if (smx0 <= tmx1 && !isLeftShorter) {\n\t          x = Math.max(tmx1, smx1);\n\t        }\n\n\t        // This handles the case when the source and target elements overlap as well as\n\t        // the case when the source is to the left of the target element.\n\t        y1 = Math.max(soy, tmy1);\n\t        y2 = Math.min(toy, smy0);\n\n\t        // This is an edge case when the source and target intersect and\n\t        if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {\n\t          // the path should no longer rely on maximal y boundary in `y1`\n\t          y1 = soy;\n\t        } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {\n\t          // the path should no longer rely on minimal y boundary in `y2`\n\t          y2 = toy;\n\t        }\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y1\n\t      }, {\n\t        x,\n\t        y: y2\n\t      }, {\n\t        x: tox,\n\t        y: y2\n\t      }];\n\t    }\n\t    const y = (soy + toy) / 2;\n\t    return [{\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'top') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);\n\n\t    // U-shape connection is a straight line if `sox` and `tox` are the same\n\t    if (useUShapeConnection && sox !== tox) {\n\t      return [{\n\t        x: sox,\n\t        y: Math.min(soy, toy)\n\t      }, {\n\t        x: tox,\n\t        y: Math.min(soy, toy)\n\t      }];\n\t    }\n\t    let x;\n\t    let y1 = Math.min((sy1 + ty0) / 2, toy);\n\t    let y2 = Math.min((sy0 + ty1) / 2, soy);\n\t    if (toy < soy) {\n\t      // Use the shortest path along the connections on horizontal sides\n\t      if (rightD > leftD) {\n\t        x = Math.min(sox, tmx0);\n\t      } else {\n\t        x = Math.max(sox, tmx1);\n\t      }\n\t    } else {\n\t      if (rightD > leftD) {\n\t        x = Math.min(tox, smx0);\n\t      } else {\n\t        x = Math.max(tox, smx1);\n\t      }\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y1\n\t    }, {\n\t      x: tox,\n\t      y: y1\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);\n\n\t    // U-shape connection is a straight line if `sox` and `tox` are the same\n\t    if (useUShapeConnection && sox !== tox) {\n\t      return [{\n\t        x: sox,\n\t        y: Math.max(soy, toy)\n\t      }, {\n\t        x: tox,\n\t        y: Math.max(soy, toy)\n\t      }];\n\t    }\n\t    let x;\n\t    let y1 = Math.max((sy0 + ty1) / 2, toy);\n\t    let y2 = Math.max((sy1 + ty0) / 2, soy);\n\t    if (toy > soy) {\n\t      // Use the shortest path along the connections on horizontal sides\n\t      if (rightD > leftD) {\n\t        x = Math.min(sox, tmx0);\n\t      } else {\n\t        x = Math.max(sox, tmx1);\n\t      }\n\t    } else {\n\t      if (rightD > leftD) {\n\t        x = Math.min(tox, smx0);\n\t      } else {\n\t        x = Math.max(tox, smx1);\n\t      }\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y2\n\t    }, {\n\t      x,\n\t      y: y1\n\t    }, {\n\t      x: tox,\n\t      y: y1\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'left') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);\n\n\t    // U-shape connection is a straight line if `soy` and `toy` are the same\n\t    if (useUShapeConnection && soy !== toy) {\n\t      return [{\n\t        x: Math.min(sox, tox),\n\t        y: soy\n\t      }, {\n\t        x: Math.min(sox, tox),\n\t        y: toy\n\t      }];\n\t    }\n\t    let y;\n\t    let x1 = Math.min((sx1 + tx0) / 2, tox);\n\t    let x2 = Math.min((sx0 + tx1) / 2, sox);\n\t    if (tox > sox) {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(smy0, toy);\n\t      } else {\n\t        y = Math.max(smy1, toy);\n\t      }\n\t    } else {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(tmy0, soy);\n\t      } else {\n\t        y = Math.max(tmy1, soy);\n\t      }\n\t    }\n\t    return [{\n\t      x: x2,\n\t      y: soy\n\t    }, {\n\t      x: x2,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'right') {\n\t    const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);\n\n\t    // U-shape connection is a straight line if `soy` and `toy` are the same\n\t    if (useUShapeConnection && soy !== toy) {\n\t      return [{\n\t        x: Math.max(sox, tox),\n\t        y: soy\n\t      }, {\n\t        x: Math.max(sox, tox),\n\t        y: toy\n\t      }];\n\t    }\n\t    let y;\n\t    let x1 = Math.max((sx0 + tx1) / 2, tox);\n\t    let x2 = Math.max((sx1 + tx0) / 2, sox);\n\t    if (tox <= sox) {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(smy0, toy);\n\t      } else {\n\t        y = Math.max(smy1, toy);\n\t      }\n\t    } else {\n\t      if (topD <= bottomD) {\n\t        y = Math.min(tmy0, soy);\n\t      } else {\n\t        y = Math.max(tmy1, soy);\n\t      }\n\t    }\n\t    return [{\n\t      x: x2,\n\t      y: soy\n\t    }, {\n\t      x: x2,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y\n\t    }, {\n\t      x: x1,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox <= tmx1) {\n\t        const x = Math.max(sox + sourceMargin, tox);\n\t        const y = Math.min(smy0, tmy0);\n\n\t        // Target anchor is on the right side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the left side of the source anchor\n\t      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n\t      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 > toy) {\n\t      if (sox < tox) {\n\t        let y = tmy0;\n\t        if (tmy1 <= smy0 && tmx1 >= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.max(middleOfVerticalSides, tmx1);\n\t    if (sox > tox && sy1 >= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x > smx0 && soy < ty1) {\n\t      const y = Math.min(smy0, tmy0);\n\t      const x = Math.max(smx1, tmx1);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'top' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox >= tmx0) {\n\t        const x = Math.min(sox - sourceMargin, tox);\n\t        const y = Math.min(smy0, tmy0);\n\n\t        // Target anchor is on the left side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y\n\t        }, {\n\t          x: x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the right side of the source anchor\n\t      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n\t      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy0 > toy) {\n\t      if (sox > tox) {\n\t        let y = tmy0;\n\t        if (tmy1 <= smy0 && tmx0 <= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.min(tmx0, middleOfVerticalSides);\n\t    if (sox < tox && sy1 >= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x < smx1 && soy < ty1) {\n\t      const y = Math.min(smy0, tmy0);\n\t      const x = Math.min(smx0, tmx0);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'right') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox <= tmx1) {\n\t        const x = Math.max(sox + sourceMargin, tox);\n\t        const y = Math.max(smy1, tmy1);\n\n\t        // Target anchor is on the right side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the left side of the source anchor\n\t      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n\t      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 < toy) {\n\t      if (sox < tox) {\n\t        let y = tmy1;\n\t        if (tmy0 >= smy1 && tmx1 >= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.max(middleOfVerticalSides, tmx1);\n\t    if (sox > tox && sy0 <= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x > smx0 && soy > ty0) {\n\t      const y = Math.max(smy1, tmy1);\n\t      const x = Math.max(smx1, tmx1);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'bottom' && targetSide === 'left') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (sox >= tmx0) {\n\t        const x = Math.min(sox - sourceMargin, tox);\n\t        const y = Math.max(smy1, tmy1);\n\n\t        // Target anchor is on the left side of the source anchor\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }];\n\t      }\n\n\t      // Target anchor is on the right side of the source anchor\n\t      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n\t      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: soy\n\t      }, {\n\t        x: anchorMiddleX,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (smy1 < toy) {\n\t      if (sox > tox) {\n\t        let y = tmy1;\n\t        if (tmy0 >= smy1 && tmx0 <= sox) {\n\t          y = middleOfHorizontalSides;\n\t        }\n\t        return [{\n\t          x: sox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: sox,\n\t        y: toy\n\t      }];\n\t    }\n\t    const x = Math.min(tmx0, middleOfVerticalSides);\n\t    if (sox < tox && sy0 <= toy) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    if (x < smx1 && soy > ty0) {\n\t      const y = Math.max(smy1, tmy1);\n\t      const x = Math.min(smx0, tmx0);\n\t      return [{\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x,\n\t        y: toy\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: soy\n\t    }, {\n\t      x,\n\t      y: toy\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy <= tmy1) {\n\t        const x = Math.min(smx0, tmx0);\n\t        const y = Math.max(soy + sourceMargin, toy);\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is above the source anchor\n\t      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx0 > tox) {\n\t      if (soy < toy) {\n\t        let x = tmx0;\n\t        if (tmx1 <= smx0 && tmy1 >= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.max(tmy1, middleOfHorizontalSides);\n\t    if (soy > toy && sx1 >= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y > smy0 && sox < tx1) {\n\t      const x = Math.min(smx0, tmx0);\n\t      const y = Math.max(smy1, tmy1);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'left' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy >= tmy0) {\n\t        const y = Math.min(soy - sourceMargin, toy);\n\t        const x = Math.min(smx0, tmx0);\n\n\t        // Target anchor is on the top side of the source anchor\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is below the source anchor\n\t      // Add the `sourceMargin` since the source anchor is above the target anchor\n\t      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx0 > tox) {\n\t      if (soy > toy) {\n\t        let x = tmx0;\n\t        if (tmx1 <= smx0 && tmy0 <= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.min(tmy0, middleOfHorizontalSides);\n\t    if (soy < toy && sx1 >= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y < smy1 && sox < tx1) {\n\t      const x = Math.min(smx0, tmx0);\n\t      const y = Math.min(smy0, tmy0);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'top') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy >= tmy0) {\n\t        const x = Math.max(smx1, tmx1);\n\t        const y = Math.min(soy - sourceMargin, toy);\n\n\t        // Target anchor is on the top side of the source anchor\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        },\n\t        // Path adjustment for right side start\n\t        {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is below the source anchor\n\t      // Adjust sourceMargin calculation since the source anchor is now on the right\n\t      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx1 < tox) {\n\t      if (soy > toy) {\n\t        let x = tmx1;\n\t        if (tmx0 >= smx1 && tmy0 <= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.min(tmy0, middleOfHorizontalSides);\n\t    if (soy < toy && sx0 <= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y < smy1 && sox > tx0) {\n\t      const x = Math.max(smx1, tmx1);\n\t      const y = Math.min(smy0, tmy0);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  } else if (sourceSide === 'right' && targetSide === 'bottom') {\n\t    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n\t    // The target point is inside the source element\n\t    if (isPointInsideSource) {\n\t      if (soy <= tmy1) {\n\t        const x = Math.max(smx1, tmx1);\n\t        const y = Math.max(soy + sourceMargin, toy);\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y\n\t        }, {\n\t          x: tox,\n\t          y\n\t        }];\n\t      }\n\n\t      // Target anchor is above the source anchor\n\t      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y: anchorMiddleY\n\t      }, {\n\t        x: tox,\n\t        y: anchorMiddleY\n\t      }];\n\t    }\n\t    if (smx1 < tox) {\n\t      if (soy < toy) {\n\t        let x = tmx1;\n\t        if (tmx0 >= smx1 && tmy1 >= soy) {\n\t          x = middleOfVerticalSides;\n\t        }\n\t        return [{\n\t          x,\n\t          y: soy\n\t        }, {\n\t          x,\n\t          y: toy\n\t        }, {\n\t          x: tox,\n\t          y: toy\n\t        }];\n\t      }\n\t      return [{\n\t        x: tox,\n\t        y: soy\n\t      }];\n\t    }\n\t    const y = Math.max(tmy1, middleOfHorizontalSides);\n\t    if (soy > toy && sx0 <= tox) {\n\t      return [{\n\t        x: sox,\n\t        y: soy\n\t      }, {\n\t        x: sox,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    if (y > smy0 && sox > tx0) {\n\t      const x = Math.max(smx1, tmx1);\n\t      const y = Math.max(smy1, tmy1);\n\t      return [{\n\t        x,\n\t        y: soy\n\t      }, {\n\t        x,\n\t        y\n\t      }, {\n\t        x: tox,\n\t        y\n\t      }];\n\t    }\n\t    return [{\n\t      x: sox,\n\t      y: soy\n\t    }, {\n\t      x: sox,\n\t      y\n\t    }, {\n\t      x: tox,\n\t      y\n\t    }];\n\t  }\n\t}\n\tfunction getLoopCoordinates(direction, angle, margin) {\n\t  const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\t  let dx = 0;\n\t  let dy = 0;\n\t  switch (normalizeAngle(Math.round(angle))) {\n\t    case 0:\n\t    case 90:\n\t      dx = isHorizontal ? 0 : margin;\n\t      dy = isHorizontal ? margin : 0;\n\t      break;\n\t    case 180:\n\t    case 270:\n\t      dx = isHorizontal ? 0 : -margin;\n\t      dy = isHorizontal ? -margin : 0;\n\t      break;\n\t  }\n\t  return {\n\t    dx,\n\t    dy\n\t  };\n\t}\n\tfunction rightAngleRouter(vertices, opt, linkView) {\n\t  const {\n\t    sourceDirection = Directions.AUTO,\n\t    targetDirection = Directions.AUTO\n\t  } = opt;\n\t  const margin = opt.margin || 20;\n\t  const useVertices = opt.useVertices || false;\n\t  const isSourcePort = !!linkView.model.source().port;\n\t  const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\t  const isTargetPort = !!linkView.model.target().port;\n\t  const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\t  let resultVertices = [];\n\t  if (!useVertices || vertices.length === 0) {\n\t    return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n\t  }\n\t  const verticesData = vertices.map(v => pointDataFromVertex(v));\n\t  const [firstVertex] = verticesData;\n\t  const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n\t  const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n\t  const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n\t  const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\t  if (isVertexInside) {\n\t    const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n\t    const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\t    const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n\t    const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\t    const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n\t    const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\t    const firstSegment = new Line(sourcePoint.point, outsidePoint);\n\t    const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\t    const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\t    if (firstPointOverlap) {\n\t      resultVertices.push(sourcePoint.point, firstVertex.point);\n\t      // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n\t      firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n\t    } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n\t      // Case where there is a need to create a loop\n\t      const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new Line(sourcePoint.point, firstVertex.point));\n\t      const {\n\t        dx,\n\t        dy\n\t      } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\t      const loop = createLoop({\n\t        point: outsidePoint\n\t      }, firstVertex, {\n\t        dx,\n\t        dy\n\t      });\n\t      const secondCreatedPoint = loop[2];\n\t      const loopEndSegment = new Line(firstVertex.point, secondCreatedPoint);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\t      firstVertex.direction = accessDirection;\n\t      resultVertices.push(...loop);\n\t    } else {\n\t      // No need to create a route, use the `routeBetweenPoints` to construct a route\n\t      firstVertex.direction = resolvedSourceDirection;\n\t      firstVertex.margin = margin;\n\t      resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, {\n\t        targetInSourceBBox: true\n\t      }), firstVertex.point);\n\t    }\n\t  } else {\n\t    // The first point responsible for the initial direction of the route\n\t    const next = verticesData[1] || targetPoint;\n\t    const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n\t    firstVertex.direction = direction;\n\t    resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n\t  }\n\t  for (let i = 0; i < verticesData.length - 1; i++) {\n\t    const from = verticesData[i];\n\t    const to = verticesData[i + 1];\n\t    const connectionSegment = new Line(from.point, to.point);\n\t    const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n\t    if (connectionSegmentAngle % 90 === 0) {\n\t      // Segment is horizontal or vertical\n\t      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\t      const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n\t      // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n\t      // Find out the direction that is used to connect the current route with the next vertex\n\t      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n\t      // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\t      // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n\t      // console.log(accessDirection);\n\t      // console.log(accessDirection2);\n\t      // if (accessDirection !== accessDirection2) {\n\t      //     console.log('error');\n\t      // }\n\t      // console.log('------------------');\n\n\t      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n\t        // The directions are not opposite, so we can connect the vertices directly\n\t        resultVertices.push(from.point, to.point);\n\t        const [, toDirection] = resolveSides(from, to);\n\t        to.direction = toDirection;\n\t      } else {\n\t        // The directions are overlapping, so we need to create a loop\n\t        const {\n\t          loopRoute,\n\t          continueDirection\n\t        } = loopSegment(from, to, connectionSegmentAngle, margin);\n\t        to.direction = continueDirection;\n\t        // Constructing a loop\n\t        resultVertices.push(...loopRoute);\n\t      }\n\t      continue;\n\t    }\n\n\t    // Vertices are not aligned vertically nor horizontally\n\t    // so we need to route between them\n\n\t    const [fromDirection, toDirection] = resolveDirection(from, to);\n\t    from.direction = fromDirection;\n\t    to.direction = toDirection;\n\t    resultVertices.push(...routeBetweenPoints(from, to), to.point);\n\t  }\n\t  const lastVertex = verticesData[verticesData.length - 1];\n\t  if (targetPoint.view && targetPoint.view.model.isElement()) {\n\t    const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n\t    const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n\t    // the last point of `simplified` array is the last defined vertex\n\t    // this will ensure that the last segment continues in a straight line\n\t    const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n\t    const simplifiedSegment = new Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n\t    const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n\t    const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\t    const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\t    if (!lastPointOverlap || lastPointOverlap && definedDirection === resolvedTargetDirection) {\n\t      lastVertex.direction = definedDirection;\n\t      let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\t      const lastSegment = new Line(p1, p2);\n\t      const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n\t      const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\t      const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\t      const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n\t      const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n\t      const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\t      const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n\t      const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\t      if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n\t        // Handle special cases when the last vertex is inside the target element\n\t        // and in is aligned with the connection point => construct a loop\n\t        const {\n\t          dx,\n\t          dy\n\t        } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n\t        lastSegmentRoute = createLoop(lastVertex, {\n\t          point: outsidePoint\n\t        }, {\n\t          dx,\n\t          dy\n\t        });\n\t      } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n\t        lastVertex.margin = margin;\n\t        lastVertex.direction = resolvedTargetDirection;\n\t        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n\t        lastVertex.margin = margin;\n\t        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n\t      }\n\t      resultVertices.push(...lastSegmentRoute);\n\t    }\n\t  } else {\n\t    // since the target is only a point we can apply the same logic as if we connected two verticesData\n\t    const from = lastVertex;\n\t    const to = targetPoint;\n\t    const connectionSegment = new Line(from.point, to.point);\n\t    const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n\t    if (connectionSegmentAngle % 90 === 0) {\n\t      // Segment is horizontal or vertical\n\t      const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\t      const simplifiedRoute = simplifyPoints(resultVertices);\n\t      // Find out the direction that is used to connect the current route with the next vertex\n\t      const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n\t      const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\t      if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n\t        // The directions are not opposite, so we can connect the vertices directly by adding the first point\n\t        // the target point is handled separately\n\t        resultVertices.push(from.point);\n\t      } else {\n\t        // The directions are overlapping, so we need to create a loop\n\t        const {\n\t          loopRoute\n\t        } = loopSegment(from, to, connectionSegmentAngle, margin);\n\t        // Remove the last point since it is the target that is handled separately\n\t        loopRoute.pop();\n\t        // Constructing a loop\n\t        resultVertices.push(...loopRoute);\n\t      }\n\t    } else {\n\t      // The last vertex and the target are not aligned vertically nor horizontally\n\t      // so we need to route between them\n\t      const [fromDirection, toDirection] = resolveDirection(from, to);\n\t      from.direction = fromDirection;\n\t      to.direction = toDirection;\n\t      resultVertices.push(...routeBetweenPoints(from, to));\n\t    }\n\t  }\n\t  return simplifyPoints(resultVertices);\n\t}\n\tfunction resolveDirection(from, to) {\n\t  const accessDirection = from.direction;\n\t  const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\t  let sourceDirection = from.direction;\n\t  let targetDirection = to.direction;\n\t  if (isDirectionVertical) {\n\t    const isToAbove = from.point.y > to.point.y;\n\t    const dx = to.point.x - from.point.x;\n\t    if (accessDirection === Directions.BOTTOM) {\n\t      // If isToAbove === false and we need figure out if to go left or right\n\t      sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\t      if (dx > 0) {\n\t        targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n\t      } else if (dx < 0) {\n\t        targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n\t      }\n\t    } else {\n\t      // If isToAbove === true and we need figure out if to go left or right\n\t      sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\t      if (dx > 0) {\n\t        targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n\t      } else if (dx < 0) {\n\t        targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n\t      }\n\t    }\n\t  } else {\n\t    const isToLeft = from.point.x > to.point.x;\n\t    const dy = to.point.y - from.point.y;\n\t    if (accessDirection === Directions.RIGHT) {\n\t      sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\t      if (dy > 0) {\n\t        targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n\t      } else if (dy < 0) {\n\t        targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n\t      }\n\t    } else {\n\t      sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\t      if (dy > 0) {\n\t        targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n\t      } else if (dy < 0) {\n\t        targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n\t      }\n\t    }\n\t  }\n\t  return [sourceDirection, targetDirection];\n\t}\n\trightAngleRouter.Directions = Directions;\n\tconst rightAngle = rightAngleRouter;\n\n\tvar routers = {\n\t\t__proto__: null,\n\t\tmanhattan: manhattan,\n\t\tmetro: metro,\n\t\tnormal: normal,\n\t\toneSide: oneSide,\n\t\torthogonal: orthogonal,\n\t\trightAngle: rightAngle\n\t};\n\n\tfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\t  var ratio = 'ratio' in opt ? opt.ratio : 0.5;\n\t  return view.getPointAtRatio(ratio);\n\t}\n\tfunction connectionLength(view, _magnet, _refPoint, opt) {\n\t  var length = 'length' in opt ? opt.length : 20;\n\t  return view.getPointAtLength(length);\n\t}\n\tfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\t  var OFFSET = 1e6;\n\t  var path = view.getConnection();\n\t  var segmentSubdivisions = view.getConnectionSubdivisions();\n\t  var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n\t  var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n\t  var verticalIntersections = verticalLine.intersect(path, {\n\t    segmentSubdivisions: segmentSubdivisions\n\t  });\n\t  var horizontalIntersections = horizontalLine.intersect(path, {\n\t    segmentSubdivisions: segmentSubdivisions\n\t  });\n\t  var intersections = [];\n\t  if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n\t  if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n\t  if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n\t  if ('fallbackAt' in opt) {\n\t    return getPointAtLink(view, opt.fallbackAt);\n\t  }\n\t  return connectionClosest(view, _magnet, refPoint, opt);\n\t}\n\tfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\t  var closestPoint = view.getClosestPoint(refPoint);\n\t  if (!closestPoint) return new Point();\n\t  return closestPoint;\n\t}\n\tfunction resolveRef(fn) {\n\t  return function (view, magnet, ref, opt, endType, linkView) {\n\t    if (ref instanceof Element) {\n\t      var refView = this.paper.findView(ref);\n\t      var refPoint;\n\t      if (refView) {\n\t        if (refView.isNodeConnection(ref)) {\n\t          var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';\n\t          refPoint = getPointAtLink(refView, distance);\n\t        } else {\n\t          refPoint = refView.getNodeBBox(ref).center();\n\t        }\n\t      } else {\n\t        // Something went wrong\n\t        refPoint = new Point();\n\t      }\n\t      return fn.call(this, view, magnet, refPoint, opt, endType, linkView);\n\t    }\n\t    return fn.apply(this, arguments);\n\t  };\n\t}\n\tfunction getPointAtLink(view, value) {\n\t  var parsedValue = parseFloat(value);\n\t  if (isPercentage(value)) {\n\t    return view.getPointAtRatio(parsedValue / 100);\n\t  } else {\n\t    return view.getPointAtLength(parsedValue);\n\t  }\n\t}\n\tconst connectionPerpendicular = resolveRef(_connectionPerpendicular);\n\tconst connectionClosest = resolveRef(_connectionClosest);\n\n\tvar linkAnchors = {\n\t\t__proto__: null,\n\t\tconnectionClosest: connectionClosest,\n\t\tconnectionLength: connectionLength,\n\t\tconnectionPerpendicular: connectionPerpendicular,\n\t\tconnectionRatio: connectionRatio,\n\t\tresolveRef: resolveRef\n\t};\n\n\tconst Side = {\n\t  LEFT: 'left',\n\t  RIGHT: 'right',\n\t  TOP: 'top',\n\t  BOTTOM: 'bottom'\n\t};\n\tconst SideMode = {\n\t  PREFER_HORIZONTAL: 'prefer-horizontal',\n\t  PREFER_VERTICAL: 'prefer-vertical',\n\t  HORIZONTAL: 'horizontal',\n\t  VERTICAL: 'vertical',\n\t  AUTO: 'auto'\n\t};\n\tfunction getModelBBoxFromConnectedLink(element, link, endType, rotate) {\n\t  const portId = link.get(endType).port;\n\t  if (element.hasPort(portId)) {\n\t    return element.getPortBBox(portId, {\n\t      rotate\n\t    });\n\t  }\n\t  return element.getBBox({\n\t    rotate\n\t  });\n\t}\n\tfunction getMiddleSide(rect, point, opt) {\n\t  const {\n\t    preferenceThreshold = 0,\n\t    mode\n\t  } = opt;\n\t  const {\n\t    x,\n\t    y\n\t  } = point;\n\t  const {\n\t    x: left,\n\t    y: top,\n\t    width,\n\t    height\n\t  } = rect;\n\t  switch (mode) {\n\t    case SideMode.PREFER_VERTICAL:\n\t      {\n\t        const {\n\t          top: topThreshold,\n\t          bottom: bottomThreshold\n\t        } = normalizeSides(preferenceThreshold);\n\t        const bottom = top + height;\n\t        if (y > top - topThreshold && y < bottom + bottomThreshold) {\n\t          const cx = left + width / 2;\n\t          return x < cx ? Side.LEFT : Side.RIGHT;\n\t        }\n\t      }\n\t    // eslint-disable-next-line no-fallthrough\n\t    case SideMode.VERTICAL:\n\t      {\n\t        const cy = top + height / 2;\n\t        return y < cy ? Side.TOP : Side.BOTTOM;\n\t      }\n\t    case SideMode.PREFER_HORIZONTAL:\n\t      {\n\t        const {\n\t          left: leftThreshold,\n\t          right: rightThreshold\n\t        } = normalizeSides(preferenceThreshold);\n\t        const right = left + width;\n\t        if (x > left - leftThreshold && x < right + rightThreshold) {\n\t          const cy = top + height / 2;\n\t          return y < cy ? Side.TOP : Side.BOTTOM;\n\t        }\n\t      }\n\t    // eslint-disable-next-line no-fallthrough\n\t    case SideMode.HORIZONTAL:\n\t      {\n\t        const cx = left + width / 2;\n\t        return x < cx ? Side.LEFT : Side.RIGHT;\n\t      }\n\t    case SideMode.AUTO:\n\t    default:\n\t      {\n\t        return rect.sideNearestToPoint(point);\n\t      }\n\t  }\n\t}\n\tfunction bboxWrapper(method) {\n\t  return function (elementView, magnet, ref, opt, endType, linkView) {\n\t    const rotate = !!opt.rotate;\n\t    const element = elementView.model;\n\t    const link = linkView.model;\n\t    const angle = element.angle();\n\t    let bbox, center;\n\t    if (opt.useModelGeometry) {\n\t      bbox = getModelBBoxFromConnectedLink(element, link, endType, !rotate);\n\t      center = bbox.center();\n\t    } else {\n\t      center = element.getCenter();\n\t      bbox = rotate ? elementView.getNodeUnrotatedBBox(magnet) : elementView.getNodeBBox(magnet);\n\t    }\n\t    const anchor = bbox[method]();\n\t    let dx = opt.dx;\n\t    if (dx) {\n\t      const isDxPercentage = isPercentage(dx);\n\t      if (!isDxPercentage && isCalcExpression(dx)) {\n\t        // calc expression\n\t        dx = Number(evalCalcExpression(dx, bbox));\n\t      } else {\n\t        // percentage or a number\n\t        dx = parseFloat(dx);\n\t      }\n\t      if (isFinite(dx)) {\n\t        if (isDxPercentage) {\n\t          dx /= 100;\n\t          dx *= bbox.width;\n\t        }\n\t        anchor.x += dx;\n\t      }\n\t    }\n\t    let dy = opt.dy;\n\t    if (dy) {\n\t      const isDyPercentage = isPercentage(dy);\n\t      if (!isDyPercentage && isCalcExpression(dy)) {\n\t        // calc expression\n\t        dy = Number(evalCalcExpression(dy, bbox));\n\t      } else {\n\t        // percentage or a number\n\t        dy = parseFloat(dy);\n\t      }\n\t      if (isFinite(dy)) {\n\t        if (isDyPercentage) {\n\t          dy /= 100;\n\t          dy *= bbox.height;\n\t        }\n\t        anchor.y += dy;\n\t      }\n\t    }\n\t    return rotate ? anchor.rotate(center, -angle) : anchor;\n\t  };\n\t}\n\tfunction _perpendicular(elementView, magnet, refPoint, opt, endType, linkView) {\n\t  const element = elementView.model;\n\t  const angle = element.angle();\n\t  let bbox;\n\t  if (opt.useModelGeometry) {\n\t    bbox = getModelBBoxFromConnectedLink(element, linkView.model, endType, true);\n\t  } else {\n\t    bbox = elementView.getNodeBBox(magnet);\n\t  }\n\t  const anchor = bbox.center();\n\t  const topLeft = bbox.origin();\n\t  const bottomRight = bbox.corner();\n\t  let padding = opt.padding;\n\t  if (!isFinite(padding)) padding = 0;\n\t  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n\t    var dy = refPoint.y - anchor.y;\n\t    anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));\n\t    anchor.y += dy;\n\t  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n\t    var dx = refPoint.x - anchor.x;\n\t    anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));\n\t    anchor.x += dx;\n\t  }\n\t  return anchor;\n\t}\n\tfunction _midSide(view, magnet, refPoint, opt, endType, linkView) {\n\t  var rotate = !!opt.rotate;\n\t  var angle = view.model.angle();\n\t  var center = view.model.getCenter();\n\t  var bbox;\n\t  if (opt.useModelGeometry) {\n\t    bbox = getModelBBoxFromConnectedLink(view.model, linkView.model, endType, !rotate);\n\t    center = bbox.center();\n\t  } else {\n\t    bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n\t  }\n\t  var padding = opt.padding;\n\t  if (isFinite(padding)) bbox.inflate(padding);\n\t  if (rotate) refPoint.rotate(center, angle);\n\t  var side = getMiddleSide(bbox, refPoint, opt);\n\t  var anchor;\n\t  switch (side) {\n\t    case Side.LEFT:\n\t      anchor = bbox.leftMiddle();\n\t      break;\n\t    case Side.RIGHT:\n\t      anchor = bbox.rightMiddle();\n\t      break;\n\t    case Side.TOP:\n\t      anchor = bbox.topMiddle();\n\t      break;\n\t    case Side.BOTTOM:\n\t      anchor = bbox.bottomMiddle();\n\t      break;\n\t  }\n\t  return rotate ? anchor.rotate(center, -angle) : anchor;\n\t}\n\n\t// Can find anchor from model, when there is no selector or the link end\n\t// is connected to a port\n\tfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n\t  return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n\t}\n\n\t//joint.anchors\n\tconst center = bboxWrapper('center');\n\tconst top = bboxWrapper('topMiddle');\n\tconst bottom = bboxWrapper('bottomMiddle');\n\tconst left = bboxWrapper('leftMiddle');\n\tconst right = bboxWrapper('rightMiddle');\n\tconst topLeft = bboxWrapper('origin');\n\tconst topRight = bboxWrapper('topRight');\n\tconst bottomLeft = bboxWrapper('bottomLeft');\n\tconst bottomRight = bboxWrapper('corner');\n\tconst perpendicular = resolveRef(_perpendicular);\n\tconst midSide = resolveRef(_midSide);\n\tconst modelCenter = _modelCenter;\n\n\tvar anchors = {\n\t\t__proto__: null,\n\t\tbottom: bottom,\n\t\tbottomLeft: bottomLeft,\n\t\tbottomRight: bottomRight,\n\t\tcenter: center,\n\t\tleft: left,\n\t\tmidSide: midSide,\n\t\tmodelCenter: modelCenter,\n\t\tperpendicular: perpendicular,\n\t\tright: right,\n\t\ttop: top,\n\t\ttopLeft: topLeft,\n\t\ttopRight: topRight\n\t};\n\n\t/**\n\t * @class GraphLayersController\n\t * @description Coordinates interactions between the graph and its layers.\n\t * Automatically moves cells between layers when the layer attribute changes.\n\t */\n\tclass GraphLayersController extends Listener {\n\t  constructor(options) {\n\t    super(options);\n\n\t    // Make sure there are no arguments passed to the callbacks.\n\t    // See the `mvc.Listener` documentation for more details.\n\t    this.callbackArguments = [];\n\t    const graph = options.graph;\n\t    if (!graph) {\n\t      throw new Error('GraphLayersController: \"graph\" option is required.');\n\t    }\n\t    this.graph = graph;\n\t    this.layerCollection = graph.layerCollection;\n\t    this.startListening();\n\t  }\n\t  startListening() {\n\t    // Handle all events from the layer collection and its inner cell collections.\n\t    this.listenTo(this.layerCollection, 'all', this.onLayerCollectionEvent);\n\t  }\n\n\t  /**\n\t   * @description When a cell changes its layer attribute,\n\t   * move the cell to the target layer.\n\t   */\n\t  onCellChange(cell, options) {\n\t    if (!cell.hasChanged(config$3.layerAttribute)) return;\n\t    // Move the cell to the appropriate layer\n\t    const targetLayerId = this.graph.getCellLayerId(cell);\n\t    this.layerCollection.moveCellBetweenLayers(cell, targetLayerId, options);\n\t  }\n\n\t  /**\n\t   * @description When a cell is removed from a layer,\n\t   * also remove its embeds and connected links from the graph.\n\t   * Note: an embedded cell might come from a different layer,\n\t   * so we can not use the layer's cell collection to remove it.\n\t   */\n\t  onCellRemove(cell, options) {\n\t    // If the cell is being moved from one layer to another,\n\t    // no further action is needed.\n\t    if (options.fromLayer) return;\n\n\t    // When replacing a cell, we do not want to remove its embeds or\n\t    // unembed it from its parent.\n\t    if (options.replace) return;\n\n\t    // First, unembed this cell from its parent cell if there is one.\n\t    const parentCell = cell.getParentCell();\n\t    if (parentCell) {\n\t      parentCell.unembed(cell, options);\n\t    }\n\n\t    // Remove also all the cells, which were embedded into this cell\n\t    const embeddedCells = cell.getEmbeddedCells();\n\t    for (let i = 0, n = embeddedCells.length; i < n; i++) {\n\t      const embed = embeddedCells[i];\n\t      if (embed) {\n\t        this.layerCollection.removeCell(embed, options);\n\t      }\n\t    }\n\n\t    // When not clearing the whole graph or replacing the cell,\n\t    // we don't want to remove the connected links.\n\t    if (!options.clear) {\n\t      // Applications might provide a `disconnectLinks` option set to `true` in order to\n\t      // disconnect links when a cell is removed rather then removing them. The default\n\t      // is to remove all the associated links.\n\t      if (options.disconnectLinks) {\n\t        this.graph.disconnectLinks(cell, options);\n\t      } else {\n\t        this.graph.removeLinks(cell, options);\n\t      }\n\t    }\n\t  }\n\t  onLayerCollectionEvent(eventName, model) {\n\t    if (!model) return;\n\t    if (model[CELL_MARKER]) {\n\t      // First handle cell-specific cases that require custom processing,\n\t      // then forward the event to the graph.\n\t      // For example, when a cell is removed from a layer, its embeds and\n\t      // connected links must be removed as well. Listeners on the graph\n\t      // should receive removal notifications in the following order:\n\t      // embeds  links  cell.\n\t      switch (eventName) {\n\t        case 'change':\n\t          /* ('change', cell, options) */\n\t          this.onCellChange.call(this, model, arguments[2]);\n\t          break;\n\t        case 'remove':\n\t          /* ('remove', cell, collection, options) */\n\t          // When a cell is removed from a layer,\n\t          // ensure it is also removed from the graph.\n\t          this.onCellRemove.call(this, model, arguments[3]);\n\t          break;\n\t      }\n\t      // Notify the graph about cell events.\n\t      this.forwardCellEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[CELL_COLLECTION_MARKER]) {\n\t      this.forwardCellCollectionEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[GRAPH_LAYER_MARKER]) {\n\t      this.forwardLayerEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t    if (model[GRAPH_LAYER_COLLECTION_MARKER]) {\n\t      this.forwardLayerCollectionEvent.apply(this, arguments);\n\t      return;\n\t    }\n\t  }\n\t  forwardLayerEvent() {\n\t    // Note: the layer event prefix is `layer:`\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardCellEvent(eventName, cell) {\n\t    var _arguments$;\n\t    // Moving a cell from one layer to another is an internal operation\n\t    // that should not be exposed at the graph level.\n\t    // The single `move` event is triggered instead.\n\t    if ((eventName === 'remove' || eventName === 'add') && (_arguments$ = arguments[3]) !== null && _arguments$ !== void 0 && _arguments$.fromLayer) return;\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardCellCollectionEvent(eventName) {\n\t    // Do not forward `layer:remove` or `layer:sort` events to the graph\n\t    if (eventName !== 'sort') return;\n\t    // Backwards compatibility:\n\t    // Trigger 'sort' event for cell collection 'sort' events\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t  forwardLayerCollectionEvent(eventName) {\n\t    if (eventName === 'reset') {\n\t      // Currently, there is no need to forward `layers:reset` event.\n\t      // The graph `fromJSON()` triggers a single `reset` event after\n\t      // resetting cells, layers and attributes.\n\t      return;\n\t    }\n\t    // Forward layer collection events with `layers:` prefix.\n\t    // For example `layers:reset` event when the layer collection is reset\n\t    arguments[0] = 'layers:' + arguments[0];\n\t    this.graph.trigger.apply(this.graph, arguments);\n\t  }\n\t}\n\n\t/**\n\t * @class CellCollection\n\t * @description A CellCollection is a collection of cells which supports z-index management.\n\t * Additionally, it facilitates creating cell models from JSON using cellNamespace\n\t * and stores a reference to the graph when the cell model has been added.\n\t */\n\tclass CellCollection extends Collection {\n\t  [CELL_COLLECTION_MARKER] = true;\n\t  initialize(_models, opt) {\n\t    this.layer = opt.layer;\n\t  }\n\n\t  // Method for checking whether an object should be considered a model for\n\t  // the purposes of adding to the collection.\n\t  _isModel(model) {\n\t    return Boolean(model[CELL_MARKER]);\n\t  }\n\n\t  // Overriding the default `model` method to create cell models\n\t  // based on their `type` attribute and the `cellNamespace` option.\n\t  model(attrs, opt) {\n\t    const namespace = this.cellNamespace;\n\t    if (!namespace) {\n\t      throw new Error('dia.CellCollection: cellNamespace is required to instantiate a Cell from JSON.');\n\t    }\n\t    const {\n\t      type\n\t    } = attrs;\n\n\t    // Find the model class based on the `type` attribute in the cell namespace\n\t    const ModelClass = getByPath(namespace, type, '.');\n\t    if (!ModelClass) {\n\t      throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n\t    }\n\t    return new ModelClass(attrs, opt);\n\t  }\n\n\t  // Override to set graph reference\n\t  _addReference(model, options) {\n\t    super._addReference(model, options);\n\n\t    // If not in `dry` mode and the model does not have a graph reference yet,\n\t    // set the reference.\n\t    if (!options.dry && !model.graph) {\n\t      model.graph = this.layer.graph;\n\t    }\n\t  }\n\n\t  // Override to remove graph reference\n\t  _removeReference(model, options) {\n\t    super._removeReference(model, options);\n\n\t    // If not in `dry` mode and the model has a reference to this exact graph,\n\t    // remove the reference.\n\t    // Note: graph reference is removed from the layer after the `remove` event is fired.\n\t    // Due to this, event handlers can still access the graph during the `remove` event.\n\t    if (!options.dry && model.graph === this.layer.graph) {\n\t      model.graph = null;\n\t    }\n\t  }\n\n\t  // remove graph reference additionally\n\t  _removeReferenceFast(model, options) {\n\t    model.off('all', this._onModelEvent, this);\n\t    if (!options.dry) {\n\t      // If not in `dry` mode and the model has a reference\n\t      // to this exact graph/collection, remove the reference.\n\t      if (this === model.collection) {\n\t        delete model.collection;\n\t      }\n\t      if (model.graph === this.layer.graph) {\n\t        model.graph = null;\n\t      }\n\t    }\n\t  }\n\n\t  // `comparator` makes it easy to sort cells based on their `z` index.\n\t  comparator(model) {\n\t    return model.get('z') || 0;\n\t  }\n\n\t  // This method overrides base mvc.Collection implementation\n\t  // in a way that improves performance of resetting large collections.\n\t  // For layers specifically, there is an option where we put references\n\t  // from the main collection in order to improve performance when\n\t  // there is only one layer\n\t  reset(models, options) {\n\t    options = assign({}, {\n\t      add: true,\n\t      remove: false,\n\t      merge: false\n\t    }, options);\n\t    for (let i = 0; i < this.models.length; i++) {\n\t      this._removeReferenceFast(this.models[i], options);\n\t    }\n\t    options.previousModels = this.models;\n\t    this._reset();\n\t    for (let i = 0; i < models.length; i++) {\n\t      const model = this._prepareModel(models[i], options);\n\t      if (model) {\n\t        this.models.push(model);\n\t        this._addReference(model, options);\n\t      }\n\t    }\n\t    this.length = this.models.length;\n\t    const sort = this.comparator && options.sort !== false;\n\t    if (sort) {\n\t      this.sort({\n\t        silent: true\n\t      });\n\t    }\n\t    if (!options.silent) {\n\t      this.trigger('reset', this, options);\n\t    }\n\t    return this.models;\n\t  }\n\t  minZIndex() {\n\t    var _this$first;\n\t    return ((_this$first = this.first()) === null || _this$first === void 0 ? void 0 : _this$first.get('z')) || 0;\n\t  }\n\t  maxZIndex() {\n\t    var _this$last;\n\t    return ((_this$last = this.last()) === null || _this$last === void 0 ? void 0 : _this$last.get('z')) || 0;\n\t  }\n\t}\n\n\tconst DEFAULT_GRAPH_LAYER_TYPE = 'GraphLayer';\n\n\t/**\n\t * @class GraphLayer\n\t * @description A GraphLayer is a model representing a single layer in a dia.Graph.\n\t */\n\tclass GraphLayer extends Model {\n\t  [GRAPH_LAYER_MARKER] = true;\n\t  preinitialize() {\n\t    // This allows for propagating events from the inner `cellCollection` collection\n\t    // without any prefix and therefore distinguish them from the events\n\t    // fired by the GraphLayer model itself.\n\t    this.eventPrefix = 'layer:';\n\t  }\n\t  defaults() {\n\t    return {\n\t      type: DEFAULT_GRAPH_LAYER_TYPE\n\t    };\n\t  }\n\t  initialize(attrs, options = {}) {\n\t    super.initialize(attrs, options);\n\t    this.cellCollection = new CellCollection([], {\n\t      layer: this\n\t    });\n\n\t    // Forward all events from the inner `cellCollection` collection\n\t    this.cellCollection.on('all', this.trigger, this);\n\t    // Listen to cell changes to manage z-index sorting\n\t    this.cellCollection.on('change', this.onCellChange, this);\n\t  }\n\t  onCellChange(cell, opt) {\n\t    if (opt.sort === false || !cell.hasChanged('z')) return;\n\t    this.cellCollection.sort();\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Returns all cells in this layer.\n\t   */\n\t  getCells() {\n\t    return this.cellCollection.toArray();\n\t  }\n\t}\n\n\t/**\n\t * @class GraphLayerCollection\n\t * @description A collection of layers used in dia.Graph. It facilitates creating layers from JSON using layerNamespace.\n\t */\n\tconst GraphLayerCollection = Collection.extend({\n\t  defaultLayerNamespace: {\n\t    GraphLayer\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Initializes the collection and sets up the layer and cell namespaces.\n\t   */\n\t  initialize: function (_models, options = {}) {\n\t    const {\n\t      layerNamespace,\n\t      cellNamespace,\n\t      graph\n\t    } = options;\n\n\t    // Initialize the namespace that holds all available layer classes.\n\t    // Custom namespaces are merged with the default ones.\n\t    this.layerNamespace = assign({}, this.defaultLayerNamespace, layerNamespace);\n\n\t    // Initialize the namespace for all cell model classes, if provided.\n\t    if (cellNamespace) {\n\t      this.cellNamespace = cellNamespace;\n\t    } else {\n\t      /* eslint-disable no-undef */\n\t      this.cellNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n\t      /* eslint-enable no-undef */\n\t    }\n\t    this.graph = graph;\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `model` method\n\t   * to create layer models based on their `type` attribute.\n\t   */\n\t  model: function (attrs, opt) {\n\t    const collection = opt.collection;\n\t    const namespace = collection.layerNamespace;\n\t    const {\n\t      type\n\t    } = attrs;\n\n\t    // Find the model class based on the `type` attribute in the cell namespace\n\t    const GraphLayerClass = getByPath(namespace, type, '.');\n\t    if (!GraphLayerClass) {\n\t      throw new Error(`dia.Graph: Could not find layer constructor for type: '${type}'. Make sure to add the constructor to 'layerNamespace'.`);\n\t    }\n\t    return new GraphLayerClass(attrs, opt);\n\t  },\n\t  // Override to set graph reference\n\t  _addReference(layer, options) {\n\t    Collection.prototype._addReference.call(this, layer, options);\n\n\t    // assign graph and cellNamespace references\n\t    // to the added layer\n\t    layer.graph = this.graph;\n\t    layer.cellCollection.cellNamespace = this.cellNamespace;\n\t  },\n\t  // Override to remove graph reference\n\t  _removeReference(layer, options) {\n\t    Collection.prototype._removeReference.call(this, layer, options);\n\n\t    // remove graph and cellNamespace references\n\t    // from the removed layer\n\t    layer.graph = null;\n\t    layer.cellCollection.cellNamespace = null;\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `_prepareModel` method\n\t   * to set default layer type if missing.\n\t   */\n\t  _prepareModel: function (attrs, options) {\n\t    if (!attrs[GRAPH_LAYER_MARKER]) {\n\t      // Add a mandatory `type` attribute if missing\n\t      if (!attrs.type) {\n\t        const preparedAttributes = clone$1(attrs);\n\t        preparedAttributes.type = DEFAULT_GRAPH_LAYER_TYPE;\n\t        arguments[0] = preparedAttributes;\n\t      }\n\t    }\n\t    return Collection.prototype._prepareModel.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct resetting of the collection.\n\t   */\n\t  reset(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.reset.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct addition of layers.\n\t   */\n\t  add(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.add.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Add an assertion to prevent direct removal of layers.\n\t   */\n\t  remove(models, options) {\n\t    this._assertInternalCall(options);\n\t    return Collection.prototype.remove.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @override\n\t   * @description Overrides the default `_onModelEvent` method\n\t   * to distinguish between events coming from different model types.\n\t   */\n\t  _onModelEvent(_, model) {\n\t    if (model && model[CELL_MARKER]) {\n\t      // Do not filter cell `add` and `remove` events\n\t      // See `mvc.Collection` for more details\n\t      this.trigger.apply(this, arguments);\n\t      return;\n\t    }\n\n\t    // For other events, use the default behavior\n\t    Collection.prototype._onModelEvent.apply(this, arguments);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Asserts that the collection manipulation\n\t   * is done via internal graph methods. Otherwise, it throws an error.\n\t   * This is a temporary measure until layers API is stabilized.\n\t   */\n\t  _assertInternalCall(options) {\n\t    if (options && !options.graph && !options.silent) {\n\t      throw new Error('dia.GraphLayerCollection: direct manipulation of the collection is not supported, use graph methods instead.');\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Inserts a layer before another layer or at the end if `beforeLayerId` is null.\n\t   */\n\t  insert(layerInit, beforeLayerId = null, options = {}) {\n\t    const id = layerInit.id;\n\t    if (id === beforeLayerId) {\n\t      // Inserting before itself is a no-op\n\t      return;\n\t    }\n\t    if (beforeLayerId && !this.has(beforeLayerId)) {\n\t      throw new Error(`dia.GraphLayerCollection: Layer \"${beforeLayerId}\" does not exist`);\n\t    }\n\n\t    // See if the layer is already in the collection\n\t    let currentIndex = -1;\n\t    if (this.has(id)) {\n\t      currentIndex = this.findIndex(l => l.id === id);\n\t      if (currentIndex === this.length - 1 && !beforeLayerId) {\n\t        // The layer is already at the end\n\t        return;\n\t      }\n\t      // Remove the layer from its current position\n\t      this.remove(id, {\n\t        silent: true\n\t      });\n\t    }\n\n\t    // At what index to insert the layer?\n\t    let insertAt;\n\t    if (!beforeLayerId) {\n\t      insertAt = this.length;\n\t    } else {\n\t      insertAt = this.findIndex(l => l.id === beforeLayerId);\n\t    }\n\t    if (currentIndex !== -1) {\n\t      // Re-insert the layer at the new position.\n\t      this.add(layerInit, {\n\t        at: insertAt,\n\t        silent: true\n\t      });\n\t      // Trigger `sort` event manually\n\t      // since we are not using collection sorting workflow\n\t      this.trigger('sort', this, options);\n\t    } else {\n\t      // Add to the collection and trigger an event\n\t      // when new layer has been added\n\t      this.add(layerInit, {\n\t        ...options,\n\t        at: insertAt\n\t      });\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Finds and returns a cell by its id from all layers.\n\t   */\n\t  getCell(cellRef) {\n\t    // TODO: should we create a map of cells for faster lookup?\n\t    for (const layer of this.models) {\n\t      const cell = layer.cellCollection.get(cellRef);\n\t      if (cell) {\n\t        return cell;\n\t      }\n\t    }\n\t    // Backward compatibility: return undefined if cell is not found\n\t    return undefined;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns all cells in all layers in the correct order.\n\t   */\n\t  getCells() {\n\t    const layers = this.models;\n\t    if (layers.length === 1) {\n\t      // Single layer:\n\t      // Fast path, just return the copy of the only layer's cells\n\t      return layers[0].getCells();\n\t    }\n\t    // Multiple layers:\n\t    // Each layer has its models sorted already, so we can just concatenate\n\t    // them in the order of layers.\n\t    const cells = [];\n\t    for (const layer of layers) {\n\t      Array.prototype.push.apply(cells, layer.cellCollection.models);\n\t    }\n\t    return cells;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Removes a cell from its current layer.\n\t   */\n\t  removeCell(cell, options = {}) {\n\t    var _cell$collection;\n\t    const cellCollection = (_cell$collection = cell.collection) === null || _cell$collection === void 0 || (_cell$collection = _cell$collection.layer) === null || _cell$collection === void 0 ? void 0 : _cell$collection.cellCollection;\n\t    if (!cellCollection) return;\n\t    cellCollection.remove(cell, options);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Move a cell from its current layer to a target layer.\n\t   */\n\t  moveCellBetweenLayers(cell, targetLayerId, options = {}) {\n\t    var _cell$collection2;\n\t    const sourceLayer = (_cell$collection2 = cell.collection) === null || _cell$collection2 === void 0 ? void 0 : _cell$collection2.layer;\n\t    if (!sourceLayer) {\n\t      throw new Error('dia.GraphLayerCollection: cannot move a cell that is not part of any layer.');\n\t    }\n\t    const targetLayer = this.get(targetLayerId);\n\t    if (!targetLayer) {\n\t      throw new Error(`dia.GraphLayerCollection: cannot move cell to layer '${targetLayerId}' because such layer does not exist.`);\n\t    }\n\t    if (sourceLayer === targetLayer) {\n\t      // 1. The provided cell is already in the target layer\n\t      // 2. Implicit default layer vs. explicit default (or vice versa)\n\t      // No follow-up action needed\n\t      return;\n\t    }\n\t    const moveOptions = {\n\t      ...options,\n\t      fromLayer: sourceLayer.id,\n\t      toLayer: targetLayer.id\n\t    };\n\t    // Move the cell between the two layer collections\n\t    sourceLayer.cellCollection.remove(cell, moveOptions);\n\t    targetLayer.cellCollection.add(cell, moveOptions);\n\t    // Trigger a single `move` event to ease distinguishing layer moves\n\t    // from add/remove operations\n\t    cell.trigger('move', cell, moveOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Adds a cell to the specified layer.\n\t   */\n\t  addCellToLayer(cell, layerId, options = {}) {\n\t    const targetLayer = this.get(layerId);\n\t    if (!targetLayer) {\n\t      throw new Error(`dia.GraphLayerCollection: layer \"${layerId}\" does not exist.`);\n\t    }\n\t    const addOptions = {\n\t      ...options,\n\t      toLayer: targetLayer.id\n\t    };\n\t    // Add the cell to the target layer collection\n\t    targetLayer.cellCollection.add(cell, addOptions);\n\t  }\n\t});\n\tObject.defineProperty(GraphLayerCollection.prototype, GRAPH_LAYER_COLLECTION_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class GraphTopologyIndex\n\t * @description Maintains an index of the graph topology (adjacency list)\n\t * for fast graph queries.\n\t */\n\tclass GraphTopologyIndex extends Listener {\n\t  constructor(options) {\n\t    super(options);\n\n\t    // Make sure there are no arguments passed to the callbacks.\n\t    // See the `mvc.Listener` documentation for more details.\n\t    this.callbackArguments = [];\n\t    this.layerCollection = options.layerCollection;\n\t    if (!this.layerCollection) {\n\t      throw new Error('GraphTopologyIndex: \"layerCollection\" option is required.');\n\t    }\n\t    this.initializeIndex();\n\t    this.startListening();\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Start listening to graph and layer collection events\n\t   * to maintain the topology index.\n\t   */\n\t  startListening() {\n\t    this.listenTo(this.layerCollection.graph, {\n\t      'add': this._restructureOnAdd,\n\t      'remove': this._restructureOnRemove,\n\t      'reset': this._restructureOnReset\n\t    });\n\t    // Listening to the collection instead of the graph\n\t    // to avoid reacting to graph attribute change events\n\t    // e.g. graph.set('source', ...);\n\t    this.listenTo(this.layerCollection, {\n\t      'change:source': this._restructureOnChangeSource,\n\t      'change:target': this._restructureOnChangeTarget\n\t    });\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Initialize the internal data structures.\n\t   */\n\t  initializeIndex() {\n\t    // Outgoing edges per node. Note that we use a hash-table for the list\n\t    // of outgoing edges for a faster lookup.\n\t    // [nodeId] -> Object [edgeId] -> true\n\t    this._out = {};\n\t    // Ingoing edges per node.\n\t    // [nodeId] -> Object [edgeId] -> true\n\t    this._in = {};\n\t    // `_nodes` is useful for quick lookup of all the elements in the graph, without\n\t    // having to go through the whole cells array.\n\t    // [node ID] -> true\n\t    this._nodes = {};\n\t    // `_edges` is useful for quick lookup of all the links in the graph, without\n\t    // having to go through the whole cells array.\n\t    // [edgeId] -> true\n\t    this._edges = {};\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on graph reset.\n\t   * E.g. when fromJSON or resetCells is called.\n\t   */\n\t  _restructureOnReset() {\n\t    this.initializeIndex();\n\t    this.layerCollection.getCells().forEach(this._restructureOnAdd, this);\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on cell addition.\n\t   * @param {dia.Cell} cell - The cell being added.\n\t   */\n\t  _restructureOnAdd(cell) {\n\t    if (cell.isLink()) {\n\t      this._edges[cell.id] = true;\n\t      const {\n\t        source,\n\t        target\n\t      } = cell.attributes;\n\t      if (source.id) {\n\t        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n\t      }\n\t      if (target.id) {\n\t        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n\t      }\n\t    } else {\n\t      this._nodes[cell.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on cell removal.\n\t   * @param {dia.Cell} cell - The cell being removed.\n\t   */\n\t  _restructureOnRemove(cell) {\n\t    if (cell.isLink()) {\n\t      delete this._edges[cell.id];\n\t      const {\n\t        source,\n\t        target\n\t      } = cell.attributes;\n\t      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n\t        delete this._out[source.id][cell.id];\n\t      }\n\t      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n\t        delete this._in[target.id][cell.id];\n\t      }\n\t    } else {\n\t      delete this._nodes[cell.id];\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on link source change.\n\t   * @param {dia.Link} link - The link being changed.\n\t   */\n\t  _restructureOnChangeSource(link) {\n\t    const prevSource = link.previous('source');\n\t    if (prevSource.id && this._out[prevSource.id]) {\n\t      delete this._out[prevSource.id][link.id];\n\t    }\n\t    const source = link.attributes.source;\n\t    if (source.id) {\n\t      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @protected\n\t   * @description Restructure the topology index on link target change.\n\t   * @param {dia.Link} link - The link being changed.\n\t   */\n\t  _restructureOnChangeTarget(link) {\n\t    const prevTarget = link.previous('target');\n\t    if (prevTarget.id && this._in[prevTarget.id]) {\n\t      delete this._in[prevTarget.id][link.id];\n\t    }\n\t    const target = link.get('target');\n\t    if (target.id) {\n\t      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n\t    }\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all outbound edges for the node. Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node.\n\t   * @returns {Object} - An object of the form: [edgeId] -> true.\n\t   */\n\t  getOutboundEdges(nodeId) {\n\t    return this._out[nodeId] || {};\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all inbound edges for the node. Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node.\n\t   * @returns {Object} - An object of the form: [edgeId] -> true.\n\t   */\n\t  getInboundEdges(nodeId) {\n\t    return this._in[nodeId] || {};\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all sink nodes (leafs) in the graph. Time complexity: O(|V|).\n\t   * @returns {string[]} - Array of node ids.\n\t   */\n\t  getSinkNodes() {\n\t    const sinks = [];\n\t    for (const nodeId in this._nodes) {\n\t      if (!this._out[nodeId] || isEmpty(this._out[nodeId])) {\n\t        sinks.push(nodeId);\n\t      }\n\t    }\n\t    return sinks;\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Get all source nodes (roots) in the graph. Time complexity: O(|V|).\n\t   * @returns {string[]} - Array of node ids.\n\t   */\n\t  getSourceNodes() {\n\t    const sources = [];\n\t    for (const nodeId in this._nodes) {\n\t      if (!this._in[nodeId] || isEmpty(this._in[nodeId])) {\n\t        sources.push(nodeId);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Return `true` if `nodeId` is a source node (root). Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node to check.\n\t   * @returns {boolean}\n\t   */\n\t  isSourceNode(nodeId) {\n\t    return !this._in[nodeId] || isEmpty(this._in[nodeId]);\n\t  }\n\n\t  /**\n\t   * @public\n\t   * @description Return `true` if `nodeId` is a sink node (leaf). Time complexity: O(1).\n\t   * @param {string} nodeId - The id of the node to check.\n\t   * @returns {boolean}\n\t   */\n\t  isSinkNode(nodeId) {\n\t    return !this._out[nodeId] || isEmpty(this._out[nodeId]);\n\t  }\n\t}\n\n\t// The ID of the default graph layer.\n\tconst DEFAULT_LAYER_ID = 'cells';\n\tconst Graph = Model.extend({\n\t  /**\n\t   * @todo Remove in v5.0.0\n\t   * @description In legacy mode, the information about layers is not\n\t   * exported into JSON.\n\t   */\n\t  legacyMode: true,\n\t  /**\n\t   * @protected\n\t   * @description The ID of the default layer.\n\t   */\n\t  defaultLayerId: DEFAULT_LAYER_ID,\n\t  initialize: function (attrs, options = {}) {\n\t    const layerCollection = this.layerCollection = new GraphLayerCollection([], {\n\t      layerNamespace: options.layerNamespace,\n\t      cellNamespace: options.cellNamespace,\n\t      graph: this,\n\t      /** @deprecated use cellNamespace instead */\n\t      model: options.cellModel\n\t    });\n\n\t    // The default setup includes a single default layer.\n\t    layerCollection.add({\n\t      id: DEFAULT_LAYER_ID\n\t    }, {\n\t      graph: this.cid\n\t    });\n\n\t    /**\n\t     * @todo Remove in v5.0.0\n\t     * @description Retain legacy 'cells' collection in attributes for backward compatibility.\n\t     * Applicable only when the default layer setup is used.\n\t     */\n\t    this.attributes.cells = this.getLayer(DEFAULT_LAYER_ID).cellCollection;\n\n\t    // Controller that manages communication between the graph and its layers.\n\t    this.layersController = new GraphLayersController({\n\t      graph: this\n\t    });\n\n\t    // `Graph` keeps an internal data structure (an adjacency list)\n\t    // for fast graph queries. All changes that affect the structure of the graph\n\t    // must be reflected in the `al` object. This object provides fast answers to\n\t    // questions such as \"what are the neighbors of this node\" or \"what\n\t    // are the sibling links of this link\".\n\t    this.topologyIndex = new GraphTopologyIndex({\n\t      layerCollection\n\t    });\n\t    this._batches = {};\n\t  },\n\t  toJSON: function (opt = {}) {\n\t    const {\n\t      layerCollection\n\t    } = this;\n\t    // Get the graph model attributes as a base JSON.\n\t    const json = Model.prototype.toJSON.apply(this, arguments);\n\n\t    // Add `cells` array holding all the cells in the graph.\n\t    json.cells = this.getCells().map(cell => cell.toJSON(opt.cellAttributes));\n\t    if (this.legacyMode) {\n\t      // Backwards compatibility for legacy setup\n\t      // with single default layer 'cells'.\n\t      // In this case, we do not need to export layers.\n\t      return json;\n\t    }\n\n\t    // Add `layers` array holding all the layers in the graph.\n\t    json.layers = layerCollection.toJSON();\n\n\t    // Add `defaultLayer` property indicating the default layer ID.\n\t    json.defaultLayer = this.defaultLayerId;\n\t    return json;\n\t  },\n\t  fromJSON: function (json, opt) {\n\t    const {\n\t      cells,\n\t      layers,\n\t      defaultLayer,\n\t      ...attributes\n\t    } = json;\n\t    if (!cells) {\n\t      throw new Error('Graph JSON must contain cells array.');\n\t    }\n\n\t    // The `fromJSON` should trigger a single 'reset' event at the end.\n\t    // Set all attributes silently for now.\n\t    this.set(attributes, {\n\t      silent: true\n\t    });\n\t    if (layers) {\n\t      // Reset the layers collection\n\t      // (`layers:reset` is not forwarded to the graph).\n\t      this._resetLayers(layers, defaultLayer, opt);\n\t    }\n\t    if (cells) {\n\t      // Reset the cells collection and trigger the 'reset' event.\n\t      this.resetCells(cells, opt);\n\t    }\n\t    return this;\n\t  },\n\t  /** @deprecated  */\n\t  clear: function (opt) {\n\t    opt = assign({}, opt, {\n\t      clear: true\n\t    });\n\t    const cells = this.getCells();\n\t    if (cells.length === 0) return this;\n\t    this.startBatch('clear', opt);\n\t    const sortedCells = sortBy(cells, cell => {\n\t      return cell.isLink() ? 1 : 2;\n\t    });\n\t    do {\n\t      // Remove all the cells one by one.\n\t      // Note that all the links are removed first, so it's\n\t      // safe to remove the elements without removing the connected\n\t      // links first.\n\t      this.layerCollection.removeCell(sortedCells.shift(), opt);\n\t    } while (sortedCells.length > 0);\n\t    this.stopBatch('clear');\n\t    return this;\n\t  },\n\t  _prepareCell: function (cellInit, opt) {\n\t    let cellAttributes;\n\t    if (cellInit[CELL_MARKER]) {\n\t      cellAttributes = cellInit.attributes;\n\t    } else {\n\t      cellAttributes = cellInit;\n\t    }\n\t    if (!isString(cellAttributes.type)) {\n\t      throw new TypeError('dia.Graph: cell type must be a string.');\n\t    }\n\n\t    // Backward compatibility: prior v4.2, z-index was not set during reset.\n\t    if (opt && opt.ensureZIndex) {\n\t      if (cellAttributes.z === undefined) {\n\t        const layerId = cellAttributes[config$3.layerAttribute] || this.defaultLayerId;\n\t        const zIndex = this.maxZIndex(layerId) + 1;\n\t        if (cellInit[CELL_MARKER]) {\n\t          // Set with event in case there is a listener\n\t          // directly on the cell instance\n\t          // (the cell is not part of graph yet)\n\t          cellInit.set('z', zIndex, opt);\n\t        } else {\n\t          cellAttributes.z = zIndex;\n\t        }\n\t      }\n\t    }\n\t    return cellInit;\n\t  },\n\t  minZIndex: function (layerId = this.defaultLayerId) {\n\t    const layer = this.getLayer(layerId);\n\t    return layer.cellCollection.minZIndex();\n\t  },\n\t  maxZIndex: function (layerId = this.defaultLayerId) {\n\t    const layer = this.getLayer(layerId);\n\t    return layer.cellCollection.maxZIndex();\n\t  },\n\t  addCell: function (cellInit, options) {\n\t    if (Array.isArray(cellInit)) {\n\t      return this.addCells(cellInit, options);\n\t    }\n\t    this._prepareCell(cellInit, {\n\t      ...options,\n\t      ensureZIndex: true\n\t    });\n\t    this.layerCollection.addCellToLayer(cellInit, this.getCellLayerId(cellInit), options);\n\t    return this;\n\t  },\n\t  addCells: function (cells, opt) {\n\t    if (cells.length === 0) return this;\n\t    cells = flattenDeep(cells);\n\t    opt.maxPosition = opt.position = cells.length - 1;\n\t    this.startBatch('add', opt);\n\t    cells.forEach(cell => {\n\t      this.addCell(cell, opt);\n\t      opt.position--;\n\t    });\n\t    this.stopBatch('add', opt);\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Reset the cells in the graph.\n\t   * Useful for bulk operations and optimizations.\n\t   */\n\t  resetCells: function (cellInits, options) {\n\t    const {\n\t      layerCollection\n\t    } = this;\n\t    // Note: `cellInits` is always an array and `options` is always an object.\n\t    // See `wrappers.cells` at the end of this file.\n\n\t    // When resetting cells, do not set z-index if not provided.\n\t    const prepareOptions = {\n\t      ...options,\n\t      ensureZIndex: false\n\t    };\n\n\t    // Initialize a map of layer IDs to arrays of cells\n\t    const layerCellsMap = layerCollection.reduce((map, layer) => {\n\t      map[layer.id] = [];\n\t      return map;\n\t    }, {});\n\n\t    // Distribute cells into their respective layers\n\t    for (let i = 0; i < cellInits.length; i++) {\n\t      const cellInit = cellInits[i];\n\t      const layerId = this.getCellLayerId(cellInit);\n\t      if (layerId in layerCellsMap) {\n\t        this._prepareCell(cellInit, prepareOptions);\n\t        layerCellsMap[layerId].push(cellInit);\n\t      } else {\n\t        throw new Error(`dia.Graph: Layer \"${layerId}\" does not exist.`);\n\t      }\n\t    }\n\n\t    // Reset each layer's cell collection with the corresponding cells.\n\t    layerCollection.each(layer => {\n\t      layer.cellCollection.reset(layerCellsMap[layer.id], options);\n\t    });\n\n\t    // Trigger a single `reset` event on the graph\n\t    // (while multiple `reset` events are triggered on layers).\n\t    // Backwards compatibility: use default layer collection\n\t    // The `collection` parameter is retained for backwards compatibility,\n\t    // and it is subject to removal in future releases.\n\t    this.trigger('reset', this.getDefaultLayer().cellCollection, options);\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Get the layer ID in which the cell resides.\n\t   * Cells without an explicit layer are assigned to the default layer.\n\t   * @param {dia.Cell | Object} cellInit - Cell model or attributes.\n\t   * @returns {string} - The layer ID.\n\t   */\n\t  getCellLayerId: function (cellInit) {\n\t    if (!cellInit) {\n\t      throw new Error('dia.Graph: No cell provided.');\n\t    }\n\t    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;\n\t    return cellAttributes[config$3.layerAttribute] || this.defaultLayerId;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Reset the layers in the graph.\n\t   * It assumes the existing cells have been removed beforehand\n\t   * or can be discarded.\n\t   */\n\t  _resetLayers: function (layers, defaultLayerId, options = {}) {\n\t    if (!Array.isArray(layers) || layers.length === 0) {\n\t      throw new Error('dia.Graph: At least one layer must be defined.');\n\t    }\n\n\t    // Resetting layers disables legacy mode\n\t    this.legacyMode = false;\n\t    this.layerCollection.reset(layers, {\n\t      ...options,\n\t      graph: this.cid\n\t    });\n\n\t    // If no default layer is specified, use the first layer as default\n\t    if (defaultLayerId) {\n\t      // The default layer must be one of the defined layers\n\t      if (!this.hasLayer(defaultLayerId)) {\n\t        throw new Error(`dia.Graph: default layer \"${defaultLayerId}\" does not exist.`);\n\t      }\n\t      this.defaultLayerId = defaultLayerId;\n\t    } else {\n\t      this.defaultLayerId = this.layerCollection.at(0).id;\n\t    }\n\t    return this;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Remove multiple cells from the graph.\n\t   * @param {Array<dia.Cell | dia.Cell.ID>} cellRefs - Array of cell references (models or IDs) to remove.\n\t   * @param {Object} [options] - Removal options. See {@link dia.Graph#removeCell}.\n\t   */\n\t  removeCells: function (cellRefs, options) {\n\t    if (!cellRefs.length) return this;\n\t    // Remove multiple cells in a single batch\n\t    this.startBatch('remove');\n\t    for (const cellRef of cellRefs) {\n\t      if (!cellRef) continue;\n\t      let cell;\n\t      if (cellRef[CELL_MARKER]) {\n\t        cell = cellRef;\n\t      } else {\n\t        cell = this.getCell(cellRef);\n\t        if (!cell) {\n\t          // The cell might have been already removed (embedded cell, connected link, etc.)\n\t          continue;\n\t        }\n\t      }\n\t      this.layerCollection.removeCell(cell, options);\n\t    }\n\t    this.stopBatch('remove');\n\t    return this;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Replace an existing cell with a new cell.\n\t   */\n\t  _replaceCell: function (currentCell, newCellInit, opt = {}) {\n\t    const batchName = 'replace-cell';\n\t    const replaceOptions = {\n\t      ...opt,\n\t      replace: true\n\t    };\n\t    this.startBatch(batchName, opt);\n\t    // 1. Remove the cell without removing connected links or embedded cells.\n\t    this.layerCollection.removeCell(currentCell, replaceOptions);\n\t    const newCellInitAttributes = newCellInit[CELL_MARKER] ? newCellInit.attributes : newCellInit;\n\t    // 2. Combine the current cell attributes with the new cell attributes\n\t    const replacementCellAttributes = Object.assign({}, currentCell.attributes, newCellInitAttributes);\n\t    let replacement;\n\t    if (newCellInit[CELL_MARKER]) {\n\t      // If the new cell is a model, set the merged attributes on the model\n\t      newCellInit.set(replacementCellAttributes, replaceOptions);\n\t      replacement = newCellInit;\n\t    } else {\n\t      replacement = replacementCellAttributes;\n\t    }\n\n\t    // 3. Add the replacement cell\n\t    this.addCell(replacement, replaceOptions);\n\t    this.stopBatch(batchName);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Synchronize a single graph cell with the provided cell (model or attributes).\n\t   * If the cell with the same `id` exists, it is updated. If the cell does not exist, it is added.\n\t   * If the existing cell type is different from the incoming cell type, the existing cell is replaced.\n\t   */\n\t  _syncCell: function (cellInit, opt = {}) {\n\t    const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;\n\t    const currentCell = this.getCell(cellInit.id);\n\t    if (currentCell) {\n\t      // `cellInit` is either a model or attributes object\n\t      if ('type' in cellAttributes && currentCell.get('type') !== cellAttributes.type) {\n\t        // Replace the cell if the type has changed\n\t        this._replaceCell(currentCell, cellInit, opt);\n\t      } else {\n\t        // Update existing cell\n\t        // Note: the existing cell attributes are not removed,\n\t        // if they're missing in `cellAttributes`.\n\t        currentCell.set(cellAttributes, opt);\n\t      }\n\t    } else {\n\t      // The cell does not exist yet, add it\n\t      this.addCell(cellInit, opt);\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Synchronize the graph cells with the provided array of cells (models or attributes).\n\t   */\n\t  syncCells: function (cellInits, opt = {}) {\n\t    const batchName = 'sync-cells';\n\t    const {\n\t      remove = false,\n\t      ...setOpt\n\t    } = opt;\n\t    let currentCells, newCellsMap;\n\t    if (remove) {\n\t      // We need to track existing cells to remove the missing ones later\n\t      currentCells = this.getCells();\n\t      newCellsMap = new Map();\n\t    }\n\n\t    // Observe changes to the graph cells\n\t    let changeObserver, changedLayers;\n\t    const shouldSort = opt.sort !== false;\n\t    if (shouldSort) {\n\t      changeObserver = new Listener();\n\t      changedLayers = new Set();\n\t      changeObserver.listenTo(this, {\n\t        'add': cell => {\n\t          changedLayers.add(this.getCellLayerId(cell));\n\t        },\n\t        'change': cell => {\n\t          if (cell.hasChanged(config$3.layerAttribute) || cell.hasChanged('z')) {\n\t            changedLayers.add(this.getCellLayerId(cell));\n\t          }\n\t        }\n\t      });\n\t    }\n\t    this.startBatch(batchName, opt);\n\n\t    // Prevent multiple sorts during sync\n\t    setOpt.sort = false;\n\n\t    // Add or update incoming cells\n\t    for (const cellInit of cellInits) {\n\t      if (remove) {\n\t        // only track existence\n\t        newCellsMap.set(cellInit.id, true);\n\t      }\n\t      this._syncCell(cellInit, setOpt);\n\t    }\n\t    if (remove) {\n\t      // Remove cells not present in the incoming array\n\t      for (const cell of currentCells) {\n\t        if (!newCellsMap.has(cell.id)) {\n\t          this.layerCollection.removeCell(cell, setOpt);\n\t        }\n\t      }\n\t    }\n\t    if (shouldSort) {\n\t      // Sort layers that had changes affecting z-index or layer\n\t      changeObserver.stopListening();\n\t      for (const layerId of changedLayers) {\n\t        this.getLayer(layerId).cellCollection.sort(opt);\n\t      }\n\t    }\n\t    this.stopBatch(batchName);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Remove a cell from the graph.\n\t   * @param {dia.Cell} cell\n\t   * @param {Object} [options]\n\t   * @param {boolean} [options.disconnectLinks=false] - If `true`, the connected links are\n\t   * disconnected instead of removed.\n\t   * @param {boolean} [options.clear=false] - If `true`, the connected links\n\t   * are kept. @internal\n\t   * @param {boolean} [options.replace=false] - If `true`, the connected links and\n\t   * embedded cells are kept. @internal\n\t   * @throws Will throw an error if no cell is provided\n\t   * @throws Will throw an error if the ID of the cell to remove\n\t   * does not exist in the graph\n\t   **/\n\t  removeCell: function (cellRef, options) {\n\t    if (!cellRef) {\n\t      throw new Error('dia.Graph: no cell provided.');\n\t    }\n\t    const cell = cellRef[CELL_MARKER] ? cellRef : this.getCell(cellRef);\n\t    if (!cell) {\n\t      throw new Error('dia.Graph: cell to remove does not exist in the graph.');\n\t    }\n\t    if (cell.graph !== this) return;\n\t    this.startBatch('remove');\n\t    cell.collection.remove(cell, options);\n\t    this.stopBatch('remove');\n\t  },\n\t  transferCellEmbeds: function (sourceCell, targetCell, opt = {}) {\n\t    const batchName = 'transfer-embeds';\n\t    this.startBatch(batchName);\n\n\t    // Embed children of the source cell in the target cell.\n\t    const children = sourceCell.getEmbeddedCells();\n\t    targetCell.embed(children, {\n\t      ...opt,\n\t      reparent: true\n\t    });\n\t    this.stopBatch(batchName);\n\t  },\n\t  transferCellConnectedLinks: function (sourceCell, targetCell, opt = {}) {\n\t    const batchName = 'transfer-connected-links';\n\t    this.startBatch(batchName);\n\n\t    // Reconnect all the links connected to the old cell to the new cell.\n\t    const connectedLinks = this.getConnectedLinks(sourceCell, opt);\n\t    connectedLinks.forEach(link => {\n\t      if (link.getSourceCell() === sourceCell) {\n\t        link.prop(['source', 'id'], targetCell.id, opt);\n\t      }\n\t      if (link.getTargetCell() === sourceCell) {\n\t        link.prop(['target', 'id'], targetCell.id, opt);\n\t      }\n\t    });\n\t    this.stopBatch(batchName);\n\t  },\n\t  /**\n\t   * @private\n\t   * Helper method for addLayer and moveLayer methods\n\t   */\n\t  _getBeforeLayerIdFromOptions(options, layer = null) {\n\t    let {\n\t      before = null,\n\t      index\n\t    } = options;\n\t    if (before && index !== undefined) {\n\t      throw new Error('dia.Graph: Options \"before\" and \"index\" are mutually exclusive.');\n\t    }\n\t    let computedBefore;\n\t    if (index !== undefined) {\n\t      const layersArray = this.getLayers();\n\t      if (index >= layersArray.length) {\n\t        // If index is greater than the number of layers,\n\t        // return before as null (move to the end).\n\t        computedBefore = null;\n\t      } else if (index < 0) {\n\t        // If index is negative, move to the beginning.\n\t        computedBefore = layersArray[0].id;\n\t      } else {\n\t        var _layersArray$index;\n\t        const originalIndex = layersArray.indexOf(layer);\n\t        if (originalIndex !== -1 && index > originalIndex) {\n\t          // If moving a layer upwards in the stack, we need to adjust the index\n\t          // to account for the layer being removed from its original position.\n\t          index += 1;\n\t        }\n\t        // Otherwise, get the layer ID at the specified index.\n\t        computedBefore = ((_layersArray$index = layersArray[index]) === null || _layersArray$index === void 0 ? void 0 : _layersArray$index.id) || null;\n\t      }\n\t    } else {\n\t      computedBefore = before;\n\t    }\n\t    return computedBefore;\n\t  },\n\t  /**\n\t   * @public\n\t   * Adds a new layer to the graph.\n\t   * @param {GraphLayer | GraphLayerJSON} layerInit\n\t   * @param {*} options\n\t   * @param {string | null} [options.before] - ID of the layer\n\t   * before which to insert the new layer. If `null`, the layer is added at the end.\n\t   * @param {number} [options.index] - Zero-based index to which to add the layer.\n\t   * @throws Will throw an error if the layer to add is invalid\n\t   * @throws Will throw an error if a layer with the same ID already exists\n\t   * @throws Will throw if `before` reference is invalid\n\t   */\n\t  addLayer(layerInit, options = {}) {\n\t    if (!layerInit || !layerInit.id) {\n\t      throw new Error('dia.Graph: Layer to add is invalid.');\n\t    }\n\t    if (this.hasLayer(layerInit.id)) {\n\t      throw new Error(`dia.Graph: Layer \"${layerInit.id}\" already exists.`);\n\t    }\n\t    const {\n\t      before = null,\n\t      index,\n\t      ...insertOptions\n\t    } = options;\n\t    insertOptions.graph = this.cid;\n\n\t    // Adding a new layer disables legacy mode\n\t    this.legacyMode = false;\n\t    const beforeId = this._getBeforeLayerIdFromOptions({\n\t      before,\n\t      index\n\t    });\n\t    this.layerCollection.insert(layerInit, beforeId, insertOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * Moves an existing layer to a new position in the layer stack.\n\t   * @param {string | GraphLayer} layerRef - ID or reference of the layer to move.\n\t   * @param {*} options\n\t   * @param {string | null} [options.before] - ID of the layer\n\t   * before which to insert the moved layer. If `null`, the layer is moved to the end.\n\t   * @param {number} [options.index] - Zero-based index to which to move the layer.\n\t   * @throws Will throw an error if the layer to move does not exist\n\t   * @throws Will throw an error if `before` reference is invalid\n\t   * @throws Will throw an error if both `before` and `index` options are provided\n\t   */\n\t  moveLayer(layerRef, options = {}) {\n\t    if (!layerRef || !this.hasLayer(layerRef)) {\n\t      throw new Error('dia.Graph: Layer to move does not exist.');\n\t    }\n\t    const layer = this.getLayer(layerRef);\n\t    const {\n\t      before = null,\n\t      index,\n\t      ...insertOptions\n\t    } = options;\n\t    insertOptions.graph = this.cid;\n\n\t    // Moving a layer disables legacy mode\n\t    this.legacyMode = false;\n\t    const beforeId = this._getBeforeLayerIdFromOptions({\n\t      before,\n\t      index\n\t    }, layer);\n\t    this.layerCollection.insert(layer, beforeId, insertOptions);\n\t  },\n\t  /**\n\t   * @public\n\t   * Removes an existing layer from the graph.\n\t   * @param {string | GraphLayer} layerRef - ID or reference of the layer to remove.\n\t   * @param {*} options\n\t   * @throws Will throw an error if no layer is provided\n\t   * @throws Will throw an error if the layer to remove does not exist\n\t   */\n\t  removeLayer(layerRef, options = {}) {\n\t    if (!layerRef) {\n\t      throw new Error('dia.Graph: No layer provided.');\n\t    }\n\n\t    // The layer must exist\n\t    const layerId = layerRef.id ? layerRef.id : layerRef;\n\t    const layer = this.getLayer(layerId);\n\n\t    // Prevent removing the default layer\n\t    // Note: if there is only one layer, it is also the default layer.\n\t    const {\n\t      id: defaultLayerId\n\t    } = this.getDefaultLayer();\n\t    if (layerId === defaultLayerId) {\n\t      throw new Error('dia.Graph: default layer cannot be removed.');\n\t    }\n\n\t    // A layer with cells cannot be removed\n\t    if (layer.cellCollection.length > 0) {\n\t      throw new Error(`dia.Graph: Layer \"${layerId}\" cannot be removed because it is not empty.`);\n\t    }\n\t    this.layerCollection.remove(layerId, {\n\t      ...options,\n\t      graph: this.cid\n\t    });\n\t  },\n\t  getDefaultLayer() {\n\t    return this.layerCollection.get(this.defaultLayerId);\n\t  },\n\t  setDefaultLayer(layerRef, options = {}) {\n\t    if (!layerRef) {\n\t      throw new Error('dia.Graph: No default layer ID provided.');\n\t    }\n\n\t    // Make sure the layer exists\n\t    const defaultLayerId = layerRef.id ? layerRef.id : layerRef;\n\t    const defaultLayer = this.getLayer(defaultLayerId);\n\n\t    // If the default layer is not changing, do nothing\n\t    const currentDefaultLayerId = this.defaultLayerId;\n\t    if (defaultLayerId === currentDefaultLayerId) {\n\t      // The default layer stays the same\n\t      return;\n\t    }\n\n\t    // Get all cells that belong to the current default layer implicitly\n\t    const implicitLayerCells = this.getImplicitLayerCells();\n\n\t    // Set the new default layer ID\n\t    this.defaultLayerId = defaultLayerId;\n\t    const batchName = 'default-layer-change';\n\t    this.startBatch(batchName, options);\n\t    if (implicitLayerCells.length > 0) {\n\t      // Reassign any cells lacking an explicit layer to the new default layer.\n\t      // Do not sort yet, wait until all cells are moved.\n\t      const moveOptions = {\n\t        ...options,\n\t        sort: false\n\t      };\n\t      for (const cell of implicitLayerCells) {\n\t        this.layerCollection.moveCellBetweenLayers(cell, defaultLayerId, moveOptions);\n\t      }\n\t      // Now sort the new default layer\n\t      if (options.sort !== false) {\n\t        defaultLayer.cellCollection.sort(options);\n\t      }\n\t    }\n\n\t    // Pretend to trigger the event on the layer itself.\n\t    // It will bubble up as `layer:default` event on the graph.\n\t    defaultLayer.trigger(defaultLayer.eventPrefix + 'default', defaultLayer, {\n\t      ...options,\n\t      previousDefaultLayerId: currentDefaultLayerId\n\t    });\n\t    this.stopBatch(batchName, options);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Get all cells that do not have an explicit layer assigned.\n\t   * These cells belong to the default layer implicitly.\n\t   * @return {Array<dia.Cell>} Array of cells without an explicit layer.\n\t   */\n\t  getImplicitLayerCells() {\n\t    return this.getDefaultLayer().cellCollection.filter(cell => {\n\t      return cell.get(config$3.layerAttribute) == null;\n\t    });\n\t  },\n\t  getLayer(layerId) {\n\t    if (!this.hasLayer(layerId)) {\n\t      throw new Error(`dia.Graph: Layer \"${layerId}\" does not exist.`);\n\t    }\n\t    return this.layerCollection.get(layerId);\n\t  },\n\t  hasLayer(layerRef) {\n\t    return this.layerCollection.has(layerRef);\n\t  },\n\t  getLayers() {\n\t    return this.layerCollection.toArray();\n\t  },\n\t  getCell: function (cellRef) {\n\t    return this.layerCollection.getCell(cellRef);\n\t  },\n\t  getCells: function () {\n\t    return this.layerCollection.getCells();\n\t  },\n\t  getElements: function () {\n\t    return this.getCells().filter(cell => cell.isElement());\n\t  },\n\t  getLinks: function () {\n\t    return this.getCells().filter(cell => cell.isLink());\n\t  },\n\t  getFirstCell: function (layerId) {\n\t    let layer;\n\t    if (!layerId) {\n\t      // Get the first cell from the bottom-most layer\n\t      layer = this.getLayers().at(0);\n\t    } else {\n\t      layer = this.getLayer(layerId);\n\t    }\n\t    return layer.cellCollection.models.at(0);\n\t  },\n\t  getLastCell: function (layerId) {\n\t    let layer;\n\t    if (!layerId) {\n\t      // Get the last cell from the top-most layer\n\t      layer = this.getLayers().at(-1);\n\t    } else {\n\t      layer = this.getLayer(layerId);\n\t    }\n\t    return layer.cellCollection.models.at(-1);\n\t  },\n\t  // Get all inbound and outbound links connected to the cell `model`.\n\t  getConnectedLinks: function (model, opt) {\n\t    opt = opt || {};\n\t    var indirect = opt.indirect;\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\n\t    // the final array of connected link models\n\t    var links = [];\n\t    // a hash table of connected edges of the form: [edgeId] -> true\n\t    // used for quick lookups to check if we already added a link\n\t    var edges = {};\n\t    if (outbound) {\n\t      addOutbounds(this, model);\n\t    }\n\t    if (inbound) {\n\t      addInbounds(this, model);\n\t    }\n\t    function addOutbounds(graph, model) {\n\t      forIn(graph.topologyIndex.getOutboundEdges(model.id), function (_, edge) {\n\t        // skip links that were already added\n\t        // (those must be self-loop links)\n\t        // (because they are inbound and outbound edges of the same two elements)\n\t        if (edges[edge]) return;\n\t        var link = graph.getCell(edge);\n\t        if (!link) return;\n\t        links.push(link);\n\t        edges[edge] = true;\n\t        if (indirect) {\n\t          if (inbound) addInbounds(graph, link);\n\t          if (outbound) addOutbounds(graph, link);\n\t        }\n\t      }.bind(graph));\n\t      if (indirect && model.isLink()) {\n\t        var outCell = model.getTargetCell();\n\t        if (outCell && outCell.isLink()) {\n\t          if (!edges[outCell.id]) {\n\t            links.push(outCell);\n\t            addOutbounds(graph, outCell);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    function addInbounds(graph, model) {\n\t      forIn(graph.topologyIndex.getInboundEdges(model.id), function (_, edge) {\n\t        // skip links that were already added\n\t        // (those must be self-loop links)\n\t        // (because they are inbound and outbound edges of the same two elements)\n\t        if (edges[edge]) return;\n\t        var link = graph.getCell(edge);\n\t        if (!link) return;\n\t        links.push(link);\n\t        edges[edge] = true;\n\t        if (indirect) {\n\t          if (inbound) addInbounds(graph, link);\n\t          if (outbound) addOutbounds(graph, link);\n\t        }\n\t      }.bind(graph));\n\t      if (indirect && model.isLink()) {\n\t        var inCell = model.getSourceCell();\n\t        if (inCell && inCell.isLink()) {\n\t          if (!edges[inCell.id]) {\n\t            links.push(inCell);\n\t            addInbounds(graph, inCell);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\t    if (opt.deep) {\n\t      var embeddedCells = model.getEmbeddedCells({\n\t        deep: true\n\t      });\n\n\t      // in the first round, we collect all the embedded elements\n\t      var embeddedElements = {};\n\t      embeddedCells.forEach(function (cell) {\n\t        if (cell.isElement()) {\n\t          embeddedElements[cell.id] = true;\n\t        }\n\t      });\n\t      embeddedCells.forEach(function (cell) {\n\t        if (cell.isLink()) return;\n\t        if (outbound) {\n\t          forIn(this.topologyIndex.getOutboundEdges(cell.id), function (exists, edge) {\n\t            if (!edges[edge]) {\n\t              var edgeCell = this.getCell(edge);\n\t              var {\n\t                source,\n\t                target\n\t              } = edgeCell.attributes;\n\t              var sourceId = source.id;\n\t              var targetId = target.id;\n\n\t              // if `includeEnclosed` option is falsy, skip enclosed links\n\t              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n\t                return;\n\t              }\n\t              links.push(this.getCell(edge));\n\t              edges[edge] = true;\n\t            }\n\t          }.bind(this));\n\t        }\n\t        if (inbound) {\n\t          forIn(this.topologyIndex.getInboundEdges(cell.id), function (exists, edge) {\n\t            if (!edges[edge]) {\n\t              var edgeCell = this.getCell(edge);\n\t              var {\n\t                source,\n\t                target\n\t              } = edgeCell.attributes;\n\t              var sourceId = source.id;\n\t              var targetId = target.id;\n\n\t              // if `includeEnclosed` option is falsy, skip enclosed links\n\t              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n\t                return;\n\t              }\n\t              links.push(this.getCell(edge));\n\t              edges[edge] = true;\n\t            }\n\t          }.bind(this));\n\t        }\n\t      }, this);\n\t    }\n\t    return links;\n\t  },\n\t  getNeighbors: function (model, opt) {\n\t    opt || (opt = {});\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\t    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      var loop = link.hasLoop(opt);\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (inbound && has(source, 'id') && !res[source.id]) {\n\t        var sourceElement = this.getCell(source.id);\n\t        if (sourceElement.isElement()) {\n\t          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n\t            res[source.id] = sourceElement;\n\t          }\n\t        }\n\t      }\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (outbound && has(target, 'id') && !res[target.id]) {\n\t        var targetElement = this.getCell(target.id);\n\t        if (targetElement.isElement()) {\n\t          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n\t            res[target.id] = targetElement;\n\t          }\n\t        }\n\t      }\n\t      return res;\n\t    }.bind(this), {});\n\t    if (model.isLink()) {\n\t      if (inbound) {\n\t        var sourceCell = model.getSourceCell();\n\t        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n\t          neighbors[sourceCell.id] = sourceCell;\n\t        }\n\t      }\n\t      if (outbound) {\n\t        var targetCell = model.getTargetCell();\n\t        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n\t          neighbors[targetCell.id] = targetCell;\n\t        }\n\t      }\n\t    }\n\t    return toArray$1(neighbors);\n\t  },\n\t  getCommonAncestor: function /* cells */\n\t  () {\n\t    var cellsAncestors = Array.from(arguments).map(function (cell) {\n\t      var ancestors = [];\n\t      var parentId = cell.get('parent');\n\t      while (parentId) {\n\t        ancestors.push(parentId);\n\t        parentId = this.getCell(parentId).get('parent');\n\t      }\n\t      return ancestors;\n\t    }, this);\n\t    cellsAncestors = cellsAncestors.sort(function (a, b) {\n\t      return a.length - b.length;\n\t    });\n\t    var commonAncestor = toArray$1(cellsAncestors.shift()).find(function (ancestor) {\n\t      return cellsAncestors.every(function (cellAncestors) {\n\t        return cellAncestors.includes(ancestor);\n\t      });\n\t    });\n\t    return this.getCell(commonAncestor);\n\t  },\n\t  // Find the whole branch starting at `element`.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t  getSuccessors: function (element, opt) {\n\t    opt = opt || {};\n\t    var res = [];\n\t    // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\t    this.search(element, function (el) {\n\t      if (el !== element) {\n\t        res.push(el);\n\t      }\n\t    }, assign({}, opt, {\n\t      outbound: true\n\t    }));\n\t    return res;\n\t  },\n\t  cloneCells: cloneCells,\n\t  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n\t  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n\t  // Return a map of the form: [original cell ID] -> [clone].\n\t  cloneSubgraph: function (cells, opt) {\n\t    var subgraph = this.getSubgraph(cells, opt);\n\t    return this.cloneCells(subgraph);\n\t  },\n\t  // Return `cells` and all the connected links that connect cells in the `cells` array.\n\t  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n\t  // and all the links that connect any of the returned cells.\n\t  // For example, for a single shallow element, the result is that very same element.\n\t  // For two elements connected with a link: `A --- L ---> B`, the result for\n\t  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n\t  getSubgraph: function (cells, opt) {\n\t    opt = opt || {};\n\t    var subgraph = [];\n\t    // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\t    var cellMap = {};\n\t    var elements = [];\n\t    var links = [];\n\t    toArray$1(cells).forEach(function (cell) {\n\t      if (!cellMap[cell.id]) {\n\t        subgraph.push(cell);\n\t        cellMap[cell.id] = cell;\n\t        if (cell.isLink()) {\n\t          links.push(cell);\n\t        } else {\n\t          elements.push(cell);\n\t        }\n\t      }\n\t      if (opt.deep) {\n\t        var embeds = cell.getEmbeddedCells({\n\t          deep: true\n\t        });\n\t        embeds.forEach(function (embed) {\n\t          if (!cellMap[embed.id]) {\n\t            subgraph.push(embed);\n\t            cellMap[embed.id] = embed;\n\t            if (embed.isLink()) {\n\t              links.push(embed);\n\t            } else {\n\t              elements.push(embed);\n\t            }\n\t          }\n\t        });\n\t      }\n\t    });\n\t    links.forEach(function (link) {\n\t      // For links, return their source & target (if they are elements - not points).\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      if (source.id && !cellMap[source.id]) {\n\t        var sourceElement = this.getCell(source.id);\n\t        subgraph.push(sourceElement);\n\t        cellMap[sourceElement.id] = sourceElement;\n\t        elements.push(sourceElement);\n\t      }\n\t      if (target.id && !cellMap[target.id]) {\n\t        var targetElement = this.getCell(target.id);\n\t        subgraph.push(this.getCell(target.id));\n\t        cellMap[targetElement.id] = targetElement;\n\t        elements.push(targetElement);\n\t      }\n\t    }, this);\n\t    elements.forEach(function (element) {\n\t      // For elements, include their connected links if their source/target is in the subgraph;\n\t      var links = this.getConnectedLinks(element, opt);\n\t      links.forEach(function (link) {\n\t        var {\n\t          source,\n\t          target\n\t        } = link.attributes;\n\t        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n\t          subgraph.push(link);\n\t          cellMap[link.id] = link;\n\t        }\n\t      });\n\t    }, this);\n\t    return subgraph;\n\t  },\n\t  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t  getPredecessors: function (element, opt) {\n\t    opt = opt || {};\n\t    var res = [];\n\t    // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\t    this.search(element, function (el) {\n\t      if (el !== element) {\n\t        res.push(el);\n\t      }\n\t    }, assign({}, opt, {\n\t      inbound: true\n\t    }));\n\t    return res;\n\t  },\n\t  // Perform search on the graph.\n\t  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n\t  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // `iteratee` is a function of the form `function(element) {}`.\n\t  // If `iteratee` explicitly returns `false`, the searching stops.\n\t  search: function (element, iteratee, opt) {\n\t    opt = opt || {};\n\t    if (opt.breadthFirst) {\n\t      this.bfs(element, iteratee, opt);\n\t    } else {\n\t      this.dfs(element, iteratee, opt);\n\t    }\n\t  },\n\t  // Breadth-first search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t  // `iteratee` is a function of the form `function(element, distance) {}`.\n\t  // where `element` is the currently visited element and `distance` is the distance of that element\n\t  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n\t  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n\t  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n\t  // If `iteratee` explicitly returns `false`, the searching stops.\n\t  bfs: function (element, iteratee, opt = {}) {\n\t    const visited = {};\n\t    const distance = {};\n\t    const queue = [];\n\t    queue.push(element);\n\t    distance[element.id] = 0;\n\t    while (queue.length > 0) {\n\t      var next = queue.shift();\n\t      if (visited[next.id]) continue;\n\t      visited[next.id] = true;\n\t      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n\t      const neighbors = this.getNeighbors(next, opt);\n\t      for (let i = 0, n = neighbors.length; i < n; i++) {\n\t        const neighbor = neighbors[i];\n\t        distance[neighbor.id] = distance[next.id] + 1;\n\t        queue.push(neighbor);\n\t      }\n\t    }\n\t  },\n\t  // Depth-first search.\n\t  // If `opt.deep` is `true`, take into account embedded elements too.\n\t  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t  // `iteratee` is a function of the form `function(element, distance) {}`.\n\t  // If `iteratee` explicitly returns `false`, the search stops.\n\t  dfs: function (element, iteratee, opt = {}) {\n\t    const visited = {};\n\t    const distance = {};\n\t    const queue = [];\n\t    queue.push(element);\n\t    distance[element.id] = 0;\n\t    while (queue.length > 0) {\n\t      const next = queue.pop();\n\t      if (visited[next.id]) continue;\n\t      visited[next.id] = true;\n\t      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n\t      const neighbors = this.getNeighbors(next, opt);\n\t      const lastIndex = queue.length;\n\t      for (let i = 0, n = neighbors.length; i < n; i++) {\n\t        const neighbor = neighbors[i];\n\t        distance[neighbor.id] = distance[next.id] + 1;\n\t        queue.splice(lastIndex, 0, neighbor);\n\t      }\n\t    }\n\t  },\n\t  // Get all the roots of the graph. Time complexity: O(|V|).\n\t  getSources: function () {\n\t    return this.topologyIndex.getSourceNodes().map(nodeId => this.getCell(nodeId));\n\t  },\n\t  // Get all the leafs of the graph. Time complexity: O(|V|).\n\t  getSinks: function () {\n\t    return this.topologyIndex.getSinkNodes().map(nodeId => this.getCell(nodeId));\n\t  },\n\t  // Return `true` if `element` is a root. Time complexity: O(1).\n\t  isSource: function (element) {\n\t    return this.topologyIndex.isSourceNode(element.id);\n\t  },\n\t  // Return `true` if `element` is a leaf. Time complexity: O(1).\n\t  isSink: function (element) {\n\t    return this.topologyIndex.isSinkNode(element.id);\n\t  },\n\t  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n\t  isSuccessor: function (elementA, elementB) {\n\t    var isSuccessor = false;\n\t    this.search(elementA, function (element) {\n\t      if (element === elementB && element !== elementA) {\n\t        isSuccessor = true;\n\t        return false;\n\t      }\n\t    }, {\n\t      outbound: true\n\t    });\n\t    return isSuccessor;\n\t  },\n\t  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n\t  isPredecessor: function (elementA, elementB) {\n\t    var isPredecessor = false;\n\t    this.search(elementA, function (element) {\n\t      if (element === elementB && element !== elementA) {\n\t        isPredecessor = true;\n\t        return false;\n\t      }\n\t    }, {\n\t      inbound: true\n\t    });\n\t    return isPredecessor;\n\t  },\n\t  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n\t  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n\t  // for more details.\n\t  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n\t  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n\t  isNeighbor: function (elementA, elementB, opt) {\n\t    opt = opt || {};\n\t    var inbound = opt.inbound;\n\t    var outbound = opt.outbound;\n\t    if (inbound === undefined && outbound === undefined) {\n\t      inbound = outbound = true;\n\t    }\n\t    var isNeighbor = false;\n\t    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\n\t      // Discard if it is a point.\n\t      if (inbound && has(source, 'id') && source.id === elementB.id) {\n\t        isNeighbor = true;\n\t        return false;\n\t      }\n\n\t      // Discard if it is a point, or if the neighbor was already added.\n\t      if (outbound && has(target, 'id') && target.id === elementB.id) {\n\t        isNeighbor = true;\n\t        return false;\n\t      }\n\t    });\n\t    return isNeighbor;\n\t  },\n\t  // Disconnect links connected to the cell `model`.\n\t  disconnectLinks: function (model, opt) {\n\t    this.getConnectedLinks(model).forEach(function (link) {\n\t      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n\t        x: 0,\n\t        y: 0\n\t      }, opt);\n\t    });\n\t  },\n\t  // Remove links connected to the cell `model` completely.\n\t  removeLinks: function (cell, opt) {\n\t    this.getConnectedLinks(cell).forEach(link => {\n\t      this.layerCollection.removeCell(link, opt);\n\t    });\n\t  },\n\t  // Find all cells at given point\n\n\t  findElementsAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getElements(), point, opt);\n\t  },\n\t  findLinksAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getLinks(), point, opt);\n\t  },\n\t  findCellsAtPoint: function (point, opt) {\n\t    return this._filterAtPoint(this.getCells(), point, opt);\n\t  },\n\t  _filterAtPoint: function (cells, point, opt = {}) {\n\t    return cells.filter(el => el.getBBox({\n\t      rotate: true\n\t    }).containsPoint(point, opt));\n\t  },\n\t  // Find all cells in given area\n\n\t  findElementsInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getElements(), area, opt);\n\t  },\n\t  findLinksInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getLinks(), area, opt);\n\t  },\n\t  findCellsInArea: function (area, opt = {}) {\n\t    return this._filterInArea(this.getCells(), area, opt);\n\t  },\n\t  _filterInArea: function (cells, area, opt = {}) {\n\t    const r = new Rect(area);\n\t    const {\n\t      strict = false\n\t    } = opt;\n\t    const method = strict ? 'containsRect' : 'intersect';\n\t    return cells.filter(el => r[method](el.getBBox({\n\t      rotate: true\n\t    })));\n\t  },\n\t  // Find all cells under the given element.\n\n\t  findElementsUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getElements(), element, opt);\n\t  },\n\t  findLinksUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getLinks(), element, opt);\n\t  },\n\t  findCellsUnderElement: function (element, opt) {\n\t    return this._filterCellsUnderElement(this.getCells(), element, opt);\n\t  },\n\t  _isValidElementUnderElement: function (el1, el2) {\n\t    return el1.id !== el2.id && !el1.isEmbeddedIn(el2);\n\t  },\n\t  _isValidLinkUnderElement: function (link, el) {\n\t    return link.source().id !== el.id && link.target().id !== el.id && !link.isEmbeddedIn(el);\n\t  },\n\t  _validateCellsUnderElement: function (cells, element) {\n\t    return cells.filter(cell => {\n\t      return cell.isLink() ? this._isValidLinkUnderElement(cell, element) : this._isValidElementUnderElement(cell, element);\n\t    });\n\t  },\n\t  _getFindUnderElementGeometry: function (element, searchBy = 'bbox') {\n\t    const bbox = element.getBBox({\n\t      rotate: true\n\t    });\n\t    return searchBy !== 'bbox' ? getRectPoint(bbox, searchBy) : bbox;\n\t  },\n\t  _filterCellsUnderElement: function (cells, element, opt = {}) {\n\t    const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);\n\t    const filteredCells = geometry.type === types.Point ? this._filterAtPoint(cells, geometry) : this._filterInArea(cells, geometry, opt);\n\t    return this._validateCellsUnderElement(filteredCells, element);\n\t  },\n\t  // @deprecated use `findElementsInArea` instead\n\t  findModelsInArea: function (area, opt) {\n\t    return this.findElementsInArea(area, opt);\n\t  },\n\t  // @deprecated use `findElementsAtPoint` instead\n\t  findModelsFromPoint: function (point) {\n\t    return this.findElementsAtPoint(point);\n\t  },\n\t  // @deprecated use `findModelsUnderElement` instead\n\t  findModelsUnderElement: function (element, opt) {\n\t    return this.findElementsUnderElement(element, opt);\n\t  },\n\t  // Return bounding box of all elements.\n\t  getBBox: function () {\n\t    return this.getCellsBBox(this.getCells());\n\t  },\n\t  // Return the bounding box of all cells in array provided.\n\t  getCellsBBox: function (cells, opt = {}) {\n\t    const {\n\t      rotate = true\n\t    } = opt;\n\t    return toArray$1(cells).reduce(function (memo, cell) {\n\t      const rect = cell.getBBox({\n\t        rotate\n\t      });\n\t      if (!rect) return memo;\n\t      if (memo) {\n\t        return memo.union(rect);\n\t      }\n\t      return rect;\n\t    }, null);\n\t  },\n\t  translate: function (dx, dy, opt) {\n\t    // Don't translate cells that are embedded in any other cell.\n\t    var cells = this.getCells().filter(function (cell) {\n\t      return !cell.isEmbedded();\n\t    });\n\t    invoke(cells, 'translate', dx, dy, opt);\n\t    return this;\n\t  },\n\t  resize: function (width, height, opt) {\n\t    return this.resizeCells(width, height, this.getCells(), opt);\n\t  },\n\t  resizeCells: function (width, height, cells, opt) {\n\t    // `getBBox` method returns `null` if no elements provided.\n\t    // i.e. cells can be an array of links\n\t    var bbox = this.getCellsBBox(cells);\n\t    if (bbox) {\n\t      var sx = Math.max(width / bbox.width, 0);\n\t      var sy = Math.max(height / bbox.height, 0);\n\t      invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n\t    }\n\t    return this;\n\t  },\n\t  startBatch: function (name, data) {\n\t    data = data || {};\n\t    this._batches[name] = (this._batches[name] || 0) + 1;\n\t    return this.trigger('batch:start', assign({}, data, {\n\t      batchName: name\n\t    }));\n\t  },\n\t  stopBatch: function (name, data) {\n\t    data = data || {};\n\t    this._batches[name] = (this._batches[name] || 0) - 1;\n\t    return this.trigger('batch:stop', assign({}, data, {\n\t      batchName: name\n\t    }));\n\t  },\n\t  hasActiveBatch: function (name) {\n\t    const batches = this._batches;\n\t    let names;\n\t    if (arguments.length === 0) {\n\t      names = Object.keys(batches);\n\t    } else if (Array.isArray(name)) {\n\t      names = name;\n\t    } else {\n\t      names = [name];\n\t    }\n\t    return names.some(batch => batches[batch] > 0);\n\t  }\n\t}, {\n\t  validations: {\n\t    multiLinks: function (graph, link) {\n\t      // Do not allow multiple links to have the same source and target.\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      if (source.id && target.id) {\n\t        var sourceModel = link.getSourceCell();\n\t        if (sourceModel) {\n\t          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n\t            outbound: true\n\t          });\n\t          var sameLinks = connectedLinks.filter(function (_link) {\n\t            var {\n\t              source: _source,\n\t              target: _target\n\t            } = _link.attributes;\n\t            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n\t          });\n\t          if (sameLinks.length > 1) {\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    },\n\t    linkPinning: function (_graph, link) {\n\t      var {\n\t        source,\n\t        target\n\t      } = link.attributes;\n\t      return source.id && target.id;\n\t    }\n\t  }\n\t});\n\twrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n\n\tconst calcAttributesList = ['transform', 'x', 'y', 'cx', 'cy', 'dx', 'dy', 'x1', 'y1', 'x2', 'y2', 'points', 'd', 'r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];\n\tconst positiveValueList = ['r', 'rx', 'ry', 'width', 'height', 'stroke-width', 'font-size'];\n\tconst calcAttributes = calcAttributesList.reduce((acc, attrName) => {\n\t  acc[attrName] = true;\n\t  return acc;\n\t}, {});\n\tconst positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {\n\t  acc[attrName] = true;\n\t  return acc;\n\t}, {});\n\tfunction evalAttributes(attrs, refBBox) {\n\t  const evalAttrs = {};\n\t  for (let attrName in attrs) {\n\t    if (!attrs.hasOwnProperty(attrName)) continue;\n\t    evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);\n\t  }\n\t  return evalAttrs;\n\t}\n\tfunction evalAttribute(attrName, attrValue, refBBox) {\n\t  if (attrName in calcAttributes && isCalcExpression(attrValue)) {\n\t    let evalAttrValue = evalCalcExpression(attrValue, refBBox);\n\t    if (attrName in positiveValueAttributes) {\n\t      evalAttrValue = Math.max(0, evalAttrValue);\n\t    }\n\t    return evalAttrValue;\n\t  }\n\t  return attrValue;\n\t}\n\n\tconst HighlightingTypes$1 = {\n\t  DEFAULT: 'default',\n\t  EMBEDDING: 'embedding',\n\t  CONNECTING: 'connecting',\n\t  MAGNET_AVAILABILITY: 'magnetAvailability',\n\t  ELEMENT_AVAILABILITY: 'elementAvailability'\n\t};\n\tconst Flags$2 = {\n\t  TOOLS: 'TOOLS'\n\t};\n\n\t// CellView base view and controller.\n\t// --------------------------------------------\n\n\t// This is the base view and controller for `ElementView` and `LinkView`.\n\tconst CellView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  selector: 'root',\n\t  metrics: null,\n\t  className: function () {\n\t    var classNames = ['cell'];\n\t    var type = this.model.get('type');\n\t    if (type) {\n\t      type.toLowerCase().split('.').forEach(function (value, index, list) {\n\t        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n\t      });\n\t    }\n\t    return classNames.join(' ');\n\t  },\n\t  _presentationAttributes: null,\n\t  _flags: null,\n\t  setFlags: function () {\n\t    var flags = {};\n\t    var attributes = {};\n\t    var shift = 0;\n\t    var i, n, label;\n\t    var presentationAttributes = result(this, 'presentationAttributes');\n\t    for (var attribute in presentationAttributes) {\n\t      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n\t      var labels = presentationAttributes[attribute];\n\t      if (!Array.isArray(labels)) labels = [labels];\n\t      for (i = 0, n = labels.length; i < n; i++) {\n\t        label = labels[i];\n\t        var flag = flags[label];\n\t        if (!flag) {\n\t          flag = flags[label] = 1 << shift++;\n\t        }\n\t        attributes[attribute] |= flag;\n\t      }\n\t    }\n\t    var initFlag = result(this, 'initFlag');\n\t    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n\t    for (i = 0, n = initFlag.length; i < n; i++) {\n\t      label = initFlag[i];\n\t      if (!flags[label]) flags[label] = 1 << shift++;\n\t    }\n\n\t    // 26 - 30 are reserved for paper flags\n\t    // 31+ overflows maximal number\n\t    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\t    this._flags = flags;\n\t    this._presentationAttributes = attributes;\n\t  },\n\t  hasFlag: function (flag, label) {\n\t    return flag & this.getFlag(label);\n\t  },\n\t  removeFlag: function (flag, label) {\n\t    return flag ^ flag & this.getFlag(label);\n\t  },\n\t  getFlag: function (label) {\n\t    var flags = this._flags;\n\t    if (!flags) return 0;\n\t    var flag = 0;\n\t    if (Array.isArray(label)) {\n\t      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n\t    } else {\n\t      flag |= flags[label];\n\t    }\n\t    return flag;\n\t  },\n\t  attributes: function () {\n\t    var cell = this.model;\n\t    return {\n\t      'model-id': cell.id,\n\t      'data-type': cell.attributes.type\n\t    };\n\t  },\n\t  constructor: function (options) {\n\t    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n\t    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n\t    // still be associated to the same object among all those clients. This is necessary for real-time\n\t    // collaboration mechanism.\n\t    options.id = options.id || guid(this);\n\t    View.call(this, options);\n\t  },\n\t  initialize: function () {\n\t    this.setFlags();\n\t    View.prototype.initialize.apply(this, arguments);\n\t    this.cleanNodesCache();\n\t    this.startListening();\n\t  },\n\t  startListening: function () {\n\t    this.listenTo(this.model, 'change', this.onAttributesChange);\n\t  },\n\t  onAttributesChange: function (model, opt) {\n\t    var flag = model.getChangeFlag(this._presentationAttributes);\n\t    if (opt.updateHandled || !flag) return;\n\t    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n\t    // TODO: tool changes does not need to be sync\n\t    // Fix Segments tools\n\t    if (opt.tool) opt.async = false;\n\t    this.requestUpdate(flag, opt);\n\t  },\n\t  requestUpdate: function (flags, opt) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    if (paper && flags > 0) {\n\t      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n\t    }\n\t  },\n\t  parseDOMJSON: function (markup, root) {\n\t    var doc = parseDOMJSON(markup);\n\t    var selectors = doc.selectors;\n\t    var groups = doc.groupSelectors;\n\t    for (var group in groups) {\n\t      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n\t      selectors[group] = groups[group];\n\t    }\n\t    if (root) {\n\t      var rootSelector = this.selector;\n\t      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n\t      selectors[rootSelector] = root;\n\t    }\n\t    return {\n\t      fragment: doc.fragment,\n\t      selectors: selectors\n\t    };\n\t  },\n\t  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n\t  // Example: `can('labelMove')`.\n\t  can: function (feature) {\n\t    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n\t    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n\t  },\n\t  findBySelector: function (selector, root, selectors) {\n\t    // These are either descendants of `this.$el` of `this.$el` itself.\n\t    // `.` is a special selector used to select the wrapping `<g>` element.\n\t    if (!selector || selector === '.') return [root];\n\t    if (selectors) {\n\t      var nodes = selectors[selector];\n\t      if (nodes) {\n\t        if (Array.isArray(nodes)) return nodes;\n\t        return [nodes];\n\t      }\n\t    }\n\n\t    // Maintaining backwards compatibility\n\t    // e.g. `circle:first` would fail with querySelector() call\n\t    if (this.useCSSSelectors) return $(root).find(selector).toArray();\n\t    return [];\n\t  },\n\t  findNodes: function (selector) {\n\t    return this.findBySelector(selector, this.el, this.selectors);\n\t  },\n\t  findNode: function (selector) {\n\t    const [node = null] = this.findNodes(selector);\n\t    return node;\n\t  },\n\t  notify: function (eventName) {\n\t    if (this.paper) {\n\t      var args = Array.prototype.slice.call(arguments, 1);\n\n\t      // Trigger the event on both the element itself and also on the paper.\n\t      this.trigger.apply(this, [eventName].concat(args));\n\n\t      // Paper event handlers receive the view object as the first argument.\n\t      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n\t    }\n\t  },\n\t  getBBox: function (opt) {\n\t    var bbox;\n\t    if (opt && opt.useModelGeometry) {\n\t      var model = this.model;\n\t      bbox = model.getBBox().bbox(model.angle());\n\t    } else {\n\t      bbox = this.getNodeBBox(this.el);\n\t    }\n\t    return this.paper.localToPaperRect(bbox);\n\t  },\n\t  getNodeBBox: function (magnet) {\n\t    const rect = this.getNodeBoundingRect(magnet);\n\t    const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n\t    const magnetMatrix = this.getNodeMatrix(magnet);\n\t    return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n\t  },\n\t  getNodeRotateMatrix(node) {\n\t    if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n\t      // Rotate transformation is applied to all nodes when no rotatableGroup\n\t      // is present or to nodes inside the rotatableGroup only.\n\t      return this.getRootRotateMatrix();\n\t    }\n\t    // Nodes outside the rotatable group\n\t    return V.createSVGMatrix();\n\t  },\n\t  getNodeUnrotatedBBox: function (magnet) {\n\t    var rect = this.getNodeBoundingRect(magnet);\n\t    var magnetMatrix = this.getNodeMatrix(magnet);\n\t    var translateMatrix = this.getRootTranslateMatrix();\n\t    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n\t  },\n\t  getRootTranslateMatrix: function () {\n\t    var model = this.model;\n\t    var position = model.position();\n\t    var mt = V.createSVGMatrix().translate(position.x, position.y);\n\t    return mt;\n\t  },\n\t  getRootRotateMatrix: function () {\n\t    var mr = V.createSVGMatrix();\n\t    var model = this.model;\n\t    var angle = model.angle();\n\t    if (angle) {\n\t      var bbox = model.getBBox();\n\t      var cx = bbox.width / 2;\n\t      var cy = bbox.height / 2;\n\t      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t    }\n\t    return mr;\n\t  },\n\t  _notifyHighlight: function (eventName, el, opt = {}) {\n\t    const {\n\t      el: rootNode\n\t    } = this;\n\t    let node;\n\t    if (typeof el === 'string') {\n\t      node = this.findNode(el) || rootNode;\n\t    } else {\n\t      [node = rootNode] = this.$(el);\n\t    }\n\t    // set partial flag if the highlighted element is not the entire view.\n\t    opt.partial = node !== rootNode;\n\t    // translate type flag into a type string\n\t    if (opt.type === undefined) {\n\t      let type;\n\t      switch (true) {\n\t        case opt.embedding:\n\t          type = HighlightingTypes$1.EMBEDDING;\n\t          break;\n\t        case opt.connecting:\n\t          type = HighlightingTypes$1.CONNECTING;\n\t          break;\n\t        case opt.magnetAvailability:\n\t          type = HighlightingTypes$1.MAGNET_AVAILABILITY;\n\t          break;\n\t        case opt.elementAvailability:\n\t          type = HighlightingTypes$1.ELEMENT_AVAILABILITY;\n\t          break;\n\t        default:\n\t          type = HighlightingTypes$1.DEFAULT;\n\t          break;\n\t      }\n\t      opt.type = type;\n\t    }\n\t    this.notify(eventName, node, opt);\n\t    return this;\n\t  },\n\t  highlight: function (el, opt) {\n\t    return this._notifyHighlight('cell:highlight', el, opt);\n\t  },\n\t  unhighlight: function (el, opt = {}) {\n\t    return this._notifyHighlight('cell:unhighlight', el, opt);\n\t  },\n\t  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n\t  // an element found, return the root element of the cell view.\n\t  findMagnet: function (el) {\n\t    const root = this.el;\n\t    let magnet = this.$(el)[0];\n\t    if (!magnet) {\n\t      magnet = root;\n\t    }\n\t    do {\n\t      const magnetAttribute = magnet.getAttribute('magnet');\n\t      const isMagnetRoot = magnet === root;\n\t      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n\t        return magnet;\n\t      }\n\t      if (isMagnetRoot) {\n\t        // If the overall cell has set `magnet === false`, then return `undefined` to\n\t        // announce there is no magnet found for this cell.\n\t        // This is especially useful to set on cells that have 'ports'. In this case,\n\t        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n\t        return undefined;\n\t      }\n\t      magnet = magnet.parentNode;\n\t    } while (magnet);\n\t    return undefined;\n\t  },\n\t  findProxyNode: function (el, type) {\n\t    el || (el = this.el);\n\t    const nodeSelector = el.getAttribute(`${type}-selector`);\n\t    if (nodeSelector) {\n\t      const proxyNode = this.findNode(nodeSelector);\n\t      if (proxyNode) return proxyNode;\n\t    }\n\t    return el;\n\t  },\n\t  // Construct a unique selector for the `el` element within this view.\n\t  // `prevSelector` is being collected through the recursive call.\n\t  // No value for `prevSelector` is expected when using this method.\n\t  getSelector: function (el, prevSelector) {\n\t    var selector;\n\t    if (el === this.el) {\n\t      if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n\t      return selector;\n\t    }\n\t    if (el) {\n\t      var nthChild = V(el).index() + 1;\n\t      selector = el.tagName + ':nth-child(' + nthChild + ')';\n\t      if (prevSelector) {\n\t        selector += ' > ' + prevSelector;\n\t      }\n\t      selector = this.getSelector(el.parentNode, selector);\n\t    }\n\t    return selector;\n\t  },\n\t  addLinkFromMagnet: function (magnet, x, y) {\n\t    var paper = this.paper;\n\t    var graph = paper.model;\n\t    var link = paper.getDefaultLink(this, magnet);\n\t    link.set({\n\t      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n\t      target: {\n\t        x: x,\n\t        y: y\n\t      }\n\t    }).addTo(graph, {\n\t      async: false,\n\t      ui: true\n\t    });\n\t    return link.findView(paper);\n\t  },\n\t  getLinkEnd: function (magnet, ...args) {\n\t    const model = this.model;\n\t    const id = model.id;\n\t    // Find a node with the `port` attribute set on it.\n\t    const portNode = this.findAttributeNode('port', magnet);\n\t    // Find a unique `selector` of the element under pointer that is a magnet.\n\t    const selector = magnet.getAttribute('joint-selector');\n\t    const end = {\n\t      id: id\n\t    };\n\t    if (selector != null) end.magnet = selector;\n\t    if (portNode != null) {\n\t      let port = portNode.getAttribute('port');\n\t      if (portNode.getAttribute('port-id-type') === 'number') {\n\t        port = parseInt(port, 10);\n\t      }\n\t      end.port = port;\n\t      if (!model.hasPort(port) && !selector) {\n\t        // port created via the `port` attribute (not API)\n\t        end.selector = this.getSelector(magnet);\n\t      }\n\t    } else if (selector == null && this.el !== magnet) {\n\t      end.selector = this.getSelector(magnet);\n\t    }\n\t    return this.customizeLinkEnd(end, magnet, ...args);\n\t  },\n\t  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      connectionStrategy\n\t    } = paper.options;\n\t    if (typeof connectionStrategy === 'function') {\n\t      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n\t      if (strategy) return strategy;\n\t    }\n\t    return end;\n\t  },\n\t  getMagnetFromLinkEnd: function (end) {\n\t    var port = end.port;\n\t    var selector = end.magnet;\n\t    var model = this.model;\n\t    var magnet;\n\t    if (port != null && model.isElement() && model.hasPort(port)) {\n\t      magnet = this.findPortNode(port, selector) || this.el;\n\t    } else {\n\t      if (!selector) selector = end.selector;\n\t      if (!selector && port != null) {\n\t        // link end has only `id` and `port` property referencing\n\t        // a port created via the `port` attribute (not API).\n\t        selector = '[port=\"' + port + '\"]';\n\t      }\n\t      magnet = this.findNode(selector);\n\t    }\n\t    return this.findProxyNode(magnet, 'magnet');\n\t  },\n\t  dragLinkStart: function (evt, magnet, x, y) {\n\t    this.model.startBatch('add-link');\n\t    const linkView = this.addLinkFromMagnet(magnet, x, y);\n\t    // backwards compatibility events\n\t    linkView.notifyPointerdown(evt, x, y);\n\t    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n\t      whenNotAllowed: 'remove'\n\t    }));\n\t    this.eventData(evt, {\n\t      linkView\n\t    });\n\t  },\n\t  dragLink: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var linkView = data.linkView;\n\t    if (linkView) {\n\t      linkView.pointermove(evt, x, y);\n\t    } else {\n\t      var paper = this.paper;\n\t      var magnetThreshold = paper.options.magnetThreshold;\n\t      var currentTarget = this.getEventTarget(evt);\n\t      var targetMagnet = data.targetMagnet;\n\t      if (magnetThreshold === 'onleave') {\n\t        // magnetThreshold when the pointer leaves the magnet\n\t        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n\t      } else {\n\t        // magnetThreshold defined as a number of movements\n\t        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n\t      }\n\t      this.dragLinkStart(evt, targetMagnet, x, y);\n\t    }\n\t  },\n\t  dragLinkEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var linkView = data.linkView;\n\t    if (!linkView) return;\n\t    linkView.pointerup(evt, x, y);\n\t    this.model.stopBatch('add-link');\n\t  },\n\t  getAttributeDefinition: function (attrName) {\n\t    return this.model.constructor.getAttributeDefinition(attrName);\n\t  },\n\t  setNodeAttributes: function (node, attrs) {\n\t    if (!isEmpty(attrs)) {\n\t      if (node instanceof SVGElement) {\n\t        V(node).attr(attrs);\n\t      } else {\n\t        $(node).attr(attrs);\n\t      }\n\t    }\n\t  },\n\t  processNodeAttributes: function (node, attrs) {\n\t    var attrName, attrVal, def, i, n;\n\t    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n\t    var relatives = [];\n\t    const rawAttrs = {};\n\t    for (attrName in attrs) {\n\t      if (!attrs.hasOwnProperty(attrName)) continue;\n\t      rawAttrs[V.attributeNames[attrName]] = attrs[attrName];\n\t    }\n\t    // divide the attributes between normal and special\n\t    for (attrName in rawAttrs) {\n\t      if (!rawAttrs.hasOwnProperty(attrName)) continue;\n\t      attrVal = rawAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      if (def) {\n\t        if (attrVal === null) {\n\t          // Assign the unset attribute name.\n\t          let unsetAttrName;\n\t          if (isFunction(def.unset)) {\n\t            unsetAttrName = def.unset.call(this, node, rawAttrs, this);\n\t          } else {\n\t            unsetAttrName = def.unset;\n\t          }\n\t          if (!unsetAttrName && isString(def.set)) {\n\t            // We unset an alias attribute.\n\t            unsetAttrName = def.set;\n\t          }\n\t          if (!unsetAttrName) {\n\t            // There is no alias for the attribute. We unset the attribute itself.\n\t            unsetAttrName = attrName;\n\t          }\n\t          // Unset the attribute.\n\t          if (isString(unsetAttrName) && unsetAttrName) {\n\t            // Unset a single attribute.\n\t            normalAttrs || (normalAttrs = {});\n\t            // values takes precedence over unset values\n\t            if (unsetAttrName in normalAttrs) continue;\n\t            normalAttrs[unsetAttrName] = attrVal;\n\t          } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {\n\t            // Unset multiple attributes.\n\t            normalAttrs || (normalAttrs = {});\n\t            for (i = 0, n = unsetAttrName.length; i < n; i++) {\n\t              const attrName = unsetAttrName[i];\n\t              // values takes precedence over unset values\n\t              if (attrName in normalAttrs) continue;\n\t              normalAttrs[attrName] = attrVal;\n\t            }\n\t          }\n\t          // The unset value is neither a string nor an array.\n\t          // The attribute is not unset.\n\t        } else {\n\t          if (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {\n\t            if (isString(def.set)) {\n\t              // An alias e.g 'xlink:href' -> 'href'\n\t              normalAttrs || (normalAttrs = {});\n\t              normalAttrs[def.set] = attrVal;\n\t            }\n\t            relatives.push(attrName, def);\n\t          } else {\n\t            normalAttrs || (normalAttrs = {});\n\t            normalAttrs[attrName] = attrVal;\n\t          }\n\t        }\n\t      } else {\n\t        normalAttrs || (normalAttrs = {});\n\t        normalAttrs[attrName] = attrVal;\n\t      }\n\t    }\n\n\t    // handle the rest of attributes via related method\n\t    // from the special attributes namespace.\n\t    for (i = 0, n = relatives.length; i < n; i += 2) {\n\t      attrName = relatives[i];\n\t      def = relatives[i + 1];\n\t      attrVal = attrs[attrName];\n\t      if (isFunction(def.set)) {\n\t        setAttrs || (setAttrs = {});\n\t        setAttrs[attrName] = attrVal;\n\t      }\n\t      if (isFunction(def.position)) {\n\t        positionAttrs || (positionAttrs = {});\n\t        positionAttrs[attrName] = attrVal;\n\t      }\n\t      if (isFunction(def.offset)) {\n\t        offsetAttrs || (offsetAttrs = {});\n\t        offsetAttrs[attrName] = attrVal;\n\t      }\n\t    }\n\t    return {\n\t      raw: rawAttrs,\n\t      normal: normalAttrs,\n\t      set: setAttrs,\n\t      position: positionAttrs,\n\t      offset: offsetAttrs\n\t    };\n\t  },\n\t  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n\t    opt || (opt = {});\n\t    var attrName, attrVal, def;\n\t    var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);\n\t    var nodeAttrs = attrs.normal || {};\n\t    for (const nodeAttrName in nodeAttrs) {\n\t      nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n\t    }\n\t    var setAttrs = attrs.set;\n\t    var positionAttrs = attrs.position;\n\t    var offsetAttrs = attrs.offset;\n\t    for (attrName in setAttrs) {\n\t      attrVal = evalAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      // SET - set function should return attributes to be set on the node,\n\t      // which will affect the node dimensions based on the reference bounding\n\t      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\t      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n\t      if (isObject(setResult)) {\n\t        assign(nodeAttrs, setResult);\n\t      } else if (setResult !== undefined) {\n\t        nodeAttrs[attrName] = setResult;\n\t      }\n\t    }\n\t    if (node instanceof HTMLElement) {\n\t      // TODO: setting the `transform` attribute on HTMLElements\n\t      // via `node.style.transform = 'matrix(...)';` would introduce\n\t      // a breaking change (e.g. basic.TextBlock).\n\t      this.setNodeAttributes(node, nodeAttrs);\n\t      return;\n\t    }\n\n\t    // The final translation of the subelement.\n\t    var nodeTransform = nodeAttrs.transform;\n\t    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n\t    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\t    if (nodeTransform) {\n\t      nodeAttrs = omit(nodeAttrs, 'transform');\n\t      nodeMatrix.e = nodeMatrix.f = 0;\n\t    }\n\n\t    // Calculate node scale determined by the scalable group\n\t    // only if later needed.\n\t    var sx, sy, translation;\n\t    if (positionAttrs || offsetAttrs) {\n\t      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n\t      sx = nodeScale.sx;\n\t      sy = nodeScale.sy;\n\t    }\n\t    var positioned = false;\n\t    for (attrName in positionAttrs) {\n\t      attrVal = evalAttrs[attrName];\n\t      def = this.getAttributeDefinition(attrName);\n\t      // POSITION - position function should return a point from the\n\t      // reference bounding box. The default position of the node is x:0, y:0 of\n\t      // the reference bounding box or could be further specify by some\n\t      // SVG attributes e.g. `x`, `y`\n\t      translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n\t      if (translation) {\n\t        nodePosition.offset(Point(translation).scale(sx, sy));\n\t        positioned || (positioned = true);\n\t      }\n\t    }\n\n\t    // The node bounding box could depend on the `size` set from the previous loop.\n\t    // Here we know, that all the size attributes have been already set.\n\t    this.setNodeAttributes(node, nodeAttrs);\n\t    var offseted = false;\n\t    if (offsetAttrs) {\n\t      // Check if the node is visible\n\t      var nodeBoundingRect = this.getNodeBoundingRect(node);\n\t      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n\t        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\t        for (attrName in offsetAttrs) {\n\t          attrVal = evalAttrs[attrName];\n\t          def = this.getAttributeDefinition(attrName);\n\t          // OFFSET - offset function should return a point from the element\n\t          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n\t          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\t          translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n\t          if (translation) {\n\t            nodePosition.offset(Point(translation).scale(sx, sy));\n\t            offseted || (offseted = true);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    // Do not touch node's transform attribute if there is no transformation applied.\n\t    if (nodeTransform !== undefined || positioned || offseted) {\n\t      // Round the coordinates to 1 decimal point.\n\t      nodePosition.round(1);\n\t      nodeMatrix.e = nodePosition.x;\n\t      nodeMatrix.f = nodePosition.y;\n\t      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n\t      // TODO: store nodeMatrix metrics?\n\t    }\n\t  },\n\t  getNodeScale: function (node, scalableNode) {\n\t    // Check if the node is a descendant of the scalable group.\n\t    var sx, sy;\n\t    if (scalableNode && scalableNode.contains(node)) {\n\t      var scale = scalableNode.scale();\n\t      sx = 1 / scale.sx;\n\t      sy = 1 / scale.sy;\n\t    } else {\n\t      sx = 1;\n\t      sy = 1;\n\t    }\n\t    return {\n\t      sx: sx,\n\t      sy: sy\n\t    };\n\t  },\n\t  cleanNodesCache: function () {\n\t    this.metrics = {};\n\t  },\n\t  cleanNodeCache: function (node) {\n\t    const id = node.id;\n\t    if (!id) return;\n\t    delete this.metrics[id];\n\t  },\n\t  nodeCache: function (magnet) {\n\t    var metrics = this.metrics;\n\t    // Don't use cache? It most likely a custom view with overridden update.\n\t    if (!metrics) return {};\n\t    var id = V.ensureId(magnet);\n\t    var value = metrics[id];\n\t    if (!value) value = metrics[id] = {};\n\t    return value;\n\t  },\n\t  getNodeData: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (!metrics.data) metrics.data = {};\n\t    return metrics.data;\n\t  },\n\t  getNodeBoundingRect: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (metrics.boundingRect === undefined) {\n\t      const {\n\t        measureNode\n\t      } = this.paper.options;\n\t      if (typeof measureNode === 'function') {\n\t        // Measure the node bounding box using the paper's measureNode method.\n\t        metrics.boundingRect = measureNode(magnet, this);\n\t      } else {\n\t        metrics.boundingRect = V(magnet).getBBox();\n\t      }\n\t    }\n\t    return new Rect(metrics.boundingRect);\n\t  },\n\t  getNodeMatrix: function (magnet) {\n\t    const metrics = this.nodeCache(magnet);\n\t    if (metrics.magnetMatrix === undefined) {\n\t      const {\n\t        rotatableNode,\n\t        el\n\t      } = this;\n\t      let target;\n\t      if (rotatableNode && rotatableNode.contains(magnet)) {\n\t        target = rotatableNode;\n\t      } else {\n\t        target = el;\n\t      }\n\t      metrics.magnetMatrix = V(magnet).getTransformToElement(target, {\n\t        // We use `safe` mode if the magnet is not visible (not in the DOM render tree).\n\t        // The browser would not be able to calculate the transformation matrix\n\t        // using `getScreenCTM()` method.\n\t        safe: !magnet.checkVisibility()\n\t      });\n\t    }\n\t    return V.createSVGMatrix(metrics.magnetMatrix);\n\t  },\n\t  getNodeShape: function (magnet) {\n\t    var metrics = this.nodeCache(magnet);\n\t    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n\t    return metrics.geometryShape.clone();\n\t  },\n\t  isNodeConnection: function (node) {\n\t    return this.model.isLink() && (!node || node === this.el);\n\t  },\n\t  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n\t    var i, n, nodeAttrs, nodeId;\n\t    var nodesAttrs = {};\n\t    var mergeIds = [];\n\t    for (var selector in attrs) {\n\t      if (!attrs.hasOwnProperty(selector)) continue;\n\t      nodeAttrs = attrs[selector];\n\t      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n\t      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\t      for (i = 0, n = selected.length; i < n; i++) {\n\t        var node = selected[i];\n\t        nodeId = V.ensureId(node);\n\t        // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n\t        // groupSelector referencing a single node is not \"unique\"\n\t        var unique = selectors && selectors[selector] === node;\n\t        var prevNodeAttrs = nodesAttrs[nodeId];\n\t        if (prevNodeAttrs) {\n\t          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n\t          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n\t          if (!prevNodeAttrs.array) {\n\t            mergeIds.push(nodeId);\n\t            prevNodeAttrs.array = true;\n\t            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n\t            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n\t          }\n\t          var attributes = prevNodeAttrs.attributes;\n\t          var selectedLength = prevNodeAttrs.selectedLength;\n\t          if (unique) {\n\t            // node referenced by `selector`\n\t            attributes.unshift(nodeAttrs);\n\t            selectedLength.unshift(-1);\n\t          } else {\n\t            // node referenced by `groupSelector`\n\t            var sortIndex = sortedIndex(selectedLength, n);\n\t            attributes.splice(sortIndex, 0, nodeAttrs);\n\t            selectedLength.splice(sortIndex, 0, n);\n\t          }\n\t        } else {\n\t          nodesAttrs[nodeId] = {\n\t            attributes: nodeAttrs,\n\t            selectedLength: unique ? -1 : n,\n\t            node: node,\n\t            array: false\n\t          };\n\t        }\n\t      }\n\t    }\n\t    for (i = 0, n = mergeIds.length; i < n; i++) {\n\t      nodeId = mergeIds[i];\n\t      nodeAttrs = nodesAttrs[nodeId];\n\t      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n\t    }\n\t    return nodesAttrs;\n\t  },\n\t  getEventTarget: function (evt, opt = {}) {\n\t    const {\n\t      target,\n\t      type,\n\t      clientX = 0,\n\t      clientY = 0\n\t    } = evt;\n\t    if (\n\t    // Explicitly defined `fromPoint` option\n\t    opt.fromPoint ||\n\t    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n\t    // It holds the element when a touchstart triggered.\n\t    type === 'touchmove' || type === 'touchend' ||\n\t    // Pointermove/Pointerup event with the pointer captured\n\t    'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {\n\t      return document.elementFromPoint(clientX, clientY);\n\t    }\n\t    return target;\n\t  },\n\t  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n\t  // unless `attrs` parameter was passed.\n\t  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n\t    opt || (opt = {});\n\t    opt.rootBBox || (opt.rootBBox = Rect());\n\t    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n\t    // Cache table for query results and bounding box calculation.\n\t    // Note that `selectorCache` needs to be invalidated for all\n\t    // `updateAttributes` calls, as the selectors might pointing\n\t    // to nodes designated by an attribute or elements dynamically\n\t    // created.\n\t    var selectorCache = {};\n\t    var bboxCache = {};\n\t    var relativeItems = [];\n\t    var relativeRefItems = [];\n\t    var item, node, nodeAttrs, nodeData, processedAttrs;\n\t    var roAttrs = opt.roAttributes;\n\t    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n\t    // `nodesAttrs` are different from all attributes, when\n\t    // rendering only  attributes sent to this method.\n\t    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n\t    for (var nodeId in nodesAttrs) {\n\t      nodeData = nodesAttrs[nodeId];\n\t      nodeAttrs = nodeData.attributes;\n\t      node = nodeData.node;\n\t      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\t      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n\t        // Set all the normal attributes right on the SVG/HTML element.\n\t        this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));\n\t      } else {\n\t        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n\t        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n\t        var refNode;\n\t        if (refSelector) {\n\t          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\t          if (!refNode) {\n\t            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n\t          }\n\t        } else {\n\t          refNode = null;\n\t        }\n\t        item = {\n\t          node: node,\n\t          refNode: refNode,\n\t          processedAttributes: processedAttrs,\n\t          allAttributes: nodeAllAttrs\n\t        };\n\t        if (refNode) {\n\t          // If an element in the list is positioned relative to this one, then\n\t          // we want to insert this one before it in the list.\n\t          var itemIndex = relativeRefItems.findIndex(function (item) {\n\t            return item.refNode === node;\n\t          });\n\t          if (itemIndex > -1) {\n\t            relativeRefItems.splice(itemIndex, 0, item);\n\t          } else {\n\t            relativeRefItems.push(item);\n\t          }\n\t        } else {\n\t          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n\t          // The order of no-ref-items is not specified/important.\n\t          relativeItems.push(item);\n\t        }\n\t      }\n\t    }\n\t    relativeItems.push(...relativeRefItems);\n\t    for (let i = 0, n = relativeItems.length; i < n; i++) {\n\t      item = relativeItems[i];\n\t      node = item.node;\n\t      refNode = item.refNode;\n\n\t      // Find the reference element bounding box. If no reference was provided, we\n\t      // use the optional bounding box.\n\t      const refNodeId = refNode ? V.ensureId(refNode) : '';\n\t      let refBBox = bboxCache[refNodeId];\n\t      if (!refBBox) {\n\t        if (refNode) {\n\t          // Get the bounding box of the reference element using to the common ancestor\n\t          // transformation space.\n\t          //\n\t          // @example 1\n\t          // <g transform=\"translate(11, 13)\">\n\t          //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n\t          //     <rect @selector=\"a\"/>\n\t          // </g>\n\t          //\n\t          // In this case, the reference bounding box can not be affected\n\t          // by the `transform` attribute of the `<g>` element,\n\t          // because the exact transformation will be applied to the `a` element\n\t          // as well as to the `b` element.\n\t          //\n\t          // @example 2\n\t          // <g transform=\"translate(11, 13)\">\n\t          //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n\t          // </g>\n\t          // <rect @selector=\"a\"/>\n\t          //\n\t          // In this case, the reference bounding box have to be affected by the\n\t          // `transform` attribute of the `<g>` element, because the `a` element\n\t          // is not descendant of the `<g>` element and will not be affected\n\t          // by the transformation.\n\t          const refRect = this.getNodeBoundingRect(refNode);\n\t          const refTMatrix = V(refNode).getTransformToElement(V.getCommonAncestor(node, refNode));\n\t          refBBox = V.transformRect(refRect, refTMatrix);\n\t        } else {\n\t          refBBox = opt.rootBBox;\n\t        }\n\t        bboxCache[refNodeId] = refBBox;\n\t      }\n\t      if (roAttrs) {\n\t        // if there was a special attribute affecting the position amongst passed-in attributes\n\t        // we have to merge it with the rest of the element's attributes as they are necessary\n\t        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n\t        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n\t        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\t      } else {\n\t        processedAttrs = item.processedAttributes;\n\t      }\n\t      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n\t    }\n\t  },\n\t  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n\t    processedAttrs.set || (processedAttrs.set = {});\n\t    processedAttrs.position || (processedAttrs.position = {});\n\t    processedAttrs.offset || (processedAttrs.offset = {});\n\t    assign(processedAttrs.set, roProcessedAttrs.set);\n\t    assign(processedAttrs.position, roProcessedAttrs.position);\n\t    assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n\t    // Handle also the special transform property.\n\t    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\t    if (transform !== undefined && roProcessedAttrs.normal) {\n\t      roProcessedAttrs.normal.transform = transform;\n\t    }\n\t    processedAttrs.normal = roProcessedAttrs.normal;\n\t  },\n\t  // Lifecycle methods\n\n\t  // Called when the view is attached to the DOM,\n\t  // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n\t  // or `paper.options.viewport` returning `true` (isInitialMount === false).\n\t  onMount(isInitialMount) {\n\t    if (isInitialMount) return;\n\t    this.mountTools();\n\t    HighlighterView.mount(this);\n\t  },\n\t  // Called when the view is detached from the DOM,\n\t  // as result of `paper.options.viewport` returning `false`.\n\t  onDetach() {\n\t    this.unmountTools();\n\t    HighlighterView.unmount(this);\n\t  },\n\t  // Called when the view is removed from the DOM\n\t  // as result of `cell.remove()`.\n\t  onRemove: function () {\n\t    this.removeTools();\n\t    this.removeHighlighters();\n\t  },\n\t  _toolsView: null,\n\t  hasTools: function (name) {\n\t    var toolsView = this._toolsView;\n\t    if (!toolsView) return false;\n\t    if (!name) return true;\n\t    return toolsView.getName() === name;\n\t  },\n\t  addTools: function (toolsView) {\n\t    this.removeTools();\n\t    if (toolsView) {\n\t      this._toolsView = toolsView;\n\t      toolsView.configure({\n\t        relatedView: this\n\t      });\n\t      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n\t    }\n\t    return this;\n\t  },\n\t  unmountTools() {\n\t    const toolsView = this._toolsView;\n\t    if (toolsView) toolsView.unmount();\n\t    return this;\n\t  },\n\t  mountTools() {\n\t    const toolsView = this._toolsView;\n\t    // Prevent unnecessary re-appending of the tools.\n\t    if (toolsView && !toolsView.isMounted()) toolsView.mount();\n\t    return this;\n\t  },\n\t  updateTools: function (opt) {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.update(opt);\n\t    return this;\n\t  },\n\t  removeTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) {\n\t      toolsView.remove();\n\t      this._toolsView = null;\n\t    }\n\t    return this;\n\t  },\n\t  hideTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.hide();\n\t    return this;\n\t  },\n\t  showTools: function () {\n\t    var toolsView = this._toolsView;\n\t    if (toolsView) toolsView.show();\n\t    return this;\n\t  },\n\t  onToolEvent: function (event) {\n\t    switch (event) {\n\t      case 'remove':\n\t        this.removeTools();\n\t        break;\n\t      case 'hide':\n\t        this.hideTools();\n\t        break;\n\t      case 'show':\n\t        this.showTools();\n\t        break;\n\t    }\n\t  },\n\t  removeHighlighters: function () {\n\t    HighlighterView.remove(this);\n\t  },\n\t  updateHighlighters: function (dirty = false) {\n\t    HighlighterView.update(this, null, dirty);\n\t  },\n\t  transformHighlighters: function () {\n\t    HighlighterView.transform(this);\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  preventDefaultInteraction(evt) {\n\t    this.eventData(evt, {\n\t      defaultInteractionPrevented: true\n\t    });\n\t  },\n\t  isDefaultInteractionPrevented(evt) {\n\t    const {\n\t      defaultInteractionPrevented = false\n\t    } = this.eventData(evt);\n\t    return defaultInteractionPrevented;\n\t  },\n\t  // Interaction is handled by the paper and delegated to the view in interest.\n\t  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n\t  // If necessary, real coordinates can be obtained from the `evt` event object.\n\n\t  // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n\t  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n\t  pointerdblclick: function (evt, x, y) {\n\t    this.notify('cell:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    this.notify('cell:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    this.notify('cell:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    const {\n\t      model\n\t    } = this;\n\t    const {\n\t      graph\n\t    } = model;\n\t    if (graph) {\n\t      model.startBatch('pointer');\n\t      this.eventData(evt, {\n\t        graph\n\t      });\n\t    }\n\t    this.notify('cell:pointerdown', evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    this.notify('cell:pointermove', evt, x, y);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    const {\n\t      graph\n\t    } = this.eventData(evt);\n\t    this.notify('cell:pointerup', evt, x, y);\n\t    if (graph) {\n\t      // we don't want to trigger event on model as model doesn't\n\t      // need to be member of collection anymore (remove)\n\t      graph.stopBatch('pointer', {\n\t        cell: this.model\n\t      });\n\t    }\n\t  },\n\t  mouseover: function (evt) {\n\t    this.notify('cell:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    this.notify('cell:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    this.notify('cell:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    this.notify('cell:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    this.notify('cell:mousewheel', evt, x, y, delta);\n\t  },\n\t  onevent: function (evt, eventName, x, y) {\n\t    this.notify(eventName, evt, x, y);\n\t  },\n\t  onmagnet: function () {\n\n\t    // noop\n\t  },\n\t  magnetpointerdblclick: function () {\n\n\t    // noop\n\t  },\n\t  magnetcontextmenu: function () {\n\n\t    // noop\n\t  },\n\t  checkMouseleave(evt) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    if (paper.isAsync()) {\n\t      // Make sure the source/target views are updated before this view.\n\t      // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n\t      // The connected cells could be links as well. In that case, we would\n\t      // need to recursively go through all the connected links and update\n\t      // their source/target views as well.\n\t      if (model.isLink()) {\n\t        // The `this.sourceView` and `this.targetView` might not be updated yet.\n\t        // We need to find the view by the model.\n\t        const sourceElement = model.getSourceElement();\n\t        if (sourceElement) {\n\t          const sourceView = paper.findViewByModel(sourceElement);\n\t          if (sourceView) {\n\t            paper.dumpView(sourceView);\n\t            paper.checkViewVisibility(sourceView);\n\t          }\n\t        }\n\t        const targetElement = model.getTargetElement();\n\t        if (targetElement) {\n\t          const targetView = paper.findViewByModel(targetElement);\n\t          if (targetView) {\n\t            paper.dumpView(targetView);\n\t            paper.checkViewVisibility(targetView);\n\t          }\n\t        }\n\t      }\n\t      // Do the updates of the current view synchronously now\n\t      paper.dumpView(this);\n\t      paper.checkViewVisibility(this);\n\t    }\n\t    const target = this.getEventTarget(evt, {\n\t      fromPoint: true\n\t    });\n\t    const view = paper.findView(target);\n\t    if (view === this) return;\n\t    // Leaving the current view\n\t    this.mouseleave(evt);\n\t    if (!view) return;\n\t    // Entering another view\n\t    view.mouseenter(evt);\n\t  },\n\t  setInteractivity: function (value) {\n\t    this.options.interactive = value;\n\t  },\n\t  isIntersecting: function (geometryShape, geometryData) {\n\t    return intersection$1.exists(geometryShape, this.getNodeBBox(this.el), geometryData);\n\t  },\n\t  isEnclosedIn: function (geometryRect) {\n\t    return geometryRect.containsRect(this.getNodeBBox(this.el));\n\t  },\n\t  isInArea: function (geometryRect, options = {}) {\n\t    if (options.strict) {\n\t      return this.isEnclosedIn(geometryRect);\n\t    }\n\t    return this.isIntersecting(geometryRect);\n\t  },\n\t  isAtPoint: function (point, options) {\n\t    return this.getNodeBBox(this.el).containsPoint(point, options);\n\t  }\n\t}, {\n\t  Flags: Flags$2,\n\t  Highlighting: HighlightingTypes$1,\n\t  addPresentationAttributes: function (presentationAttributes) {\n\t    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {\n\t      if (!a || !b) return;\n\t      if (typeof a === 'string') a = [a];\n\t      if (typeof b === 'string') b = [b];\n\t      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n\t    });\n\t  },\n\t  evalAttribute\n\t});\n\tObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n\t  get() {\n\t    const localUse = this.model.useCSSSelectors;\n\t    if (localUse !== undefined) return localUse;\n\t    return config$3.useCSSSelectors;\n\t  }\n\t});\n\n\t// Internal tag to identify this object as a cell view instance.\n\t// Used instead of `instanceof` for performance and cross-frame safety.\n\n\tObject.defineProperty(CellView.prototype, CELL_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\tconst Flags$1 = {\n\t  TOOLS: CellView.Flags.TOOLS,\n\t  UPDATE: 'UPDATE',\n\t  TRANSLATE: 'TRANSLATE',\n\t  RESIZE: 'RESIZE',\n\t  PORTS: 'PORTS',\n\t  ROTATE: 'ROTATE',\n\t  RENDER: 'RENDER'\n\t};\n\tconst DragActions = {\n\t  MOVE: 'move',\n\t  MAGNET: 'magnet'\n\t};\n\t// Element base view and controller.\n\t// -------------------------------------------\n\n\tconst ElementView = CellView.extend({\n\t  /**\n\t   * @abstract\n\t   */\n\t  _removePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  /**\n\t   *\n\t   * @abstract\n\t   */\n\t  _renderPorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  className: function () {\n\t    var classNames = CellView.prototype.className.apply(this).split(' ');\n\t    classNames.push('element');\n\t    return classNames.join(' ');\n\t  },\n\t  initialize: function () {\n\t    CellView.prototype.initialize.apply(this, arguments);\n\t    this._initializePorts();\n\t  },\n\t  presentationAttributes: {\n\t    'attrs': [Flags$1.UPDATE],\n\t    'position': [Flags$1.TRANSLATE, Flags$1.TOOLS],\n\t    'size': [Flags$1.RESIZE, Flags$1.PORTS, Flags$1.TOOLS],\n\t    'angle': [Flags$1.ROTATE, Flags$1.TOOLS],\n\t    'markup': [Flags$1.RENDER],\n\t    'ports': [Flags$1.PORTS]\n\t  },\n\t  initFlag: [Flags$1.RENDER],\n\t  UPDATE_PRIORITY: 0,\n\t  confirmUpdate: function (flag, opt) {\n\t    const {\n\t      useCSSSelectors\n\t    } = this;\n\t    if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t      this._removePorts();\n\t      this._cleanPortsCache();\n\t    }\n\t    let transformHighlighters = false;\n\t    if (this.hasFlag(flag, Flags$1.RENDER)) {\n\t      this.render();\n\t      this.updateTools(opt);\n\t      this.updateHighlighters(true);\n\t      transformHighlighters = true;\n\t      flag = this.removeFlag(flag, [Flags$1.RENDER, Flags$1.UPDATE, Flags$1.RESIZE, Flags$1.TRANSLATE, Flags$1.ROTATE, Flags$1.PORTS, Flags$1.TOOLS]);\n\t    } else {\n\t      let updateHighlighters = false;\n\n\t      // Skip this branch if render is required\n\t      if (this.hasFlag(flag, Flags$1.RESIZE)) {\n\t        this.resize(opt);\n\t        updateHighlighters = true;\n\t        // Resize method is calling `update()` internally\n\t        flag = this.removeFlag(flag, [Flags$1.RESIZE, Flags$1.UPDATE]);\n\t        if (useCSSSelectors) {\n\t          // `resize()` rendered the ports when useCSSSelectors are enabled\n\t          flag = this.removeFlag(flag, Flags$1.PORTS);\n\t        }\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.UPDATE)) {\n\t        this.update(this.model, null, opt);\n\t        flag = this.removeFlag(flag, Flags$1.UPDATE);\n\t        updateHighlighters = true;\n\t        if (useCSSSelectors) {\n\t          // `update()` will render ports when useCSSSelectors are enabled\n\t          flag = this.removeFlag(flag, Flags$1.PORTS);\n\t        }\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.TRANSLATE)) {\n\t        this.translate();\n\t        flag = this.removeFlag(flag, Flags$1.TRANSLATE);\n\t        transformHighlighters = true;\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.ROTATE)) {\n\t        this.rotate();\n\t        flag = this.removeFlag(flag, Flags$1.ROTATE);\n\t        transformHighlighters = true;\n\t      }\n\t      if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t        this._renderPorts();\n\t        updateHighlighters = true;\n\t        flag = this.removeFlag(flag, Flags$1.PORTS);\n\t      }\n\t      if (updateHighlighters) {\n\t        this.updateHighlighters(false);\n\t      }\n\t    }\n\t    if (transformHighlighters) {\n\t      this.transformHighlighters();\n\t    }\n\t    if (this.hasFlag(flag, Flags$1.TOOLS)) {\n\t      this.updateTools(opt);\n\t      flag = this.removeFlag(flag, Flags$1.TOOLS);\n\t    }\n\t    return flag;\n\t  },\n\t  /**\n\t   * @abstract\n\t   */\n\t  _initializePorts: function () {\n\t    // implemented in ports.js\n\t  },\n\t  update: function (_, renderingOnlyAttrs) {\n\t    this.cleanNodesCache();\n\n\t    // When CSS selector strings are used, make sure no rule matches port nodes.\n\t    const {\n\t      useCSSSelectors\n\t    } = this;\n\t    if (useCSSSelectors) this._removePorts();\n\t    var model = this.model;\n\t    var modelAttrs = model.attr();\n\t    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n\t      rootBBox: new Rect(model.size()),\n\t      selectors: this.selectors,\n\t      scalableNode: this.scalableNode,\n\t      rotatableNode: this.rotatableNode,\n\t      // Use rendering only attributes if they differs from the model attributes\n\t      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n\t    });\n\t    if (useCSSSelectors) {\n\t      this._renderPorts();\n\t    }\n\t  },\n\t  rotatableSelector: 'rotatable',\n\t  scalableSelector: 'scalable',\n\t  scalableNode: null,\n\t  rotatableNode: null,\n\t  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n\t  // default markup is not desirable.\n\t  renderMarkup: function () {\n\t    var element = this.model;\n\t    var markup = element.get('markup') || element.markup;\n\t    if (!markup) throw new Error('dia.ElementView: markup required');\n\t    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n\t    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n\t    throw new Error('dia.ElementView: invalid markup');\n\t  },\n\t  renderJSONMarkup: function (markup) {\n\t    var doc = this.parseDOMJSON(markup, this.el);\n\t    var selectors = this.selectors = doc.selectors;\n\t    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n\t    this.scalableNode = V(selectors[this.scalableSelector]) || null;\n\t    // Fragment\n\t    this.vel.append(doc.fragment);\n\t  },\n\t  renderStringMarkup: function (markup) {\n\t    var vel = this.vel;\n\t    vel.append(V(markup));\n\t    // Cache transformation groups\n\t    this.rotatableNode = vel.findOne('.rotatable');\n\t    this.scalableNode = vel.findOne('.scalable');\n\t    var selectors = this.selectors = {};\n\t    selectors[this.selector] = this.el;\n\t  },\n\t  render: function () {\n\t    this.vel.empty();\n\t    this.renderMarkup();\n\t    if (this.scalableNode) {\n\t      // Double update is necessary for elements with the scalable group only\n\t      // Note the resize() triggers the other `update`.\n\t      this.update();\n\t    }\n\t    this.resize();\n\t    if (this.rotatableNode) {\n\t      // Translate transformation is applied on `this.el` while the rotation transformation\n\t      // on `this.rotatableNode`\n\t      this.rotate();\n\t      this.translate();\n\t    } else {\n\t      this.updateTransformation();\n\t    }\n\t    if (!this.useCSSSelectors) this._renderPorts();\n\t    return this;\n\t  },\n\t  resize: function (opt) {\n\t    if (this.scalableNode) return this.sgResize(opt);\n\t    if (this.model.attributes.angle) this.rotate();\n\t    this.update();\n\t  },\n\t  translate: function () {\n\t    if (this.rotatableNode) return this.rgTranslate();\n\t    this.updateTransformation();\n\t  },\n\t  rotate: function () {\n\t    if (this.rotatableNode) {\n\t      this.rgRotate();\n\t      // It's necessary to call the update for the nodes outside\n\t      // the rotatable group referencing nodes inside the group\n\t      this.update();\n\t      return;\n\t    }\n\t    this.updateTransformation();\n\t  },\n\t  updateTransformation: function () {\n\t    var transformation = this.getTranslateString();\n\t    var rotateString = this.getRotateString();\n\t    if (rotateString) transformation += ' ' + rotateString;\n\t    this.vel.attr('transform', transformation);\n\t  },\n\t  getTranslateString: function () {\n\t    const {\n\t      x,\n\t      y\n\t    } = this.model.position();\n\t    return `translate(${x},${y})`;\n\t  },\n\t  getRotateString: function () {\n\t    const angle = this.model.angle();\n\t    if (!angle) return null;\n\t    const {\n\t      width,\n\t      height\n\t    } = this.model.size();\n\t    return `rotate(${angle},${width / 2},${height / 2})`;\n\t  },\n\t  // Rotatable & Scalable Group\n\t  // always slower, kept mainly for backwards compatibility\n\n\t  rgRotate: function () {\n\t    this.rotatableNode.attr('transform', this.getRotateString());\n\t  },\n\t  rgTranslate: function () {\n\t    this.vel.attr('transform', this.getTranslateString());\n\t  },\n\t  sgResize: function (opt) {\n\t    var model = this.model;\n\t    var angle = model.angle();\n\t    var size = model.size();\n\t    var scalable = this.scalableNode;\n\n\t    // Getting scalable group's bbox.\n\t    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n\t    // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\t    var recursive = false;\n\t    if (scalable.node.getElementsByTagName('path').length > 0) {\n\t      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n\t      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n\t      recursive = true;\n\t    }\n\t    var scalableBBox = scalable.getBBox({\n\t      recursive: recursive\n\t    });\n\n\t    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n\t    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\t    var sx = size.width / (scalableBBox.width || 1);\n\t    var sy = size.height / (scalableBBox.height || 1);\n\t    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n\t    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n\t    // Order of transformations is significant but we want to reconstruct the object always in the order:\n\t    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n\t    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n\t    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n\t    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n\t    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n\t    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\t    var rotatable = this.rotatableNode;\n\t    var rotation = rotatable && rotatable.attr('transform');\n\t    if (rotation) {\n\t      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');\n\t      var rotatableBBox = scalable.getBBox({\n\t        target: this.paper.cells\n\t      });\n\n\t      // Store new x, y and perform rotate() again against the new rotation origin.\n\t      model.set('position', {\n\t        x: rotatableBBox.x,\n\t        y: rotatableBBox.y\n\t      }, assign({\n\t        updateHandled: true\n\t      }, opt));\n\t      this.translate();\n\t      this.rotate();\n\t    }\n\n\t    // Update must always be called on non-rotated element. Otherwise, relative positioning\n\t    // would work with wrong (rotated) bounding boxes.\n\t    this.update();\n\t  },\n\t  // Embedding mode methods.\n\t  // -----------------------\n\n\t  prepareEmbedding: function (data = {}) {\n\t    const element = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    const initialZIndices = data.initialZIndices = {};\n\t    const embeddedCells = element.getEmbeddedCells({\n\t      deep: true\n\t    });\n\t    const connectedLinks = graph.getConnectedLinks(element, {\n\t      deep: true,\n\t      includeEnclosed: true\n\t    });\n\n\t    // Note: an embedded cell can be a connect link, but it's fine\n\t    // to iterate over the cell twice.\n\t    [element, ...embeddedCells, ...connectedLinks].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\t    element.startBatch('to-front');\n\n\t    // Bring the model to the front with all his embeds.\n\t    element.toFront({\n\t      deep: true,\n\t      ui: true\n\t    });\n\n\t    // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n\t    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\t    const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n\t    // Move to front also all the inbound and outbound links that are connected\n\t    // to any of the element descendant. If we bring to front only embedded elements,\n\t    // links connected to them would stay in the background.\n\t    connectedLinks.forEach(link => {\n\t      if (link.attributes.z <= maxZ) {\n\t        link.set('z', maxZ + 1, {\n\t          ui: true\n\t        });\n\t      }\n\t    });\n\t    element.stopBatch('to-front');\n\n\t    // Before we start looking for suitable parent we remove the current one.\n\t    const parentId = element.parent();\n\t    if (parentId) {\n\t      const parent = graph.getCell(parentId);\n\t      parent.unembed(element, {\n\t        ui: true\n\t      });\n\t      data.initialParentId = parentId;\n\t    } else {\n\t      // `data.initialParentId` can be explicitly set to a dummy value to enable validation of unembedding.\n\t      data.initialParentId = data.initialParentId || null;\n\t    }\n\t  },\n\t  processEmbedding: function (data = {}, evt, x, y) {\n\t    const model = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    const {\n\t      findParentBy,\n\t      frontParentOnly,\n\t      validateEmbedding\n\t    } = paper.options;\n\t    let candidates;\n\t    if (isFunction(findParentBy)) {\n\t      candidates = toArray$1(findParentBy.call(graph, this, evt, x, y));\n\t    } else if (findParentBy === 'pointer') {\n\t      candidates = graph.findElementsAtPoint({\n\t        x,\n\t        y\n\t      });\n\t    } else {\n\t      candidates = graph.findElementsUnderElement(model, {\n\t        searchBy: findParentBy\n\t      });\n\t    }\n\t    candidates = candidates.filter(el => {\n\t      return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n\t    });\n\t    if (frontParentOnly) {\n\t      // pick the element with the highest `z` index\n\t      candidates = candidates.slice(-1);\n\t    }\n\t    let newCandidateView = null;\n\t    const prevCandidateView = data.candidateEmbedView;\n\n\t    // iterate over all candidates starting from the last one (has the highest z-index).\n\t    for (let i = candidates.length - 1; i >= 0; i--) {\n\t      const candidate = candidates[i];\n\t      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n\t        // candidate remains the same\n\t        newCandidateView = prevCandidateView;\n\t        break;\n\t      } else {\n\t        const view = candidate.findView(paper);\n\t        if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n\t          // flip to the new candidate\n\t          newCandidateView = view;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    if (newCandidateView && newCandidateView != prevCandidateView) {\n\t      // A new candidate view found. Highlight the new one.\n\t      this.clearEmbedding(data);\n\t      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t    }\n\t    if (!newCandidateView && prevCandidateView) {\n\t      // No candidate view found. Unhighlight the previous candidate.\n\t      this.clearEmbedding(data);\n\t    }\n\t  },\n\t  clearEmbedding: function (data) {\n\t    data || (data = {});\n\t    var candidateView = data.candidateEmbedView;\n\t    if (candidateView) {\n\t      // No candidate view found. Unhighlight the previous candidate.\n\t      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t      data.candidateEmbedView = null;\n\t    }\n\t  },\n\t  finalizeEmbedding: function (data = {}) {\n\t    const candidateView = data.candidateEmbedView;\n\t    const element = data.model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    if (candidateView) {\n\t      // We finished embedding. Candidate view is chosen to become the parent of the model.\n\t      candidateView.model.embed(element, {\n\t        ui: true\n\t      });\n\t      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n\t        embedding: true\n\t      });\n\t      data.candidateEmbedView = null;\n\t    } else {\n\t      const {\n\t        validateUnembedding\n\t      } = paper.options;\n\t      const {\n\t        initialParentId\n\t      } = data;\n\t      // The element was originally embedded into another element.\n\t      // The interaction would unembed the element. Let's validate\n\t      // if the element can be unembedded.\n\t      if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {\n\t        this._disallowUnembed(data);\n\t        return;\n\t      }\n\t    }\n\t    paper.model.getConnectedLinks(element, {\n\t      deep: true\n\t    }).forEach(link => {\n\t      link.reparent({\n\t        ui: true\n\t      });\n\t    });\n\t  },\n\t  _disallowUnembed: function (data) {\n\t    const {\n\t      model,\n\t      whenNotAllowed = 'revert'\n\t    } = data;\n\t    const element = model || this.model;\n\t    const paper = data.paper || this.paper;\n\t    const graph = paper.model;\n\t    switch (whenNotAllowed) {\n\t      case 'remove':\n\t        {\n\t          element.remove({\n\t            ui: true\n\t          });\n\t          break;\n\t        }\n\t      case 'revert':\n\t        {\n\t          const {\n\t            initialParentId,\n\t            initialPosition,\n\t            initialZIndices\n\t          } = data;\n\t          // Revert the element's position (and the position of its embedded cells if any)\n\t          if (initialPosition) {\n\t            const {\n\t              x,\n\t              y\n\t            } = initialPosition;\n\t            element.position(x, y, {\n\t              deep: true,\n\t              ui: true\n\t            });\n\t          }\n\t          // Revert all the z-indices changed during the embedding\n\t          if (initialZIndices) {\n\t            Object.keys(initialZIndices).forEach(id => {\n\t              const cell = graph.getCell(id);\n\t              if (cell) {\n\t                cell.set('z', initialZIndices[id], {\n\t                  ui: true\n\t                });\n\t              }\n\t            });\n\t          }\n\t          // Revert the original parent\n\t          const parent = graph.getCell(initialParentId);\n\t          if (parent) {\n\t            parent.embed(element, {\n\t              ui: true\n\t            });\n\t          }\n\t          break;\n\t        }\n\t    }\n\t  },\n\t  getTargetParentView: function (evt) {\n\t    const {\n\t      candidateEmbedView = null\n\t    } = this.eventData(evt);\n\t    return candidateEmbedView;\n\t  },\n\t  getDelegatedView: function () {\n\t    var view = this;\n\t    var model = view.model;\n\t    var paper = view.paper;\n\t    while (view) {\n\t      if (model.isLink()) break;\n\t      if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n\t      model = model.getParentCell();\n\t      view = paper.findViewByModel(model);\n\t    }\n\t    return null;\n\t  },\n\t  findProxyNode: function (el, type) {\n\t    el || (el = this.el);\n\t    const nodeSelector = el.getAttribute(`${type}-selector`);\n\t    if (nodeSelector) {\n\t      const port = this.findAttribute('port', el);\n\t      if (port) {\n\t        const proxyPortNode = this.findPortNode(port, nodeSelector);\n\t        if (proxyPortNode) return proxyPortNode;\n\t      } else {\n\t        const proxyNode = this.findNode(nodeSelector);\n\t        if (proxyNode) return proxyNode;\n\t      }\n\t    }\n\t    return el;\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  notifyPointerdown(evt, x, y) {\n\t    CellView.prototype.pointerdown.call(this, evt, x, y);\n\t    this.notify('element:pointerdown', evt, x, y);\n\t  },\n\t  notifyPointermove(evt, x, y) {\n\t    CellView.prototype.pointermove.call(this, evt, x, y);\n\t    this.notify('element:pointermove', evt, x, y);\n\t  },\n\t  notifyPointerup(evt, x, y) {\n\t    this.notify('element:pointerup', evt, x, y);\n\t    CellView.prototype.pointerup.call(this, evt, x, y);\n\t  },\n\t  pointerdblclick: function (evt, x, y) {\n\t    CellView.prototype.pointerdblclick.apply(this, arguments);\n\t    this.notify('element:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    CellView.prototype.pointerclick.apply(this, arguments);\n\t    this.notify('element:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    CellView.prototype.contextmenu.apply(this, arguments);\n\t    this.notify('element:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragStart(evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    const data = this.eventData(evt);\n\t    const {\n\t      targetMagnet,\n\t      action,\n\t      delegatedView\n\t    } = data;\n\t    if (targetMagnet) {\n\t      this.magnetpointermove(evt, targetMagnet, x, y);\n\t    }\n\t    switch (action) {\n\t      case DragActions.MAGNET:\n\t        this.dragMagnet(evt, x, y);\n\t        break;\n\t      case DragActions.MOVE:\n\t        (delegatedView || this).drag(evt, x, y);\n\t      // eslint: no-fallthrough=false\n\t      default:\n\t        if (data.preventPointerEvents) break;\n\t        this.notifyPointermove(evt, x, y);\n\t        break;\n\t    }\n\n\t    // Make sure the element view data is passed along.\n\t    // It could have been wiped out in the handlers above.\n\t    this.eventData(evt, data);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    const data = this.eventData(evt);\n\t    const {\n\t      targetMagnet,\n\t      action,\n\t      delegatedView\n\t    } = data;\n\t    if (targetMagnet) {\n\t      this.magnetpointerup(evt, targetMagnet, x, y);\n\t    }\n\t    switch (action) {\n\t      case DragActions.MAGNET:\n\t        this.dragMagnetEnd(evt, x, y);\n\t        break;\n\t      case DragActions.MOVE:\n\t        (delegatedView || this).dragEnd(evt, x, y);\n\t      // eslint: no-fallthrough=false\n\t      default:\n\t        if (data.preventPointerEvents) break;\n\t        this.notifyPointerup(evt, x, y);\n\t    }\n\t    if (targetMagnet) {\n\t      this.magnetpointerclick(evt, targetMagnet, x, y);\n\t    }\n\t    this.checkMouseleave(evt);\n\t  },\n\t  mouseover: function (evt) {\n\t    CellView.prototype.mouseover.apply(this, arguments);\n\t    this.notify('element:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    CellView.prototype.mouseout.apply(this, arguments);\n\t    this.notify('element:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    CellView.prototype.mouseenter.apply(this, arguments);\n\t    this.notify('element:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    CellView.prototype.mouseleave.apply(this, arguments);\n\t    this.notify('element:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    CellView.prototype.mousewheel.apply(this, arguments);\n\t    this.notify('element:mousewheel', evt, x, y, delta);\n\t  },\n\t  onmagnet: function (evt, x, y) {\n\t    const {\n\t      currentTarget: targetMagnet\n\t    } = evt;\n\t    this.magnetpointerdown(evt, targetMagnet, x, y);\n\t    this.eventData(evt, {\n\t      targetMagnet\n\t    });\n\t    this.dragMagnetStart(evt, x, y);\n\t  },\n\t  magnetpointerdown: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n\t  },\n\t  magnetpointermove: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointermove', evt, magnet, x, y);\n\t  },\n\t  magnetpointerup: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerup', evt, magnet, x, y);\n\t  },\n\t  magnetpointerdblclick: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n\t  },\n\t  magnetcontextmenu: function (evt, magnet, x, y) {\n\t    this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n\t  },\n\t  // Drag Start Handlers\n\n\t  dragStart: function (evt, x, y) {\n\t    if (this.isDefaultInteractionPrevented(evt)) return;\n\t    var view = this.getDelegatedView();\n\t    if (!view || !view.can('elementMove')) return;\n\t    this.eventData(evt, {\n\t      action: DragActions.MOVE,\n\t      delegatedView: view\n\t    });\n\t    const position = view.model.position();\n\t    view.eventData(evt, {\n\t      initialPosition: position,\n\t      pointerOffset: position.difference(x, y),\n\t      restrictedArea: this.paper.getRestrictedArea(view, x, y)\n\t    });\n\t  },\n\t  dragMagnetStart: function (evt, x, y) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const isPropagationAlreadyStopped = evt.isPropagationStopped();\n\t    if (isPropagationAlreadyStopped) {\n\t      // Special case when the propagation was already stopped\n\t      // on the `element:magnet:pointerdown` event.\n\t      // Do not trigger any `element:pointer*` events\n\t      // but still start the magnet dragging.\n\t      this.eventData(evt, {\n\t        preventPointerEvents: true\n\t      });\n\t    }\n\t    if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n\t      // Stop the default action, which is to start dragging a link.\n\t      return;\n\t    }\n\t    const {\n\t      targetMagnet = evt.currentTarget\n\t    } = this.eventData(evt);\n\t    evt.stopPropagation();\n\n\t    // Invalid (Passive) magnet. Start dragging the element.\n\t    if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n\t      if (isPropagationAlreadyStopped) {\n\t        // Do not trigger `element:pointerdown` and start element dragging\n\t        // if the propagation was stopped.\n\t        this.dragStart(evt, x, y);\n\t        // The `element:pointerdown` event is not triggered because\n\t        // of `preventPointerEvents` flag.\n\t      } else {\n\t        // We need to reset the action\n\t        // to `MOVE` so that the element is dragged.\n\t        this.pointerdown(evt, x, y);\n\t      }\n\t      return;\n\t    }\n\n\t    // Valid magnet. Start dragging a link.\n\t    if (paper.options.magnetThreshold <= 0) {\n\t      this.dragLinkStart(evt, targetMagnet, x, y);\n\t    }\n\t    this.eventData(evt, {\n\t      action: DragActions.MAGNET\n\t    });\n\t  },\n\t  // Drag Handlers\n\n\t  snapToGrid: function (evt, x, y) {\n\t    const grid = this.paper.options.gridSize;\n\t    return {\n\t      x: snapToGrid$1(x, grid),\n\t      y: snapToGrid$1(y, grid)\n\t    };\n\t  },\n\t  drag: function (evt, x, y) {\n\t    var paper = this.paper;\n\t    var element = this.model;\n\t    var data = this.eventData(evt);\n\t    var {\n\t      pointerOffset,\n\t      restrictedArea,\n\t      embedding\n\t    } = data;\n\n\t    // Make sure the new element's position always snaps to the current grid\n\t    const {\n\t      x: elX,\n\t      y: elY\n\t    } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);\n\t    element.position(elX, elY, {\n\t      restrictedArea,\n\t      deep: true,\n\t      ui: true\n\t    });\n\t    if (paper.options.embeddingMode) {\n\t      if (!embedding) {\n\t        // Prepare the element for embedding only if the pointer moves.\n\t        // We don't want to do unnecessary action with the element\n\t        // if an user only clicks/dblclicks on it.\n\t        this.prepareEmbedding(data);\n\t        embedding = true;\n\t      }\n\t      this.processEmbedding(data, evt, x, y);\n\t    }\n\t    this.eventData(evt, {\n\t      embedding\n\t    });\n\t  },\n\t  dragMagnet: function (evt, x, y) {\n\t    this.dragLink(evt, x, y);\n\t  },\n\t  // Drag End Handlers\n\n\t  dragEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    if (data.embedding) this.finalizeEmbedding(data);\n\t  },\n\t  dragMagnetEnd: function (evt, x, y) {\n\t    this.dragLinkEnd(evt, x, y);\n\t  },\n\t  magnetpointerclick: function (evt, magnet, x, y) {\n\t    var paper = this.paper;\n\t    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n\t    this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n\t  }\n\t}, {\n\t  Flags: Flags$1\n\t});\n\tassign(ElementView.prototype, elementViewPortPrototype);\n\n\tconst Flags = {\n\t  TOOLS: CellView.Flags.TOOLS,\n\t  RENDER: 'RENDER',\n\t  UPDATE: 'UPDATE',\n\t  LABELS: 'LABELS',\n\t  SOURCE: 'SOURCE',\n\t  TARGET: 'TARGET',\n\t  CONNECTOR: 'CONNECTOR'\n\t};\n\n\t// Link base view and controller.\n\t// ----------------------------------------\n\n\tconst LinkView = CellView.extend({\n\t  className: function () {\n\t    var classNames = CellView.prototype.className.apply(this).split(' ');\n\t    classNames.push('link');\n\t    return classNames.join(' ');\n\t  },\n\t  _labelCache: null,\n\t  _labelSelectors: null,\n\t  _V: null,\n\t  _sourceMagnet: null,\n\t  _targetMagnet: null,\n\t  _dragData: null,\n\t  // deprecated\n\n\t  metrics: null,\n\t  decimalsRounding: 2,\n\t  initialize: function () {\n\t    CellView.prototype.initialize.apply(this, arguments);\n\n\t    // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n\t    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n\t    // nodes in `updateLabelPosition()` in order to update the label positions.\n\t    this._labelCache = {};\n\n\t    // a cache of label selectors\n\t    this._labelSelectors = {};\n\n\t    // cache of default markup nodes\n\t    this._V = {};\n\n\t    // connection path metrics\n\t    this.cleanNodesCache();\n\t  },\n\t  presentationAttributes: {\n\t    markup: [Flags.RENDER],\n\t    attrs: [Flags.UPDATE],\n\t    router: [Flags.UPDATE],\n\t    connector: [Flags.CONNECTOR],\n\t    labels: [Flags.LABELS, Flags.TOOLS],\n\t    labelMarkup: [Flags.LABELS],\n\t    vertices: [Flags.UPDATE],\n\t    source: [Flags.SOURCE, Flags.UPDATE],\n\t    target: [Flags.TARGET, Flags.UPDATE]\n\t  },\n\t  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\t  UPDATE_PRIORITY: 1,\n\t  EPSILON: 1e-6,\n\t  confirmUpdate: function (flags, opt = {}) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    const {\n\t      attributes\n\t    } = model;\n\t    const {\n\t      source: {\n\t        id: sourceId\n\t      },\n\t      target: {\n\t        id: targetId\n\t      }\n\t    } = attributes;\n\t    if (this.hasFlag(flags, Flags.SOURCE)) {\n\t      this._sourceMagnet = null; // reset cached source magnet\n\t      this.checkEndModel('source', sourceId);\n\t      flags = this.removeFlag(flags, Flags.SOURCE);\n\t    }\n\t    if (this.hasFlag(flags, Flags.TARGET)) {\n\t      this._targetMagnet = null; // reset cached target magnet\n\t      this.checkEndModel('target', targetId);\n\t      flags = this.removeFlag(flags, Flags.TARGET);\n\t    }\n\t    if (paper && (sourceId && !paper.isCellVisible(sourceId) || targetId && !paper.isCellVisible(targetId))) {\n\t      // Wait for the source and target views to be rendered\n\t      return flags;\n\t    }\n\t    if (this.hasFlag(flags, Flags.RENDER)) {\n\t      this.render();\n\t      this.updateHighlighters(true);\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\t      if (env.test('isAppleWebKit')) {\n\t        this.__fixWebKitBug268376();\n\t      }\n\t      return flags;\n\t    }\n\t    let updateHighlighters = false;\n\t    let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\t    if (updateLabels) {\n\t      this.onLabelsChange(model, attributes.labels, opt);\n\t      flags = this.removeFlag(flags, Flags.LABELS);\n\t      updateHighlighters = true;\n\t    }\n\t    const updateAll = this.hasFlag(flags, Flags.UPDATE);\n\t    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n\t    if (updateAll || updateConnector) {\n\t      if (!updateAll) {\n\t        // Keep the current route and update the geometry\n\t        this.updatePath();\n\t        this.updateDOM();\n\t      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n\t        // The link is being translated by an ancestor that will\n\t        // shift source point, target point and all vertices\n\t        // by an equal distance.\n\t        this.translate(opt.tx, opt.ty);\n\t      } else {\n\t        this.update();\n\t      }\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n\t      updateLabels = false;\n\t      updateHighlighters = true;\n\t    }\n\t    if (updateLabels) {\n\t      this.updateLabelPositions();\n\t    }\n\t    if (updateHighlighters) {\n\t      this.updateHighlighters();\n\t    }\n\t    if (this.hasFlag(flags, Flags.TOOLS)) {\n\t      this.updateTools(opt);\n\t      flags = this.removeFlag(flags, Flags.TOOLS);\n\t    }\n\t    return flags;\n\t  },\n\t  __fixWebKitBug268376: function () {\n\t    // WebKit has a bug where any change after the first render is not reflected in the DOM.\n\t    // https://bugs.webkit.org/show_bug.cgi?id=268376\n\t    const {\n\t      el\n\t    } = this;\n\t    const childNodes = Array.from(el.childNodes);\n\t    const fragment = document.createDocumentFragment();\n\t    for (let i = 0, n = childNodes.length; i < n; i++) {\n\t      el.removeChild(childNodes[i]);\n\t      fragment.appendChild(childNodes[i]);\n\t    }\n\t    el.appendChild(fragment);\n\t  },\n\t  requestConnectionUpdate: function (opt) {\n\t    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n\t  },\n\t  isLabelsRenderRequired: function (opt = {}) {\n\t    const previousLabels = this.model.previous('labels');\n\t    if (!previousLabels) return true;\n\n\t    // Here is an optimization for cases when we know, that change does\n\t    // not require re-rendering of all labels.\n\t    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n\t      // The label is setting by `prop()` method\n\t      var pathArray = opt.propertyPathArray || [];\n\t      var pathLength = pathArray.length;\n\t      if (pathLength > 1) {\n\t        // We are changing a single label here e.g. 'labels/0/position'\n\t        var labelExists = !!previousLabels[pathArray[1]];\n\t        if (labelExists) {\n\t          if (pathLength === 2) {\n\t            // We are changing the entire label. Need to check if the\n\t            // markup is also being changed.\n\t            return 'markup' in Object(opt.propertyValue);\n\t          } else if (pathArray[2] !== 'markup') {\n\t            // We are changing a label property but not the markup\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  onLabelsChange: function (_link, _labels, opt) {\n\t    // Note: this optimization works in async=false mode only\n\t    if (this.isLabelsRenderRequired(opt)) {\n\t      this.renderLabels();\n\t    } else {\n\t      this.updateLabels();\n\t    }\n\t  },\n\t  // Rendering.\n\t  // ----------\n\n\t  render: function () {\n\t    this.vel.empty();\n\t    this.unmountLabels();\n\t    this._V = {};\n\t    this.renderMarkup();\n\t    // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n\t    // returns zero values)\n\t    this.renderLabels();\n\t    this.update();\n\t    return this;\n\t  },\n\t  renderMarkup: function () {\n\t    var link = this.model;\n\t    var markup = link.get('markup') || link.markup;\n\t    if (!markup) throw new Error('dia.LinkView: markup required');\n\t    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n\t    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n\t    throw new Error('dia.LinkView: invalid markup');\n\t  },\n\t  renderJSONMarkup: function (markup) {\n\t    var doc = this.parseDOMJSON(markup, this.el);\n\t    // Selectors\n\t    this.selectors = doc.selectors;\n\t    // Fragment\n\t    this.vel.append(doc.fragment);\n\t  },\n\t  renderStringMarkup: function (markup) {\n\t    // A special markup can be given in the `properties.markup` property. This might be handy\n\t    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n\t    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n\t    // of elements with special meaning though. Therefore, those classes should be preserved in any\n\t    // special markup passed in `properties.markup`.\n\t    var children = V(markup);\n\t    // custom markup may contain only one children\n\t    if (!Array.isArray(children)) children = [children];\n\t    this.vel.append(children);\n\t  },\n\t  _getLabelMarkup: function (labelMarkup) {\n\t    if (!labelMarkup) return undefined;\n\t    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n\t    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n\t    throw new Error('dia.linkView: invalid label markup');\n\t  },\n\t  _getLabelStringMarkup: function (labelMarkup) {\n\t    var children = V(labelMarkup);\n\t    var fragment = document.createDocumentFragment();\n\t    if (!Array.isArray(children)) {\n\t      fragment.appendChild(children.node);\n\t    } else {\n\t      for (var i = 0, n = children.length; i < n; i++) {\n\t        var currentChild = children[i].node;\n\t        fragment.appendChild(currentChild);\n\t      }\n\t    }\n\t    return {\n\t      fragment: fragment,\n\t      selectors: {}\n\t    }; // no selectors\n\t  },\n\t  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n\t  // If it doesn't, add the <g /> container here.\n\t  _normalizeLabelMarkup: function (markup) {\n\t    if (!markup) return undefined;\n\t    var fragment = markup.fragment;\n\t    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\t    var vNode;\n\t    var childNodes = fragment.childNodes;\n\t    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n\t      // default markup fragment is not wrapped in <g />\n\t      // add a <g /> container\n\t      vNode = V('g').append(fragment);\n\t    } else {\n\t      vNode = V(childNodes[0]);\n\t    }\n\t    vNode.addClass('label');\n\t    return {\n\t      node: vNode.node,\n\t      selectors: markup.selectors\n\t    };\n\t  },\n\t  renderLabels: function () {\n\t    var cache = this._V;\n\t    var vLabels = cache.labels;\n\t    var labelCache = this._labelCache = {};\n\t    var labelSelectors = this._labelSelectors = {};\n\t    var model = this.model;\n\t    var labels = model.attributes.labels || [];\n\t    var labelsCount = labels.length;\n\t    if (labelsCount === 0) {\n\t      if (vLabels) vLabels.remove();\n\t      return this;\n\t    }\n\t    if (vLabels) {\n\t      vLabels.empty();\n\t    } else {\n\t      // there is no label container in the markup but some labels are defined\n\t      // add a <g class=\"labels\" /> container\n\t      vLabels = cache.labels = V('g').addClass('labels');\n\t      if (this.options.labelsLayer) {\n\t        vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n\t        vLabels.attr('model-id', model.id);\n\t      }\n\t    }\n\t    for (var i = 0; i < labelsCount; i++) {\n\t      var label = labels[i];\n\t      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\t      var labelNode;\n\t      var selectors;\n\t      if (labelMarkup) {\n\t        labelNode = labelMarkup.node;\n\t        selectors = labelMarkup.selectors;\n\t      } else {\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\t        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\t        labelNode = defaultMarkup.node;\n\t        selectors = defaultMarkup.selectors;\n\t      }\n\t      labelNode.setAttribute('label-idx', i); // assign label-idx\n\t      vLabels.append(labelNode);\n\t      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n\t      var rootSelector = this.selector;\n\t      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n\t      selectors[rootSelector] = labelNode;\n\t      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n\t    }\n\t    if (!vLabels.parent()) {\n\t      this.mountLabels();\n\t    }\n\t    this.updateLabels();\n\t    return this;\n\t  },\n\t  mountLabels: function () {\n\t    const {\n\t      el,\n\t      paper,\n\t      model,\n\t      _V,\n\t      options\n\t    } = this;\n\t    const {\n\t      labels: vLabels\n\t    } = _V;\n\t    if (!vLabels || !model.hasLabels()) return;\n\t    const {\n\t      node\n\t    } = vLabels;\n\t    if (options.labelsLayer) {\n\t      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n\t    } else {\n\t      if (node.parentNode !== el) {\n\t        el.appendChild(node);\n\t      }\n\t    }\n\t  },\n\t  unmountLabels: function () {\n\t    const {\n\t      options,\n\t      _V\n\t    } = this;\n\t    if (!_V) return;\n\t    const {\n\t      labels: vLabels\n\t    } = _V;\n\t    if (vLabels && options.labelsLayer) {\n\t      vLabels.remove();\n\t    }\n\t  },\n\t  findLabelNodes: function (labelIndex, selector) {\n\t    const labelRoot = this._labelCache[labelIndex];\n\t    if (!labelRoot) return [];\n\t    const labelSelectors = this._labelSelectors[labelIndex];\n\t    return this.findBySelector(selector, labelRoot, labelSelectors);\n\t  },\n\t  findLabelNode: function (labelIndex, selector) {\n\t    const [node = null] = this.findLabelNodes(labelIndex, selector);\n\t    return node;\n\t  },\n\t  // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\t    if (labelAttrs === null) return null;\n\t    if (labelAttrs === undefined) {\n\t      if (defaultLabelAttrs === null) return null;\n\t      if (defaultLabelAttrs === undefined) {\n\t        if (hasCustomMarkup) return undefined;\n\t        return builtinDefaultLabelAttrs;\n\t      }\n\t      if (hasCustomMarkup) return defaultLabelAttrs;\n\t      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n\t    }\n\t    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n\t    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n\t  },\n\t  // merge default label size into label size (no built-in default)\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelSize: function (labelSize, defaultLabelSize) {\n\t    if (labelSize === null) return null;\n\t    if (labelSize === undefined) {\n\t      if (defaultLabelSize === null) return null;\n\t      if (defaultLabelSize === undefined) return undefined;\n\t      return defaultLabelSize;\n\t    }\n\t    return merge({}, defaultLabelSize, labelSize);\n\t  },\n\t  updateLabels: function () {\n\t    if (!this._V.labels) return this;\n\t    if (!this.paper.options.labelLayer) {\n\t      // If there is no label layer, the cache needs to be cleared\n\t      // of the root node because the labels are attached\n\t      // to it and could affect the bounding box.\n\t      this.cleanNodeCache(this.el);\n\t    }\n\t    var model = this.model;\n\t    var labels = model.get('labels') || [];\n\t    var canLabelMove = this.can('labelMove');\n\t    var builtinDefaultLabel = model._builtins.defaultLabel;\n\t    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\t    var defaultLabel = model._getDefaultLabel();\n\t    var defaultLabelMarkup = defaultLabel.markup;\n\t    var defaultLabelAttrs = defaultLabel.attrs;\n\t    var defaultLabelSize = defaultLabel.size;\n\t    for (var i = 0, n = labels.length; i < n; i++) {\n\t      var labelNode = this._labelCache[i];\n\t      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n\t      var selectors = this._labelSelectors[i];\n\t      var label = labels[i];\n\t      var labelMarkup = label.markup;\n\t      var labelAttrs = label.attrs;\n\t      var labelSize = label.size;\n\t      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n\t      var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n\t      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n\t        rootBBox: new Rect(size),\n\t        selectors: selectors\n\t      });\n\t    }\n\t    return this;\n\t  },\n\t  // remove vertices that lie on (or nearly on) straight lines within the link\n\t  // return the number of removed points\n\t  removeRedundantLinearVertices: function (opt) {\n\t    const SIMPLIFY_THRESHOLD = 0.001;\n\t    const link = this.model;\n\t    const vertices = link.vertices();\n\t    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n\t    const numRoutePoints = routePoints.length;\n\n\t    // put routePoints into a polyline and try to simplify\n\t    const polyline = new Polyline$1(routePoints);\n\t    polyline.simplify({\n\t      threshold: SIMPLIFY_THRESHOLD\n\t    });\n\t    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n\t    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n\t    // shortcut if simplification did not remove any redundant vertices:\n\t    if (numRoutePoints === numPolylinePoints) return 0;\n\n\t    // else: set simplified polyline points as link vertices\n\t    // remove first and last polyline points again (= source/target anchors)\n\t    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n\t    return numRoutePoints - numPolylinePoints;\n\t  },\n\t  getEndView: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return this.sourceView || null;\n\t      case 'target':\n\t        return this.targetView || null;\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndAnchor: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return new Point(this.sourceAnchor);\n\t      case 'target':\n\t        return new Point(this.targetAnchor);\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndConnectionPoint: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        return new Point(this.sourcePoint);\n\t      case 'target':\n\t        return new Point(this.targetPoint);\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t  },\n\t  getEndMagnet: function (type) {\n\t    switch (type) {\n\t      case 'source':\n\t        var sourceView = this.sourceView;\n\t        if (!sourceView) break;\n\t        return this.sourceMagnet || sourceView.el;\n\t      case 'target':\n\t        var targetView = this.targetView;\n\t        if (!targetView) break;\n\t        return this.targetMagnet || targetView.el;\n\t      default:\n\t        throw new Error('dia.LinkView: type parameter required.');\n\t    }\n\t    return null;\n\t  },\n\t  // Updating.\n\t  // ---------\n\n\t  update: function () {\n\t    this.updateRoute();\n\t    this.updatePath();\n\t    this.updateDOM();\n\t    return this;\n\t  },\n\t  translate: function (tx = 0, ty = 0) {\n\t    const {\n\t      route,\n\t      path\n\t    } = this;\n\t    if (!route || !path) return;\n\t    // translate the route\n\t    const polyline = new Polyline$1(route);\n\t    polyline.translate(tx, ty);\n\t    this.route = polyline.points;\n\t    // translate source and target connection and anchor points.\n\t    this.sourcePoint.offset(tx, ty);\n\t    this.targetPoint.offset(tx, ty);\n\t    this.sourceAnchor.offset(tx, ty);\n\t    this.targetAnchor.offset(tx, ty);\n\t    // translate the geometry path\n\t    path.translate(tx, ty);\n\t    this.updateDOM();\n\t  },\n\t  updateDOM() {\n\t    const {\n\t      el,\n\t      model,\n\t      selectors\n\t    } = this;\n\t    this.cleanNodesCache();\n\t    // update SVG attributes defined by 'attrs/'.\n\t    this.updateDOMSubtreeAttributes(el, model.attr(), {\n\t      selectors\n\t    });\n\t    // update the label position etc.\n\t    this.updateLabelPositions();\n\t    // *Deprecated*\n\t    // Local perpendicular flag (as opposed to one defined on paper).\n\t    // Could be enabled inside a connector/router. It's valid only\n\t    // during the update execution.\n\t    this.options.perpendicular = null;\n\t  },\n\t  updateRoute: function () {\n\t    const {\n\t      model\n\t    } = this;\n\t    const vertices = model.vertices();\n\t    // 1. Find Anchors\n\t    const anchors = this.findAnchors(vertices);\n\t    const sourceAnchor = this.sourceAnchor = anchors.source;\n\t    const targetAnchor = this.targetAnchor = anchors.target;\n\t    // 2. Find Route\n\t    const route = this.findRoute(vertices);\n\t    this.route = route;\n\t    // 3. Find Connection Points\n\t    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n\t    this.sourcePoint = connectionPoints.source;\n\t    this.targetPoint = connectionPoints.target;\n\t  },\n\t  updatePath: function () {\n\t    const {\n\t      route,\n\t      sourcePoint,\n\t      targetPoint\n\t    } = this;\n\t    // 4. Find Connection\n\t    const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n\t    this.path = path;\n\t  },\n\t  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n\t    var firstAnchor, secondAnchor;\n\t    var firstAnchorRef, secondAnchorRef;\n\t    var model = this.model;\n\t    var firstDef = model.get(firstEndType);\n\t    var secondDef = model.get(secondEndType);\n\t    var firstView = this.getEndView(firstEndType);\n\t    var secondView = this.getEndView(secondEndType);\n\t    var firstMagnet = this.getEndMagnet(firstEndType);\n\t    var secondMagnet = this.getEndMagnet(secondEndType);\n\n\t    // Anchor first\n\t    if (firstView) {\n\t      if (firstRef) {\n\t        firstAnchorRef = new Point(firstRef);\n\t      } else if (secondView) {\n\t        firstAnchorRef = secondMagnet;\n\t      } else {\n\t        firstAnchorRef = new Point(secondDef);\n\t      }\n\t      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n\t    } else {\n\t      firstAnchor = new Point(firstDef);\n\t    }\n\n\t    // Anchor second\n\t    if (secondView) {\n\t      secondAnchorRef = new Point(secondRef || firstAnchor);\n\t      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n\t    } else {\n\t      secondAnchor = new Point(secondDef);\n\t    }\n\t    var res = {};\n\t    res[firstEndType] = firstAnchor;\n\t    res[secondEndType] = secondAnchor;\n\t    return res;\n\t  },\n\t  findAnchors: function (vertices) {\n\t    var model = this.model;\n\t    var firstVertex = vertices[0];\n\t    var lastVertex = vertices[vertices.length - 1];\n\t    if (model.target().priority && !model.source().priority) {\n\t      // Reversed order\n\t      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n\t    }\n\n\t    // Usual order\n\t    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n\t  },\n\t  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n\t    var firstWaypoint = route[0];\n\t    var lastWaypoint = route[route.length - 1];\n\t    var model = this.model;\n\t    var sourceDef = model.get('source');\n\t    var targetDef = model.get('target');\n\t    var sourceView = this.sourceView;\n\t    var targetView = this.targetView;\n\t    var paperOptions = this.paper.options;\n\t    var sourceMagnet, targetMagnet;\n\n\t    // Connection Point Source\n\t    var sourcePoint;\n\t    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n\t      sourceMagnet = this.sourceMagnet || sourceView.el;\n\t      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t      var sourcePointRef = firstWaypoint || targetAnchor;\n\t      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n\t      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n\t    } else {\n\t      sourcePoint = sourceAnchor;\n\t    }\n\t    // Connection Point Target\n\t    var targetPoint;\n\t    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n\t      targetMagnet = this.targetMagnet || targetView.el;\n\t      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t      var targetPointRef = lastWaypoint || sourceAnchor;\n\t      var targetLine = new Line(targetPointRef, targetAnchor);\n\t      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n\t    } else {\n\t      targetPoint = targetAnchor;\n\t    }\n\t    return {\n\t      source: sourcePoint,\n\t      target: targetPoint\n\t    };\n\t  },\n\t  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n\t    var isConnection = cellView.isNodeConnection(magnet);\n\t    var paperOptions = this.paper.options;\n\t    if (!anchorDef) {\n\t      if (isConnection) {\n\t        anchorDef = paperOptions.defaultLinkAnchor;\n\t      } else {\n\t        if (this.options.perpendicular) {\n\t          // Backwards compatibility\n\t          // See `manhattan` router for more details\n\t          anchorDef = {\n\t            name: 'perpendicular'\n\t          };\n\t        } else {\n\t          anchorDef = paperOptions.defaultAnchor;\n\t        }\n\t      }\n\t    }\n\t    if (!anchorDef) throw new Error('Anchor required.');\n\t    var anchorFn;\n\t    if (typeof anchorDef === 'function') {\n\t      anchorFn = anchorDef;\n\t    } else {\n\t      var anchorName = anchorDef.name;\n\t      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n\t      anchorFn = paperOptions[anchorNamespace][anchorName];\n\t      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n\t    }\n\t    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n\t    if (!anchor) return new Point();\n\t    return anchor.round(this.decimalsRounding);\n\t  },\n\t  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n\t    var connectionPoint;\n\t    var anchor = line.end;\n\t    var paperOptions = this.paper.options;\n\t    if (!connectionPointDef) return anchor;\n\t    var connectionPointFn;\n\t    if (typeof connectionPointDef === 'function') {\n\t      connectionPointFn = connectionPointDef;\n\t    } else {\n\t      var connectionPointName = connectionPointDef.name;\n\t      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n\t      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n\t    }\n\t    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n\t    if (!connectionPoint) return anchor;\n\t    return connectionPoint.round(this.decimalsRounding);\n\t  },\n\t  isIntersecting: function (geometryShape, geometryData) {\n\t    const connection = this.getConnection();\n\t    if (!connection) return false;\n\t    return intersection$1.exists(geometryShape, connection, geometryData, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  isEnclosedIn: function (geometryRect) {\n\t    const connection = this.getConnection();\n\t    if (!connection) return false;\n\t    const bbox = connection.bbox();\n\t    if (!bbox) return false;\n\t    return geometryRect.containsRect(bbox);\n\t  },\n\t  isAtPoint: function (point /*, options */) {\n\t    // Note: `strict` option is not applicable for links.\n\t    // There is currently no method to determine if a path contains a point.\n\t    const area = new Rect(point);\n\t    // Intersection with a zero-size area is not possible.\n\t    area.inflate(this.EPSILON);\n\t    return this.isIntersecting(area);\n\t  },\n\t  // combine default label position with built-in default label position\n\t  _getDefaultLabelPositionProperty: function () {\n\t    var model = this.model;\n\t    var builtinDefaultLabel = model._builtins.defaultLabel;\n\t    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\t    var defaultLabel = model._getDefaultLabel();\n\t    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\t    return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\t  },\n\t  // if label position is a number, normalize it to a position object\n\t  // this makes sure that label positions can be merged properly\n\t  _normalizeLabelPosition: function (labelPosition) {\n\t    if (typeof labelPosition === 'number') return {\n\t      distance: labelPosition,\n\t      offset: null,\n\t      angle: 0,\n\t      args: null\n\t    };\n\t    return labelPosition;\n\t  },\n\t  // expects normalized position properties\n\t  // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n\t  _mergeLabelPositionProperty: function (normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\t    if (normalizedLabelPosition === null) return null;\n\t    if (normalizedLabelPosition === undefined) {\n\t      if (normalizedDefaultLabelPosition === null) return null;\n\t      return normalizedDefaultLabelPosition;\n\t    }\n\t    return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n\t  },\n\t  updateLabelPositions: function () {\n\t    if (!this._V.labels) return this;\n\t    var path = this.path;\n\t    if (!path) return this;\n\n\t    // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n\t    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n\t    var model = this.model;\n\t    var labels = model.get('labels') || [];\n\t    if (!labels.length) return this;\n\t    var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\t    for (var idx = 0, n = labels.length; idx < n; idx++) {\n\t      var labelNode = this._labelCache[idx];\n\t      if (!labelNode) continue;\n\t      var label = labels[idx];\n\t      var labelPosition = this._normalizeLabelPosition(label.position);\n\t      var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n\t      var transformationMatrix = this._getLabelTransformationMatrix(position);\n\t      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\t      this._cleanLabelMatrices(idx);\n\t    }\n\t    return this;\n\t  },\n\t  _cleanLabelMatrices: function (index) {\n\t    // Clean magnetMatrix for all nodes of the label.\n\t    // Cached BoundingRect does not need to updated when the position changes\n\t    // TODO: this doesn't work for labels with XML String markups.\n\t    const {\n\t      metrics,\n\t      _labelSelectors\n\t    } = this;\n\t    const selectors = _labelSelectors[index];\n\t    if (!selectors) return;\n\t    for (let selector in selectors) {\n\t      const {\n\t        id\n\t      } = selectors[selector];\n\t      if (id && id in metrics) delete metrics[id].magnetMatrix;\n\t    }\n\t  },\n\t  checkEndModel: function (endType, endId) {\n\t    if (!endId) return;\n\t    const endModel = this.paper.getModelById(endId);\n\t    if (!endModel) {\n\t      throw new Error(`LinkView: invalid ${endType} cell.`);\n\t    }\n\t  },\n\t  _getLabelPositionProperty: function (idx) {\n\t    return this.model.label(idx).position || {};\n\t  },\n\t  _getLabelPositionAngle: function (idx) {\n\t    var labelPosition = this._getLabelPositionProperty(idx);\n\t    return labelPosition.angle || 0;\n\t  },\n\t  _getLabelPositionArgs: function (idx) {\n\t    var labelPosition = this._getLabelPositionProperty(idx);\n\t    return labelPosition.args;\n\t  },\n\t  _getDefaultLabelPositionArgs: function () {\n\t    var defaultLabel = this.model._getDefaultLabel();\n\t    var defaultLabelPosition = defaultLabel.position || {};\n\t    return defaultLabelPosition.args;\n\t  },\n\t  // merge default label position args into label position args\n\t  // keep `undefined` or `null` because `{}` means something else\n\t  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n\t    if (labelPositionArgs === null) return null;\n\t    if (labelPositionArgs === undefined) {\n\t      if (defaultLabelPositionArgs === null) return null;\n\t      return defaultLabelPositionArgs;\n\t    }\n\t    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n\t  },\n\t  // Add default label at given position at end of `labels` array.\n\t  // Four signatures:\n\t  // - obj, obj = point, opt\n\t  // - obj, num, obj = point, angle, opt\n\t  // - num, num, obj = x, y, opt\n\t  // - num, num, num, obj = x, y, angle, opt\n\t  // Assigns relative coordinates by default:\n\t  // `opt.absoluteDistance` forces absolute coordinates.\n\t  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n\t  // `opt.absoluteOffset` forces absolute coordinates for offset.\n\t  // Additional args:\n\t  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n\t  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n\t  addLabel: function (p1, p2, p3, p4) {\n\t    // normalize data from the four possible signatures\n\t    var localX;\n\t    var localY;\n\t    var localAngle = 0;\n\t    var localOpt;\n\t    if (typeof p1 !== 'number') {\n\t      // {x, y} object provided as first parameter\n\t      localX = p1.x;\n\t      localY = p1.y;\n\t      if (typeof p2 === 'number') {\n\t        // angle and opt provided as second and third parameters\n\t        localAngle = p2;\n\t        localOpt = p3;\n\t      } else {\n\t        // opt provided as second parameter\n\t        localOpt = p2;\n\t      }\n\t    } else {\n\t      // x and y provided as first and second parameters\n\t      localX = p1;\n\t      localY = p2;\n\t      if (typeof p3 === 'number') {\n\t        // angle and opt provided as third and fourth parameters\n\t        localAngle = p3;\n\t        localOpt = p4;\n\t      } else {\n\t        // opt provided as third parameter\n\t        localOpt = p3;\n\t      }\n\t    }\n\n\t    // merge label position arguments\n\t    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t    var labelPositionArgs = localOpt;\n\t    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t    // append label to labels array\n\t    var label = {\n\t      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n\t    };\n\t    var idx = -1;\n\t    this.model.insertLabel(idx, label, localOpt);\n\t    return idx;\n\t  },\n\t  // Add a new vertex at calculated index to the `vertices` array.\n\t  addVertex: function (x, y, opt) {\n\t    // accept input in form `{ x, y }, opt` or `x, y, opt`\n\t    var isPointProvided = typeof x !== 'number';\n\t    var localX = isPointProvided ? x.x : x;\n\t    var localY = isPointProvided ? x.y : y;\n\t    var localOpt = isPointProvided ? y : opt;\n\t    var vertex = {\n\t      x: localX,\n\t      y: localY\n\t    };\n\t    var idx = this.getVertexIndex(localX, localY);\n\t    this.model.insertVertex(idx, vertex, localOpt);\n\t    return idx;\n\t  },\n\t  // Send a token (an SVG element, usually a circle) along the connection path.\n\t  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n\t  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n\t  // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n\t  // `opt.connection` is an optional selector to the connection path.\n\t  // `callback` is optional and is a function to be called once the token reaches the target.\n\t  sendToken: function (token, opt, callback) {\n\t    function onAnimationEnd(vToken, callback) {\n\t      return function () {\n\t        vToken.remove();\n\t        if (typeof callback === 'function') {\n\t          callback();\n\t        }\n\t      };\n\t    }\n\t    var duration, isReversed, selector;\n\t    if (isObject(opt)) {\n\t      duration = opt.duration;\n\t      isReversed = opt.direction === 'reverse';\n\t      selector = opt.connection;\n\t    } else {\n\t      // Backwards compatibility\n\t      duration = opt;\n\t      isReversed = false;\n\t      selector = null;\n\t    }\n\t    duration = duration || 1000;\n\t    var animationAttributes = {\n\t      dur: duration + 'ms',\n\t      repeatCount: 1,\n\t      calcMode: 'linear',\n\t      fill: 'freeze'\n\t    };\n\t    if (isReversed) {\n\t      animationAttributes.keyPoints = '1;0';\n\t      animationAttributes.keyTimes = '0;1';\n\t    }\n\t    var vToken = V(token);\n\t    var connection;\n\t    if (typeof selector === 'string') {\n\t      // Use custom connection path.\n\t      connection = this.findNode(selector);\n\t    } else {\n\t      // Select connection path automatically.\n\t      var cache = this._V;\n\t      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n\t    }\n\t    if (!(connection instanceof SVGPathElement)) {\n\t      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n\t    }\n\t    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n\t    setTimeout(onAnimationEnd(vToken, callback), duration);\n\t  },\n\t  findRoute: function (vertices) {\n\t    vertices || (vertices = []);\n\t    var namespace = this.paper.options.routerNamespace || routers;\n\t    var router = this.model.router();\n\t    var defaultRouter = this.paper.options.defaultRouter;\n\t    if (!router) {\n\t      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n\t    }\n\t    var routerFn = isFunction(router) ? router : namespace[router.name];\n\t    if (!isFunction(routerFn)) {\n\t      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n\t    }\n\t    var args = router.args || {};\n\t    var route = routerFn.call(this,\n\t    // context\n\t    vertices,\n\t    // vertices\n\t    args,\n\t    // options\n\t    this // linkView\n\t    );\n\t    if (!route) return vertices.map(Point);\n\t    return route;\n\t  },\n\t  // Return the `d` attribute value of the `<path>` element representing the link\n\t  // between `source` and `target`.\n\t  findPath: function (route, sourcePoint, targetPoint) {\n\t    var namespace = this.paper.options.connectorNamespace || connectors;\n\t    var connector = this.model.connector();\n\t    var defaultConnector = this.paper.options.defaultConnector;\n\t    if (!connector) {\n\t      connector = defaultConnector || {};\n\t    }\n\t    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\t    if (!isFunction(connectorFn)) {\n\t      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n\t    }\n\t    var args = clone$1(connector.args || {});\n\t    args.raw = true; // Request raw g.Path as the result.\n\n\t    var path = connectorFn.call(this,\n\t    // context\n\t    sourcePoint,\n\t    // start point\n\t    targetPoint,\n\t    // end point\n\t    route,\n\t    // vertices\n\t    args,\n\t    // options\n\t    this // linkView\n\t    );\n\t    if (typeof path === 'string') {\n\t      // Backwards compatibility for connectors not supporting `raw` option.\n\t      path = new Path$1(V.normalizePathData(path));\n\t    }\n\t    return path;\n\t  },\n\t  // Public API.\n\t  // -----------\n\n\t  getConnection: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.clone();\n\t  },\n\t  getSerializedConnection: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('data')) return metrics.data;\n\t    var data = path.serialize();\n\t    metrics.data = data;\n\t    return data;\n\t  },\n\t  getConnectionSubdivisions: function () {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n\t    var subdivisions = path.getSegmentSubdivisions();\n\t    metrics.segmentSubdivisions = subdivisions;\n\t    return subdivisions;\n\t  },\n\t  getConnectionLength: function () {\n\t    var path = this.path;\n\t    if (!path) return 0;\n\t    var metrics = this.metrics;\n\t    if (metrics.hasOwnProperty('length')) return metrics.length;\n\t    var length = path.length({\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t    metrics.length = length;\n\t    return length;\n\t  },\n\t  getPointAtLength: function (length) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.pointAtLength(length, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getPointAtRatio: function (ratio) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n\t    return path.pointAt(ratio, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getTangentAtLength: function (length) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.tangentAtLength(length, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getTangentAtRatio: function (ratio) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.tangentAt(ratio, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPoint: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPoint(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPointLength: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPointLength(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  getClosestPointRatio: function (point) {\n\t    var path = this.path;\n\t    if (!path) return null;\n\t    return path.closestPointNormalizedLength(point, {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    });\n\t  },\n\t  // Get label position object based on two provided coordinates, x and y.\n\t  // (Used behind the scenes when user moves labels around.)\n\t  // Two signatures:\n\t  // - num, num, obj = x, y, options\n\t  // - num, num, num, obj = x, y, angle, options\n\t  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n\t  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n\t  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n\t  getLabelPosition: function (x, y, p3, p4) {\n\t    var position = {};\n\n\t    // normalize data from the two possible signatures\n\t    var localAngle = 0;\n\t    var localOpt;\n\t    if (typeof p3 === 'number') {\n\t      // angle and opt provided as third and fourth argument\n\t      localAngle = p3;\n\t      localOpt = p4;\n\t    } else {\n\t      // opt provided as third argument\n\t      localOpt = p3;\n\t    }\n\n\t    // save localOpt as `args` of the position object that is passed along\n\t    if (localOpt) position.args = localOpt;\n\n\t    // identify distance/offset settings\n\t    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\t    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n\t    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n\t    // find closest point t\n\t    var path = this.path;\n\t    var pathOpt = {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    };\n\t    var labelPoint = new Point(x, y);\n\t    var t = path.closestPointT(labelPoint, pathOpt);\n\n\t    // DISTANCE:\n\t    var labelDistance = path.lengthAtT(t, pathOpt);\n\t    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n\t    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n\t    position.distance = labelDistance;\n\n\t    // OFFSET:\n\t    // use absolute offset if:\n\t    // - opt.absoluteOffset is true,\n\t    // - opt.absoluteOffset is not true but there is no tangent\n\t    var tangent;\n\t    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n\t    var labelOffset;\n\t    if (tangent) {\n\t      labelOffset = tangent.pointOffset(labelPoint);\n\t    } else {\n\t      var closestPoint = path.pointAtT(t);\n\t      var labelOffsetDiff = labelPoint.difference(closestPoint);\n\t      labelOffset = {\n\t        x: labelOffsetDiff.x,\n\t        y: labelOffsetDiff.y\n\t      };\n\t    }\n\t    position.offset = labelOffset;\n\n\t    // ANGLE:\n\t    position.angle = localAngle;\n\t    return position;\n\t  },\n\t  _getLabelTransformationMatrix: function (labelPosition) {\n\t    var labelDistance;\n\t    var labelAngle = 0;\n\t    var args = {};\n\t    if (typeof labelPosition === 'number') {\n\t      labelDistance = labelPosition;\n\t    } else if (typeof labelPosition.distance === 'number') {\n\t      args = labelPosition.args || {};\n\t      labelDistance = labelPosition.distance;\n\t      labelAngle = labelPosition.angle || 0;\n\t    } else {\n\t      throw new Error('dia.LinkView: invalid label position distance.');\n\t    }\n\t    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n\t    var labelOffset = 0;\n\t    var labelOffsetCoordinates = {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t    if (labelPosition.offset) {\n\t      var positionOffset = labelPosition.offset;\n\t      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n\t      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n\t      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n\t    }\n\t    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n\t    var isKeepGradient = args.keepGradient;\n\t    var isEnsureLegibility = args.ensureLegibility;\n\t    var path = this.path;\n\t    var pathOpt = {\n\t      segmentSubdivisions: this.getConnectionSubdivisions()\n\t    };\n\t    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n\t    var tangent = path.tangentAtLength(distance, pathOpt);\n\t    var translation;\n\t    var angle = labelAngle;\n\t    if (tangent) {\n\t      if (isOffsetAbsolute) {\n\t        translation = tangent.start.clone();\n\t        translation.offset(labelOffsetCoordinates);\n\t      } else {\n\t        var normal = tangent.clone();\n\t        normal.rotate(tangent.start, -90);\n\t        normal.setLength(labelOffset);\n\t        translation = normal.end;\n\t      }\n\t      if (isKeepGradient) {\n\t        angle = tangent.angle() + labelAngle;\n\t        if (isEnsureLegibility) {\n\t          angle = normalizeAngle((angle + 90) % 180 - 90);\n\t        }\n\t      }\n\t    } else {\n\t      // fallback - the connection has zero length\n\t      translation = path.start.clone();\n\t      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n\t    }\n\t    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n\t  },\n\t  getLabelCoordinates: function (labelPosition) {\n\t    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\t    return new Point(transformationMatrix.e, transformationMatrix.f);\n\t  },\n\t  getVertexIndex: function (x, y) {\n\t    var model = this.model;\n\t    var vertices = model.vertices();\n\t    var vertexLength = this.getClosestPointLength(new Point(x, y));\n\t    var idx = 0;\n\t    for (var n = vertices.length; idx < n; idx++) {\n\t      var currentVertex = vertices[idx];\n\t      var currentVertexLength = this.getClosestPointLength(currentVertex);\n\t      if (vertexLength < currentVertexLength) break;\n\t    }\n\t    return idx;\n\t  },\n\t  // Interaction. The controller part.\n\t  // ---------------------------------\n\n\t  notifyPointerdown(evt, x, y) {\n\t    CellView.prototype.pointerdown.call(this, evt, x, y);\n\t    this.notify('link:pointerdown', evt, x, y);\n\t  },\n\t  notifyPointermove(evt, x, y) {\n\t    CellView.prototype.pointermove.call(this, evt, x, y);\n\t    this.notify('link:pointermove', evt, x, y);\n\t  },\n\t  notifyPointerup(evt, x, y) {\n\t    this.notify('link:pointerup', evt, x, y);\n\t    CellView.prototype.pointerup.call(this, evt, x, y);\n\t  },\n\t  pointerdblclick: function (evt, x, y) {\n\t    CellView.prototype.pointerdblclick.apply(this, arguments);\n\t    this.notify('link:pointerdblclick', evt, x, y);\n\t  },\n\t  pointerclick: function (evt, x, y) {\n\t    CellView.prototype.pointerclick.apply(this, arguments);\n\t    this.notify('link:pointerclick', evt, x, y);\n\t  },\n\t  contextmenu: function (evt, x, y) {\n\t    CellView.prototype.contextmenu.apply(this, arguments);\n\t    this.notify('link:contextmenu', evt, x, y);\n\t  },\n\t  pointerdown: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragStart(evt, x, y);\n\t  },\n\t  pointermove: function (evt, x, y) {\n\t    // Backwards compatibility\n\t    var dragData = this._dragData;\n\t    if (dragData) this.eventData(evt, dragData);\n\t    var data = this.eventData(evt);\n\t    switch (data.action) {\n\t      case 'label-move':\n\t        this.dragLabel(evt, x, y);\n\t        break;\n\t      case 'arrowhead-move':\n\t        this.dragArrowhead(evt, x, y);\n\t        break;\n\t      case 'move':\n\t        this.drag(evt, x, y);\n\t        break;\n\t    }\n\n\t    // Backwards compatibility\n\t    if (dragData) assign(dragData, this.eventData(evt));\n\t    this.notifyPointermove(evt, x, y);\n\t  },\n\t  pointerup: function (evt, x, y) {\n\t    // Backwards compatibility\n\t    var dragData = this._dragData;\n\t    if (dragData) {\n\t      this.eventData(evt, dragData);\n\t      this._dragData = null;\n\t    }\n\t    var data = this.eventData(evt);\n\t    switch (data.action) {\n\t      case 'label-move':\n\t        this.dragLabelEnd(evt, x, y);\n\t        break;\n\t      case 'arrowhead-move':\n\t        this.dragArrowheadEnd(evt, x, y);\n\t        break;\n\t      case 'move':\n\t        this.dragEnd(evt, x, y);\n\t    }\n\t    this.notifyPointerup(evt, x, y);\n\t    this.checkMouseleave(evt);\n\t  },\n\t  mouseover: function (evt) {\n\t    CellView.prototype.mouseover.apply(this, arguments);\n\t    this.notify('link:mouseover', evt);\n\t  },\n\t  mouseout: function (evt) {\n\t    CellView.prototype.mouseout.apply(this, arguments);\n\t    this.notify('link:mouseout', evt);\n\t  },\n\t  mouseenter: function (evt) {\n\t    CellView.prototype.mouseenter.apply(this, arguments);\n\t    this.notify('link:mouseenter', evt);\n\t  },\n\t  mouseleave: function (evt) {\n\t    CellView.prototype.mouseleave.apply(this, arguments);\n\t    this.notify('link:mouseleave', evt);\n\t  },\n\t  mousewheel: function (evt, x, y, delta) {\n\t    CellView.prototype.mousewheel.apply(this, arguments);\n\t    this.notify('link:mousewheel', evt, x, y, delta);\n\t  },\n\t  onlabel: function (evt, x, y) {\n\t    this.notifyPointerdown(evt, x, y);\n\t    this.dragLabelStart(evt, x, y);\n\t    var stopPropagation = this.eventData(evt).stopPropagation;\n\t    if (stopPropagation) evt.stopPropagation();\n\t  },\n\t  // Drag Start Handlers\n\n\t  dragLabelStart: function (evt, x, y) {\n\t    if (this.can('labelMove')) {\n\t      if (this.isDefaultInteractionPrevented(evt)) return;\n\t      var labelNode = evt.currentTarget;\n\t      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\t      var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\t      var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n\t      var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\t      var coords = this.getLabelCoordinates(position);\n\t      var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n\t      var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n\t      var positionAngle = this._getLabelPositionAngle(labelIdx);\n\t      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\t      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\t      this.eventData(evt, {\n\t        action: 'label-move',\n\t        labelIdx: labelIdx,\n\t        dx: dx,\n\t        dy: dy,\n\t        positionAngle: positionAngle,\n\t        positionArgs: positionArgs,\n\t        stopPropagation: true\n\t      });\n\t    } else {\n\t      // Backwards compatibility:\n\t      // If labels can't be dragged no default action is triggered.\n\t      this.eventData(evt, {\n\t        stopPropagation: true\n\t      });\n\t    }\n\t    this.paper.delegateDragEvents(this, evt.data);\n\t  },\n\t  dragArrowheadStart: function (evt, x, y) {\n\t    if (!this.can('arrowheadMove')) return;\n\t    var arrowheadNode = evt.target;\n\t    var arrowheadType = arrowheadNode.getAttribute('end');\n\t    var data = this.startArrowheadMove(arrowheadType, {\n\t      ignoreBackwardsCompatibility: true\n\t    });\n\t    this.eventData(evt, data);\n\t  },\n\t  dragStart: function (evt, x, y) {\n\t    if (this.isDefaultInteractionPrevented(evt)) return;\n\t    if (!this.can('linkMove')) return;\n\t    this.eventData(evt, {\n\t      action: 'move',\n\t      dx: x,\n\t      dy: y\n\t    });\n\t  },\n\t  // Drag Handlers\n\t  dragLabel: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var label = {\n\t      position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n\t    };\n\t    if (this.paper.options.snapLabels) delete label.position.offset;\n\t    // The `touchmove' events are not fired\n\t    // when the original event target is removed from the DOM.\n\t    // The labels are currently re-rendered completely when only\n\t    // the position changes. This is why we need to make sure that\n\t    // the label is updated synchronously.\n\t    // TODO: replace `touchmove` with `pointermove` (breaking change).\n\t    const setOptions = {\n\t      ui: true\n\t    };\n\t    if (this.paper.isAsync() && evt.type === 'touchmove') {\n\t      setOptions.async = false;\n\t    }\n\t    this.model.label(data.labelIdx, label, setOptions);\n\t  },\n\t  dragArrowhead: function (evt, x, y) {\n\t    if (this.paper.options.snapLinks) {\n\t      const isSnapped = this._snapArrowhead(evt, x, y);\n\t      if (!isSnapped && this.paper.options.snapLinksSelf) {\n\t        this._snapArrowheadSelf(evt, x, y);\n\t      }\n\t    } else {\n\t      if (this.paper.options.snapLinksSelf) {\n\t        this._snapArrowheadSelf(evt, x, y);\n\t      } else {\n\t        this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n\t      }\n\t    }\n\t  },\n\t  drag: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    this.model.translate(x - data.dx, y - data.dy, {\n\t      ui: true\n\t    });\n\t    this.eventData(evt, {\n\t      dx: x,\n\t      dy: y\n\t    });\n\t  },\n\t  // Drag End Handlers\n\n\t  dragLabelEnd: function () {\n\t    // noop\n\t  },\n\t  dragArrowheadEnd: function (evt, x, y) {\n\t    var data = this.eventData(evt);\n\t    var paper = this.paper;\n\t    if (paper.options.snapLinks) {\n\t      this._snapArrowheadEnd(data);\n\t    } else {\n\t      this._connectArrowheadEnd(data, x, y);\n\t    }\n\t    if (!paper.linkAllowed(this)) {\n\t      // If the changed link is not allowed, revert to its previous state.\n\t      this._disallow(data);\n\t    } else {\n\t      this._finishEmbedding(data);\n\t      this._notifyConnectEvent(data, evt);\n\t    }\n\t    this._afterArrowheadMove(data);\n\t  },\n\t  dragEnd: function () {\n\t    // noop\n\t  },\n\t  _disallow: function (data) {\n\t    switch (data.whenNotAllowed) {\n\t      case 'remove':\n\t        this.model.remove({\n\t          ui: true\n\t        });\n\t        break;\n\t      case 'revert':\n\t      default:\n\t        this.model.set(data.arrowhead, data.initialEnd, {\n\t          ui: true\n\t        });\n\t        break;\n\t    }\n\t  },\n\t  _finishEmbedding: function (data) {\n\t    // Reparent the link if embedding is enabled\n\t    if (this.paper.options.embeddingMode && this.model.reparent()) {\n\t      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n\t      data.z = null;\n\t    }\n\t  },\n\t  _notifyConnectEvent: function (data, evt) {\n\t    var arrowhead = data.arrowhead;\n\t    var initialEnd = data.initialEnd;\n\t    var currentEnd = this.model.prop(arrowhead);\n\t    var endChanged = currentEnd && !Link$1.endsEqual(initialEnd, currentEnd);\n\t    if (endChanged) {\n\t      var paper = this.paper;\n\t      if (initialEnd.id) {\n\t        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n\t      }\n\t      if (currentEnd.id) {\n\t        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n\t      }\n\t    }\n\t  },\n\t  _snapToPoints: function (snapPoint, points, radius) {\n\t    let closestPointX = null;\n\t    let closestDistanceX = Infinity;\n\t    let closestPointY = null;\n\t    let closestDistanceY = Infinity;\n\t    let x = snapPoint.x;\n\t    let y = snapPoint.y;\n\t    for (let i = 0; i < points.length; i++) {\n\t      const distX = Math.abs(points[i].x - snapPoint.x);\n\t      if (distX < closestDistanceX) {\n\t        closestDistanceX = distX;\n\t        closestPointX = points[i];\n\t      }\n\t      const distY = Math.abs(points[i].y - snapPoint.y);\n\t      if (distY < closestDistanceY) {\n\t        closestDistanceY = distY;\n\t        closestPointY = points[i];\n\t      }\n\t    }\n\t    if (closestDistanceX < radius) {\n\t      x = closestPointX.x;\n\t    }\n\t    if (closestDistanceY < radius) {\n\t      y = closestPointY.y;\n\t    }\n\t    return {\n\t      x,\n\t      y\n\t    };\n\t  },\n\t  _snapArrowheadSelf: function (evt, x, y) {\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    const {\n\t      snapLinksSelf\n\t    } = paper.options;\n\t    const data = this.eventData(evt);\n\t    const radius = snapLinksSelf.radius || 20;\n\t    const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n\t    const vertices = model.vertices();\n\t    const points = [anchor, ...vertices];\n\t    const snapPoint = this._snapToPoints({\n\t      x: x,\n\t      y: y\n\t    }, points, radius);\n\t    const point = paper.localToClientPoint(snapPoint);\n\t    this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n\t  },\n\t  _snapArrowhead: function (evt, x, y) {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      snapLinks,\n\t      connectionStrategy\n\t    } = paper.options;\n\t    const data = this.eventData(evt);\n\t    let isSnapped = false;\n\t    // checking view in close area of the pointer\n\n\t    const radius = snapLinks.radius || 50;\n\t    const findInAreaOptions = snapLinks.findInAreaOptions;\n\t    const prevClosestView = data.closestView || null;\n\t    const prevClosestMagnet = data.closestMagnet || null;\n\t    const prevMagnetProxy = data.magnetProxy || null;\n\t    data.closestView = data.closestMagnet = data.magnetProxy = null;\n\t    const isValidCandidate = (view, magnet) => {\n\t      // Do not snap to the current view\n\t      if (view === this) {\n\t        return false;\n\t      }\n\t      const isAlreadyValidated = prevClosestMagnet === magnet;\n\t      return isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet));\n\t    };\n\t    const closest = paper.findClosestMagnetToPoint({\n\t      x,\n\t      y\n\t    }, {\n\t      radius,\n\t      findInAreaOptions,\n\t      filter: isValidCandidate\n\t    });\n\t    data.closestView = closest ? closest.view : null;\n\t    data.closestMagnet = closest ? closest.magnet : null;\n\t    var end;\n\t    var magnetProxy = null;\n\t    var closestView = data.closestView;\n\t    var closestMagnet = data.closestMagnet;\n\t    if (closestMagnet) {\n\t      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n\t    }\n\t    var endType = data.arrowhead;\n\t    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n\t    if (prevClosestView && newClosestMagnet) {\n\t      prevClosestView.unhighlight(prevMagnetProxy, {\n\t        connecting: true,\n\t        snapping: true\n\t      });\n\t    }\n\t    if (closestView) {\n\t      const {\n\t        prevEnd,\n\t        prevX,\n\t        prevY\n\t      } = data;\n\t      data.prevX = x;\n\t      data.prevY = y;\n\t      isSnapped = true;\n\t      if (!newClosestMagnet) {\n\t        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {\n\t          // the magnet has not changed and the link's end does not depend on the x and y\n\t          return isSnapped;\n\t        }\n\t      }\n\t      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\t      if (!newClosestMagnet && isEqual(prevEnd, end)) {\n\t        // the source/target json has not changed\n\t        return isSnapped;\n\t      }\n\t      data.prevEnd = end;\n\t      if (newClosestMagnet) {\n\t        closestView.highlight(magnetProxy, {\n\t          connecting: true,\n\t          snapping: true\n\t        });\n\t      }\n\t    } else {\n\t      end = {\n\t        x: x,\n\t        y: y\n\t      };\n\t    }\n\t    this.model.set(endType, end || {\n\t      x: x,\n\t      y: y\n\t    }, {\n\t      ui: true\n\t    });\n\t    if (prevClosestView) {\n\t      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n\t    }\n\t    if (closestView) {\n\t      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n\t    }\n\t    return isSnapped;\n\t  },\n\t  _snapArrowheadEnd: function (data) {\n\t    // Finish off link snapping.\n\t    // Everything except view unhighlighting was already done on pointermove.\n\t    var closestView = data.closestView;\n\t    var closestMagnet = data.closestMagnet;\n\t    if (closestView && closestMagnet) {\n\t      closestView.unhighlight(data.magnetProxy, {\n\t        connecting: true,\n\t        snapping: true\n\t      });\n\t      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n\t    }\n\t    data.closestView = data.closestMagnet = null;\n\t  },\n\t  _connectArrowhead: function (target, x, y, data) {\n\t    // checking views right under the pointer\n\t    const {\n\t      paper,\n\t      model\n\t    } = this;\n\t    if (data.eventTarget !== target) {\n\t      // Unhighlight the previous view under pointer if there was one.\n\t      if (data.magnetProxy) {\n\t        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n\t          connecting: true\n\t        });\n\t      }\n\t      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\t      if (viewUnderPointer) {\n\t        // If we found a view that is under the pointer, we need to find the closest\n\t        // magnet based on the real target element of the event.\n\t        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n\t        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\t        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n\t          // If there was no magnet found, do not highlight anything and assume there\n\t          // is no view under pointer we're interested in reconnecting to.\n\t          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n\t          if (magnetProxy) {\n\t            viewUnderPointer.highlight(magnetProxy, {\n\t              connecting: true\n\t            });\n\t          }\n\t        } else {\n\t          // This type of connection is not valid. Disregard this magnet.\n\t          data.magnetUnderPointer = null;\n\t          data.magnetProxy = null;\n\t        }\n\t      } else {\n\t        // Make sure we'll unset previous magnet.\n\t        data.magnetUnderPointer = null;\n\t        data.magnetProxy = null;\n\t      }\n\t    }\n\t    data.eventTarget = target;\n\t    model.set(data.arrowhead, {\n\t      x: x,\n\t      y: y\n\t    }, {\n\t      ui: true\n\t    });\n\t  },\n\t  _connectArrowheadEnd: function (data = {}, x, y) {\n\t    const {\n\t      model\n\t    } = this;\n\t    const {\n\t      viewUnderPointer,\n\t      magnetUnderPointer,\n\t      magnetProxy,\n\t      arrowhead\n\t    } = data;\n\t    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\t    viewUnderPointer.unhighlight(magnetProxy, {\n\t      connecting: true\n\t    });\n\n\t    // The link end is taken from the magnet under the pointer, not the proxy.\n\t    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n\t    model.set(arrowhead, end, {\n\t      ui: true\n\t    });\n\t  },\n\t  _beforeArrowheadMove: function (data) {\n\t    data.z = this.model.get('z');\n\t    this.model.toFront();\n\n\t    // Let the pointer propagate through the link view elements so that\n\t    // the `evt.target` is another element under the pointer, not the link itself.\n\t    var style = this.el.style;\n\t    data.pointerEvents = style.pointerEvents;\n\t    style.pointerEvents = 'none';\n\t    if (this.paper.options.markAvailable) {\n\t      this._markAvailableMagnets(data);\n\t    }\n\t  },\n\t  _afterArrowheadMove: function (data) {\n\t    if (data.z !== null) {\n\t      this.model.set('z', data.z, {\n\t        ui: true\n\t      });\n\t      data.z = null;\n\t    }\n\n\t    // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\t    this.el.style.pointerEvents = data.pointerEvents;\n\t    if (this.paper.options.markAvailable) {\n\t      this._unmarkAvailableMagnets(data);\n\t    }\n\t  },\n\t  _createValidateConnectionArgs: function (arrowhead) {\n\t    // It makes sure the arguments for validateConnection have the following form:\n\t    // (source view, source magnet, target view, target magnet and link view)\n\t    var args = [];\n\t    args[4] = arrowhead;\n\t    args[5] = this;\n\t    var oppositeArrowhead;\n\t    var i = 0;\n\t    var j = 0;\n\t    if (arrowhead === 'source') {\n\t      i = 2;\n\t      oppositeArrowhead = 'target';\n\t    } else {\n\t      j = 2;\n\t      oppositeArrowhead = 'source';\n\t    }\n\t    var end = this.model.get(oppositeArrowhead);\n\t    if (end.id) {\n\t      var view = args[i] = this.paper.findViewByModel(end.id);\n\t      var magnet = view.getMagnetFromLinkEnd(end);\n\t      if (magnet === view.el) magnet = undefined;\n\t      args[i + 1] = magnet;\n\t    }\n\t    function validateConnectionArgs(cellView, magnet) {\n\t      args[j] = cellView;\n\t      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n\t      return args;\n\t    }\n\t    return validateConnectionArgs;\n\t  },\n\t  _markAvailableMagnets: function (data) {\n\t    function isMagnetAvailable(view, magnet) {\n\t      var paper = view.paper;\n\t      var validate = paper.options.validateConnection;\n\t      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n\t    }\n\t    var paper = this.paper;\n\t    var elements = paper.model.getCells();\n\t    data.marked = {};\n\t    for (var i = 0, n = elements.length; i < n; i++) {\n\t      var view = elements[i].findView(paper);\n\t      if (!view) {\n\t        continue;\n\t      }\n\t      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\t      if (view.el.getAttribute('magnet') !== 'false') {\n\t        // Element wrapping group is also a magnet\n\t        magnets.push(view.el);\n\t      }\n\t      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\t      if (availableMagnets.length > 0) {\n\t        // highlight all available magnets\n\t        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n\t          view.highlight(availableMagnets[j], {\n\t            magnetAvailability: true\n\t          });\n\t        }\n\t        // highlight the entire view\n\t        view.highlight(null, {\n\t          elementAvailability: true\n\t        });\n\t        data.marked[view.model.id] = availableMagnets;\n\t      }\n\t    }\n\t  },\n\t  _unmarkAvailableMagnets: function (data) {\n\t    var markedKeys = Object.keys(data.marked);\n\t    var id;\n\t    var markedMagnets;\n\t    for (var i = 0, n = markedKeys.length; i < n; i++) {\n\t      id = markedKeys[i];\n\t      markedMagnets = data.marked[id];\n\t      var view = this.paper.findViewByModel(id);\n\t      if (view) {\n\t        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n\t          view.unhighlight(markedMagnets[j], {\n\t            magnetAvailability: true\n\t          });\n\t        }\n\t        view.unhighlight(null, {\n\t          elementAvailability: true\n\t        });\n\t      }\n\t    }\n\t    data.marked = null;\n\t  },\n\t  startArrowheadMove: function (end, opt) {\n\t    opt || (opt = {});\n\n\t    // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n\t    // move without need to click on the actual arrowhead dom element.\n\t    var data = {\n\t      action: 'arrowhead-move',\n\t      arrowhead: end,\n\t      whenNotAllowed: opt.whenNotAllowed || 'revert',\n\t      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n\t      initialEnd: clone$1(this.model.get(end)),\n\t      validateConnectionArgs: this._createValidateConnectionArgs(end)\n\t    };\n\t    this._beforeArrowheadMove(data);\n\t    if (opt.ignoreBackwardsCompatibility !== true) {\n\t      this._dragData = data;\n\t    }\n\t    return data;\n\t  },\n\t  // Lifecycle methods\n\n\t  onMount: function () {\n\t    CellView.prototype.onMount.apply(this, arguments);\n\t    this.mountLabels();\n\t  },\n\t  onDetach: function () {\n\t    CellView.prototype.onDetach.apply(this, arguments);\n\t    this.unmountLabels();\n\t  },\n\t  onRemove: function () {\n\t    CellView.prototype.onRemove.apply(this, arguments);\n\t    this.unmountLabels();\n\t  }\n\t}, {\n\t  Flags: Flags\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceView', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const source = this.model.attributes.source;\n\t    if (source.id && this.paper) {\n\t      return this.paper.findViewByModel(source.id);\n\t    }\n\t    return null;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetView', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const target = this.model.attributes.target;\n\t    if (target.id && this.paper) {\n\t      return this.paper.findViewByModel(target.id);\n\t    }\n\t    return null;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceMagnet', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const sourceView = this.sourceView;\n\t    if (!sourceView) return null;\n\t    let sourceMagnet = null;\n\t    // Check if the magnet is already found and cached.\n\t    // We need to check if the cached magnet is still part of the source view.\n\t    // The source view might have been disposed and recreated, or the magnet might have been changed.\n\t    const cachedSourceMagnet = this._sourceMagnet;\n\t    if (cachedSourceMagnet && sourceView.el.contains(cachedSourceMagnet)) {\n\t      sourceMagnet = cachedSourceMagnet;\n\t    } else {\n\t      // If the cached magnet is not valid, we need to find the magnet.\n\t      sourceMagnet = sourceView.getMagnetFromLinkEnd(this.model.attributes.source);\n\t    }\n\t    this._sourceMagnet = sourceMagnet;\n\t    if (sourceMagnet === sourceView.el) {\n\t      // If the source magnet is the element itself, we treat it as no magnet.\n\t      return null;\n\t    }\n\t    return sourceMagnet;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetMagnet', {\n\t  enumerable: true,\n\t  get: function () {\n\t    const targetView = this.targetView;\n\t    if (!targetView) return null;\n\t    let targetMagnet = null;\n\t    // Check if the magnet is already found and cached (See `sourceMagnet` for explanation).\n\t    const cachedTargetMagnet = this._targetMagnet;\n\t    if (cachedTargetMagnet && targetView.el.contains(cachedTargetMagnet)) {\n\t      targetMagnet = cachedTargetMagnet;\n\t    } else {\n\t      // If the cached magnet is not valid, we need to find the magnet.\n\t      targetMagnet = targetView.getMagnetFromLinkEnd(this.model.attributes.target);\n\t    }\n\t    this._targetMagnet = targetMagnet;\n\t    if (targetMagnet === targetView.el) {\n\t      // If the target magnet is the element itself, we treat it as no magnet.\n\t      return null;\n\t    }\n\t    return targetMagnet;\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\t  enumerable: true,\n\t  get: function () {\n\t    var sourceView = this.sourceView;\n\t    if (!sourceView) {\n\t      var sourceDef = this.model.source();\n\t      return new Rect(sourceDef.x, sourceDef.y);\n\t    }\n\t    var sourceMagnet = this.sourceMagnet;\n\t    if (sourceView.isNodeConnection(sourceMagnet)) {\n\t      return new Rect(this.sourceAnchor);\n\t    }\n\t    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n\t  }\n\t});\n\tObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\t  enumerable: true,\n\t  get: function () {\n\t    var targetView = this.targetView;\n\t    if (!targetView) {\n\t      var targetDef = this.model.target();\n\t      return new Rect(targetDef.x, targetDef.y);\n\t    }\n\t    var targetMagnet = this.targetMagnet;\n\t    if (targetView.isNodeConnection(targetMagnet)) {\n\t      return new Rect(this.targetAnchor);\n\t    }\n\t    return targetView.getNodeBBox(targetMagnet || targetView.el);\n\t  }\n\t});\n\n\tconst LayerView = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  pivotNodes: null,\n\t  defaultTheme: null,\n\t  UPDATE_PRIORITY: 4,\n\t  options: {\n\t    id: ''\n\t  },\n\t  paper: null,\n\t  init: function () {\n\t    this.pivotNodes = {};\n\t    this.id = this.options.id || this.cid;\n\t  },\n\t  setPaperReference: function (paper) {\n\t    this.paper = paper;\n\t    this.afterPaperReferenceSet(paper);\n\t  },\n\t  unsetPaperReference: function () {\n\t    if (!this.paper) return;\n\t    this.beforePaperReferenceUnset(this.paper);\n\t    this.paper = null;\n\t  },\n\t  assertPaperReference() {\n\t    if (!this.paper) {\n\t      throw new Error('LayerView: paper reference is not set.');\n\t    }\n\t  },\n\t  afterPaperReferenceSet: function () {\n\t    // Can be overridden in subclasses.\n\t  },\n\t  beforePaperReferenceUnset: function () {\n\t    // Can be overridden in subclasses.\n\t  },\n\t  // prevents id to be set on the DOM element\n\t  _setAttributes: function (attrs) {\n\t    const newAttrs = clone$1(attrs);\n\t    delete newAttrs.id;\n\t    View.prototype._setAttributes.call(this, newAttrs);\n\t  },\n\t  className: function () {\n\t    const {\n\t      id\n\t    } = this.options;\n\t    return addClassNamePrefix(`${id}-layer`);\n\t  },\n\t  insertSortedNode: function (node, z) {\n\t    this.el.insertBefore(node, this.insertPivot(z));\n\t  },\n\t  insertNode: function (node) {\n\t    const {\n\t      el\n\t    } = this;\n\t    if (node.parentNode !== el) {\n\t      el.appendChild(node);\n\t    }\n\t  },\n\t  insertPivot: function (z) {\n\t    const {\n\t      el,\n\t      pivotNodes\n\t    } = this;\n\t    z = +z;\n\t    z || (z = 0);\n\t    let pivotNode = pivotNodes[z];\n\t    if (pivotNode) return pivotNode;\n\t    pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n\t    let neighborZ = -Infinity;\n\t    for (let currentZ in pivotNodes) {\n\t      currentZ = +currentZ;\n\t      if (currentZ < z && currentZ > neighborZ) {\n\t        neighborZ = currentZ;\n\t        if (neighborZ === z - 1) continue;\n\t      }\n\t    }\n\t    if (neighborZ !== -Infinity) {\n\t      const neighborPivot = pivotNodes[neighborZ];\n\t      // Insert After\n\t      el.insertBefore(pivotNode, neighborPivot.nextSibling);\n\t    } else {\n\t      // First Child\n\t      el.insertBefore(pivotNode, el.firstChild);\n\t    }\n\t    return pivotNode;\n\t  },\n\t  removePivots: function () {\n\t    const {\n\t      el,\n\t      pivotNodes\n\t    } = this;\n\t    for (let z in pivotNodes) el.removeChild(pivotNodes[z]);\n\t    this.pivotNodes = {};\n\t  },\n\t  isEmpty: function () {\n\t    // Check if the layer has any child elements (pivot comments are not counted).\n\t    return this.el.children.length === 0;\n\t  },\n\t  reset: function () {\n\t    this.removePivots();\n\t  }\n\t});\n\tObject.defineProperty(LayerView.prototype, LAYER_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class GraphLayerView\n\t * @description A GraphLayerView is responsible for managing the rendering of cell views inside a layer.\n\t * It listens to the corresponding GraphLayer model and updates the DOM accordingly.\n\t * It uses dia.Paper sorting options to sort cell views in the DOM based on their `z` attribute.\n\t */\n\tconst GraphLayerView = LayerView.extend({\n\t  SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n\t  style: {\n\t    webkitUserSelect: 'none',\n\t    userSelect: 'none'\n\t  },\n\t  graph: null,\n\t  init() {\n\t    LayerView.prototype.init.apply(this, arguments);\n\t    this.graph = this.model.graph;\n\t  },\n\t  className: function () {\n\t    const {\n\t      id\n\t    } = this.options;\n\t    return [addClassNamePrefix(`${id}-layer`), addClassNamePrefix('cells')].join(' ');\n\t  },\n\t  afterPaperReferenceSet(paper) {\n\t    this.listenTo(this.model, 'sort', this.onCellCollectionSort);\n\t    this.listenTo(this.model, 'change', this.onCellChange);\n\t    this.listenTo(this.model, 'move', this.onCellMove);\n\t    this.listenTo(this.graph, 'batch:stop', this.onGraphBatchStop);\n\t  },\n\t  beforePaperReferenceUnset() {\n\t    this.stopListening(this.model);\n\t    this.stopListening(this.graph);\n\t  },\n\t  onCellCollectionSort() {\n\t    if (this.graph.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n\t    this.sort();\n\t  },\n\t  onCellMove(cell, opt = {}) {\n\t    // When a cell is moved from one layer to another,\n\t    // request insertion of its view in the new layer.\n\t    this.paper.requestCellViewInsertion(cell, opt);\n\t  },\n\t  onCellChange(cell, opt) {\n\t    if (!cell.hasChanged('z')) return;\n\t    // Re-insert the cell view to maintain correct z-ordering\n\t    if (this.paper.options.sorting === sortingTypes.APPROX) {\n\t      this.paper.requestCellViewInsertion(cell, opt);\n\t    }\n\t  },\n\t  onGraphBatchStop(data) {\n\t    const name = data && data.batchName;\n\t    const sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n\t    // After certain batches, sorting may be required\n\t    if (sortDelayingBatches.includes(name) && !this.graph.hasActiveBatch(sortDelayingBatches)) {\n\t      this.sort();\n\t    }\n\t  },\n\t  sort() {\n\t    this.assertPaperReference();\n\t    const {\n\t      paper\n\t    } = this;\n\t    if (!paper.isExactSorting()) {\n\t      // noop\n\t      return;\n\t    }\n\t    if (paper.isFrozen()) {\n\t      // sort views once unfrozen\n\t      paper._updates.sort = true;\n\t      return;\n\t    }\n\t    this.sortExact();\n\t  },\n\t  sortExact() {\n\t    // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n\t    // associated model `z` attribute.\n\t    const cellNodes = Array.from(this.el.children).filter(node => node.getAttribute('model-id'));\n\t    const cellCollection = this.model.cellCollection;\n\t    sortElements(cellNodes, function (a, b) {\n\t      const cellA = cellCollection.get(a.getAttribute('model-id'));\n\t      const cellB = cellCollection.get(b.getAttribute('model-id'));\n\t      const zA = cellA.attributes.z || 0;\n\t      const zB = cellB.attributes.z || 0;\n\t      return zA === zB ? 0 : zA < zB ? -1 : 1;\n\t    });\n\t  },\n\t  insertCellView(cellView) {\n\t    this.assertPaperReference();\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      el,\n\t      model\n\t    } = cellView;\n\t    switch (paper.options.sorting) {\n\t      case sortingTypes.APPROX:\n\t        this.insertSortedNode(el, model.get('z'));\n\t        break;\n\t      case sortingTypes.EXACT:\n\t      default:\n\t        this.insertNode(el);\n\t        break;\n\t    }\n\t  }\n\t});\n\tObject.defineProperty(GraphLayerView.prototype, GRAPH_LAYER_VIEW_MARKER, {\n\t  value: true\n\t});\n\n\t/**\n\t * @class LegacyGraphLayerView\n\t * @description A legacy GraphLayerView with an additional class name for backward compatibility.\n\t */\n\tconst LegacyGraphLayerView = GraphLayerView.extend({\n\t  className: function () {\n\t    const className = GraphLayerView.prototype.className.apply(this, arguments);\n\t    return className + ' ' + addClassNamePrefix('viewport');\n\t  }\n\t});\n\n\t/**\n\t * Deque implementation for managing a double-ended queue.\n\t * This implementation uses a doubly linked list for efficient operations.\n\t * It supports operations like push, pop, move to head, and delete.\n\t * The deque maintains a map for O(1) access to nodes by key.\n\t */\n\tclass Deque {\n\t  constructor() {\n\t    this.head = null;\n\t    this.tail = null;\n\t    this.map = new Map(); // key -> node\n\t  }\n\n\t  // Return an array of keys in the deque\n\t  keys() {\n\t    let current = this.head;\n\t    const keys = [];\n\t    while (current) {\n\t      keys.push(current.key);\n\t      current = current.next;\n\t    }\n\t    return keys;\n\t  }\n\n\t  // Return the first node and remove it from the deque\n\t  popHead() {\n\t    if (!this.head) return null;\n\t    const node = this.head;\n\t    this.map.delete(node.key);\n\t    this.head = node.next;\n\t    if (this.head) {\n\t      this.head.prev = null;\n\t    } else {\n\t      this.tail = null;\n\t    }\n\t    return node;\n\t  }\n\n\t  // Add a new node to the back of the deque\n\t  pushTail(key, value) {\n\t    if (this.map.has(key)) {\n\t      throw new Error(`Key \"${key}\" already exists in the deque.`);\n\t    }\n\t    const node = {\n\t      key,\n\t      value,\n\t      prev: null,\n\t      next: null\n\t    };\n\t    this.map.set(key, node);\n\t    if (!this.tail) {\n\t      this.head = this.tail = node;\n\t    } else {\n\t      this.tail.next = node;\n\t      node.prev = this.tail;\n\t      this.tail = node;\n\t    }\n\t  }\n\n\t  // Move a node from the deque to the head\n\t  moveToHead(key) {\n\t    const node = this.map.get(key);\n\t    if (!node) return;\n\t    if (node === this.head) return; // already at head\n\t    // Remove node from its current position\n\t    if (node.prev) node.prev.next = node.next;\n\t    if (node.next) node.next.prev = node.prev;\n\t    if (node === this.tail) this.tail = node.prev; // if it's the tail\n\t    if (node === this.head) this.head = node.next; // if it's the head\n\t    // Move node to head\n\t    node.prev = null;\n\t    node.next = this.head;\n\t    if (this.head) {\n\t      this.head.prev = node; // link old head back to new head\n\t    }\n\t    this.head = node; // update head to be the moved node\n\t    if (!this.tail) {\n\t      this.tail = node; // if it was the only node, set tail as well\n\t    }\n\t  }\n\n\t  // Return the first node without removing it\n\t  peekHead() {\n\t    return this.head || null;\n\t  }\n\n\t  // Move the head node to the back of the deque\n\t  rotate() {\n\t    if (!this.head || !this.head.next) return;\n\t    this.tail.next = this.head; // link tail to head\n\t    this.head.prev = this.tail; // link head back to tail\n\t    this.tail = this.head; // update tail to be the old head\n\t    this.head = this.head.next; // move head to the next node\n\t    this.tail.next = null; // set new tail's next to null\n\t    this.head.prev = null; // set new head's prev to null\n\t  }\n\n\t  // Remove a node from the deque\n\t  delete(key) {\n\t    const node = this.map.get(key);\n\t    if (!node) return;\n\t    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n\t    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\t    this.map.delete(key);\n\t  }\n\n\t  // Does the deque contain a node with the given key?\n\t  has(key) {\n\t    return this.map.has(key);\n\t  }\n\n\t  // Get the node with the given key\n\t  get(key) {\n\t    return this.map.get(key) || null;\n\t  }\n\n\t  // Number of nodes in the deque\n\t  get length() {\n\t    return this.map.size;\n\t  }\n\t}\n\n\tconst GridLayerView = LayerView.extend({\n\t  style: {\n\t    'pointer-events': 'none'\n\t  },\n\t  _gridCache: null,\n\t  _gridSettings: null,\n\t  init() {\n\t    LayerView.prototype.init.apply(this, arguments);\n\t    this.paper = this.options.paper;\n\t    this._gridCache = null;\n\t    this._gridSettings = [];\n\t  },\n\t  afterPaperReferenceSet(paper) {\n\t    this.listenTo(paper, 'transform resize', this.updateGrid);\n\t  },\n\t  beforePaperReferenceUnset(paper) {\n\t    this.stopListening(paper);\n\t  },\n\t  setGrid(drawGrid) {\n\t    this._gridSettings = this.getGridSettings(drawGrid);\n\t    this.renderGrid();\n\t  },\n\t  getGridSettings(drawGrid) {\n\t    const gridSettings = [];\n\t    if (drawGrid) {\n\t      const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n\t      optionsList.forEach(item => {\n\t        gridSettings.push(...this._resolveDrawGridOption(item));\n\t      });\n\t    }\n\t    return gridSettings;\n\t  },\n\t  removeGrid() {\n\t    const {\n\t      _gridCache: grid\n\t    } = this;\n\t    if (!grid) return;\n\t    grid.root.remove();\n\t    this._gridCache = null;\n\t  },\n\t  renderGrid() {\n\t    const {\n\t      paper\n\t    } = this;\n\t    const {\n\t      _gridSettings: gridSettings\n\t    } = this;\n\t    this.removeGrid();\n\t    if (gridSettings.length === 0) return;\n\t    const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n\t    if (gridSize <= 1) {\n\t      return;\n\t    }\n\t    const refs = this._getGridRefs();\n\t    gridSettings.forEach((gridLayerSetting, index) => {\n\t      const id = this._getPatternId(index);\n\t      const options = merge({}, gridLayerSetting);\n\t      const {\n\t        scaleFactor = 1\n\t      } = options;\n\t      options.width = gridSize * scaleFactor || 1;\n\t      options.height = gridSize * scaleFactor || 1;\n\t      let vPattern;\n\t      if (!refs.exist(id)) {\n\t        vPattern = V('pattern', {\n\t          id: id,\n\t          patternUnits: 'userSpaceOnUse'\n\t        }, V(options.markup));\n\t        refs.add(id, vPattern);\n\t      } else {\n\t        vPattern = refs.get(id);\n\t      }\n\t      if (isFunction(options.render)) {\n\t        options.render(vPattern.node.firstChild, options, paper);\n\t      }\n\t      vPattern.attr({\n\t        width: options.width,\n\t        height: options.height\n\t      });\n\t    });\n\t    refs.root.appendTo(this.el);\n\t    this.updateGrid();\n\t  },\n\t  updateGrid() {\n\t    const {\n\t      _gridCache: grid,\n\t      _gridSettings: gridSettings,\n\t      paper\n\t    } = this;\n\t    if (!grid) return;\n\t    const {\n\t      root: vSvg,\n\t      patterns\n\t    } = grid;\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = paper.getArea();\n\t    vSvg.attr({\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    });\n\t    for (const patternId in patterns) {\n\t      const vPattern = patterns[patternId];\n\t      vPattern.attr({\n\t        x: -x,\n\t        y: -y\n\t      });\n\t    }\n\t    gridSettings.forEach((options, index) => {\n\t      if (isFunction(options.update)) {\n\t        const vPattern = patterns[this._getPatternId(index)];\n\t        options.update(vPattern.node.firstChild, options, paper);\n\t      }\n\t    });\n\t  },\n\t  _getPatternId(index) {\n\t    return `pattern_${this.paper.cid}_${index}`;\n\t  },\n\t  _getGridRefs() {\n\t    let {\n\t      _gridCache: grid\n\t    } = this;\n\t    if (grid) return grid;\n\t    const defsVEl = V('defs');\n\t    const svgVEl = V('svg', {\n\t      width: '100%',\n\t      height: '100%'\n\t    }, [defsVEl]);\n\t    grid = this._gridCache = {\n\t      root: svgVEl,\n\t      patterns: {},\n\t      add: function (id, patternVEl) {\n\t        const rectVEl = V('rect', {\n\t          width: '100%',\n\t          height: '100%',\n\t          fill: `url(#${id})`\n\t        });\n\t        defsVEl.append(patternVEl);\n\t        svgVEl.append(rectVEl);\n\t        this.patterns[id] = patternVEl;\n\t      },\n\t      get: function (id) {\n\t        return this.patterns[id];\n\t      },\n\t      exist: function (id) {\n\t        return this.patterns[id] !== undefined;\n\t      }\n\t    };\n\t    return grid;\n\t  },\n\t  _resolveDrawGridOption(opt) {\n\t    const namespace = this.options.patterns;\n\t    if (isString(opt) && Array.isArray(namespace[opt])) {\n\t      return namespace[opt].map(function (item) {\n\t        return assign({}, item);\n\t      });\n\t    }\n\t    const options = opt || {\n\t      args: [{}]\n\t    };\n\t    const isArray = Array.isArray(options);\n\t    let name = options.name;\n\t    if (!isArray && !name && !options.markup) {\n\t      name = 'dot';\n\t    }\n\t    if (name && Array.isArray(namespace[name])) {\n\t      const pattern = namespace[name].map(function (item) {\n\t        return assign({}, item);\n\t      });\n\t      const args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\t      defaults(args[0], omit(opt, 'args'));\n\t      for (let i = 0; i < args.length; i++) {\n\t        if (pattern[i]) {\n\t          assign(pattern[i], args[i]);\n\t        }\n\t      }\n\t      return pattern;\n\t    }\n\t    return isArray ? options : [options];\n\t  },\n\t  isEmpty() {\n\t    const {\n\t      _gridCache: grid\n\t    } = this;\n\t    return this.el.children.length === (grid ? 1 : 0);\n\t  }\n\t});\n\n\tconst paperLayers = {\n\t  GRID: 'grid',\n\t  BACK: 'back',\n\t  /** @deprecated */\n\t  CELLS: 'cells',\n\t  FRONT: 'front',\n\t  TOOLS: 'tools',\n\t  LABELS: 'labels'\n\t};\n\tconst sortingTypes = {\n\t  NONE: 'sorting-none',\n\t  APPROX: 'sorting-approximate',\n\t  EXACT: 'sorting-exact'\n\t};\n\tconst WHEEL_CAP = 50;\n\tconst WHEEL_WAIT_MS = 20;\n\tconst MOUNT_BATCH_SIZE = 1000;\n\tconst UPDATE_BATCH_SIZE = Infinity;\n\tconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\n\tconst HighlightingTypes = CellView.Highlighting;\n\tconst defaultHighlighting = {\n\t  [HighlightingTypes.DEFAULT]: {\n\t    name: 'stroke',\n\t    options: {\n\t      padding: 3\n\t    }\n\t  },\n\t  [HighlightingTypes.MAGNET_AVAILABILITY]: {\n\t    name: 'addClass',\n\t    options: {\n\t      className: 'available-magnet'\n\t    }\n\t  },\n\t  [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n\t    name: 'addClass',\n\t    options: {\n\t      className: 'available-cell'\n\t    }\n\t  }\n\t};\n\tconst gridPatterns = {\n\t  dot: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'rect',\n\t    render: function (el, opt) {\n\t      V(el).attr({\n\t        width: opt.thickness,\n\t        height: opt.thickness,\n\t        fill: opt.color\n\t      });\n\t    }\n\t  }],\n\t  fixedDot: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'rect',\n\t    render: function (el, opt) {\n\t      V(el).attr({\n\t        fill: opt.color\n\t      });\n\t    },\n\t    update: function (el, opt, paper) {\n\t      const {\n\t        sx,\n\t        sy\n\t      } = paper.scale();\n\t      const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n\t      const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n\t      V(el).attr({\n\t        width,\n\t        height\n\t      });\n\t    }\n\t  }],\n\t  mesh: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }],\n\t  doubleMesh: [{\n\t    color: '#AAAAAA',\n\t    thickness: 1,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }, {\n\t    color: '#000000',\n\t    thickness: 3,\n\t    scaleFactor: 4,\n\t    markup: 'path',\n\t    render: function (el, opt) {\n\t      var d;\n\t      var width = opt.width;\n\t      var height = opt.height;\n\t      var thickness = opt.thickness;\n\t      if (width - thickness >= 0 && height - thickness >= 0) {\n\t        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t      } else {\n\t        d = 'M 0 0 0 0';\n\t      }\n\t      V(el).attr({\n\t        'd': d,\n\t        stroke: opt.color,\n\t        'stroke-width': opt.thickness\n\t      });\n\t    }\n\t  }]\n\t};\n\tconst backgroundPatterns = {\n\t  flipXy: function (img) {\n\t    // d b\n\t    // q p\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = 2 * imgWidth;\n\t    canvas.height = 2 * imgHeight;\n\t    var ctx = canvas.getContext('2d');\n\t    // top-left image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // xy-flipped bottom-right image\n\t    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // x-flipped top-right image\n\t    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // y-flipped bottom-left image\n\t    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  flipX: function (img) {\n\t    // d b\n\t    // d b\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = imgWidth * 2;\n\t    canvas.height = imgHeight;\n\t    var ctx = canvas.getContext('2d');\n\t    // left image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // flipped right image\n\t    ctx.translate(2 * imgWidth, 0);\n\t    ctx.scale(-1, 1);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  flipY: function (img) {\n\t    // d d\n\t    // q q\n\n\t    var canvas = document.createElement('canvas');\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    canvas.width = imgWidth;\n\t    canvas.height = imgHeight * 2;\n\t    var ctx = canvas.getContext('2d');\n\t    // top image\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    // flipped bottom image\n\t    ctx.translate(0, 2 * imgHeight);\n\t    ctx.scale(1, -1);\n\t    ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t    return canvas;\n\t  },\n\t  watermark: function (img, opt) {\n\t    //   d\n\t    // d\n\n\t    opt = opt || {};\n\t    var imgWidth = img.width;\n\t    var imgHeight = img.height;\n\t    var canvas = document.createElement('canvas');\n\t    canvas.width = imgWidth * 3;\n\t    canvas.height = imgHeight * 3;\n\t    var ctx = canvas.getContext('2d');\n\t    var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n\t    var radians = toRad(angle);\n\t    var stepX = canvas.width / 4;\n\t    var stepY = canvas.height / 4;\n\t    for (var i = 0; i < 4; i++) {\n\t      for (var j = 0; j < 4; j++) {\n\t        if ((i + j) % 2 > 0) {\n\t          // reset the current transformations\n\t          ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n\t          ctx.rotate(radians);\n\t          ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n\t        }\n\t      }\n\t    }\n\t    return canvas;\n\t  }\n\t};\n\tconst implicitLayers = [{\n\t  id: paperLayers.GRID,\n\t  type: 'GridLayerView',\n\t  patterns: gridPatterns\n\t}, {\n\t  id: paperLayers.BACK\n\t}, {\n\t  id: paperLayers.LABELS\n\t}, {\n\t  id: paperLayers.FRONT\n\t}, {\n\t  id: paperLayers.TOOLS\n\t}];\n\tconst CELL_VIEW_PLACEHOLDER_MARKER = Symbol('joint.cellViewPlaceholderMarker');\n\tconst Paper = View.extend({\n\t  className: 'paper',\n\t  options: {\n\t    width: 800,\n\t    height: 600,\n\t    gridSize: 1,\n\t    // Whether or not to draw the grid lines on the paper's DOM element.\n\t    // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n\t    drawGrid: false,\n\t    // If not set, the size of the visual grid is the same as the `gridSize`.\n\t    drawGridSize: null,\n\t    // Whether or not to draw the background on the paper's DOM element.\n\t    // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n\t    background: false,\n\t    elementView: ElementView,\n\t    linkView: LinkView,\n\t    snapLabels: false,\n\t    // false, true\n\t    snapLinks: false,\n\t    // false, true, { radius: value }\n\t    snapLinksSelf: false,\n\t    // false, true, { radius: value }\n\n\t    // Should the link labels be rendered into its own layer?\n\t    // `false` - the labels are part of the links\n\t    // `true` - the labels are appended to LayersName.LABELS\n\t    // [LayersName] - the labels are appended to the layer specified\n\t    labelsLayer: false,\n\t    // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n\t    multiLinks: true,\n\t    // For adding custom guard logic.\n\t    guard: function (evt, view) {\n\t      // FALSE means the event isn't guarded.\n\t      return false;\n\t    },\n\t    highlighting: defaultHighlighting,\n\t    // Prevent the default context menu from being displayed.\n\t    preventContextMenu: true,\n\t    // Prevent the default action for blank:pointer<action>.\n\t    preventDefaultBlankAction: true,\n\t    // Prevent the default action for cell:pointer<action>.\n\t    preventDefaultViewAction: true,\n\t    // Restrict the translation of elements by given bounding box.\n\t    // Option accepts a boolean:\n\t    //  true - the translation is restricted to the paper area\n\t    //  false - no restrictions\n\t    // A method:\n\t    // restrictTranslate: function(elementView) {\n\t    //     var parentId = elementView.model.get('parent');\n\t    //     return parentId && this.model.getCell(parentId).getBBox();\n\t    // },\n\t    // Or a bounding box:\n\t    // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n\t    restrictTranslate: false,\n\t    // Marks all available magnets with 'available-magnet' class name and all available cells with\n\t    // 'available-cell' class name. Marks them when dragging a link is started and unmark\n\t    // when the dragging is stopped.\n\t    markAvailable: false,\n\t    // Defines what link model is added to the graph after an user clicks on an active magnet.\n\t    // Value could be the mvc.model or a function returning the mvc.model\n\t    // defaultLink: (elementView, magnet) => {\n\t    //   return condition ? new customLink1() : new customLink2()\n\t    // }\n\t    defaultLink: function () {\n\t      // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n\t      const {\n\t        cellNamespace\n\t      } = this.model.layerCollection;\n\t      const ctor = getByPath(cellNamespace, ['standard', 'Link']);\n\t      if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n\t      return new ctor();\n\t    },\n\t    // A connector that is used by links with no connector defined on the model.\n\t    // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n\t    defaultConnector: {\n\t      name: 'normal'\n\t    },\n\t    // A router that is used by links with no router defined on the model.\n\t    // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n\t    defaultRouter: {\n\t      name: 'normal'\n\t    },\n\t    defaultAnchor: {\n\t      name: 'center'\n\t    },\n\t    defaultLinkAnchor: {\n\t      name: 'connectionRatio'\n\t    },\n\t    defaultConnectionPoint: {\n\t      name: 'boundary'\n\t    },\n\t    /* CONNECTING */\n\n\t    connectionStrategy: null,\n\t    // Check whether to add a new link to the graph when user clicks on an a magnet.\n\t    validateMagnet: function (_cellView, magnet, _evt) {\n\t      return magnet.getAttribute('magnet') !== 'passive';\n\t    },\n\t    // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n\t    // being changed.\n\t    validateConnection: function (cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n\t      return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n\t    },\n\t    /* EMBEDDING */\n\n\t    // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n\t    // all links and elements are visible taken the level of embedding into account.\n\t    embeddingMode: false,\n\t    // Check whether to allow or disallow the element embedding while an element being translated.\n\t    validateEmbedding: function (childView, parentView) {\n\t      // by default all elements can be in relation child-parent\n\t      return true;\n\t    },\n\t    // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n\t    validateUnembedding: function (childView) {\n\t      // by default all elements can become roots\n\t      return true;\n\t    },\n\t    // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n\t    // The cell with the highest z-index (visually on the top) will be chosen.\n\t    findParentBy: 'bbox',\n\t    // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n\t    // If enabled only the element on the very front is taken into account for the embedding.\n\t    // If disabled the elements under the dragged view are tested one by one\n\t    // (from front to back) until a valid parent found.\n\t    frontParentOnly: true,\n\t    // Interactive flags. See online docs for the complete list of interactive flags.\n\t    interactive: {\n\t      labelMove: false\n\t    },\n\t    // When set to true the links can be pinned to the paper.\n\t    // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n\t    linkPinning: true,\n\t    // Custom validation after an interaction with a link ends.\n\t    // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n\t    // (linkView, paper) => boolean\n\t    allowLink: null,\n\t    // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n\t    clickThreshold: 0,\n\t    // Number of required mousemove events before the first pointermove event will be triggered.\n\t    moveThreshold: 0,\n\t    // Number of required mousemove events before a link is created out of the magnet.\n\t    // Or string `onleave` so the link is created when the pointer leaves the magnet\n\t    magnetThreshold: 0,\n\t    // Rendering Options\n\n\t    sorting: sortingTypes.APPROX,\n\t    frozen: false,\n\t    autoFreeze: false,\n\t    viewManagement: false,\n\t    // no docs yet\n\t    onViewUpdate: function (view, flag, priority, opt, paper) {\n\t      if (opt.mounting || opt.isolate) {\n\t        // Do not update connected links when:\n\t        // - the view was just mounted (added back to the paper by viewport function)\n\t        // - the change was marked as `isolate`.\n\t        return;\n\t      }\n\t      // Always update connected links when the view model was replaced with another model\n\t      // with the same id.\n\t      // Note: the removal is done in 2 steps: remove the old model, add the new model.\n\t      // We update connected links on the add step.\n\t      if (!(opt.replace && opt.add)) {\n\t        if (flag & (paper.FLAG_INSERT | paper.FLAG_REMOVE)) {\n\t          // Do not update connected links when:\n\t          // - the view was just inserted (added to the graph and rendered)\n\t          // - the view model was just removed from the graph\n\t          return;\n\t        }\n\t      }\n\t      paper.requestConnectedLinksUpdate(view, priority, opt);\n\t    },\n\t    // no docs yet\n\t    onViewPostponed: function (view, flag, paper) {\n\t      return paper.forcePostponedViewUpdate(view, flag);\n\t    },\n\t    beforeRender: null,\n\t    // function(opt, paper) { },\n\n\t    afterRender: null,\n\t    // function(stats, opt, paper) {\n\n\t    viewport: null,\n\t    // Default namespaces\n\n\t    cellViewNamespace: null,\n\t    layerViewNamespace: null,\n\t    routerNamespace: null,\n\t    connectorNamespace: null,\n\t    highlighterNamespace: highlighters,\n\t    anchorNamespace: anchors,\n\t    linkAnchorNamespace: linkAnchors,\n\t    connectionPointNamespace: connectionPoints,\n\t    overflow: false\n\t  },\n\t  events: {\n\t    'dblclick': 'pointerdblclick',\n\t    'dbltap': 'pointerdblclick',\n\t    'contextmenu': 'contextmenu',\n\t    'mousedown': 'pointerdown',\n\t    'touchstart': 'pointerdown',\n\t    'mouseover': 'mouseover',\n\t    'mouseout': 'mouseout',\n\t    'mouseenter': 'mouseenter',\n\t    'mouseleave': 'mouseleave',\n\t    'wheel': 'mousewheel',\n\t    'mouseenter .joint-cell': 'mouseenter',\n\t    'mouseleave .joint-cell': 'mouseleave',\n\t    'mouseenter .joint-tools': 'mouseenter',\n\t    'mouseleave .joint-tools': 'mouseleave',\n\t    'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n\t    'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n\t    'mousedown .joint-link .label': 'onlabel',\n\t    // interaction with link label\n\t    'touchstart .joint-link .label': 'onlabel',\n\t    'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n\t  },\n\t  documentEvents: {\n\t    'mousemove': 'pointermove',\n\t    'touchmove': 'pointermove',\n\t    'mouseup': 'pointerup',\n\t    'touchend': 'pointerup',\n\t    'touchcancel': 'pointerup'\n\t  },\n\t  /* CSS within the SVG document\n\t  * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n\t  *    elements that use the `scalable` group.\n\t  */\n\t  stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\t  svg: null,\n\t  defs: null,\n\t  tools: null,\n\t  layers: null,\n\t  // deprecated, use layers element instead\n\t  viewport: null,\n\t  // For storing the current transformation matrix (CTM) of the paper's viewport.\n\t  _viewportMatrix: null,\n\t  // For verifying whether the CTM is up-to-date. The viewport transform attribute\n\t  // could have been manipulated directly.\n\t  _viewportTransformString: null,\n\t  // Updates data (priorities, unmounted views etc.)\n\t  _updates: null,\n\t  // Paper Layers\n\t  _layers: null,\n\t  UPDATE_DELAYING_BATCHES: ['translate'],\n\t  // If you interact with these elements,\n\t  // the default interaction such as `element move` is prevented.\n\t  FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],\n\t  // If you interact with these elements, the events are not propagated to the paper\n\t  // i.e. paper events such as `element:pointerdown` are not triggered.\n\t  GUARDED_TAG_NAMES: [\n\t  // Guard <select> for consistency. When you click on it:\n\t  // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n\t  // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n\t  //          on close. However, if you open and then close by clicking elsewhere on the page,\n\t  //           no other event is triggered.\n\t  // Safari: when you open it, it triggers `pointerdown`. That's it.\n\t  'SELECT'],\n\t  MIN_SCALE: 1e-6,\n\t  // Default find buffer for the findViewsInArea and findViewsAtPoint methods.\n\t  // The find buffer is used to extend the area of the search\n\t  // to mitigate the differences between the model and view geometry.\n\t  DEFAULT_FIND_BUFFER: 200,\n\t  FLAG_INSERT: 1 << 30,\n\t  FLAG_REMOVE: 1 << 29,\n\t  FLAG_INIT: 1 << 28,\n\t  // Layers that are always present on the paper (e.g. grid, back, front, tools)\n\t  implicitLayers,\n\t  // Reference layer for inserting new graph layers.\n\t  graphLayerRefId: paperLayers.LABELS,\n\t  init: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    if (!options.cellViewNamespace) {\n\t      /* eslint-disable no-undef */\n\t      options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n\t      /* eslint-enable no-undef */\n\t    }\n\t    const defaultLayerViewNamespace = {\n\t      LayerView,\n\t      GraphLayerView,\n\t      GridLayerView\n\t    };\n\t    this.layerViewNamespace = defaultsDeep({}, options.layerViewNamespace || {}, defaultLayerViewNamespace);\n\t    const model = this.model = options.model || new Graph();\n\n\t    // This property tells us if we need to keep the compatibility\n\t    // with the v4 API and behavior.\n\t    this.legacyMode = !options.viewManagement;\n\n\t    // Layers (SVGGroups)\n\t    this._layers = {\n\t      viewsMap: {},\n\t      order: []\n\t    };\n\n\t    // Hash of all cell views.\n\t    this._views = {};\n\t    this._viewPlaceholders = {};\n\t    this._idToCid = {};\n\t    this.cloneOptions();\n\t    this.render();\n\t    this._setDimensions();\n\t    this.startListening();\n\n\t    // Mouse wheel events buffer\n\t    this._mw_evt_buffer = {\n\t      event: null,\n\t      deltas: []\n\t    };\n\n\t    // Render existing cells in the graph\n\t    this.resetViews(model.getCells());\n\t  },\n\t  _resetUpdates: function () {\n\t    if (this._updates && this._updates.id) cancelFrame(this._updates.id);\n\t    return this._updates = {\n\t      id: null,\n\t      priorities: [{}, {}, {}],\n\t      unmountedList: new Deque(),\n\t      mountedList: new Deque(),\n\t      count: 0,\n\t      keyFrozen: false,\n\t      freezeKey: null,\n\t      sort: false,\n\t      disabled: false,\n\t      idle: false,\n\t      freshAfterReset: true\n\t    };\n\t  },\n\t  startListening: function () {\n\t    var model = this.model;\n\t    this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'batch:stop', this.onGraphBatchStop);\n\t    this.listenTo(model, 'layer:add', this.onGraphLayerAdd).listenTo(model, 'layer:remove', this.onGraphLayerRemove).listenTo(model, 'layers:sort', this.onGraphLayerCollectionSort);\n\t    this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('transform', this.update);\n\t  },\n\t  onCellAdded: function (cell, _, opt) {\n\t    var position = opt.position;\n\t    if (this.isAsync() || !isNumber(position)) {\n\t      this.renderView(cell, opt);\n\t    } else {\n\t      if (opt.maxPosition === position) this.freeze({\n\t        key: 'addCells'\n\t      });\n\t      this.renderView(cell, opt);\n\t      if (position === 0) this.unfreeze({\n\t        key: 'addCells'\n\t      });\n\t    }\n\t  },\n\t  onCellRemoved: function (cell, _, opt) {\n\t    const viewLike = this._getCellViewLike(cell);\n\t    if (!viewLike) return;\n\t    if (viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      // It's a cell placeholder, it must be in the unmounted list.\n\t      // Remove it from there and unregister.\n\t      this._updates.unmountedList.delete(viewLike.cid);\n\t      this._unregisterCellViewPlaceholder(viewLike);\n\t    } else {\n\t      this.requestViewUpdate(viewLike, this.FLAG_REMOVE, viewLike.UPDATE_PRIORITY, opt);\n\t    }\n\t  },\n\t  onGraphReset: function (_collection, opt) {\n\t    // Re-render all graph layer views\n\t    // but keep the implicit layer views.\n\t    this.renderGraphLayerViews();\n\t    this.resetLayerViews();\n\t    // Backward compatibility: reassign the `cells` property\n\t    // with the default layer view.\n\t    this.assertLayerViews();\n\t    this.resetViews(this.model.getCells(), opt);\n\t  },\n\t  onGraphBatchStop: function (data) {\n\t    if (this.isFrozen() || this.isIdle()) return;\n\t    var name = data && data.batchName;\n\t    var graph = this.model;\n\t    if (!this.isAsync()) {\n\t      var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n\t      if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n\t        this.updateViews(data);\n\t      }\n\t    }\n\t  },\n\t  /**\n\t  * @protected\n\t  * @description When a new layer is added to the graph, we create a new layer view\n\t  **/\n\t  onGraphLayerAdd: function (layer, _, opt) {\n\t    if (this.hasLayerView(layer.id)) return;\n\t    const layerView = this.createLayerView({\n\t      id: layer.id,\n\t      model: layer\n\t    });\n\t    const layers = this.model.getLayers();\n\t    let before;\n\t    // Note: There is always at least one graph layer.\n\t    if (layers[layers.length - 1] === layer) {\n\t      // This is the last layer, so insert before the labels layer\n\t      before = paperLayers.LABELS;\n\t    } else {\n\t      // There is a layer after the current one, so insert before that one\n\t      const index = layers.indexOf(layer);\n\t      before = layers[index + 1].id;\n\t    }\n\t    this.addLayerView(layerView, {\n\t      before\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description When a layer is removed from the graph, we remove the corresponding layer view\n\t   **/\n\t  onGraphLayerRemove: function (layer, _, opt) {\n\t    if (!this.hasLayerView(layer)) return;\n\n\t    // Request layer removal. Since the UPDATE_PRIORITY is lower\n\t    // than cells update priority, the cell views will be removed first.\n\t    this.requestLayerViewRemoval(layer);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description When the graph layer collection is sorted,\n\t   * we reorder all graph layer views.\n\t   **/\n\t  onGraphLayerCollectionSort: function (layerCollection) {\n\t    layerCollection.each(layer => {\n\t      if (!this.hasLayerView(layer)) return;\n\t      this.moveLayerView(layer, {\n\t        before: this.graphLayerRefId\n\t      });\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Resets all graph layer views.\n\t   */\n\t  renderGraphLayerViews: function () {\n\t    // Remove all existing graph layer views\n\t    // Note: we don't use `getGraphLayerViews()` here because\n\t    // rendered graph layer views could be different from the ones\n\t    // in the graph layer collection (`onResetGraphLayerCollectionReset`).\n\t    this.getLayerViews().forEach(layerView => {\n\t      if (!layerView[GRAPH_LAYER_VIEW_MARKER]) return;\n\t      this._removeLayerView(layerView);\n\t    });\n\t    // Create and insert new graph layer views\n\t    this.model.getLayers().forEach(layer => {\n\t      const layerView = this.createLayerView({\n\t        id: layer.id,\n\t        model: layer\n\t      });\n\t      // Insert the layer view into the paper layers, just before the labels layer.\n\t      // All cell layers are positioned between the \"back\" and \"labels\" layers,\n\t      // with the default \"cells\" layer originally occupying this position.\n\t      this.addLayerView(layerView, {\n\t        before: this.graphLayerRefId\n\t      });\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Renders all implicit layer views.\n\t   */\n\t  renderImplicitLayerViews: function () {\n\t    this.implicitLayers.forEach(layerInit => {\n\t      const layerView = this.createLayerView(layerInit);\n\t      this.addLayerView(layerView);\n\t    });\n\t  },\n\t  cloneOptions: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      defaultConnector,\n\t      defaultRouter,\n\t      defaultConnectionPoint,\n\t      defaultAnchor,\n\t      defaultLinkAnchor,\n\t      highlighting,\n\t      cellViewNamespace,\n\t      interactive\n\t    } = options;\n\n\t    // Default cellView namespace for ES5\n\t    /* eslint-disable no-undef */\n\t    if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n\t      options.cellViewNamespace = joint.shapes;\n\t    }\n\t    /* eslint-enable no-undef */\n\n\t    // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n\t    // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n\t    if (!isFunction(defaultConnector)) {\n\t      options.defaultConnector = cloneDeep(defaultConnector);\n\t    }\n\t    if (!isFunction(defaultRouter)) {\n\t      options.defaultRouter = cloneDeep(defaultRouter);\n\t    }\n\t    if (!isFunction(defaultConnectionPoint)) {\n\t      options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n\t    }\n\t    if (!isFunction(defaultAnchor)) {\n\t      options.defaultAnchor = cloneDeep(defaultAnchor);\n\t    }\n\t    if (!isFunction(defaultLinkAnchor)) {\n\t      options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n\t    }\n\t    if (isPlainObject(interactive)) {\n\t      options.interactive = assign({}, interactive);\n\t    }\n\t    if (isPlainObject(highlighting)) {\n\t      // Return the default highlighting options into the user specified options.\n\t      options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n\t    }\n\t    // Copy and set defaults for the view management options.\n\t    options.viewManagement = defaults({}, options.viewManagement, {\n\t      // Whether to lazy initialize the cell views.\n\t      lazyInitialize: !!options.viewManagement,\n\t      // default `true` if options.viewManagement provided\n\t      // Whether to add initialized cell views into the unmounted queue.\n\t      initializeUnmounted: false,\n\t      // Whether to dispose the cell views that are not visible.\n\t      disposeHidden: false\n\t    });\n\t  },\n\t  children: function () {\n\t    var ns = V.namespace;\n\t    return [{\n\t      namespaceURI: ns.xhtml,\n\t      tagName: 'div',\n\t      className: addClassNamePrefix('paper-background'),\n\t      selector: 'background',\n\t      style: {\n\t        position: 'absolute',\n\t        inset: 0\n\t      }\n\t    }, {\n\t      namespaceURI: ns.svg,\n\t      tagName: 'svg',\n\t      attributes: {\n\t        'width': '100%',\n\t        'height': '100%',\n\t        'xmlns:xlink': ns.xlink\n\t      },\n\t      selector: 'svg',\n\t      style: {\n\t        position: 'absolute',\n\t        inset: 0\n\t      },\n\t      children: [{\n\t        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n\t        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n\t        tagName: 'defs',\n\t        selector: 'defs'\n\t      }, {\n\t        tagName: 'g',\n\t        className: addClassNamePrefix('layers'),\n\t        selector: 'layers'\n\t      }]\n\t    }];\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Checks whether the layer view exists by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @return {boolean} True if the layer view exists, false otherwise.\n\t   */\n\t  hasLayerView(layerRef) {\n\t    let layerId;\n\t    if (isString(layerRef)) {\n\t      layerId = layerRef;\n\t    } else if (layerRef) {\n\t      layerId = layerRef.id;\n\t    } else {\n\t      return false;\n\t    }\n\t    return layerId in this._layers.viewsMap;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns the layer view by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @return {dia.LayerView} The layer view.\n\t   * @throws {Error} if the layer view is not found\n\t   */\n\t  getLayerView(layerRef) {\n\t    let layerId;\n\t    if (isString(layerRef)) {\n\t      layerId = layerRef;\n\t    } else if (layerRef) {\n\t      layerId = layerRef.id;\n\t    } else {\n\t      throw new Error('dia.Paper: No layer provided.');\n\t    }\n\t    const layerView = this._layers.viewsMap[layerId];\n\t    if (!layerView) {\n\t      throw new Error(`dia.Paper: Unknown layer view \"${layerId}\".`);\n\t    }\n\t    return layerView;\n\t  },\n\t  /**\n\t   * @deprecated use `getLayerView(layerId).el` instead\n\t   */\n\t  getLayerNode(layerId) {\n\t    return this.getLayerView(layerId).el;\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Removes the given layer view from the paper.\n\t   * It does not check whether the layer view is empty.\n\t   * @param {dia.LayerView} layerView - The layer view to remove.\n\t   */\n\t  _removeLayerView(layerView) {\n\t    this._unregisterLayerView(layerView);\n\t    layerView.remove();\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Removes all layer views from the paper.\n\t   * It does not check whether the layer views are empty.\n\t   */\n\t  _removeLayerViews: function () {\n\t    Object.values(this._layers.viewsMap).forEach(layerView => {\n\t      this._removeLayerView(layerView);\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Unregisters the given layer view from the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to unregister.\n\t   */\n\t  _unregisterLayerView(layerView) {\n\t    const {\n\t      _layers: {\n\t        viewsMap,\n\t        order\n\t      }\n\t    } = this;\n\t    const layerId = layerView.id;\n\t    // Remove the layer id from the order list.\n\t    const layerIndex = order.indexOf(layerId);\n\t    if (layerIndex !== -1) {\n\t      order.splice(layerIndex, 1);\n\t    }\n\t    // Unlink the layer view from the paper.\n\t    layerView.unsetPaperReference();\n\t    // Remove the layer view from the paper's registry.\n\t    delete viewsMap[layerId];\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Registers the given layer view in the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to register.\n\t   * @throws {Error} if the layer view is not an instance of dia.LayerView\n\t   * @throws {Error} if the layer view already exists in the paper\n\t   */\n\t  _registerLayerView(layerView) {\n\t    if (!layerView || !layerView[LAYER_VIEW_MARKER]) {\n\t      throw new Error('dia.Paper: The layer view must be an instance of dia.LayerView.');\n\t    }\n\t    if (this.hasLayerView(layerView.id)) {\n\t      throw new Error(`dia.Paper: The layer view \"${layerView.id}\" already exists.`);\n\t    }\n\t    // Link the layer view back to the paper.\n\t    layerView.setPaperReference(this);\n\t    // Store the layer view in the paper's registry.\n\t    this._layers.viewsMap[layerView.id] = layerView;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Removes the layer view by the given layer id or layer model.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @throws {Error} if the layer view is not empty\n\t   */\n\t  removeLayerView(layerRef) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    if (!layerView.isEmpty()) {\n\t      throw new Error('dia.Paper: The layer view is not empty.');\n\t    }\n\t    this._removeLayerView(layerView);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Schedules the layer view removal by the given layer id or layer model.\n\t   * The actual removal will be performed during the paper update cycle.\n\t   * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.\n\t   * @param {Object} [opt] - Update options.\n\t   */\n\t  requestLayerViewRemoval(layerRef, opt) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    const {\n\t      FLAG_REMOVE\n\t    } = this;\n\t    const {\n\t      UPDATE_PRIORITY\n\t    } = layerView;\n\t    this.requestViewUpdate(layerView, FLAG_REMOVE, UPDATE_PRIORITY, opt);\n\t  },\n\t  /**\n\t   * @public\n\t   * @internal not documented\n\t   * @description Schedules the cell view insertion into the appropriate layer view.\n\t   * The actual insertion will be performed during the paper update cycle.\n\t   * @param {dia.Cell} cell - The cell model whose view should be inserted.\n\t   * @param {Object} [opt] - Update options.\n\t   */\n\t  requestCellViewInsertion(cell, opt) {\n\t    const viewLike = this._getCellViewLike(cell);\n\t    if (!viewLike) return;\n\t    this.requestViewUpdate(viewLike, this.FLAG_INSERT, viewLike.UPDATE_PRIORITY, opt);\n\t  },\n\t  /**\n\t   * @private\n\t   * Helper method for addLayerView and moveLayerView methods\n\t   */\n\t  _getBeforeLayerViewFromOptions(layerView, options) {\n\t    let {\n\t      before = null,\n\t      index\n\t    } = options;\n\t    if (before && index !== undefined) {\n\t      throw new Error('dia.Paper: Options \"before\" and \"index\" are mutually exclusive.');\n\t    }\n\t    let computedBefore;\n\t    if (index !== undefined) {\n\t      const {\n\t        _layers: {\n\t          order\n\t        }\n\t      } = this;\n\t      if (index >= order.length) {\n\t        // If index is greater than the number of layers,\n\t        // return before as null (move to the end).\n\t        computedBefore = null;\n\t      } else if (index < 0) {\n\t        // If index is negative, move to the beginning.\n\t        computedBefore = order[0];\n\t      } else {\n\t        const originalIndex = order.indexOf(layerView.id);\n\t        if (originalIndex !== -1 && index > originalIndex) {\n\t          // If moving a layer upwards in the stack, we need to adjust the index\n\t          // to account for the layer being removed from its original position.\n\t          index += 1;\n\t        }\n\t        // Otherwise, get the layer ID at the specified index.\n\t        computedBefore = order[index] || null;\n\t      }\n\t    } else {\n\t      computedBefore = before;\n\t    }\n\t    return computedBefore ? this.getLayerView(computedBefore) : null;\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Adds the layer view to the paper.\n\t   * @param {dia.LayerView} layerView - The layer view to add.\n\t   * @param {Object} [options] - Adding options.\n\t   * @param {string|dia.GraphLayer} [options.before] - Layer id or layer model before\n\t   */\n\t  addLayerView(layerView, options = {}) {\n\t    this._registerLayerView(layerView);\n\t    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);\n\t    this.insertLayerView(layerView, beforeLayerView);\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Moves the layer view.\n\t   * @param {Paper.LayerRef} layerRef - The layer view reference to move.\n\t   * @param {Object} [options] - Moving options.\n\t   * @param {Paper.LayerRef} [options.before] - Layer id or layer model before\n\t   * @param {number} [options.index] - Zero-based index to which to move the layer view.\n\t   */\n\t  moveLayerView(layerRef, options = {}) {\n\t    const layerView = this.getLayerView(layerRef);\n\t    const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);\n\t    this.insertLayerView(layerView, beforeLayerView);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Inserts the layer view into the paper.\n\t   * If the layer view already exists in the paper, it is moved to the new position.\n\t   * @param {dia.LayerView} layerView - The layer view to insert.\n\t   * @param {dia.LayerView} [before] - Layer view before\n\t   * which the layer view should be inserted.\n\t   */\n\t  insertLayerView(layerView, beforeLayerView) {\n\t    const layerId = layerView.id;\n\t    const {\n\t      _layers: {\n\t        order\n\t      }\n\t    } = this;\n\t    const currentLayerIndex = order.indexOf(layerId);\n\n\t    // Should the layer view be inserted before another layer view?\n\t    if (beforeLayerView) {\n\t      const beforeLayerViewId = beforeLayerView.id;\n\t      if (layerId === beforeLayerViewId) {\n\t        // The layer view is already in the right place.\n\t        return;\n\t      }\n\t      let beforeLayerPosition = order.indexOf(beforeLayerViewId);\n\t      // Remove from the `order` list if the layer view is already in the order.\n\t      if (currentLayerIndex !== -1) {\n\t        if (currentLayerIndex < beforeLayerPosition) {\n\t          beforeLayerPosition -= 1;\n\t        }\n\t        order.splice(currentLayerIndex, 1);\n\t      }\n\t      order.splice(beforeLayerPosition, 0, layerId);\n\t      this.layers.insertBefore(layerView.el, beforeLayerView.el);\n\t      return;\n\t    }\n\n\t    // Remove from the `order` list if the layer view is already in the order.\n\t    // This is needed for the case when the layer view is inserted in the new position.\n\t    if (currentLayerIndex !== -1) {\n\t      order.splice(currentLayerIndex, 1);\n\t    }\n\t    order.push(layerId);\n\t    this.layers.appendChild(layerView.el);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Returns an array of layer view ids in the order they are rendered.\n\t   * @returns {string[]} An array of layer view ids.\n\t   */\n\t  getLayerViewOrder() {\n\t    return this._layers.order.slice();\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns an array of layer views in the order they are rendered.\n\t   * @returns {dia.LayerView[]} An array of layer views.\n\t   */\n\t  getLayerViews() {\n\t    return this.getLayerViewOrder().map(id => this.getLayerView(id));\n\t  },\n\t  /**\n\t   * @public\n\t   * @description Returns an array of graph layer views in the order they are rendered.\n\t   * @returns {dia.GraphLayerView[]} An array of graph layer views.\n\t   */\n\t  getGraphLayerViews() {\n\t    const {\n\t      _layers: {\n\t        viewsMap\n\t      }\n\t    } = this;\n\t    return this.model.getLayers().map(layer => viewsMap[layer.id]);\n\t  },\n\t  render: function () {\n\t    this.renderChildren();\n\t    const {\n\t      el,\n\t      childNodes,\n\t      options,\n\t      stylesheet\n\t    } = this;\n\t    const {\n\t      svg,\n\t      defs,\n\t      layers\n\t    } = childNodes;\n\t    el.style.position = 'relative';\n\t    svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\t    this.svg = svg;\n\t    this.defs = defs;\n\t    this.layers = layers;\n\t    this.renderLayerViews();\n\t    V.ensureId(svg);\n\t    this.addStylesheet(stylesheet);\n\t    if (options.background) {\n\t      this.drawBackground(options.background);\n\t    }\n\t    if (options.drawGrid) {\n\t      this.setGrid(options.drawGrid);\n\t    }\n\t    return this;\n\t  },\n\t  addStylesheet: function (css) {\n\t    if (!css) return;\n\t    V(this.svg).prepend(V.createSVGStyle(css));\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Creates a layer view instance based on the provided options.\n\t   * It finds the appropriate layer view constructor from the paper's\n\t   * `layerViewNamespace` and instantiates it.\n\t   * @param {*} options See `dia.LayerView` options.\n\t   * @returns {dia.LayerView}\n\t   */\n\t  createLayerView(options) {\n\t    if (options == null) {\n\t      throw new Error('dia.Paper: Layer view options are required.');\n\t    }\n\t    if (options.id == null) {\n\t      throw new Error('dia.Paper: Layer view id is required.');\n\t    }\n\t    const viewOptions = clone$1(options);\n\t    let viewConstructor;\n\t    if (viewOptions.model) {\n\t      const modelType = viewOptions.model.get('type') || viewOptions.model.constructor.name;\n\t      const type = modelType + 'View';\n\n\t      // For backward compatibility we use the LegacyGraphLayerView for the default `cells` layer.\n\t      if (this.model.legacyMode) {\n\t        viewConstructor = LegacyGraphLayerView;\n\t      } else {\n\t        viewConstructor = this.layerViewNamespace[type] || LayerView;\n\t      }\n\t    } else {\n\t      // Paper layers\n\t      const type = viewOptions.type;\n\t      viewConstructor = this.layerViewNamespace[type] || LayerView;\n\t    }\n\t    return new viewConstructor(viewOptions);\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Renders all paper layer views and graph layer views.\n\t   */\n\t  renderLayerViews: function () {\n\t    this._removeLayerViews();\n\t    // Render the paper layers.\n\t    this.renderImplicitLayerViews();\n\t    // Render the layers.\n\t    this.renderGraphLayerViews();\n\t    // Ensure that essential layer views are present.\n\t    this.assertLayerViews();\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Ensures that essential layer views are present on the paper.\n\t   * @throws {Error} if any of the essential layer views is missing\n\t   */\n\t  assertLayerViews: function () {\n\t    // Throws an exception if essential layer views are missing.\n\t    const cellsLayerView = this.getLayerView(this.model.getDefaultLayer().id);\n\t    const toolsLayerView = this.getLayerView(paperLayers.TOOLS);\n\t    const labelsLayerView = this.getLayerView(paperLayers.LABELS);\n\n\t    // backwards compatibility\n\t    this.tools = toolsLayerView.el;\n\t    this.cells = this.viewport = cellsLayerView.el;\n\t    // Backwards compatibility: same as `LegacyGraphLayerView` we keep\n\t    // the `viewport` class on the labels layer.\n\t    labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n\t    labelsLayerView.el.style.webkitUserSelect = 'none';\n\t    labelsLayerView.el.style.userSelect = 'none';\n\t  },\n\t  /**\n\t   * @protected\n\t   * @description Resets all layer views.\n\t   */\n\t  resetLayerViews: function () {\n\t    this.getLayerViews().forEach(layerView => layerView.reset());\n\t  },\n\t  update: function () {\n\t    if (this._background) {\n\t      this.updateBackgroundImage(this._background);\n\t    }\n\t    return this;\n\t  },\n\t  scale: function (sx, sy, data) {\n\t    const ctm = this.matrix();\n\t    // getter\n\t    if (sx === undefined) {\n\t      return V.matrixToScale(ctm);\n\t    }\n\t    // setter\n\t    if (sy === undefined) {\n\t      sy = sx;\n\t    }\n\t    sx = Math.max(sx || 0, this.MIN_SCALE);\n\t    sy = Math.max(sy || 0, this.MIN_SCALE);\n\t    ctm.a = sx;\n\t    ctm.d = sy;\n\t    this.matrix(ctm, data);\n\t    return this;\n\t  },\n\t  scaleUniformAtPoint: function (scale, point, data) {\n\t    const {\n\t      a: sx,\n\t      d: sy,\n\t      e: tx,\n\t      f: ty\n\t    } = this.matrix();\n\t    scale = Math.max(scale || 0, this.MIN_SCALE);\n\t    if (scale === sx && scale === sy) {\n\t      // The scale is the same as the current one.\n\t      return this;\n\t    }\n\t    const matrix = V.createSVGMatrix().translate(tx - point.x * (scale - sx), ty - point.y * (scale - sy)).scale(scale, scale);\n\t    this.matrix(matrix, data);\n\t    return this;\n\t  },\n\t  translate: function (tx, ty, data) {\n\t    const ctm = this.matrix();\n\t    // getter\n\t    if (tx === undefined) {\n\t      return V.matrixToTranslate(ctm);\n\t    }\n\t    // setter\n\t    tx || (tx = 0);\n\t    ty || (ty = 0);\n\t    if (ctm.e === tx && ctm.f === ty) return this;\n\t    ctm.e = tx;\n\t    ctm.f = ty;\n\t    this.matrix(ctm, data);\n\t    return this;\n\t  },\n\t  matrix: function (ctm, data = {}) {\n\t    var viewport = this.layers;\n\n\t    // Getter:\n\t    if (ctm === undefined) {\n\t      var transformString = viewport.getAttribute('transform');\n\t      if ((this._viewportTransformString || null) === transformString) {\n\t        // It's ok to return the cached matrix. The transform attribute has not changed since\n\t        // the matrix was stored.\n\t        ctm = this._viewportMatrix;\n\t      } else {\n\t        // The viewport transform attribute has changed. Measure the matrix and cache again.\n\t        ctm = viewport.getCTM();\n\t        this._viewportMatrix = ctm;\n\t        this._viewportTransformString = transformString;\n\t      }\n\n\t      // Clone the cached current transformation matrix.\n\t      // If no matrix previously stored the identity matrix is returned.\n\t      return V.createSVGMatrix(ctm);\n\t    }\n\n\t    // Setter:\n\t    const prev = this.matrix();\n\t    const current = V.createSVGMatrix(ctm);\n\t    const currentTransformString = this._viewportTransformString;\n\t    const ctmString = V.matrixToTransformString(current);\n\t    if (ctmString === currentTransformString) {\n\t      // The new transform string is the same as the current one.\n\t      // No need to update the transform attribute.\n\t      return this;\n\t    }\n\t    if (!currentTransformString && V.matrixToTransformString() === ctmString) {\n\t      // The current transform string is empty and the new one is an identity matrix.\n\t      // No need to update the transform attribute.\n\t      return this;\n\t    }\n\t    const {\n\t      a,\n\t      d,\n\t      e,\n\t      f\n\t    } = current;\n\t    viewport.setAttribute('transform', ctmString);\n\t    this._viewportMatrix = current;\n\t    this._viewportTransformString = viewport.getAttribute('transform');\n\n\t    // scale event\n\t    if (a !== prev.a || d !== prev.d) {\n\t      this.trigger('scale', a, d, data);\n\t    }\n\n\t    // translate event\n\t    if (e !== prev.e || f !== prev.f) {\n\t      this.trigger('translate', e, f, data);\n\t    }\n\t    this.trigger('transform', current, data);\n\t    return this;\n\t  },\n\t  clientMatrix: function () {\n\t    return V.createSVGMatrix(this.layers.getScreenCTM());\n\t  },\n\t  requestConnectedLinksUpdate: function (view, priority, opt) {\n\t    if (!view || !view[CELL_VIEW_MARKER]) return;\n\t    const model = view.model;\n\t    const links = this.model.getConnectedLinks(model);\n\t    for (let j = 0, n = links.length; j < n; j++) {\n\t      const link = links[j];\n\t      const linkView = this._getCellViewLike(link);\n\t      if (!linkView) continue;\n\t      // We do not have to update placeholder views.\n\t      // They will be updated on initial render.\n\t      if (linkView[CELL_VIEW_PLACEHOLDER_MARKER]) continue;\n\t      const flagLabels = [LinkView.Flags.UPDATE];\n\t      // We need to tell the link view which end requested this update.\n\t      if (link.getTargetCell() === model) flagLabels.push(LinkView.Flags.TARGET);\n\t      if (link.getSourceCell() === model) flagLabels.push(LinkView.Flags.SOURCE);\n\t      const nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n\t      this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n\t    }\n\t  },\n\t  forcePostponedViewUpdate: function (view, flag) {\n\t    if (!view || !view[CELL_VIEW_MARKER]) return false;\n\t    const model = view.model;\n\t    if (model.isElement()) return false;\n\t    const dumpOptions = {\n\t      silent: true\n\t    };\n\t    // LinkView is waiting for the target or the source cellView to be rendered\n\t    // This can happen when the cells are not in the viewport.\n\t    let sourceFlag = 0;\n\t    const sourceCell = model.getSourceCell();\n\t    if (sourceCell && !this.isCellVisible(sourceCell)) {\n\t      const sourceView = this.findViewByModel(sourceCell);\n\t      sourceFlag = this.dumpView(sourceView, dumpOptions);\n\t    }\n\t    let targetFlag = 0;\n\t    const targetCell = model.getTargetCell();\n\t    if (targetCell && !this.isCellVisible(targetCell)) {\n\t      const targetView = this.findViewByModel(targetCell);\n\t      targetFlag = this.dumpView(targetView, dumpOptions);\n\t    }\n\t    if (sourceFlag === 0 && targetFlag === 0) {\n\t      // If leftover flag is 0, all view updates were done.\n\t      return !this.dumpView(view, dumpOptions);\n\t    }\n\t    return false;\n\t  },\n\t  requestViewUpdate: function (view, flag, priority, opt) {\n\t    opt || (opt = {});\n\t    // Note: `scheduleViewUpdate` wakes up the paper if it is idle.\n\t    this.scheduleViewUpdate(view, flag, priority, opt);\n\t    var isAsync = this.isAsync();\n\t    if (this.isFrozen() || isAsync && opt.async !== false) return;\n\t    if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n\t    var stats = this.updateViews(opt);\n\t    if (isAsync) this.notifyAfterRender(stats, opt);\n\t  },\n\t  scheduleViewUpdate: function (view, type, priority, opt) {\n\t    const {\n\t      _updates: updates,\n\t      options\n\t    } = this;\n\t    if (updates.idle && options.autoFreeze) {\n\t      this.legacyMode ? this.unfreeze() // Restart rendering loop without original options\n\t      : this.wakeUp();\n\t    }\n\t    const {\n\t      FLAG_REMOVE,\n\t      FLAG_INSERT\n\t    } = this;\n\t    const {\n\t      UPDATE_PRIORITY,\n\t      cid\n\t    } = view;\n\t    let priorityUpdates = updates.priorities[priority];\n\t    if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n\t    // Move higher priority updates to this priority\n\t    if (priority > UPDATE_PRIORITY) {\n\t      // Not the default priority for this view. It's most likely a link view\n\t      // connected to another link view, which triggered the update.\n\t      // TODO: If there is an update scheduled with a lower priority already, we should\n\t      // change the requested priority to the lowest one. Does not seem to be critical\n\t      // right now, as it \"only\" results in multiple updates on the same view.\n\t      for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n\t        const prevPriorityUpdates = updates.priorities[i];\n\t        if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n\t        priorityUpdates[cid] |= prevPriorityUpdates[cid];\n\t        delete prevPriorityUpdates[cid];\n\t      }\n\t    }\n\t    let currentType = priorityUpdates[cid] || 0;\n\t    // Prevent cycling\n\t    if ((currentType & type) === type) return;\n\t    if (!currentType) updates.count++;\n\t    if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n\t      // When a view is removed we need to remove the insert flag as this is a reinsert\n\t      priorityUpdates[cid] ^= FLAG_INSERT;\n\t    } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n\t      // When a view is added we need to remove the remove flag as this is view was previously removed\n\t      priorityUpdates[cid] ^= FLAG_REMOVE;\n\t    }\n\t    priorityUpdates[cid] |= type;\n\t    const viewUpdateFn = options.onViewUpdate;\n\t    if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n\t  },\n\t  dumpViewUpdate: function (view) {\n\t    if (!view) return 0;\n\t    var updates = this._updates;\n\t    var cid = view.cid;\n\t    var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n\t    var flag = this.registerMountedView(view) | priorityUpdates[cid];\n\t    delete priorityUpdates[cid];\n\t    return flag;\n\t  },\n\t  dumpView: function (view, opt = {}) {\n\t    const flag = this.dumpViewUpdate(view);\n\t    if (!flag) return 0;\n\t    this.notifyBeforeRender(opt);\n\t    const leftover = this.updateView(view, flag, opt);\n\t    const stats = {\n\t      updated: 1,\n\t      priority: view.UPDATE_PRIORITY\n\t    };\n\t    this.notifyAfterRender(stats, opt);\n\t    return leftover;\n\t  },\n\t  updateView: function (view, flag, opt) {\n\t    if (!view) return 0;\n\t    const {\n\t      FLAG_REMOVE,\n\t      FLAG_INSERT,\n\t      FLAG_INIT\n\t    } = this;\n\t    const {\n\t      model\n\t    } = view;\n\t    if (view[GRAPH_LAYER_VIEW_MARKER]) {\n\t      if (flag & FLAG_REMOVE) {\n\t        this.removeLayerView(view);\n\t        return 0;\n\t      }\n\t    }\n\t    if (view[CELL_VIEW_MARKER]) {\n\t      if (flag & FLAG_REMOVE) {\n\t        this.removeView(model);\n\t        return 0;\n\t      }\n\t      if (flag & FLAG_INSERT) {\n\t        const isInitialInsert = !!(flag & FLAG_INIT);\n\t        if (isInitialInsert) {\n\t          flag ^= FLAG_INIT;\n\t        }\n\t        this.insertView(view, isInitialInsert);\n\t        flag ^= FLAG_INSERT;\n\t      }\n\t    }\n\t    if (!flag) return 0;\n\t    return view.confirmUpdate(flag, opt || {});\n\t  },\n\t  requireView: function (model, opt) {\n\t    var view = this.findViewByModel(model);\n\t    if (!view) return null;\n\t    this.dumpView(view, opt);\n\t    return view;\n\t  },\n\t  registerUnmountedView: function (view) {\n\t    var cid = view.cid;\n\t    var updates = this._updates;\n\t    if (updates.unmountedList.has(cid)) return 0;\n\t    const flag = this.FLAG_INSERT;\n\t    updates.unmountedList.pushTail(cid, flag);\n\t    updates.mountedList.delete(cid);\n\t    return flag;\n\t  },\n\t  registerMountedView: function (view) {\n\t    var cid = view.cid;\n\t    var updates = this._updates;\n\t    if (updates.mountedList.has(cid)) return 0;\n\t    const unmountedItem = updates.unmountedList.get(cid);\n\t    const flag = unmountedItem ? unmountedItem.value : 0;\n\t    updates.unmountedList.delete(cid);\n\t    updates.mountedList.pushTail(cid);\n\t    return flag;\n\t  },\n\t  isCellVisible: function (cellOrId) {\n\t    const cid = cellOrId && this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false; // The view is not registered.\n\t    return this.isViewMounted(cid);\n\t  },\n\t  isViewMounted: function (viewOrCid) {\n\t    if (!viewOrCid) return false;\n\t    let cid;\n\t    if (viewOrCid[CELL_VIEW_MARKER] || viewOrCid[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      cid = viewOrCid.cid;\n\t    } else {\n\t      cid = viewOrCid;\n\t    }\n\t    return this._updates.mountedList.has(cid);\n\t  },\n\t  /**\n\t   * @deprecated use `updateCellsVisibility` instead.\n\t   * `paper.updateCellsVisibility({ cellVisibility: () => true });`\n\t   */\n\t  dumpViews: function (opt) {\n\t    // Update cell visibility without `cellVisibility` callback i.e. make the cells visible\n\t    const passingOpt = defaults({}, opt, {\n\t      cellVisibility: null,\n\t      viewport: null\n\t    });\n\t    this.updateCellsVisibility(passingOpt);\n\t  },\n\t  /**\n\t   * Process all scheduled updates synchronously.\n\t   */\n\t  updateViews: function (opt = {}) {\n\t    this.notifyBeforeRender(opt);\n\t    const batchStats = this.updateViewsBatch({\n\t      ...opt,\n\t      batchSize: Infinity\n\t    });\n\t    const stats = {\n\t      updated: batchStats.updated,\n\t      priority: batchStats.priority,\n\t      // For backward compatibility. Will be removed in the future.\n\t      batches: Number.isFinite(opt.batchSize) ? Math.ceil(batchStats.updated / opt.batchSize) : 1\n\t    };\n\t    this.notifyAfterRender(stats, opt);\n\t    return stats;\n\t  },\n\t  hasScheduledUpdates: function () {\n\t    const updates = this._updates;\n\t    const priorities = updates.priorities;\n\t    const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t    let i = priorityIndexes.length;\n\t    while (i > 0 && i--) {\n\t      // a faster way how to check if an object is empty\n\t      for (let _key in priorities[priorityIndexes[i]]) return true;\n\t    }\n\t    return false;\n\t  },\n\t  updateViewsAsync: function (opt, data) {\n\t    opt || (opt = {});\n\t    data || (data = {\n\t      processed: 0,\n\t      priority: MIN_PRIORITY,\n\t      checkedUnmounted: 0,\n\t      checkedMounted: 0\n\t    });\n\t    const {\n\t      _updates: updates,\n\t      options\n\t    } = this;\n\t    const {\n\t      id,\n\t      mountedList,\n\t      unmountedList,\n\t      freshAfterReset\n\t    } = updates;\n\n\t    // Should we run the next batch update this frame?\n\t    let runBatchUpdate = true;\n\t    if (!id) {\n\t      // If there's no scheduled frame, no batch update is needed.\n\t      runBatchUpdate = false;\n\t    } else {\n\t      // Cancel any scheduled frame.\n\t      cancelFrame(id);\n\t      if (freshAfterReset) {\n\t        // First update after a reset.\n\t        updates.freshAfterReset = false;\n\t        // When `initializeUnmounted` is enabled, there are no scheduled updates.\n\t        // We check whether the `mountedList` and `unmountedList` are empty.\n\t        if (!this.legacyMode && mountedList.length === 0 && unmountedList.length === 0) {\n\t          // No updates to process; We trigger before/after render events via `updateViews`.\n\t          // Note: If `autoFreeze` is enabled, 'idle' event triggers next frame.\n\t          this.updateViews();\n\t          runBatchUpdate = false;\n\t        }\n\t      }\n\t    }\n\t    if (runBatchUpdate) {\n\t      if (data.processed === 0 && this.hasScheduledUpdates()) {\n\t        this.notifyBeforeRender(opt);\n\t      }\n\t      const stats = this.updateViewsBatch(opt);\n\t      const passingOpt = defaults({}, opt, {\n\t        mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n\t        unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n\t      });\n\t      const checkStats = this.scheduleCellsVisibilityUpdate(passingOpt);\n\t      const unmountCount = checkStats.unmounted;\n\t      const mountCount = checkStats.mounted;\n\t      let processed = data.processed;\n\t      const total = updates.count;\n\t      if (stats.updated > 0) {\n\t        // Some updates have been just processed\n\t        processed += stats.updated + stats.unmounted;\n\t        stats.processed = processed;\n\t        data.priority = Math.min(stats.priority, data.priority);\n\t        if (stats.empty && mountCount === 0) {\n\t          stats.unmounted += unmountCount;\n\t          stats.mounted += mountCount;\n\t          stats.priority = data.priority;\n\t          this.notifyAfterRender(stats, opt);\n\t          data.processed = 0;\n\t          data.priority = MIN_PRIORITY;\n\t          updates.count = 0;\n\t        } else {\n\t          data.processed = processed;\n\t        }\n\t        data.checkedUnmounted = 0;\n\t        data.checkedMounted = 0;\n\t      } else {\n\t        data.checkedUnmounted += Math.max(passingOpt.mountBatchSize, 0);\n\t        data.checkedMounted += Math.max(passingOpt.unmountBatchSize, 0);\n\t        // The `scheduleCellsVisibilityUpdate` could have scheduled some insertions\n\t        // (note that removals are currently done synchronously).\n\t        if (options.autoFreeze && !this.hasScheduledUpdates()) {\n\t          // If there are no updates scheduled and we checked all unmounted views,\n\t          if (data.checkedUnmounted >= unmountedList.length && data.checkedMounted >= mountedList.length) {\n\t            // We freeze the paper and notify the idle state.\n\t            this.freeze();\n\t            updates.idle = {\n\t              wakeUpOptions: opt\n\t            };\n\t            this.trigger('render:idle', opt);\n\t          }\n\t        }\n\t      }\n\t      // Progress callback\n\t      const progressFn = opt.progress;\n\t      if (total && typeof progressFn === 'function') {\n\t        progressFn.call(this, stats.empty, processed, total, stats, this);\n\t      }\n\t      // The current frame could have been canceled in a callback\n\t      if (updates.id !== id) return;\n\t    }\n\t    if (updates.disabled) {\n\t      throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n\t    }\n\t    updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n\t  },\n\t  notifyBeforeRender: function (opt = {}) {\n\t    if (opt.silent) return;\n\t    let beforeFn = opt.beforeRender;\n\t    if (typeof beforeFn !== 'function') {\n\t      beforeFn = this.options.beforeRender;\n\t      if (typeof beforeFn !== 'function') return;\n\t    }\n\t    beforeFn.call(this, opt, this);\n\t  },\n\t  notifyAfterRender: function (stats, opt = {}) {\n\t    if (opt.silent) return;\n\t    let afterFn = opt.afterRender;\n\t    if (typeof afterFn !== 'function') {\n\t      afterFn = this.options.afterRender;\n\t    }\n\t    if (typeof afterFn === 'function') {\n\t      afterFn.call(this, stats, opt, this);\n\t    }\n\t    this.trigger('render:done', stats, opt);\n\t  },\n\t  prioritizeCellViewMount: function (cellOrId) {\n\t    if (!cellOrId) return false;\n\t    const cid = this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false;\n\t    const {\n\t      unmountedList\n\t    } = this._updates;\n\t    if (!unmountedList.has(cid)) return false;\n\t    // Move the view to the head of the mounted list\n\t    unmountedList.moveToHead(cid);\n\t    return true;\n\t  },\n\t  prioritizeCellViewUnmount: function (cellOrId) {\n\t    if (!cellOrId) return false;\n\t    const cid = this._idToCid[cellOrId.id || cellOrId];\n\t    if (!cid) return false;\n\t    const {\n\t      mountedList\n\t    } = this._updates;\n\t    if (!mountedList.has(cid)) return false;\n\t    // Move the view to the head of the unmounted list\n\t    mountedList.moveToHead(cid);\n\t    return true;\n\t  },\n\t  _evalCellVisibility: function (viewLike, isMounted, visibilityCallback) {\n\t    if (!visibilityCallback || !viewLike.DETACHABLE) return true;\n\t    if (this.legacyMode) {\n\t      return visibilityCallback.call(this, viewLike, isMounted, this);\n\t    }\n\t    // The visibility check runs for CellView only.\n\t    if (!viewLike[CELL_VIEW_MARKER] && !viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) return true;\n\t    // The cellView model must be a member of this graph.\n\t    if (viewLike.model.graph !== this.model) {\n\t      // It could have been removed from the graph.\n\t      // If the view was mounted, we keep it mounted.\n\t      return isMounted;\n\t    }\n\t    return visibilityCallback.call(this, viewLike.model, isMounted, this);\n\t  },\n\t  _getCellVisibilityCallback: function (opt) {\n\t    const {\n\t      options\n\t    } = this;\n\t    if (this.legacyMode) {\n\t      const viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n\t      if (typeof viewportFn === 'function') return viewportFn;\n\t    } else {\n\t      const isVisibleFn = 'cellVisibility' in opt ? opt.cellVisibility : options.cellVisibility;\n\t      if (typeof isVisibleFn === 'function') return isVisibleFn;\n\t    }\n\t    return null;\n\t  },\n\t  updateViewsBatch: function (opt) {\n\t    opt || (opt = {});\n\t    var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n\t    var updates = this._updates;\n\t    var updateCount = 0;\n\t    var postponeCount = 0;\n\t    var unmountCount = 0;\n\t    var mountCount = 0;\n\t    var maxPriority = MIN_PRIORITY;\n\t    var empty = true;\n\t    var options = this.options;\n\t    var priorities = updates.priorities;\n\t    const visibilityCb = this._getCellVisibilityCallback(opt);\n\t    var postponeViewFn = options.onViewPostponed;\n\t    if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n\t    var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t    main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n\t      var priority = +priorityIndexes[i];\n\t      var priorityUpdates = priorities[priority];\n\t      for (var cid in priorityUpdates) {\n\t        if (updateCount >= batchSize) {\n\t          empty = false;\n\t          break main;\n\t        }\n\t        var view = views[cid];\n\t        if (!view) {\n\t          view = this._viewPlaceholders[cid];\n\t          if (!view) {\n\t            /**\n\t             * This can occur when:\n\t             * - the model is removed and a new model with the same id is added\n\t             * - the view `initialize` method was overridden and the view was not registered\n\t             * - an mvc.View scheduled an update, was removed and paper was not notified\n\t             */\n\t            delete priorityUpdates[cid];\n\t            continue;\n\t          }\n\t        }\n\t        var currentFlag = priorityUpdates[cid];\n\t        if ((currentFlag & this.FLAG_REMOVE) === 0) {\n\t          // We should never check a view for viewport if we are about to remove the view\n\t          const isMounted = !updates.unmountedList.has(cid);\n\t          if (!this._evalCellVisibility(view, isMounted, visibilityCb)) {\n\t            // Unmount View\n\t            if (isMounted) {\n\t              // The view is currently mounted. Hide the view (detach or remove it).\n\t              this.registerUnmountedView(view);\n\t              this._hideView(view);\n\t            } else {\n\t              // The view is not mounted. We can just update the unmounted list.\n\t              // We ADD the current flag to the flag that was already scheduled.\n\t              this._mergeUnmountedViewScheduledUpdates(cid, currentFlag);\n\t            }\n\t            // Delete the current update as it has been processed.\n\t            delete priorityUpdates[cid];\n\t            unmountCount++;\n\t            continue;\n\t          }\n\t          // Mount View\n\t          if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t            view = this._resolveCellViewPlaceholder(view);\n\t            // Newly initialized view needs to be initialized\n\t            currentFlag |= this.getCellViewInitFlag(view);\n\t          }\n\t          if (!isMounted) {\n\t            currentFlag |= this.FLAG_INSERT;\n\t            mountCount++;\n\t          }\n\t          currentFlag |= this.registerMountedView(view);\n\t        } else if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t          // We are trying to remove a placeholder view.\n\t          // This should not occur as the placeholder should have been unregistered\n\t          continue;\n\t        }\n\t        var leftoverFlag = this.updateView(view, currentFlag, opt);\n\t        if (leftoverFlag > 0) {\n\t          // View update has not finished completely\n\t          priorityUpdates[cid] = leftoverFlag;\n\t          if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n\t            postponeCount++;\n\t            empty = false;\n\t            continue;\n\t          }\n\t        }\n\t        if (maxPriority > priority) maxPriority = priority;\n\t        updateCount++;\n\t        delete priorityUpdates[cid];\n\t      }\n\t    }\n\t    return {\n\t      priority: maxPriority,\n\t      updated: updateCount,\n\t      postponed: postponeCount,\n\t      unmounted: unmountCount,\n\t      mounted: mountCount,\n\t      empty: empty\n\t    };\n\t  },\n\t  getCellViewInitFlag: function (cellView) {\n\t    return this.FLAG_INIT | cellView.getFlag(result(cellView, 'initFlag'));\n\t  },\n\t  /**\n\t   * @ignore This method returns an array of cellViewLike objects and therefore\n\t   * is meant for internal/test use only.\n\t   * The view placeholders are not exposed via public API.\n\t  */\n\t  getUnmountedViews: function () {\n\t    const updates = this._updates;\n\t    const unmountedViews = new Array(updates.unmountedList.length);\n\t    const unmountedCids = updates.unmountedList.keys();\n\t    let i = 0;\n\t    for (const cid of unmountedCids) {\n\t      // If the view is a placeholder, it won't be in the global views map\n\t      // If the view is not a cell view, it won't be in the viewPlaceholders map\n\t      unmountedViews[i++] = views[cid] || this._viewPlaceholders[cid];\n\t    }\n\t    return unmountedViews;\n\t  },\n\t  /**\n\t   * @ignore This method returns an array of cellViewLike objects and therefore\n\t   * is meant for internal/test use only.\n\t   * The view placeholders are not exposed via public API.\n\t   */\n\t  getMountedViews: function () {\n\t    const updates = this._updates;\n\t    const mountedViews = new Array(updates.mountedList.length);\n\t    const mountedCids = updates.mountedList.keys();\n\t    let i = 0;\n\t    for (const cid of mountedCids) {\n\t      mountedViews[i++] = views[cid] || this._viewPlaceholders[cid];\n\t    }\n\t    return mountedViews;\n\t  },\n\t  checkUnmountedViews: function (visibilityCb, opt) {\n\t    opt || (opt = {});\n\t    var mountCount = 0;\n\t    if (typeof visibilityCb !== 'function') visibilityCb = null;\n\t    var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n\t    var updates = this._updates;\n\t    var unmountedList = updates.unmountedList;\n\t    for (var i = 0, n = Math.min(unmountedList.length, batchSize); i < n; i++) {\n\t      const {\n\t        key: cid\n\t      } = unmountedList.peekHead();\n\t      let view = views[cid] || this._viewPlaceholders[cid];\n\t      if (!view) {\n\t        // This should not occur\n\t        // Prevent looping over this invalid cid\n\t        unmountedList.popHead();\n\t        continue;\n\t      }\n\t      if (!this._evalCellVisibility(view, false, visibilityCb)) {\n\t        // Push at the end of all unmounted ids, so this can be check later again\n\t        unmountedList.rotate();\n\t        continue;\n\t      }\n\t      // Remove the view from the unmounted list\n\t      const {\n\t        value: prevFlag\n\t      } = unmountedList.popHead();\n\t      mountCount++;\n\t      const flag = this.registerMountedView(view) | prevFlag;\n\t      if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n\t        mounting: true\n\t      });\n\t    }\n\t    return mountCount;\n\t  },\n\t  checkMountedViews: function (visibilityCb, opt) {\n\t    opt || (opt = {});\n\t    var unmountCount = 0;\n\t    if (typeof visibilityCb !== 'function') return unmountCount;\n\t    var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n\t    var updates = this._updates;\n\t    const mountedList = updates.mountedList;\n\t    for (var i = 0, n = Math.min(mountedList.length, batchSize); i < n; i++) {\n\t      const {\n\t        key: cid\n\t      } = mountedList.peekHead();\n\t      const view = views[cid];\n\t      if (!view) {\n\t        // A view (not a cell view) has been removed from the paper.\n\t        // Remove it from the mounted list and continue.\n\t        mountedList.popHead();\n\t        continue;\n\t      }\n\t      if (this._evalCellVisibility(view, true, visibilityCb)) {\n\t        // Push at the end of all mounted ids, so this can be check later again\n\t        mountedList.rotate();\n\t        continue;\n\t      }\n\t      // Remove the view from the mounted list\n\t      mountedList.popHead();\n\t      unmountCount++;\n\t      var flag = this.registerUnmountedView(view);\n\t      if (flag) {\n\t        this._hideView(view);\n\t      }\n\t    }\n\t    return unmountCount;\n\t  },\n\t  checkViewVisibility: function (cellView, opt = {}) {\n\t    const visibilityCb = this._getCellVisibilityCallback(opt);\n\t    const updates = this._updates;\n\t    const {\n\t      mountedList,\n\t      unmountedList\n\t    } = updates;\n\t    const visible = this._evalCellVisibility(cellView, false, visibilityCb);\n\t    let isUnmounted = false;\n\t    let isMounted = false;\n\t    if (mountedList.has(cellView.cid) && !visible) {\n\t      const flag = this.registerUnmountedView(cellView);\n\t      if (flag) this._hideView(cellView);\n\t      mountedList.delete(cellView.cid);\n\t      isUnmounted = true;\n\t    }\n\t    if (!isUnmounted && unmountedList.has(cellView.cid) && visible) {\n\t      const unmountedItem = unmountedList.get(cellView.cid);\n\t      unmountedList.delete(cellView.cid);\n\t      const flag = unmountedItem.value | this.registerMountedView(cellView);\n\t      if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n\t        mounting: true\n\t      });\n\t      isMounted = true;\n\t    }\n\t    return {\n\t      mounted: isMounted ? 1 : 0,\n\t      unmounted: isUnmounted ? 1 : 0\n\t    };\n\t  },\n\t  /**\n\t   * @public\n\t   * Update the visibility of a single cell.\n\t   */\n\t  updateCellVisibility: function (cell, opt = {}) {\n\t    const cellViewLike = this._getCellViewLike(cell);\n\t    if (!cellViewLike) return;\n\t    const stats = this.checkViewVisibility(cellViewLike, opt);\n\t    // Note: `unmounted` views are removed immediately\n\t    if (stats.mounted > 0) {\n\t      // Mounting is scheduled. Run the update.\n\t      // Note: the view might be a placeholder.\n\t      this.requireView(cell, opt);\n\t    }\n\t  },\n\t  /**\n\t   * @public\n\t   * Update the visibility of all cells.\n\t   */\n\t  updateCellsVisibility: function (opt = {}) {\n\t    // Check the visibility of all cells and schedule their updates.\n\t    this.scheduleCellsVisibilityUpdate(opt);\n\t    // Perform the scheduled updates while avoiding re-evaluating the visibility.\n\t    const keepCurrentVisibility = (_, isVisible) => isVisible;\n\t    this.updateViews({\n\t      ...opt,\n\t      cellVisibility: keepCurrentVisibility\n\t    });\n\t  },\n\t  /**\n\t   * @protected\n\t   * Run visibility checks for all cells and schedule their updates.\n\t   */\n\t  scheduleCellsVisibilityUpdate(opt) {\n\t    const passingOpt = defaults({}, opt, {\n\t      mountBatchSize: Infinity,\n\t      unmountBatchSize: Infinity\n\t    });\n\t    const visibilityCb = this._getCellVisibilityCallback(passingOpt);\n\t    const unmountedCount = this.checkMountedViews(visibilityCb, passingOpt);\n\t    if (unmountedCount > 0) {\n\t      // Do not check views, that have been just unmounted and pushed at the end of the cids array\n\t      var unmountedList = this._updates.unmountedList;\n\t      passingOpt.mountBatchSize = Math.min(unmountedList.length - unmountedCount, passingOpt.mountBatchSize);\n\t    }\n\t    const mountedCount = this.checkUnmountedViews(visibilityCb, passingOpt);\n\t    return {\n\t      mounted: mountedCount,\n\t      unmounted: unmountedCount\n\t    };\n\t  },\n\t  /**\n\t   * @deprecated use `updateCellsVisibility` instead\n\t   * This method will be renamed and made private in the future.\n\t   */\n\t  checkViewport: function (opt) {\n\t    return this.scheduleCellsVisibilityUpdate(opt);\n\t  },\n\t  freeze: function (opt) {\n\t    opt || (opt = {});\n\t    var updates = this._updates;\n\t    var key = opt.key;\n\t    var isFrozen = this.options.frozen;\n\t    var freezeKey = updates.freezeKey;\n\t    if (key && key !== freezeKey) {\n\t      // key passed, but the paper is already freezed with another key\n\t      if (isFrozen && freezeKey) return;\n\t      updates.freezeKey = key;\n\t      updates.keyFrozen = isFrozen;\n\t    }\n\t    this.options.frozen = true;\n\t    var id = updates.id;\n\t    updates.id = null;\n\t    if (!this.legacyMode) {\n\t      // Make sure the `freeze()` method ends the idle state.\n\t      updates.idle = false;\n\t    }\n\t    if (this.isAsync() && id) cancelFrame(id);\n\t  },\n\t  unfreeze: function (opt) {\n\t    opt || (opt = {});\n\t    var updates = this._updates;\n\t    var key = opt.key;\n\t    var freezeKey = updates.freezeKey;\n\t    // key passed, but the paper is already freezed with another key\n\t    if (key && freezeKey && key !== freezeKey) return;\n\t    updates.freezeKey = null;\n\t    // key passed, but the paper is already freezed\n\t    if (key && key === freezeKey && updates.keyFrozen) return;\n\t    updates.idle = false;\n\t    if (this.isAsync()) {\n\t      this.freeze();\n\t      this.updateViewsAsync(opt);\n\t    } else {\n\t      this.updateViews(opt);\n\t    }\n\t    this.options.frozen = updates.keyFrozen = false;\n\t    if (updates.sort) {\n\t      this.sortLayerViews();\n\t      updates.sort = false;\n\t    }\n\t  },\n\t  wakeUp: function () {\n\t    if (!this.isIdle()) return;\n\t    this.unfreeze(this._updates.idle.wakeUpOptions);\n\t  },\n\t  isAsync: function () {\n\t    return !!this.options.async;\n\t  },\n\t  isFrozen: function () {\n\t    return !!this.options.frozen && !this.isIdle();\n\t  },\n\t  isIdle: function () {\n\t    if (this.legacyMode) {\n\t      // Not implemented in the legacy mode.\n\t      return false;\n\t    }\n\t    return !!(this._updates && this._updates.idle);\n\t  },\n\t  isExactSorting: function () {\n\t    return this.options.sorting === sortingTypes.EXACT;\n\t  },\n\t  onRemove: function () {\n\t    this.freeze();\n\t    this._updates.disabled = true;\n\t    //clean up all DOM elements/views to prevent memory leaks\n\t    this.removeViews();\n\t    this._removeLayerViews();\n\t  },\n\t  getComputedSize: function () {\n\t    var options = this.options;\n\t    var w = options.width;\n\t    var h = options.height;\n\t    if (!isNumber(w)) w = this.el.clientWidth;\n\t    if (!isNumber(h)) h = this.el.clientHeight;\n\t    return {\n\t      width: w,\n\t      height: h\n\t    };\n\t  },\n\t  setDimensions: function (width, height, data = {}) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      width: currentWidth,\n\t      height: currentHeight\n\t    } = options;\n\t    let w = width === undefined ? currentWidth : width;\n\t    let h = height === undefined ? currentHeight : height;\n\t    if (currentWidth === w && currentHeight === h) return;\n\t    options.width = w;\n\t    options.height = h;\n\t    this._setDimensions();\n\t    const computedSize = this.getComputedSize();\n\t    this.trigger('resize', computedSize.width, computedSize.height, data);\n\t  },\n\t  _setDimensions: function () {\n\t    const {\n\t      options\n\t    } = this;\n\t    let w = options.width;\n\t    let h = options.height;\n\t    if (isNumber(w)) w = `${Math.round(w)}px`;\n\t    if (isNumber(h)) h = `${Math.round(h)}px`;\n\t    this.$el.css({\n\t      width: w === null ? '' : w,\n\t      height: h === null ? '' : h\n\t    });\n\t  },\n\t  // Expand/shrink the paper to fit the content.\n\t  // Alternatively signature function(opt)\n\t  fitToContent: function (gridWidth, gridHeight, padding, opt) {\n\t    if (isObject(gridWidth)) {\n\t      // first parameter is an option object\n\t      opt = gridWidth;\n\t    } else {\n\t      // Support for a deprecated signature\n\t      opt = assign({\n\t        gridWidth,\n\t        gridHeight,\n\t        padding\n\t      }, opt);\n\t    }\n\t    const {\n\t      x,\n\t      y,\n\t      width,\n\t      height\n\t    } = this.getFitToContentArea(opt);\n\t    const {\n\t      sx,\n\t      sy\n\t    } = this.scale();\n\t    this.translate(-x * sx, -y * sy, opt);\n\t    this.setDimensions(width * sx, height * sy, opt);\n\t    return new Rect(x, y, width, height);\n\t  },\n\t  getFitToContentArea: function (opt = {}) {\n\t    // Calculate the paper size to accommodate all the graph's elements.\n\n\t    const gridWidth = opt.gridWidth || 1;\n\t    const gridHeight = opt.gridHeight || 1;\n\t    const padding = normalizeSides(opt.padding || 0);\n\t    const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n\t    const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n\t    const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n\t    const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n\t    const newOrigin = opt.allowNewOrigin;\n\t    const area = 'contentArea' in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);\n\t    const {\n\t      sx,\n\t      sy\n\t    } = this.scale();\n\t    area.x *= sx;\n\t    area.y *= sy;\n\t    area.width *= sx;\n\t    area.height *= sy;\n\t    let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n\t    let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n\t    if (!opt.allowNegativeBottomRight) {\n\t      calcWidth = Math.max(calcWidth, 1);\n\t      calcHeight = Math.max(calcHeight, 1);\n\t    }\n\t    calcWidth *= gridWidth;\n\t    calcHeight *= gridHeight;\n\t    let tx = 0;\n\t    if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {\n\t      tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n\t      tx += padding.left;\n\t      calcWidth += tx;\n\t    }\n\t    let ty = 0;\n\t    if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {\n\t      ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n\t      ty += padding.top;\n\t      calcHeight += ty;\n\t    }\n\t    calcWidth += padding.right;\n\t    calcHeight += padding.bottom;\n\n\t    // Make sure the resulting width and height are greater than minimum.\n\t    calcWidth = Math.max(calcWidth, minWidth);\n\t    calcHeight = Math.max(calcHeight, minHeight);\n\n\t    // Make sure the resulting width and height are lesser than maximum.\n\t    calcWidth = Math.min(calcWidth, maxWidth);\n\t    calcHeight = Math.min(calcHeight, maxHeight);\n\t    return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n\t  },\n\t  transformToFitContent: function (opt) {\n\t    opt || (opt = {});\n\t    let contentBBox, contentLocalOrigin;\n\t    if ('contentArea' in opt) {\n\t      const contentArea = opt.contentArea;\n\t      contentBBox = this.localToPaperRect(contentArea);\n\t      contentLocalOrigin = new Point(contentArea);\n\t    } else {\n\t      contentBBox = this.getContentBBox(opt);\n\t      contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n\t    }\n\t    if (!contentBBox.width || !contentBBox.height) return;\n\t    defaults(opt, {\n\t      padding: 0,\n\t      preserveAspectRatio: true,\n\t      scaleGrid: null,\n\t      minScale: 0,\n\t      maxScale: Number.MAX_VALUE,\n\t      verticalAlign: 'top',\n\t      horizontalAlign: 'left'\n\t      //minScaleX\n\t      //minScaleY\n\t      //maxScaleX\n\t      //maxScaleY\n\t      //fittingBBox\n\t    });\n\t    const padding = normalizeSides(opt.padding);\n\t    const minScaleX = opt.minScaleX || opt.minScale;\n\t    const maxScaleX = opt.maxScaleX || opt.maxScale;\n\t    const minScaleY = opt.minScaleY || opt.minScale;\n\t    const maxScaleY = opt.maxScaleY || opt.maxScale;\n\t    let fittingBBox;\n\t    if (opt.fittingBBox) {\n\t      fittingBBox = opt.fittingBBox;\n\t    } else {\n\t      const currentTranslate = this.translate();\n\t      const computedSize = this.getComputedSize();\n\t      fittingBBox = {\n\t        x: currentTranslate.tx,\n\t        y: currentTranslate.ty,\n\t        width: computedSize.width,\n\t        height: computedSize.height\n\t      };\n\t    }\n\t    fittingBBox = new Rect(fittingBBox).moveAndExpand({\n\t      x: padding.left,\n\t      y: padding.top,\n\t      width: -padding.left - padding.right,\n\t      height: -padding.top - padding.bottom\n\t    });\n\t    const ctm = this.matrix();\n\t    const {\n\t      a: sx,\n\t      d: sy,\n\t      e: tx,\n\t      f: ty\n\t    } = ctm;\n\t    let newSx = fittingBBox.width / contentBBox.width * sx;\n\t    let newSy = fittingBBox.height / contentBBox.height * sy;\n\t    if (opt.preserveAspectRatio) {\n\t      newSx = newSy = Math.min(newSx, newSy);\n\t    }\n\n\t    // snap scale to a grid\n\t    if (opt.scaleGrid) {\n\t      const gridSize = opt.scaleGrid;\n\t      newSx = gridSize * Math.floor(newSx / gridSize);\n\t      newSy = gridSize * Math.floor(newSy / gridSize);\n\t    }\n\n\t    // scale min/max boundaries\n\t    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n\t    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\t    const scaleDiff = {\n\t      x: newSx / sx,\n\t      y: newSy / sy\n\t    };\n\t    let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n\t    let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\t    switch (opt.verticalAlign) {\n\t      case 'middle':\n\t        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n\t        break;\n\t      case 'bottom':\n\t        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n\t        break;\n\t      case 'top':\n\t      default:\n\t        break;\n\t    }\n\t    switch (opt.horizontalAlign) {\n\t      case 'middle':\n\t        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n\t        break;\n\t      case 'right':\n\t        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n\t        break;\n\t      case 'left':\n\t      default:\n\t        break;\n\t    }\n\t    ctm.a = newSx;\n\t    ctm.d = newSy;\n\t    ctm.e = newOx;\n\t    ctm.f = newOy;\n\t    this.matrix(ctm, opt);\n\t  },\n\t  scaleContentToFit: function (opt) {\n\t    this.transformToFitContent(opt);\n\t  },\n\t  // Return the dimensions of the content area in local units (without transformations).\n\t  getContentArea: function (opt) {\n\t    if (opt && opt.useModelGeometry) {\n\t      return this.model.getBBox() || new Rect();\n\t    }\n\t    const graphLayerViews = this.getGraphLayerViews();\n\t    // Return an empty rectangle if there are no layers\n\t    // should not happen in practice\n\t    if (graphLayerViews.length === 0) {\n\t      return new Rect();\n\t    }\n\n\t    // Combine content area rectangles from all layers,\n\t    // considering only graph layer views to exclude non-cell elements (e.g., grid, tools)\n\t    const bbox = Rect.fromRectUnion(...graphLayerViews.map(view => view.vel.getBBox()));\n\t    return bbox;\n\t  },\n\t  // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n\t  getContentBBox: function (opt) {\n\t    return this.localToPaperRect(this.getContentArea(opt));\n\t  },\n\t  // Returns a geometry rectangle representing the entire\n\t  // paper area (coordinates from the left paper border to the right one\n\t  // and the top border to the bottom one).\n\t  getArea: function () {\n\t    return this.paperToLocalRect(this.getComputedSize());\n\t  },\n\t  getRestrictedArea: function (...args) {\n\t    const {\n\t      restrictTranslate\n\t    } = this.options;\n\t    let restrictedArea;\n\t    if (isFunction(restrictTranslate)) {\n\t      // A method returning a bounding box\n\t      restrictedArea = restrictTranslate.apply(this, args);\n\t    } else if (restrictTranslate === true) {\n\t      // The paper area\n\t      restrictedArea = this.getArea();\n\t    } else if (!restrictTranslate) {\n\t      // falsy value\n\t      restrictedArea = null;\n\t    } else {\n\t      // any other value\n\t      restrictedArea = new Rect(restrictTranslate);\n\t    }\n\t    return restrictedArea;\n\t  },\n\t  _resolveCellViewPlaceholder: function (placeholder) {\n\t    const {\n\t      model,\n\t      viewClass,\n\t      cid\n\t    } = placeholder;\n\t    const view = this._initializeCellView(viewClass, model, cid);\n\t    this._registerCellView(view);\n\t    this._unregisterCellViewPlaceholder(placeholder);\n\t    return view;\n\t  },\n\t  _registerCellViewPlaceholder: function (cell, cid = uniqueId('view')) {\n\t    const ViewClass = this._resolveCellViewClass(cell);\n\t    const placeholder = {\n\t      // A tag to identify the placeholder from a CellView.\n\t      [CELL_VIEW_PLACEHOLDER_MARKER]: true,\n\t      cid,\n\t      model: cell,\n\t      DETACHABLE: true,\n\t      viewClass: ViewClass,\n\t      UPDATE_PRIORITY: ViewClass.prototype.UPDATE_PRIORITY\n\t    };\n\t    this._viewPlaceholders[cid] = placeholder;\n\t    return placeholder;\n\t  },\n\t  _registerCellView: function (cellView) {\n\t    cellView.paper = this;\n\t    this._views[cellView.model.id] = cellView;\n\t  },\n\t  _unregisterCellViewPlaceholder: function (placeholder) {\n\t    delete this._viewPlaceholders[placeholder.cid];\n\t  },\n\t  _initializeCellView: function (ViewClass, cell, cid) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      interactive,\n\t      labelsLayer\n\t    } = options;\n\t    return new ViewClass({\n\t      cid,\n\t      model: cell,\n\t      interactive,\n\t      labelsLayer: labelsLayer === true ? paperLayers.LABELS : labelsLayer\n\t    });\n\t  },\n\t  _resolveCellViewClass: function (cell) {\n\t    const {\n\t      options\n\t    } = this;\n\t    const {\n\t      cellViewNamespace\n\t    } = options;\n\t    const type = cell.get('type') + 'View';\n\t    const namespaceViewClass = getByPath(cellViewNamespace, type, '.');\n\t    // A class taken from the paper options.\n\t    let optionalViewClass;\n\t    let defaultViewClass;\n\t    if (cell.isLink()) {\n\t      optionalViewClass = options.linkView;\n\t      defaultViewClass = LinkView;\n\t    } else {\n\t      optionalViewClass = options.elementView;\n\t      defaultViewClass = ElementView;\n\t    }\n\t    // a) the paper options view is a class (deprecated)\n\t    //  1. search the namespace for a view\n\t    //  2. if no view was found, use view from the paper options\n\t    // b) the paper options view is a function\n\t    //  1. call the function from the paper options\n\t    //  2. if no view was return, search the namespace for a view\n\t    //  3. if no view was found, use the default\n\t    return optionalViewClass.prototype instanceof ViewBase ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\t  },\n\t  // Returns a CellView instance or its placeholder for the given cell.\n\t  _getCellViewLike: function (cell) {\n\t    let id;\n\t    if (isString(cell) || isNumber(cell)) {\n\t      // If the cell is a string or number, it is an id of the view.\n\t      id = cell;\n\t    } else if (cell) {\n\t      // If the cell is an object, it should have an id property.\n\t      id = cell.id;\n\t    } else {\n\t      // If the cell is falsy, return null.\n\t      return null;\n\t    }\n\t    const view = this._views[id];\n\t    if (view) return view;\n\n\t    // If the view is not found, it may be a placeholder\n\t    const cid = this._idToCid[id];\n\t    if (cid) {\n\t      return this._viewPlaceholders[cid];\n\t    }\n\t    return null;\n\t  },\n\t  createViewForModel: function (cell, cid) {\n\t    return this._initializeCellView(this._resolveCellViewClass(cell), cell, cid);\n\t  },\n\t  removeView: function (cell) {\n\t    const {\n\t      id\n\t    } = cell;\n\t    const {\n\t      _views,\n\t      _updates\n\t    } = this;\n\t    const view = _views[id];\n\t    if (view) {\n\t      var {\n\t        cid\n\t      } = view;\n\t      const {\n\t        mountedList,\n\t        unmountedList\n\t      } = _updates;\n\t      view.remove();\n\t      delete _views[id];\n\t      delete this._idToCid[id];\n\t      mountedList.delete(cid);\n\t      unmountedList.delete(cid);\n\t    }\n\t    return view;\n\t  },\n\t  renderView: function (cell, opt) {\n\t    const {\n\t      id\n\t    } = cell;\n\t    const views = this._views;\n\t    let view, flag;\n\t    let create = true;\n\t    if (id in views) {\n\t      view = views[id];\n\t      if (view.model === cell) {\n\t        flag = this.FLAG_INSERT;\n\t        create = false;\n\t      } else {\n\t        // The view for this `id` already exist.\n\t        // The cell is a new instance of the model with identical id\n\t        // We simply remove the existing view and create a new one\n\t        this.removeView(cell);\n\t      }\n\t    }\n\t    if (create) {\n\t      const {\n\t        viewManagement\n\t      } = this.options;\n\t      const cid = uniqueId('view');\n\t      this._idToCid[cell.id] = cid;\n\t      if (viewManagement.lazyInitialize) {\n\t        // Register only a placeholder for the view\n\t        view = this._registerCellViewPlaceholder(cell, cid);\n\t        flag = this.registerUnmountedView(view);\n\t      } else {\n\t        // Create a new view instance\n\t        view = this.createViewForModel(cell, cid);\n\t        this._registerCellView(view);\n\t        flag = this.registerUnmountedView(view);\n\t        // The newly created view needs to be initialized\n\t        flag |= this.getCellViewInitFlag(view);\n\t      }\n\t      if (viewManagement.initializeUnmounted) {\n\t        // Save the initialization flags for later and exit early\n\t        this._mergeUnmountedViewScheduledUpdates(cid, flag);\n\t        return view;\n\t      }\n\t    }\n\t    this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n\t    return view;\n\t  },\n\t  // Update the view flags in the `unmountedList` using the bitwise OR operation\n\t  _mergeUnmountedViewScheduledUpdates: function (cid, flag) {\n\t    const {\n\t      unmountedList\n\t    } = this._updates;\n\t    const unmountedItem = unmountedList.get(cid);\n\t    if (unmountedItem) {\n\t      unmountedItem.value |= flag;\n\t    }\n\t  },\n\t  onImageDragStart: function () {\n\t    // This is the only way to prevent image dragging in Firefox that works.\n\t    // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n\t    return false;\n\t  },\n\t  resetViews: function (cells, opt) {\n\t    opt || (opt = {});\n\t    cells || (cells = []);\n\t    // Allows to unfreeze normally while in the idle state using autoFreeze option\n\t    const key = (this.legacyMode ? this.options.autoFreeze : this.isIdle()) ? null : 'reset';\n\t    this._resetUpdates();\n\t    // clearing views removes any event listeners\n\t    this.removeViews();\n\t    this.freeze({\n\t      key\n\t    });\n\t    for (var i = 0, n = cells.length; i < n; i++) {\n\t      this.renderView(cells[i], opt);\n\t    }\n\t    this.unfreeze({\n\t      key\n\t    });\n\t    this.sortLayerViews();\n\t  },\n\t  removeViews: function () {\n\t    // Remove all views and their references from the paper.\n\t    for (const id in this._views) {\n\t      const view = this._views[id];\n\t      if (view) {\n\t        view.remove();\n\t      }\n\t    }\n\t    this._views = {};\n\t    this._viewPlaceholders = {};\n\t    this._idToCid = {};\n\t  },\n\t  sortLayerViews: function () {\n\t    if (!this.isExactSorting()) {\n\t      // noop\n\t      return;\n\t    }\n\t    if (this.isFrozen() || this.isIdle()) {\n\t      // sort views once unfrozen\n\t      this._updates.sort = true;\n\t      return;\n\t    }\n\t    this.sortLayerViewsExact();\n\t  },\n\t  sortLayerViewsExact: function () {\n\t    this.getGraphLayerViews().forEach(view => view.sortExact());\n\t  },\n\t  insertView: function (view, isInitialInsert) {\n\t    // layer can be null if it is added to the graph with 'dry' option\n\t    const layerId = this.model.getCellLayerId(view.model);\n\t    const layerView = this.getLayerView(layerId);\n\t    layerView.insertCellView(view);\n\t    view.onMount(isInitialInsert);\n\t  },\n\t  _hideView: function (viewLike) {\n\t    if (!viewLike || viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {\n\t      // A placeholder view was never mounted\n\t      return;\n\t    }\n\t    if (viewLike[CELL_VIEW_MARKER]) {\n\t      this._hideCellView(viewLike);\n\t    } else {\n\t      // A generic view that is not a cell view.\n\t      viewLike.unmount();\n\t    }\n\t  },\n\t  // If `cellVisibility` returns `false`, the view will be hidden using this method.\n\t  _hideCellView: function (cellView) {\n\t    if (this.options.viewManagement.disposeHidden) {\n\t      if (this._disposeCellView(cellView)) return;\n\t    }\n\t    // Detach the view from the paper, but keep it in memory\n\t    this._detachCellView(cellView);\n\t  },\n\t  _disposeCellView: function (cellView) {\n\t    if (HighlighterView.has(cellView) || cellView.hasTools()) {\n\t      // We currently do not dispose views which has a highlighter or tools attached\n\t      // Note: Possible improvement would be to serialize highlighters/tools and\n\t      // restore them on view re-mount.\n\t      return false;\n\t    }\n\t    const cell = cellView.model;\n\t    // Remove the view from the paper and dispose it\n\t    cellView.remove();\n\t    delete this._views[cell.id];\n\t    this._registerCellViewPlaceholder(cell, cellView.cid);\n\t    return true;\n\t  },\n\t  // Dispose (release resources) all hidden views.\n\t  disposeHiddenCellViews: function () {\n\t    // Only cell views can be in the unmounted list (not in the legacy mode).\n\t    if (this.legacyMode) return;\n\t    const unmountedCids = this._updates.unmountedList.keys();\n\t    for (const cid of unmountedCids) {\n\t      const cellView = views[cid];\n\t      cellView && this._disposeCellView(cellView);\n\t    }\n\t  },\n\t  // Detach a view from the paper, but keep it in memory.\n\t  _detachCellView(cellView) {\n\t    cellView.unmount();\n\t    cellView.onDetach();\n\t  },\n\t  // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n\t  // be a selector or a jQuery object.\n\t  findView: function ($el) {\n\t    var el = isString($el) ? this.layers.querySelector($el) : $el instanceof $ ? $el[0] : $el;\n\t    var id = this.findAttribute('model-id', el);\n\t    if (id) return this._views[id];\n\t    return undefined;\n\t  },\n\t  // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n\t  findViewByModel: function (cellOrId) {\n\t    const cellViewLike = this._getCellViewLike(cellOrId);\n\t    if (!cellViewLike) return undefined;\n\t    if (cellViewLike[CELL_VIEW_MARKER]) {\n\t      // If the view is not a placeholder, return it directly\n\t      return cellViewLike;\n\t    }\n\t    // We do not expose placeholder views directly. We resolve them before returning.\n\t    const cellView = this._resolveCellViewPlaceholder(cellViewLike);\n\t    const flag = this.getCellViewInitFlag(cellView);\n\t    if (this.isViewMounted(cellView)) {\n\t      // The view was acting as a placeholder and is already present in the `mounted` list,\n\t      // indicating that its visibility has been checked, but the update hasn't occurred yet.\n\t      // Placeholders are resolved during the update routine. Since we're handling it\n\t      // manually here, we must ensure the view is properly initialized on the next update.\n\t      this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n\t        // It's important to run in isolation to avoid triggering the update of\n\t        // connected links\n\t        isolate: true\n\t      });\n\t    } else {\n\t      // Update the flags in the `unmounted` list\n\t      this._mergeUnmountedViewScheduledUpdates(cellView.cid, flag);\n\t    }\n\t    return cellView;\n\t  },\n\t  // Find all views at given point\n\t  findViewsFromPoint: function (p) {\n\t    p = new Point(p);\n\t    var views = this.model.getElements().map(this.findViewByModel, this);\n\t    return views.filter(function (view) {\n\t      return view && view.vel.getBBox({\n\t        target: this.layers\n\t      }).containsPoint(p);\n\t    }, this);\n\t  },\n\t  // Find all views in given area\n\t  findViewsInArea: function (rect, opt) {\n\t    opt = defaults(opt || {}, {\n\t      strict: false\n\t    });\n\t    rect = new Rect(rect);\n\t    var views = this.model.getElements().map(this.findViewByModel, this);\n\t    var method = opt.strict ? 'containsRect' : 'intersect';\n\t    return views.filter(function (view) {\n\t      return view && rect[method](view.vel.getBBox({\n\t        target: this.layers\n\t      }));\n\t    }, this);\n\t  },\n\t  findElementViewsInArea(plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt), opt);\n\t  },\n\t  findLinkViewsInArea: function (plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt), opt);\n\t  },\n\t  findCellViewsInArea: function (plainArea, opt) {\n\t    return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt), opt);\n\t  },\n\t  findElementViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findElementsInArea(extArea), opt);\n\t  },\n\t  findLinkViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint, extArea => this.model.findLinksInArea(extArea), opt);\n\t  },\n\t  findCellViewsAtPoint: function (plainPoint, opt) {\n\t    return this._filterViewsAtPoint(plainPoint,\n\t    // Note: we do not want to pass `opt` to `findCellsInArea`\n\t    // because the `strict` option works differently for querying at a point\n\t    extArea => this.model.findCellsInArea(extArea), opt);\n\t  },\n\t  findClosestMagnetToPoint: function (point, options = {}) {\n\t    let minDistance = Number.MAX_SAFE_INTEGER;\n\t    let bestPriority = -Infinity;\n\t    const pointer = new Point(point);\n\t    const radius = options.radius || Number.MAX_SAFE_INTEGER;\n\t    const viewsInArea = this.findCellViewsInArea({\n\t      x: pointer.x - radius,\n\t      y: pointer.y - radius,\n\t      width: 2 * radius,\n\t      height: 2 * radius\n\t    }, options.findInAreaOptions);\n\t    // Enable all connections by default\n\t    const filterFn = typeof options.filter === 'function' ? options.filter : null;\n\t    let closestView = null;\n\t    let closestMagnet = null;\n\n\t    // Note: If snapRadius is smaller than magnet size, views will not be found.\n\t    viewsInArea.forEach(view => {\n\t      const candidates = [];\n\t      const {\n\t        model\n\t      } = view;\n\t      // skip connecting to the element in case '.': { magnet: false } attribute present\n\t      if (view.el.getAttribute('magnet') !== 'false') {\n\t        if (model.isLink()) {\n\t          const connection = view.getConnection();\n\t          candidates.push({\n\t            // find distance from the closest point of a link to pointer coordinates\n\t            priority: 0,\n\t            distance: connection.closestPoint(pointer).squaredDistance(pointer),\n\t            magnet: view.el\n\t          });\n\t        } else {\n\t          candidates.push({\n\t            // Set the priority to the level of nested elements of the model\n\t            // To ensure that the embedded cells get priority over the parent cells\n\t            priority: model.getAncestors().length,\n\t            // find distance from the center of the model to pointer coordinates\n\t            distance: model.getBBox().center().squaredDistance(pointer),\n\t            magnet: view.el\n\t          });\n\t        }\n\t      }\n\t      view.$('[magnet]').toArray().forEach(magnet => {\n\t        const magnetBBox = view.getNodeBBox(magnet);\n\t        let magnetDistance = magnetBBox.pointNearestToPoint(pointer).squaredDistance(pointer);\n\t        if (magnetBBox.containsPoint(pointer)) {\n\t          // Pointer sits inside this magnet.\n\t          // Push its distance far into the negative range so any\n\t          // \"under-pointer\" magnet outranks magnets that are only nearby\n\t          // (positive distance) and every non-magnet candidate.\n\t          // We add the original distance back to keep ordering among\n\t          // overlapping magnets: the one whose border is closest to the\n\t          // pointer (smaller original distance) still wins.\n\t          magnetDistance = -Number.MAX_SAFE_INTEGER + magnetDistance;\n\t        }\n\n\t        // Check if magnet is inside the snap radius.\n\t        if (magnetDistance <= radius * radius) {\n\t          candidates.push({\n\t            // Give magnets priority over other candidates.\n\t            priority: Number.MAX_SAFE_INTEGER,\n\t            distance: magnetDistance,\n\t            magnet\n\t          });\n\t        }\n\t      });\n\t      candidates.forEach(candidate => {\n\t        const {\n\t          magnet,\n\t          distance,\n\t          priority\n\t        } = candidate;\n\t        const isBetterCandidate = priority > bestPriority || priority === bestPriority && distance < minDistance;\n\t        if (isBetterCandidate && (!filterFn || filterFn(view, magnet))) {\n\t          bestPriority = priority;\n\t          minDistance = distance;\n\t          closestView = view;\n\t          closestMagnet = magnet;\n\t        }\n\t      });\n\t    });\n\t    return closestView ? {\n\t      view: closestView,\n\t      magnet: closestMagnet\n\t    } : null;\n\t  },\n\t  _findInExtendedArea: function (area, findCellsFn, opt = {}) {\n\t    const {\n\t      buffer = this.DEFAULT_FIND_BUFFER\n\t    } = opt;\n\t    const extendedArea = new Rect(area).inflate(buffer);\n\t    const cellsInExtendedArea = findCellsFn(extendedArea, opt);\n\t    return cellsInExtendedArea.map(element => this.findViewByModel(element));\n\t  },\n\t  _filterViewsInArea: function (plainArea, findCells, opt = {}) {\n\t    const area = new Rect(plainArea);\n\t    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n\t    const viewsInArea = viewsInExtendedArea.filter(view => {\n\t      if (!view) return false;\n\t      return view.isInArea(area, opt);\n\t    });\n\t    return viewsInArea;\n\t  },\n\t  _filterViewsAtPoint: function (plainPoint, findCells, opt = {}) {\n\t    const area = new Rect(plainPoint); // zero-size area\n\t    const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n\t    const viewsAtPoint = viewsInExtendedArea.filter(view => {\n\t      if (!view) return false;\n\t      return view.isAtPoint(plainPoint, opt);\n\t    });\n\t    return viewsAtPoint;\n\t  },\n\t  removeTools: function () {\n\t    this.dispatchToolsEvent('remove');\n\t    return this;\n\t  },\n\t  hideTools: function () {\n\t    this.dispatchToolsEvent('hide');\n\t    return this;\n\t  },\n\t  showTools: function () {\n\t    this.dispatchToolsEvent('show');\n\t    return this;\n\t  },\n\t  dispatchToolsEvent: function (event, ...args) {\n\t    if (typeof event !== 'string') return;\n\t    this.trigger('tools:event', event, ...args);\n\t  },\n\t  getModelById: function (id) {\n\t    return this.model.getCell(id);\n\t  },\n\t  snapToGrid: function (x, y) {\n\t    // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n\t    // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n\t    return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n\t  },\n\t  localToPaperPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localPoint = new Point(x, y);\n\t    var paperPoint = V.transformPoint(localPoint, this.matrix());\n\t    return paperPoint;\n\t  },\n\t  localToPaperRect: function (x, y, width, height) {\n\t    // allow `x` to be a rectangle and rest arguments undefined\n\t    var localRect = new Rect(x, y, width, height);\n\t    var paperRect = V.transformRect(localRect, this.matrix());\n\t    return paperRect;\n\t  },\n\t  paperToLocalPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var paperPoint = new Point(x, y);\n\t    var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n\t    return localPoint;\n\t  },\n\t  paperToLocalRect: function (x, y, width, height) {\n\t    // allow `x` to be a rectangle and rest arguments undefined\n\t    var paperRect = new Rect(x, y, width, height);\n\t    var localRect = V.transformRect(paperRect, this.matrix().inverse());\n\t    return localRect;\n\t  },\n\t  localToClientPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localPoint = new Point(x, y);\n\t    var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n\t    return clientPoint;\n\t  },\n\t  localToClientRect: function (x, y, width, height) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var localRect = new Rect(x, y, width, height);\n\t    var clientRect = V.transformRect(localRect, this.clientMatrix());\n\t    return clientRect;\n\t  },\n\t  // Transform client coordinates to the paper local coordinates.\n\t  // Useful when you have a mouse event object and you'd like to get coordinates\n\t  // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n\t  // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n\t  clientToLocalPoint: function (x, y) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var clientPoint = new Point(x, y);\n\t    var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n\t    return localPoint;\n\t  },\n\t  clientToLocalRect: function (x, y, width, height) {\n\t    // allow `x` to be a point and `y` undefined\n\t    var clientRect = new Rect(x, y, width, height);\n\t    var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n\t    return localRect;\n\t  },\n\t  localToPagePoint: function (x, y) {\n\t    return this.localToPaperPoint(x, y).offset(this.pageOffset());\n\t  },\n\t  localToPageRect: function (x, y, width, height) {\n\t    return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n\t  },\n\t  pageToLocalPoint: function (x, y) {\n\t    var pagePoint = new Point(x, y);\n\t    var paperPoint = pagePoint.difference(this.pageOffset());\n\t    return this.paperToLocalPoint(paperPoint);\n\t  },\n\t  pageToLocalRect: function (x, y, width, height) {\n\t    var pageOffset = this.pageOffset();\n\t    var paperRect = new Rect(x, y, width, height);\n\t    paperRect.x -= pageOffset.x;\n\t    paperRect.y -= pageOffset.y;\n\t    return this.paperToLocalRect(paperRect);\n\t  },\n\t  clientOffset: function () {\n\t    var clientRect = this.svg.getBoundingClientRect();\n\t    return new Point(clientRect.left, clientRect.top);\n\t  },\n\t  pageOffset: function () {\n\t    return this.clientOffset().offset(window.scrollX, window.scrollY);\n\t  },\n\t  linkAllowed: function (linkView) {\n\t    if (!(linkView instanceof LinkView)) {\n\t      throw new Error('Must provide a linkView.');\n\t    }\n\t    var link = linkView.model;\n\t    var paperOptions = this.options;\n\t    var graph = this.model;\n\t    var ns = graph.constructor.validations;\n\t    if (!paperOptions.multiLinks) {\n\t      if (!ns.multiLinks.call(this, graph, link)) return false;\n\t    }\n\t    if (!paperOptions.linkPinning) {\n\t      // Link pinning is not allowed and the link is not connected to the target.\n\t      if (!ns.linkPinning.call(this, graph, link)) return false;\n\t    }\n\t    if (typeof paperOptions.allowLink === 'function') {\n\t      if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n\t    }\n\t    return true;\n\t  },\n\t  getDefaultLink: function (cellView, magnet) {\n\t    return isFunction(this.options.defaultLink)\n\t    // default link is a function producing link model\n\t    ? this.options.defaultLink.call(this, cellView, magnet)\n\t    // default link is the mvc model\n\t    : this.options.defaultLink.clone();\n\t  },\n\t  // Cell highlighting.\n\t  // ------------------\n\n\t  resolveHighlighter: function (opt = {}) {\n\t    let {\n\t      highlighter: highlighterDef,\n\t      type\n\t    } = opt;\n\t    const {\n\t      highlighting,\n\t      highlighterNamespace\n\t    } = this.options;\n\n\t    /*\n\t        Expecting opt.highlighter to have the following structure:\n\t        {\n\t            name: 'highlighter-name',\n\t            options: {\n\t                some: 'value'\n\t            }\n\t        }\n\t    */\n\t    if (highlighterDef === undefined) {\n\t      // Is highlighting disabled?\n\t      if (!highlighting) return false;\n\t      // check for built-in types\n\t      if (type) {\n\t        highlighterDef = highlighting[type];\n\t        // Is a specific type highlight disabled?\n\t        if (highlighterDef === false) return false;\n\t      }\n\t      if (!highlighterDef) {\n\t        // Type not defined use default highlight\n\t        highlighterDef = highlighting['default'];\n\t      }\n\t    }\n\n\t    // Do nothing if opt.highlighter is falsy.\n\t    // This allows the case to not highlight cell(s) in certain cases.\n\t    // For example, if you want to NOT highlight when embedding elements\n\t    // or use a custom highlighter.\n\t    if (!highlighterDef) return false;\n\n\t    // Allow specifying a highlighter by name.\n\t    if (isString(highlighterDef)) {\n\t      highlighterDef = {\n\t        name: highlighterDef\n\t      };\n\t    }\n\t    const name = highlighterDef.name;\n\t    const highlighter = highlighterNamespace[name];\n\n\t    // Highlighter validation\n\t    if (!highlighter) {\n\t      throw new Error('Unknown highlighter (\"' + name + '\")');\n\t    }\n\t    if (typeof highlighter.highlight !== 'function') {\n\t      throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n\t    }\n\t    if (typeof highlighter.unhighlight !== 'function') {\n\t      throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n\t    }\n\t    return {\n\t      highlighter,\n\t      options: highlighterDef.options || {},\n\t      name\n\t    };\n\t  },\n\t  onCellHighlight: function (cellView, magnetEl, opt) {\n\t    const highlighterDescriptor = this.resolveHighlighter(opt);\n\t    if (!highlighterDescriptor) return;\n\t    const {\n\t      highlighter,\n\t      options\n\t    } = highlighterDescriptor;\n\t    highlighter.highlight(cellView, magnetEl, options);\n\t  },\n\t  onCellUnhighlight: function (cellView, magnetEl, opt) {\n\t    const highlighterDescriptor = this.resolveHighlighter(opt);\n\t    if (!highlighterDescriptor) return;\n\t    const {\n\t      highlighter,\n\t      options\n\t    } = highlighterDescriptor;\n\t    highlighter.unhighlight(cellView, magnetEl, options);\n\t  },\n\t  // Interaction.\n\t  // ------------\n\n\t  pointerdblclick: function (evt) {\n\t    evt.preventDefault();\n\n\t    // magnetpointerdblclick can stop propagation\n\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    if (view) {\n\t      view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n\t    }\n\t  },\n\t  pointerclick: function (evt) {\n\t    // magnetpointerclick can stop propagation\n\n\t    var data = this.eventData(evt);\n\t    // Trigger event only if mouse has not moved.\n\t    if (data.mousemoved <= this.options.clickThreshold) {\n\t      evt = normalizeEvent(evt);\n\t      var view = this.findView(evt.target);\n\t      if (this.guard(evt, view)) return;\n\t      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t      if (view) {\n\t        view.pointerclick(evt, localPoint.x, localPoint.y);\n\t      } else {\n\t        this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  contextmenu: function (evt) {\n\t    if (this.options.preventContextMenu) evt.preventDefault();\n\t    if (this.contextMenuFired) {\n\t      this.contextMenuFired = false;\n\t      return;\n\t    }\n\t    evt = normalizeEvent(evt);\n\t    this.contextMenuTrigger(evt);\n\t  },\n\t  contextMenuTrigger: function (evt) {\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    if (view) {\n\t      view.contextmenu(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n\t    }\n\t  },\n\t  pointerdown: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      button\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    const isContextMenu = button === 2;\n\t    if (view) {\n\t      if (!isContextMenu && this.guard(evt, view)) return;\n\t      const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\t      if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n\t        // If the target is a form element, we do not want to prevent the default action.\n\t        // For example, we want to be able to select text in a text input or\n\t        // to be able to click on a checkbox.\n\t        evt.preventDefault();\n\t      }\n\t      if (isTargetFormNode) {\n\t        // If the target is a form element, we do not want to start dragging the element.\n\t        // For example, we want to be able to select text by dragging the mouse.\n\t        view.preventDefaultInteraction(evt);\n\t      }\n\n\t      // Custom event\n\t      const eventEvt = this.customEventTrigger(evt, view);\n\t      if (eventEvt) {\n\t        // `onevent` could have stopped propagation\n\t        if (eventEvt.isPropagationStopped()) return;\n\t        evt.data = eventEvt.data;\n\t      }\n\n\t      // Element magnet\n\t      const magnetNode = target.closest('[magnet]');\n\t      if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n\t        const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n\t          data: evt.data,\n\t          // Originally the event listener was attached to the magnet element.\n\t          currentTarget: magnetNode\n\t        }));\n\t        this.onmagnet(magnetEvt);\n\t        if (magnetEvt.isDefaultPrevented()) {\n\t          evt.preventDefault();\n\t        }\n\t        // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n\t        if (magnetEvt.isPropagationStopped()) {\n\t          // `magnet:pointermove` and `magnet:pointerup` events must be fired\n\t          if (isContextMenu) return;\n\t          this.delegateDragEvents(view, magnetEvt.data);\n\t          return;\n\t        }\n\t        evt.data = magnetEvt.data;\n\t      }\n\t    }\n\t    if (isContextMenu) {\n\t      this.contextMenuFired = true;\n\t      const contextmenuEvt = new $.Event(evt.originalEvent, {\n\t        type: 'contextmenu',\n\t        data: evt.data\n\t      });\n\t      this.contextMenuTrigger(contextmenuEvt);\n\t    } else {\n\t      const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t      if (view) {\n\t        view.pointerdown(evt, localPoint.x, localPoint.y);\n\t      } else {\n\t        if (this.options.preventDefaultBlankAction) {\n\t          evt.preventDefault();\n\t        }\n\t        this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n\t      }\n\t      this.delegateDragEvents(view, evt.data);\n\t    }\n\t  },\n\t  pointermove: function (evt) {\n\t    // mouse moved counter\n\t    var data = this.eventData(evt);\n\t    if (!data.mousemoved) {\n\t      data.mousemoved = 0;\n\t      // Make sure that events like `mouseenter` and `mouseleave` are\n\t      // not triggered while the user is dragging a cellView.\n\t      this.undelegateEvents();\n\t      // Note: the events are undelegated after the first `pointermove` event.\n\t      // Not on `pointerdown` to make sure that `dbltap` is recognized.\n\t    }\n\t    var mousemoved = ++data.mousemoved;\n\t    if (mousemoved <= this.options.moveThreshold) return;\n\t    evt = normalizeEvent(evt);\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    let view = data.sourceView;\n\t    if (view) {\n\t      // The view could have been disposed during dragging\n\t      // e.g. dragged outside of the viewport and hidden\n\t      view = this.findViewByModel(view.model);\n\t      view.pointermove(evt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n\t    }\n\t    this.eventData(evt, data);\n\t  },\n\t  pointerup: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    var normalizedEvt = normalizeEvent(evt);\n\t    var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t    let view = this.eventData(evt).sourceView;\n\t    if (view) {\n\t      // The view could have been disposed during dragging\n\t      // e.g. dragged outside of the viewport and hidden\n\t      view = this.findViewByModel(view.model);\n\t      view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n\t    } else {\n\t      this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n\t    }\n\t    if (!normalizedEvt.isPropagationStopped()) {\n\t      this.pointerclick(new $.Event(evt.originalEvent, {\n\t        type: 'click',\n\t        data: evt.data\n\t      }));\n\t    }\n\t    this.delegateEvents();\n\t  },\n\t  mouseover: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    if (view) {\n\t      view.mouseover(evt);\n\t    } else {\n\t      if (this.el === evt.target) return; // prevent border of paper from triggering this\n\t      this.trigger('blank:mouseover', evt);\n\t    }\n\t  },\n\t  mouseout: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    var view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    if (view) {\n\t      view.mouseout(evt);\n\t    } else {\n\t      if (this.el === evt.target) return; // prevent border of paper from triggering this\n\t      this.trigger('blank:mouseout', evt);\n\t    }\n\t  },\n\t  mouseenter: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      // The EventTarget the pointing device entered to\n\t      relatedTarget,\n\t      // The EventTarget the pointing device exited from\n\t      currentTarget // The EventTarget on which the event listener was registered\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    if (this.guard(evt, view)) return;\n\t    const relatedView = this.findView(relatedTarget);\n\t    if (view) {\n\t      if (relatedView === view) {\n\t        // Mouse left a cell tool\n\t        return;\n\t      }\n\t      view.mouseenter(evt);\n\t      if (this.el.contains(relatedTarget)) {\n\t        // The pointer remains inside the paper.\n\t        return;\n\t      }\n\t    }\n\t    if (relatedView) {\n\t      return;\n\t    }\n\t    // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n\t    // (mouseenter method would be fired twice)\n\t    if (currentTarget === this.el) {\n\t      // `paper` (more descriptive), not `blank`\n\t      this.trigger('paper:mouseenter', evt);\n\t    }\n\t  },\n\t  mouseleave: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const {\n\t      target,\n\t      // The EventTarget the pointing device exited from\n\t      relatedTarget,\n\t      // The EventTarget the pointing device entered to\n\t      currentTarget // The EventTarget on which the event listener was registered\n\t    } = evt;\n\t    const view = this.findView(target);\n\t    if (this.guard(evt, view)) return;\n\t    const relatedView = this.findView(relatedTarget);\n\t    if (view) {\n\t      if (relatedView === view) {\n\t        // Mouse entered a cell tool\n\t        return;\n\t      }\n\t      view.mouseleave(evt);\n\t      if (this.el.contains(relatedTarget)) {\n\t        // The pointer has exited a cellView. The pointer is still inside of the paper.\n\t        return;\n\t      }\n\t    }\n\t    if (relatedView) {\n\t      // The pointer has entered a new cellView\n\t      return;\n\t    }\n\t    // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n\t    // (mouseleave method would be fired twice)\n\t    if (currentTarget === this.el) {\n\t      // There is no cellView under the pointer, nor the blank area of the paper\n\t      this.trigger('paper:mouseleave', evt);\n\t    }\n\t  },\n\t  _processMouseWheelEvtBuf: debounce(function () {\n\t    const {\n\t      event,\n\t      deltas\n\t    } = this._mw_evt_buffer;\n\t    const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n\t    const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n\t    const {\n\t      x,\n\t      y\n\t    } = this.clientToLocalPoint(event.clientX, event.clientY);\n\t    this.trigger('paper:pinch', event, x, y, scale);\n\t    this._mw_evt_buffer = {\n\t      event: null,\n\t      deltas: []\n\t    };\n\t  }, WHEEL_WAIT_MS, {\n\t    maxWait: WHEEL_WAIT_MS\n\t  }),\n\t  mousewheel: function (evt) {\n\t    evt = normalizeEvent(evt);\n\t    const view = this.findView(evt.target);\n\t    if (this.guard(evt, view)) return;\n\t    const originalEvent = evt.originalEvent;\n\t    const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n\t    const {\n\t      deltaX,\n\t      deltaY\n\t    } = normalizeWheel(originalEvent);\n\t    const pinchHandlers = this._events['paper:pinch'];\n\n\t    // Touchpad devices will send a fake CTRL press when a pinch is performed\n\t    //\n\t    // We also check if there are any subscribers to paper:pinch event. If there are none,\n\t    // just skip the entire block of code (we don't want to blindly call\n\t    // .preventDefault() if we really don't have to).\n\t    if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n\t      // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n\t      originalEvent.preventDefault();\n\t      this._mw_evt_buffer.event = evt;\n\t      this._mw_evt_buffer.deltas.push(deltaY);\n\t      this._processMouseWheelEvtBuf();\n\t    } else {\n\t      const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n\t      if (view) {\n\t        view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\t      } else {\n\t        this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n\t      }\n\t      this.trigger('paper:pan', evt, deltaX, deltaY);\n\t    }\n\t  },\n\t  onevent: function (evt) {\n\t    var eventNode = evt.currentTarget;\n\t    var eventName = eventNode.getAttribute('event');\n\t    if (eventName) {\n\t      var view = this.findView(eventNode);\n\t      if (view) {\n\t        evt = normalizeEvent(evt);\n\t        if (this.guard(evt, view)) return;\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t        view.onevent(evt, eventName, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  magnetEvent: function (evt, handler) {\n\t    var magnetNode = evt.currentTarget;\n\t    var magnetValue = magnetNode.getAttribute('magnet');\n\t    if (magnetValue) {\n\t      var view = this.findView(magnetNode);\n\t      if (view) {\n\t        evt = normalizeEvent(evt);\n\t        if (this.guard(evt, view)) return;\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t        handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n\t      }\n\t    }\n\t  },\n\t  onmagnet: function (evt) {\n\t    if (evt.button === 2) {\n\t      this.contextMenuFired = true;\n\t      this.magnetContextMenuFired = true;\n\t      const contextmenuEvt = new $.Event(evt.originalEvent, {\n\t        type: 'contextmenu',\n\t        data: evt.data,\n\t        currentTarget: evt.currentTarget\n\t      });\n\t      this.magnetContextMenuTrigger(contextmenuEvt);\n\t      if (contextmenuEvt.isPropagationStopped()) {\n\t        evt.stopPropagation();\n\t      }\n\t    } else {\n\t      this.magnetEvent(evt, function (view, evt, _, x, y) {\n\t        view.onmagnet(evt, x, y);\n\t      });\n\t    }\n\t  },\n\t  magnetpointerdblclick: function (evt) {\n\t    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n\t      view.magnetpointerdblclick(evt, magnet, x, y);\n\t    });\n\t  },\n\t  magnetcontextmenu: function (evt) {\n\t    if (this.options.preventContextMenu) evt.preventDefault();\n\t    if (this.magnetContextMenuFired) {\n\t      this.magnetContextMenuFired = false;\n\t      return;\n\t    }\n\t    this.magnetContextMenuTrigger(evt);\n\t  },\n\t  magnetContextMenuTrigger: function (evt) {\n\t    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n\t      view.magnetcontextmenu(evt, magnet, x, y);\n\t    });\n\t  },\n\t  onlabel: function (evt) {\n\t    var labelNode = evt.currentTarget;\n\t    var view = this.findView(labelNode);\n\t    if (!view) return;\n\t    evt = normalizeEvent(evt);\n\t    if (this.guard(evt, view)) return;\n\n\t    // Custom event\n\t    const eventEvt = this.customEventTrigger(evt, view, labelNode);\n\t    if (eventEvt) {\n\t      // `onevent` could have stopped propagation\n\t      if (eventEvt.isPropagationStopped()) return;\n\t      evt.data = eventEvt.data;\n\t    }\n\t    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t    view.onlabel(evt, localPoint.x, localPoint.y);\n\t  },\n\t  getPointerArgs(evt) {\n\t    const normalizedEvt = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t    return [normalizedEvt, x, y];\n\t  },\n\t  delegateDragEvents: function (view, data) {\n\t    data || (data = {});\n\t    this.eventData({\n\t      data: data\n\t    }, {\n\t      sourceView: view || null,\n\t      mousemoved: 0\n\t    });\n\t    this.delegateDocumentEvents(null, data);\n\t  },\n\t  // Guard the specified event. If the event should be ignored, guard returns `true`.\n\t  // Otherwise, it returns `false`.\n\t  guard: function (evt, view) {\n\t    if (evt.type === 'mousedown' && evt.button === 2) {\n\t      // handled as `contextmenu` type\n\t      return true;\n\t    }\n\t    if (this.options.guard && this.options.guard(evt, view)) {\n\t      return true;\n\t    }\n\t    if (evt.data && evt.data.guarded !== undefined) {\n\t      return evt.data.guarded;\n\t    }\n\t    const {\n\t      target\n\t    } = evt;\n\t    if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n\t      return true;\n\t    }\n\t    if (view && view.model && view.model[CELL_MARKER]) {\n\t      return false;\n\t    }\n\t    if (this.el === target || this.svg.contains(target)) {\n\t      return false;\n\t    }\n\t    return true; // Event guarded. Paper should not react on it in any way.\n\t  },\n\t  setGridSize: function (gridSize) {\n\t    const {\n\t      options\n\t    } = this;\n\t    options.gridSize = gridSize;\n\t    if (options.drawGrid && !options.drawGridSize) {\n\t      // Do not redraw the grid if the `drawGridSize` is set.\n\t      this.getLayerView(paperLayers.GRID).renderGrid();\n\t    }\n\t    return this;\n\t  },\n\t  setGrid: function (drawGrid) {\n\t    this.getLayerView(paperLayers.GRID).setGrid(drawGrid);\n\t    return this;\n\t  },\n\t  updateBackgroundImage: function (opt) {\n\t    opt = opt || {};\n\t    var backgroundPosition = opt.position || 'center';\n\t    var backgroundSize = opt.size || 'auto auto';\n\t    var currentScale = this.scale();\n\t    var currentTranslate = this.translate();\n\n\t    // backgroundPosition\n\t    if (isObject(backgroundPosition)) {\n\t      var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n\t      var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n\t      backgroundPosition = x + 'px ' + y + 'px';\n\t    }\n\n\t    // backgroundSize\n\t    if (isObject(backgroundSize)) {\n\t      backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n\t      backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n\t    }\n\t    const {\n\t      background\n\t    } = this.childNodes;\n\t    background.style.backgroundSize = backgroundSize;\n\t    background.style.backgroundPosition = backgroundPosition;\n\t  },\n\t  drawBackgroundImage: function (img, opt) {\n\t    // Clear the background image if no image provided\n\t    if (!(img instanceof HTMLImageElement)) {\n\t      this.childNodes.background.style.backgroundImage = '';\n\t      return;\n\t    }\n\t    if (!this._background || this._background.id !== opt.id) {\n\t      // Draw only the last image requested (see drawBackground())\n\t      return;\n\t    }\n\t    opt = opt || {};\n\t    var backgroundImage;\n\t    var backgroundSize = opt.size;\n\t    var backgroundRepeat = opt.repeat || 'no-repeat';\n\t    var backgroundOpacity = opt.opacity || 1;\n\t    var backgroundQuality = Math.abs(opt.quality) || 1;\n\t    var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\t    if (isFunction(backgroundPattern)) {\n\t      // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n\t      img.width *= backgroundQuality;\n\t      img.height *= backgroundQuality;\n\t      var canvas = backgroundPattern(img, opt);\n\t      if (!(canvas instanceof HTMLCanvasElement)) {\n\t        throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n\t      }\n\t      backgroundImage = canvas.toDataURL('image/png');\n\t      backgroundRepeat = 'repeat';\n\t      if (isObject(backgroundSize)) {\n\t        // recalculate the tile size if an object passed in\n\t        backgroundSize.width *= canvas.width / img.width;\n\t        backgroundSize.height *= canvas.height / img.height;\n\t      } else if (backgroundSize === undefined) {\n\t        // calculate the tile size if no provided\n\t        opt.size = {\n\t          width: canvas.width / backgroundQuality,\n\t          height: canvas.height / backgroundQuality\n\t        };\n\t      }\n\t    } else {\n\t      // backgroundRepeat:\n\t      // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n\t      backgroundImage = img.src;\n\t      if (backgroundSize === undefined) {\n\t        // pass the image size for  the backgroundSize if no size provided\n\t        opt.size = {\n\t          width: img.width,\n\t          height: img.height\n\t        };\n\t      }\n\t    }\n\t    this.childNodes.background.style.opacity = backgroundOpacity;\n\t    this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n\t    this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\t    this.updateBackgroundImage(opt);\n\t  },\n\t  updateBackgroundColor: function (color) {\n\t    this.$el.css('backgroundColor', color || '');\n\t  },\n\t  drawBackground: function (opt) {\n\t    opt = opt || {};\n\t    this.updateBackgroundColor(opt.color);\n\t    if (opt.image) {\n\t      opt = this._background = cloneDeep(opt);\n\t      guid(opt);\n\t      var img = document.createElement('img');\n\t      img.onload = this.drawBackgroundImage.bind(this, img, opt);\n\t      img.src = opt.image;\n\t    } else {\n\t      this.drawBackgroundImage(null);\n\t      this._background = null;\n\t    }\n\t    return this;\n\t  },\n\t  setInteractivity: function (value) {\n\t    this.options.interactive = value;\n\t    invoke(this._views, 'setInteractivity', value);\n\t  },\n\t  // Paper definitions.\n\t  // ------------------\n\n\t  isDefined: function (defId) {\n\t    return !!this.svg.getElementById(defId);\n\t  },\n\t  defineFilter: function (filter$1) {\n\t    if (!isObject(filter$1)) {\n\t      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n\t    }\n\t    var filterId = filter$1.id;\n\t    var name = filter$1.name;\n\t    // Generate a hash code from the stringified filter definition. This gives us\n\t    // a unique filter ID for different definitions.\n\t    if (!filterId) {\n\t      filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));\n\t    }\n\t    // If the filter already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    // If not, create one.\n\t    if (!this.isDefined(filterId)) {\n\t      var namespace = filter;\n\t      var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});\n\t      if (!filterSVGString) {\n\t        throw new Error('Non-existing filter ' + name);\n\t      }\n\n\t      // SVG <filter/> attributes\n\t      var filterAttrs = assign({\n\t        filterUnits: 'userSpaceOnUse'\n\t      }, filter$1.attrs, {\n\t        id: filterId\n\t      });\n\t      V(filterSVGString, filterAttrs).appendTo(this.defs);\n\t    }\n\t    return filterId;\n\t  },\n\t  defineGradient: function (gradient) {\n\t    if (!isObject(gradient)) {\n\t      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      type,\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = type + svg.id + hashCode(JSON.stringify(gradient)),\n\t      stops,\n\t      attrs = {}\n\t    } = gradient;\n\t    // If the gradient already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const stopVEls = toArray$1(stops).map(({\n\t      offset,\n\t      color,\n\t      opacity\n\t    }) => {\n\t      return V('stop').attr({\n\t        'offset': offset,\n\t        'stop-color': color,\n\t        'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n\t      });\n\t    });\n\t    const gradientVEl = V(type, attrs, stopVEls);\n\t    gradientVEl.id = id;\n\t    gradientVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  definePattern: function (pattern) {\n\t    if (!isObject(pattern)) {\n\t      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = svg.id + hashCode(JSON.stringify(pattern)),\n\t      markup,\n\t      attrs = {}\n\t    } = pattern;\n\t    if (!markup) {\n\t      throw new TypeError('dia.Paper: definePattern() requires markup.');\n\t    }\n\t    // If the gradient already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const patternVEl = V('pattern', {\n\t      patternUnits: 'userSpaceOnUse'\n\t    });\n\t    patternVEl.id = id;\n\t    patternVEl.attr(attrs);\n\t    if (typeof markup === 'string') {\n\t      patternVEl.append(V(markup));\n\t    } else {\n\t      const {\n\t        fragment\n\t      } = parseDOMJSON(markup);\n\t      patternVEl.append(fragment);\n\t    }\n\t    patternVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  defineMarker: function (marker) {\n\t    if (!isObject(marker)) {\n\t      throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n\t    }\n\t    const {\n\t      svg,\n\t      defs\n\t    } = this;\n\t    const {\n\t      // Generate a hash code from the stringified filter definition. This gives us\n\t      // a unique filter ID for different definitions.\n\t      id = svg.id + hashCode(JSON.stringify(marker)),\n\t      // user-provided markup\n\t      // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n\t      markup,\n\t      // user-provided attributes\n\t      // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n\t      // note: `transform` attrs are ignored by browsers\n\t      attrs = {},\n\t      // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n\t      markerUnits = 'userSpaceOnUse'\n\t    } = marker;\n\t    // If the marker already exists in the document,\n\t    // we're done and we can just use it (reference it using `url()`).\n\t    if (this.isDefined(id)) return id;\n\t    // If not, create one.\n\t    const markerVEl = V('marker', {\n\t      orient: 'auto',\n\t      overflow: 'visible',\n\t      markerUnits: markerUnits\n\t    });\n\t    markerVEl.id = id;\n\t    markerVEl.attr(attrs);\n\t    let markerContentVEl;\n\t    if (markup) {\n\t      let markupVEl;\n\t      if (typeof markup === 'string') {\n\t        // Marker object has a `markup` property of type string.\n\t        // - Construct V from the provided string.\n\t        markupVEl = V(markup);\n\t        // `markupVEl` is now either a single VEl, or an array of VEls.\n\t        // - Coerce it to an array.\n\t        markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];\n\t      } else {\n\t        // Marker object has a `markup` property of type object.\n\t        // - Construct V from the object by parsing it as DOM JSON.\n\t        const {\n\t          fragment\n\t        } = parseDOMJSON(markup);\n\t        markupVEl = V(fragment).children();\n\t      }\n\t      // `markupVEl` is an array with one or more VEls inside.\n\t      // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n\t      if (markupVEl.length > 1) {\n\t        markerContentVEl = V('g').append(markupVEl);\n\t      } else {\n\t        markerContentVEl = markupVEl[0];\n\t      }\n\t    } else {\n\t      // Marker object is a flat structure.\n\t      // - Construct a new V of type `marker.type`.\n\t      const {\n\t        type = 'path'\n\t      } = marker;\n\t      markerContentVEl = V(type);\n\t    }\n\t    // `markerContentVEl` is a single VEl.\n\t    // Assign additional attributes to it (= context attributes + marker attributes):\n\t    // - Attribute values are taken from non-special properties of `marker`.\n\t    const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n\t    const markerAttrsKeys = Object.keys(markerAttrs);\n\t    markerAttrsKeys.forEach(key => {\n\t      const value = markerAttrs[key];\n\t      const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n\t      if (markupValue == null) {\n\t        // Default logic:\n\t        markerContentVEl.attr(key, value);\n\t      } else {\n\t        // Properties with special logic should be added as cases to this switch block:\n\t        switch (key) {\n\t          case 'transform':\n\t            // - Prepend `transform` to existing value.\n\t            markerContentVEl.attr(key, value + ' ' + markupValue);\n\t            break;\n\t        }\n\t      }\n\t    });\n\t    markerContentVEl.appendTo(markerVEl);\n\t    markerVEl.appendTo(defs);\n\t    return id;\n\t  },\n\t  customEventTrigger: function (evt, view, rootNode = view.el) {\n\t    const eventNode = evt.target.closest('[event]');\n\t    if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n\t      const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n\t        data: evt.data,\n\t        // Originally the event listener was attached to the event element.\n\t        currentTarget: eventNode\n\t      }));\n\t      this.onevent(eventEvt);\n\t      if (eventEvt.isDefaultPrevented()) {\n\t        evt.preventDefault();\n\t      }\n\t      return eventEvt;\n\t    }\n\t    return null;\n\t  }\n\t}, {\n\t  sorting: sortingTypes,\n\t  Layers: paperLayers,\n\t  backgroundPatterns,\n\t  gridPatterns\n\t});\n\n\tconst ToolView = View.extend({\n\t  name: null,\n\t  tagName: 'g',\n\t  className: 'tool',\n\t  svgElement: true,\n\t  _visible: true,\n\t  _visibleExplicit: true,\n\t  init: function () {\n\t    var name = this.name;\n\t    if (name) this.vel.attr('data-tool-name', name);\n\t  },\n\t  configure: function (view, toolsView) {\n\t    this.relatedView = view;\n\t    this.paper = view.paper;\n\t    this.parentView = toolsView;\n\t    this.simulateRelatedView(this.el);\n\t    // Delegate events in case the ToolView was removed from the DOM and reused.\n\t    this.delegateEvents();\n\t    return this;\n\t  },\n\t  simulateRelatedView: function (el) {\n\t    if (el) el.setAttribute('model-id', this.relatedView.model.id);\n\t  },\n\t  getName: function () {\n\t    return this.name;\n\t  },\n\t  // Evaluate the visibility of the tool and update the `display` CSS property\n\t  updateVisibility: function () {\n\t    const isVisible = this.computeVisibility();\n\t    this.el.style.display = isVisible ? '' : 'none';\n\t    this._visible = isVisible;\n\t  },\n\t  // Evaluate the visibility of the tool. The method returns `true` if the tool\n\t  // should be visible in the DOM.\n\t  computeVisibility() {\n\t    if (!this.isExplicitlyVisible()) return false;\n\t    const {\n\t      visibility\n\t    } = this.options;\n\t    if (typeof visibility !== 'function') return true;\n\t    return !!visibility.call(this, this.relatedView, this);\n\t  },\n\t  show: function () {\n\t    this._visibleExplicit = true;\n\t    this.updateVisibility();\n\t  },\n\t  hide: function () {\n\t    this._visibleExplicit = false;\n\t    this.updateVisibility();\n\t  },\n\t  // The method returns `false` if the `hide()` method was called on the tool.\n\t  isExplicitlyVisible: function () {\n\t    return !!this._visibleExplicit;\n\t  },\n\t  // The method returns `false` if the tool is not visible (it has `display: none`).\n\t  // This can happen if the `hide()` method was called or the tool is not visible\n\t  // because of the `visibility` option was evaluated to `false`.\n\t  isVisible: function () {\n\t    return !!this._visible;\n\t  },\n\t  isOverlay: function () {\n\t    return !!this.parentView && this.parentView.hasLayer();\n\t  },\n\t  focus: function () {\n\t    var opacity = this.options.focusOpacity;\n\t    if (isFinite(opacity)) this.el.style.opacity = opacity;\n\t    this.parentView.focusTool(this);\n\t  },\n\t  blur: function () {\n\t    this.el.style.opacity = '';\n\t    this.parentView.blurTool(this);\n\t  },\n\t  update: function () {\n\t    // to be overridden\n\t  },\n\t  guard: function (evt) {\n\t    // Let the context-menu event bubble up to the relatedView\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    if (!paper || !relatedView) return true;\n\t    return paper.guard(evt, relatedView);\n\t  }\n\t});\n\n\tconst ToolsView = View.extend({\n\t  tagName: 'g',\n\t  className: 'tools',\n\t  svgElement: true,\n\t  tools: null,\n\t  isRendered: false,\n\t  options: {\n\t    tools: null,\n\t    relatedView: null,\n\t    name: null\n\t    // layer?: Paper.Layers.TOOLS\n\t    // z?: number\n\t  },\n\t  configure: function (options) {\n\t    options = assign(this.options, options);\n\t    var tools = options.tools;\n\t    if (!Array.isArray(tools)) return this;\n\t    var relatedView = options.relatedView;\n\t    if (!(relatedView instanceof CellView)) return this;\n\t    var views = this.tools = [];\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (!(tool instanceof ToolView)) continue;\n\t      tool.configure(relatedView, this);\n\t      this.vel.append(tool.el);\n\t      views.push(tool);\n\t    }\n\t    this.isRendered = false;\n\t    relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n\t    return this;\n\t  },\n\t  getName: function () {\n\t    return this.options.name;\n\t  },\n\t  update: function (opt) {\n\t    opt || (opt = {});\n\t    const tools = this.tools;\n\t    if (!tools) return this;\n\t    const n = tools.length;\n\t    const wasRendered = this.isRendered;\n\t    for (let i = 0; i < n; i++) {\n\t      const tool = tools[i];\n\t      tool.updateVisibility();\n\t      if (!tool.isVisible()) continue;\n\t      if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {\n\t        tool.update();\n\t      }\n\t    }\n\t    if (!this.isRendered && n > 0) {\n\t      // None of the tools is visible\n\t      // Note: ToolsView with no tools are always mounted\n\t      return this;\n\t    }\n\t    if (!this.isMounted()) {\n\t      this.mount();\n\t    }\n\t    if (!wasRendered) {\n\t      // Make sure tools are visible (if they were hidden and the tool removed)\n\t      this.blurTool();\n\t    }\n\t    return this;\n\t  },\n\t  ensureToolRendered(tools, i) {\n\t    if (!this.isRendered) {\n\t      // There is at least one visible tool\n\t      this.isRendered = Array(tools.length).fill(false);\n\t    }\n\t    if (!this.isRendered[i]) {\n\t      // First update executes render()\n\t      tools[i].render();\n\t      this.isRendered[i] = true;\n\t      return false;\n\t    }\n\t    return true;\n\t  },\n\t  focusTool: function (focusedTool) {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (focusedTool === tool) {\n\t        tool.show();\n\t      } else {\n\t        tool.hide();\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  blurTool: function (blurredTool) {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      var tool = tools[i];\n\t      if (tool !== blurredTool && !tool.isExplicitlyVisible()) {\n\t        tool.show();\n\t        // Check if the tool is conditionally visible too\n\t        if (tool.isVisible()) {\n\t          this.ensureToolRendered(tools, i) && tool.update();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  hide: function () {\n\t    return this.focusTool(null);\n\t  },\n\t  show: function () {\n\t    this.blurTool(null);\n\t    // If this the first time the tools are shown, make sure they are mounted\n\t    if (!this.isMounted()) {\n\t      this.mount();\n\t    }\n\t    return this;\n\t  },\n\t  onRemove: function () {\n\t    var tools = this.tools;\n\t    if (!tools) return this;\n\t    for (var i = 0, n = tools.length; i < n; i++) {\n\t      tools[i].remove();\n\t    }\n\t    this.tools = null;\n\t  },\n\t  getLayer() {\n\t    const {\n\t      layer = Paper.Layers.TOOLS\n\t    } = this.options;\n\t    return layer;\n\t  },\n\t  hasLayer() {\n\t    return !!this.getLayer();\n\t  },\n\t  mount: function () {\n\t    const {\n\t      options,\n\t      el\n\t    } = this;\n\t    const {\n\t      relatedView,\n\t      z\n\t    } = options;\n\t    if (relatedView) {\n\t      if (this.hasLayer()) {\n\t        relatedView.paper.getLayerView(this.getLayer()).insertSortedNode(el, z);\n\t      } else {\n\t        relatedView.el.appendChild(el);\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t});\n\n\tvar index$2 = {\n\t\t__proto__: null,\n\t\tCell: Cell,\n\t\tCellCollection: CellCollection,\n\t\tCellView: CellView,\n\t\tDEFAULT_GRAPH_LAYER_TYPE: DEFAULT_GRAPH_LAYER_TYPE,\n\t\tElement: Element$1,\n\t\tElementView: ElementView,\n\t\tGraph: Graph,\n\t\tGraphLayer: GraphLayer,\n\t\tGraphLayerCollection: GraphLayerCollection,\n\t\tGraphLayerView: GraphLayerView,\n\t\tGridLayerView: GridLayerView,\n\t\tHighlighterView: HighlighterView,\n\t\tLayerView: LayerView,\n\t\tLink: Link$1,\n\t\tLinkView: LinkView,\n\t\tPaper: Paper,\n\t\tToolView: ToolView,\n\t\tToolsView: ToolsView,\n\t\tattributes: attributes,\n\t\tsortingTypes: sortingTypes\n\t};\n\n\t// Vertex Handles\n\tvar VertexHandle = View.extend({\n\t  tagName: 'circle',\n\t  svgElement: true,\n\t  className: 'marker-vertex',\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onDoubleClick',\n\t    dbltap: 'onDoubleClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  attributes: {\n\t    'r': 6,\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move'\n\t  },\n\t  position: function (x, y) {\n\t    const {\n\t      vel,\n\t      options\n\t    } = this;\n\t    const {\n\t      scale\n\t    } = options;\n\t    let matrix = V.createSVGMatrix().translate(x, y);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    vel.transform(matrix, {\n\t      absolute: true\n\t    });\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.options.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.options.paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, evt.data);\n\t    this.trigger('will-change', this, evt);\n\t  },\n\t  onPointerMove: function (evt) {\n\t    this.trigger('changing', this, evt);\n\t  },\n\t  onDoubleClick: function (evt) {\n\t    this.trigger('remove', this, evt);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.trigger('changed', this, evt);\n\t    this.undelegateDocumentEvents();\n\t    this.options.paper.delegateEvents();\n\t  }\n\t});\n\tconst Vertices = ToolView.extend({\n\t  name: 'vertices',\n\t  options: {\n\t    handleClass: VertexHandle,\n\t    snapRadius: 20,\n\t    redundancyRemoval: true,\n\t    vertexAdding: true,\n\t    // vertexRemoving: true,\n\t    // vertexMoving: true,\n\t    stopPropagation: true,\n\t    scale: null\n\t  },\n\t  children: [{\n\t    tagName: 'path',\n\t    selector: 'connection',\n\t    className: 'joint-vertices-path',\n\t    attributes: {\n\t      'fill': 'none',\n\t      'stroke': 'transparent',\n\t      'stroke-width': 10,\n\t      'cursor': 'cell'\n\t    }\n\t  }],\n\t  handles: null,\n\t  interactiveLinkNode: null,\n\t  events: {\n\t    'mousedown .joint-vertices-path': 'onPathPointerDown',\n\t    'touchstart .joint-vertices-path': 'onPathPointerDown'\n\t  },\n\t  linkEvents: {\n\t    mousedown: 'onLinkPointerDown',\n\t    touchstart: 'onLinkPointerDown'\n\t  },\n\t  onRender: function () {\n\t    const {\n\t      vertexAdding\n\t    } = this.options;\n\t    if (vertexAdding) {\n\t      const {\n\t        interactiveLinkNode = null\n\t      } = vertexAdding;\n\t      if (interactiveLinkNode) {\n\t        this.delegateLinkEvents(interactiveLinkNode);\n\t      } else {\n\t        this.renderChildren();\n\t        this.updatePath();\n\t      }\n\t    }\n\t    this.resetHandles();\n\t    this.renderHandles();\n\t    return this;\n\t  },\n\t  delegateLinkEvents: function (selector) {\n\t    this.undelegateLinkEvents();\n\t    const el = this.relatedView.findNode(selector);\n\t    if (!el) {\n\t      console.warn(`Interactive link node \"${selector}\" not found.`);\n\t      return;\n\t    }\n\t    el.classList.add('joint-vertices-path');\n\t    this.interactiveLinkNode = el;\n\t    this.delegateElementEvents(el, this.linkEvents);\n\t  },\n\t  undelegateLinkEvents: function () {\n\t    const el = this.interactiveLinkNode;\n\t    if (!el) return;\n\t    this.undelegateElementEvents(el);\n\t    el.classList.remove('joint-vertices-path');\n\t    this.interactiveLinkNode = null;\n\t  },\n\t  update: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    if (vertices.length === this.handles.length) {\n\t      this.updateHandles();\n\t    } else {\n\t      this.resetHandles();\n\t      this.renderHandles();\n\t    }\n\t    if (this.options.vertexAdding) {\n\t      this.updatePath();\n\t    }\n\t    return this;\n\t  },\n\t  resetHandles: function () {\n\t    var handles = this.handles;\n\t    this.handles = [];\n\t    this.stopListening();\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      handles[i].remove();\n\t    }\n\t  },\n\t  renderHandles: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    for (var i = 0, n = vertices.length; i < n; i++) {\n\t      var vertex = vertices[i];\n\t      var handle = new this.options.handleClass({\n\t        index: i,\n\t        paper: this.paper,\n\t        scale: this.options.scale,\n\t        guard: evt => this.guard(evt)\n\t      });\n\t      handle.render();\n\t      handle.position(vertex.x, vertex.y);\n\t      this.simulateRelatedView(handle.el);\n\t      handle.vel.appendTo(this.el);\n\t      this.handles.push(handle);\n\t      this.startHandleListening(handle);\n\t    }\n\t  },\n\t  updateHandles: function () {\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    for (var i = 0, n = vertices.length; i < n; i++) {\n\t      var vertex = vertices[i];\n\t      var handle = this.handles[i];\n\t      if (!handle) return;\n\t      handle.position(vertex.x, vertex.y);\n\t    }\n\t  },\n\t  updatePath: function () {\n\t    if (this.interactiveLinkNode) return;\n\t    const connection = this.childNodes.connection;\n\t    if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());\n\t  },\n\t  startHandleListening: function (handle) {\n\t    const {\n\t      vertexRemoving = true,\n\t      vertexMoving = true\n\t    } = this.options;\n\t    if (vertexMoving) {\n\t      this.listenTo(handle, 'will-change', this.onHandleWillChange);\n\t      this.listenTo(handle, 'changing', this.onHandleChanging);\n\t      this.listenTo(handle, 'changed', this.onHandleChanged);\n\t    }\n\t    if (vertexRemoving) {\n\t      this.listenTo(handle, 'remove', this.onHandleRemove);\n\t    }\n\t  },\n\t  getNeighborPoints: function (index) {\n\t    var linkView = this.relatedView;\n\t    var vertices = linkView.model.vertices();\n\t    var prev = index > 0 ? vertices[index - 1] : linkView.sourceAnchor;\n\t    var next = index < vertices.length - 1 ? vertices[index + 1] : linkView.targetAnchor;\n\t    return {\n\t      prev: new Point(prev),\n\t      next: new Point(next)\n\t    };\n\t  },\n\t  onHandleWillChange: function (_handle, evt) {\n\t    this.focus();\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    relatedView.model.startBatch('vertex-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));\n\t  },\n\t  onHandleChanging: function (handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    var index = handle.options.index;\n\t    var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);\n\t    var vertex = {\n\t      x,\n\t      y\n\t    };\n\t    this.snapVertex(vertex, index);\n\t    linkView.model.vertex(index, vertex, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    handle.position(vertex.x, vertex.y);\n\t    if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n\t  },\n\t  onHandleChanged: function (_handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    if (options.vertexAdding) this.updatePath();\n\t    if (options.redundancyRemoval) {\n\t      const verticesRemoved = linkView.removeRedundantLinearVertices({\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t      if (verticesRemoved) this.render();\n\t    }\n\t    this.blur();\n\t    linkView.model.stopBatch('vertex-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (this.eventData(evt).vertexAdded) {\n\t      linkView.model.stopBatch('vertex-add', {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t    const [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);\n\t    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n\t    linkView.checkMouseleave(normalizedEvt);\n\t  },\n\t  snapVertex: function (vertex, index) {\n\t    var snapRadius = this.options.snapRadius;\n\t    if (snapRadius > 0) {\n\t      var neighbors = this.getNeighborPoints(index);\n\t      var prev = neighbors.prev;\n\t      var next = neighbors.next;\n\t      if (Math.abs(vertex.x - prev.x) < snapRadius) {\n\t        vertex.x = prev.x;\n\t      } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n\t        vertex.x = next.x;\n\t      }\n\t      if (Math.abs(vertex.y - prev.y) < snapRadius) {\n\t        vertex.y = neighbors.prev.y;\n\t      } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n\t        vertex.y = next.y;\n\t      }\n\t    }\n\t  },\n\t  onHandleRemove: function (handle, evt) {\n\t    var index = handle.options.index;\n\t    var linkView = this.relatedView;\n\t    linkView.model.removeVertex(index, {\n\t      ui: true\n\t    });\n\t    if (this.options.vertexAdding) this.updatePath();\n\t    linkView.checkMouseleave(normalizeEvent(evt));\n\t  },\n\t  onPathPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n\t    var relatedView = this.relatedView;\n\t    relatedView.model.startBatch('vertex-add', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    var index = relatedView.getVertexIndex(vertex.x, vertex.y);\n\t    this.snapVertex(vertex, index);\n\t    relatedView.model.insertVertex(index, vertex, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    this.update();\n\t    var handle = this.handles[index];\n\t    this.eventData(normalizedEvent, {\n\t      vertexAdded: true\n\t    });\n\t    handle.onPointerDown(normalizedEvent);\n\t  },\n\t  onLinkPointerDown: function (evt) {\n\t    this.relatedView.preventDefaultInteraction(evt);\n\t    this.onPathPointerDown(evt);\n\t  },\n\t  onRemove: function () {\n\t    this.resetHandles();\n\t    this.undelegateLinkEvents();\n\t  }\n\t}, {\n\t  VertexHandle: VertexHandle // keep as class property\n\t});\n\n\t/**\n\t * Common helper for getting a cell views bounding box,\n\t * configurable with `useModelGeometry`, `relative`, and `el`.\n\t */\n\tfunction getViewBBox(view, {\n\t  useModelGeometry = false,\n\t  relative = false,\n\t  el = view.el\n\t} = {}) {\n\t  const {\n\t    model\n\t  } = view;\n\t  let bbox;\n\t  if (useModelGeometry) {\n\t    // cell model bbox\n\t    bbox = model.getBBox();\n\t  } else if (model.isLink()) {\n\t    // link view bbox\n\t    bbox = view.getConnection().bbox();\n\t  } else {\n\t    // element view bbox\n\t    bbox = view.getNodeUnrotatedBBox(el);\n\t  }\n\t  if (relative) {\n\t    // Relative to the element position.\n\t    const position = model.position();\n\t    bbox.x -= position.x;\n\t    bbox.y -= position.y;\n\t  }\n\t  return bbox;\n\t}\n\n\t/**\n\t * Retrieves the tool options.\n\t * Automatically overrides `useModelGeometry` and `rotate`\n\t * if the tool is positioned relative to the element.\n\t */\n\tfunction getToolOptions(toolView) {\n\t  // Positioning is relative if the tool is drawn within the element view.\n\t  const relative = !toolView.isOverlay();\n\t  const {\n\t    useModelGeometry,\n\t    rotate,\n\t    ...otherOptions\n\t  } = toolView.options;\n\t  return {\n\t    ...otherOptions,\n\t    useModelGeometry: useModelGeometry || relative,\n\t    rotate: rotate || relative,\n\t    relative\n\t  };\n\t}\n\tfunction getAnchor(coords, view, magnet) {\n\t  // take advantage of an existing logic inside of the\n\t  // pin relative connection strategy\n\t  var end = pinRelative.call(this.paper, {}, view, magnet, coords, this.model);\n\t  return end.anchor;\n\t}\n\tfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n\t  var snapRadius = toolView.options.snapRadius;\n\t  var isSource = type === 'source';\n\t  var refIndex = isSource ? 0 : -1;\n\t  var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n\t  if (ref) {\n\t    if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n\t    if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n\t  }\n\t  return coords;\n\t}\n\n\tvar SegmentHandle = View.extend({\n\t  tagName: 'g',\n\t  svgElement: true,\n\t  className: 'marker-segment',\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  children: [{\n\t    tagName: 'line',\n\t    selector: 'line',\n\t    attributes: {\n\t      'stroke': '#33334F',\n\t      'stroke-width': 2,\n\t      'fill': 'none',\n\t      'pointer-events': 'none'\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'handle',\n\t    attributes: {\n\t      'width': 20,\n\t      'height': 8,\n\t      'x': -10,\n\t      'y': -4,\n\t      'rx': 4,\n\t      'ry': 4,\n\t      'fill': '#33334F',\n\t      'stroke': '#FFFFFF',\n\t      'stroke-width': 2\n\t    }\n\t  }],\n\t  onRender: function () {\n\t    this.renderChildren();\n\t  },\n\t  position: function (x, y, angle, view) {\n\t    const {\n\t      scale\n\t    } = this.options;\n\t    let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    var handle = this.childNodes.handle;\n\t    handle.setAttribute('transform', V.matrixToTransformString(matrix));\n\t    handle.setAttribute('cursor', angle % 180 === 0 ? 'row-resize' : 'col-resize');\n\t    var viewPoint = view.getClosestPoint(new Point(x, y));\n\t    var line = this.childNodes.line;\n\t    line.setAttribute('x1', x);\n\t    line.setAttribute('y1', y);\n\t    line.setAttribute('x2', viewPoint.x);\n\t    line.setAttribute('y2', viewPoint.y);\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.options.guard(evt)) return;\n\t    this.trigger('change:start', this, evt);\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.options.paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, evt.data);\n\t  },\n\t  onPointerMove: function (evt) {\n\t    this.trigger('changing', this, evt);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    this.options.paper.delegateEvents();\n\t    this.trigger('change:end', this, evt);\n\t  },\n\t  show: function () {\n\t    this.el.style.display = '';\n\t  },\n\t  hide: function () {\n\t    this.el.style.display = 'none';\n\t  }\n\t});\n\tconst Segments = ToolView.extend({\n\t  name: 'segments',\n\t  precision: .5,\n\t  options: {\n\t    handleClass: SegmentHandle,\n\t    segmentLengthThreshold: 40,\n\t    redundancyRemoval: true,\n\t    anchor: getAnchor,\n\t    snapRadius: 10,\n\t    snapHandle: true,\n\t    stopPropagation: true\n\t  },\n\t  handles: null,\n\t  onRender: function () {\n\t    this.resetHandles();\n\t    var relatedView = this.relatedView;\n\t    var vertices = relatedView.model.vertices();\n\t    vertices.unshift(relatedView.sourcePoint);\n\t    vertices.push(relatedView.targetPoint);\n\t    for (var i = 0, n = vertices.length; i < n - 1; i++) {\n\t      var vertex = vertices[i];\n\t      var nextVertex = vertices[i + 1];\n\t      var handle = this.renderHandle(vertex, nextVertex);\n\t      this.simulateRelatedView(handle.el);\n\t      this.handles.push(handle);\n\t      handle.options.index = i;\n\t    }\n\t    return this;\n\t  },\n\t  renderHandle: function (vertex, nextVertex) {\n\t    var handle = new this.options.handleClass({\n\t      paper: this.paper,\n\t      scale: this.options.scale,\n\t      guard: evt => this.guard(evt)\n\t    });\n\t    handle.render();\n\t    this.updateHandle(handle, vertex, nextVertex);\n\t    handle.vel.appendTo(this.el);\n\t    this.startHandleListening(handle);\n\t    return handle;\n\t  },\n\t  update: function () {\n\t    this.render();\n\t    return this;\n\t  },\n\t  startHandleListening: function (handle) {\n\t    this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n\t    this.listenTo(handle, 'changing', this.onHandleChanging);\n\t    this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n\t  },\n\t  resetHandles: function () {\n\t    var handles = this.handles;\n\t    this.handles = [];\n\t    this.stopListening();\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      handles[i].remove();\n\t    }\n\t  },\n\t  shiftHandleIndexes: function (value) {\n\t    var handles = this.handles;\n\t    for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n\t  },\n\t  resetAnchor: function (type, anchor) {\n\t    var relatedModel = this.relatedView.model;\n\t    if (anchor) {\n\t      relatedModel.prop([type, 'anchor'], anchor, {\n\t        rewrite: true,\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    } else {\n\t      relatedModel.removeProp([type, 'anchor'], {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t  },\n\t  snapHandle: function (handle, position, data) {\n\t    var index = handle.options.index;\n\t    var linkView = this.relatedView;\n\t    var link = linkView.model;\n\t    var vertices = link.vertices();\n\t    var axis = handle.options.axis;\n\t    var prev = vertices[index - 2] || data.sourceAnchor;\n\t    var next = vertices[index + 1] || data.targetAnchor;\n\t    var snapRadius = this.options.snapRadius;\n\t    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n\t      position[axis] = prev[axis];\n\t    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n\t      position[axis] = next[axis];\n\t    }\n\t    return position;\n\t  },\n\t  onHandleChanging: function (handle, evt) {\n\t    const {\n\t      options\n\t    } = this;\n\t    var data = this.eventData(evt);\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    var index = handle.options.index - 1;\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    var position = this.snapHandle(handle, coords.clone(), data);\n\t    var axis = handle.options.axis;\n\t    var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];\n\t    var link = relatedView.model;\n\t    var vertices = cloneDeep(link.vertices());\n\t    var anchorFn = this.options.anchor;\n\t    if (typeof anchorFn !== 'function') anchorFn = null;\n\t    const handleIndex = handle.options.index;\n\t    const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n\t    let indexOffset = 0;\n\n\t    // check if vertex before handle vertex exists\n\t    if (handleIndex - 1 >= 0) {\n\t      const v1 = vertexPoints[handleIndex - 1];\n\t      const v2 = vertexPoints[handleIndex];\n\t      const theta = new Line(v1, v2).vector().theta();\n\n\t      // check only non-orthogonal segments\n\t      if (theta % 90 !== 0) {\n\t        vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n\t        indexOffset++;\n\t        this.shiftHandleIndexes(1);\n\t      }\n\t    }\n\t    var vertex = vertices[index + indexOffset];\n\t    var nextVertex = vertices[index + 1 + indexOffset];\n\n\t    // check if vertex after handle vertex exists\n\t    if (handleIndex + 2 < vertexPoints.length) {\n\t      const v1 = vertexPoints[handleIndex + 1];\n\t      const v2 = vertexPoints[handleIndex + 2];\n\t      const theta = new Line(v1, v2).vector().theta();\n\n\t      // check only non-orthogonal segments\n\t      if (theta % 90 !== 0) {\n\t        const isSingleVertex = data.originalVertices.length === 1;\n\t        const origVIndex = isSingleVertex ? 0 : handleIndex;\n\t        const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n\t        let nextVIndex = 1 + indexOffset;\n\t        vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n\t      }\n\t    }\n\n\t    // First Segment\n\t    var sourceView = relatedView.sourceView;\n\t    var sourceBBox = relatedView.sourceBBox;\n\t    var changeSourceAnchor = false;\n\t    var deleteSourceAnchor = false;\n\t    if (!vertex) {\n\t      vertex = relatedView.sourceAnchor.toJSON();\n\t      vertex[axis] = position[axis];\n\t      if (sourceBBox.containsPoint(vertex)) {\n\t        vertex[axis] = position[axis];\n\t        changeSourceAnchor = true;\n\t      } else {\n\t        // we left the area of the source magnet for the first time\n\t        vertices.unshift(vertex);\n\t        this.shiftHandleIndexes(1);\n\t        data.firstHandleShifted = true;\n\t        deleteSourceAnchor = true;\n\t      }\n\t    } else if (index === 0) {\n\t      if (sourceBBox.containsPoint(vertex)) {\n\t        vertices.shift();\n\t        this.shiftHandleIndexes(-1);\n\t        changeSourceAnchor = true;\n\t      } else {\n\t        vertex[axis] = position[axis];\n\t        deleteSourceAnchor = true;\n\t      }\n\t    } else {\n\t      vertex[axis] = position[axis];\n\t    }\n\t    if (anchorFn && sourceView) {\n\t      if (changeSourceAnchor) {\n\t        var sourceAnchorPosition = data.sourceAnchor.clone();\n\t        sourceAnchorPosition[axis] = position[axis];\n\t        var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n\t        this.resetAnchor('source', sourceAnchor);\n\t      }\n\t      if (deleteSourceAnchor) {\n\t        this.resetAnchor('source', data.sourceAnchorDef);\n\t      }\n\t    }\n\n\t    // Last segment\n\t    var targetView = relatedView.targetView;\n\t    var targetBBox = relatedView.targetBBox;\n\t    var changeTargetAnchor = false;\n\t    var deleteTargetAnchor = false;\n\t    if (!nextVertex) {\n\t      nextVertex = relatedView.targetAnchor.toJSON();\n\t      nextVertex[axis] = position[axis];\n\t      if (targetBBox.containsPoint(nextVertex)) {\n\t        changeTargetAnchor = true;\n\t      } else {\n\t        // we left the area of the target magnet for the first time\n\t        vertices.push(nextVertex);\n\t        deleteTargetAnchor = true;\n\t      }\n\t    } else if (index === vertices.length - 2) {\n\t      if (targetBBox.containsPoint(nextVertex)) {\n\t        vertices.pop();\n\t        changeTargetAnchor = true;\n\t      } else {\n\t        nextVertex[axis] = position[axis];\n\t        deleteTargetAnchor = true;\n\t      }\n\t    } else {\n\t      nextVertex[axis] = position[axis];\n\t    }\n\t    if (anchorFn && targetView) {\n\t      if (changeTargetAnchor) {\n\t        var targetAnchorPosition = data.targetAnchor.clone();\n\t        targetAnchorPosition[axis] = position[axis];\n\t        var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n\t        this.resetAnchor('target', targetAnchor);\n\t      }\n\t      if (deleteTargetAnchor) {\n\t        this.resetAnchor('target', data.targetAnchorDef);\n\t      }\n\t    }\n\t    if (vertices.some(v => !v)) {\n\t      // This can happen when the link is using a smart routing and the number of\n\t      // vertices is not the same as the number of route points.\n\t      throw new Error('Segments: incompatible router in use');\n\t    }\n\t    link.vertices(vertices, {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    this.updateHandle(handle, vertex, nextVertex, offset);\n\t    if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n\t  },\n\t  onHandleChangeStart: function (handle, evt) {\n\t    const {\n\t      options,\n\t      handles,\n\t      relatedView: linkView\n\t    } = this;\n\t    const {\n\t      model,\n\t      paper\n\t    } = linkView;\n\t    var index = handle.options.index;\n\t    if (!Array.isArray(handles)) return;\n\t    for (var i = 0, n = handles.length; i < n; i++) {\n\t      if (i !== index) handles[i].hide();\n\t    }\n\t    this.focus();\n\t    this.eventData(evt, {\n\t      sourceAnchor: linkView.sourceAnchor.clone(),\n\t      targetAnchor: linkView.targetAnchor.clone(),\n\t      sourceAnchorDef: clone$1(model.prop(['source', 'anchor'])),\n\t      targetAnchorDef: clone$1(model.prop(['target', 'anchor'])),\n\t      originalVertices: cloneDeep(model.vertices()),\n\t      firstHandleShifted: false\n\t    });\n\t    model.startBatch('segment-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n\t  },\n\t  onHandleChangeEnd: function (_handle, evt) {\n\t    const {\n\t      options,\n\t      relatedView: linkView\n\t    } = this;\n\t    const {\n\t      paper,\n\t      model\n\t    } = linkView;\n\t    if (options.redundancyRemoval) {\n\t      linkView.removeRedundantLinearVertices({\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    this.render();\n\t    this.blur();\n\t    model.stopBatch('segment-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n\t    linkView.checkMouseleave(normalizedEvent);\n\t  },\n\t  updateHandle: function (handle, vertex, nextVertex, offset) {\n\t    var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n\t    var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n\t    if (vertical || horizontal) {\n\t      var segmentLine = new Line(vertex, nextVertex);\n\t      var length = segmentLine.length();\n\t      if (length < this.options.segmentLengthThreshold) {\n\t        handle.hide();\n\t      } else {\n\t        var position = segmentLine.midpoint();\n\t        var axis = vertical ? 'x' : 'y';\n\t        position[axis] += offset || 0;\n\t        var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n\t        handle.position(position.x, position.y, angle, this.relatedView);\n\t        handle.show();\n\t        handle.options.axis = axis;\n\t      }\n\t    } else {\n\t      handle.hide();\n\t    }\n\t  },\n\t  onRemove: function () {\n\t    this.resetHandles();\n\t  }\n\t}, {\n\t  SegmentHandle: SegmentHandle // keep as class property\n\t});\n\n\t// End Markers\n\tconst Arrowhead = ToolView.extend({\n\t  tagName: 'path',\n\t  xAxisVector: new Point(1, 0),\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    scale: null\n\t  },\n\t  onRender: function () {\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    var ratio = this.ratio;\n\t    var view = this.relatedView;\n\t    var tangent = view.getTangentAtRatio(ratio);\n\t    var position, angle;\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t    } else {\n\t      position = view.getPointAtRatio(ratio);\n\t      angle = 0;\n\t    }\n\t    if (!position) return this;\n\t    var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n\t    const {\n\t      scale\n\t    } = this.options;\n\t    if (scale) matrix = matrix.scale(scale);\n\t    this.vel.transform(matrix, {\n\t      absolute: true\n\t    });\n\t    return this;\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    relatedView.model.startBatch('arrowhead-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    relatedView.startArrowheadMove(this.arrowheadType);\n\t    const data = evt.data || (evt.data = {});\n\t    this.delegateDocumentEvents(null, data);\n\t    paper.undelegateEvents();\n\t    this.focus();\n\t    this.el.style.pointerEvents = 'none';\n\t    relatedView.notifyPointerdown(...paper.getPointerArgs(evt));\n\t  },\n\t  onPointerMove: function (evt) {\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n\t  },\n\t  onPointerUp: function (evt) {\n\t    this.undelegateDocumentEvents();\n\t    var relatedView = this.relatedView;\n\t    var paper = relatedView.paper;\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n\t    paper.delegateEvents();\n\t    this.blur();\n\t    this.el.style.pointerEvents = '';\n\t    relatedView.model.stopBatch('arrowhead-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  }\n\t});\n\tconst TargetArrowhead = Arrowhead.extend({\n\t  name: 'target-arrowhead',\n\t  ratio: 1,\n\t  arrowheadType: 'target',\n\t  attributes: {\n\t    'd': 'M -10 -8 10 0 -10 8 Z',\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move',\n\t    'class': 'target-arrowhead'\n\t  }\n\t});\n\tconst SourceArrowhead = Arrowhead.extend({\n\t  name: 'source-arrowhead',\n\t  ratio: 0,\n\t  arrowheadType: 'source',\n\t  attributes: {\n\t    'd': 'M 10 -8 -10 0 10 8 Z',\n\t    'fill': '#33334F',\n\t    'stroke': '#FFFFFF',\n\t    'stroke-width': 2,\n\t    'cursor': 'move',\n\t    'class': 'source-arrowhead'\n\t  }\n\t});\n\n\tconst Anchor = ToolView.extend({\n\t  tagName: 'g',\n\t  type: null,\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'anchor',\n\t    attributes: {\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'area',\n\t    attributes: {\n\t      'pointer-events': 'none',\n\t      'fill': 'none',\n\t      'stroke': '#33334F',\n\t      'stroke-dasharray': '2,4',\n\t      'rx': 5,\n\t      'ry': 5\n\t    }\n\t  }],\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onPointerDblClick',\n\t    dbltap: 'onPointerDblClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    snap: snapAnchor,\n\t    anchor: getAnchor,\n\t    scale: null,\n\t    resetAnchor: true,\n\t    customAnchorAttributes: {\n\t      'stroke-width': 4,\n\t      'stroke': '#33334F',\n\t      'fill': '#FFFFFF',\n\t      'r': 5\n\t    },\n\t    defaultAnchorAttributes: {\n\t      'stroke-width': 2,\n\t      'stroke': '#FFFFFF',\n\t      'fill': '#33334F',\n\t      'r': 6\n\t    },\n\t    areaPadding: 6,\n\t    snapRadius: 10,\n\t    restrictArea: true,\n\t    redundancyRemoval: true\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.toggleArea(false);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    var type = this.type;\n\t    var relatedView = this.relatedView;\n\t    var view = relatedView.getEndView(type);\n\t    if (view) {\n\t      this.updateAnchor();\n\t      this.updateArea();\n\t      this.el.style.display = '';\n\t    } else {\n\t      this.el.style.display = 'none';\n\t    }\n\t    return this;\n\t  },\n\t  updateAnchor: function () {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var anchorNode = childNodes.anchor;\n\t    if (!anchorNode) return;\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var position = relatedView.getEndAnchor(type);\n\t    var options = this.options;\n\t    var customAnchor = relatedView.model.prop([type, 'anchor']);\n\t    let transformString = `translate(${position.x},${position.y})`;\n\t    if (options.scale) {\n\t      transformString += ` scale(${options.scale})`;\n\t    }\n\t    anchorNode.setAttribute('transform', transformString);\n\t    var anchorAttributes = customAnchor ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n\t    for (var attrName in anchorAttributes) {\n\t      anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n\t    }\n\t  },\n\t  updateArea: function () {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var areaNode = childNodes.area;\n\t    if (!areaNode) return;\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var view = relatedView.getEndView(type);\n\t    var model = view.model;\n\t    var magnet = relatedView.getEndMagnet(type);\n\t    var padding = this.options.areaPadding;\n\t    if (!isFinite(padding)) padding = 0;\n\t    var bbox, angle, center;\n\t    if (view.isNodeConnection(magnet)) {\n\t      bbox = view.getNodeBBox(magnet);\n\t      angle = 0;\n\t      center = bbox.center();\n\t    } else {\n\t      bbox = view.getNodeUnrotatedBBox(magnet);\n\t      angle = model.angle();\n\t      center = bbox.center();\n\t      if (angle) center.rotate(model.getCenter(), -angle);\n\t      // TODO: get the link's magnet rotation into account\n\t    }\n\t    bbox.inflate(padding);\n\t    areaNode.setAttribute('x', -bbox.width / 2);\n\t    areaNode.setAttribute('y', -bbox.height / 2);\n\t    areaNode.setAttribute('width', bbox.width);\n\t    areaNode.setAttribute('height', bbox.height);\n\t    areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n\t  },\n\t  toggleArea: function (visible) {\n\t    var childNodes = this.childNodes;\n\t    if (!childNodes) return;\n\t    var areaNode = childNodes.area;\n\t    if (!areaNode) return;\n\t    areaNode.style.display = visible ? '' : 'none';\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    this.paper.undelegateEvents();\n\t    this.delegateDocumentEvents();\n\t    this.focus();\n\t    this.toggleArea(this.options.restrictArea);\n\t    this.relatedView.model.startBatch('anchor-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  resetAnchor: function (anchor) {\n\t    var type = this.type;\n\t    var relatedModel = this.relatedView.model;\n\t    if (anchor) {\n\t      relatedModel.prop([type, 'anchor'], anchor, {\n\t        rewrite: true,\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    } else {\n\t      relatedModel.removeProp([type, 'anchor'], {\n\t        ui: true,\n\t        tool: this.cid\n\t      });\n\t    }\n\t  },\n\t  onPointerMove: function (evt) {\n\t    var relatedView = this.relatedView;\n\t    var type = this.type;\n\t    var view = relatedView.getEndView(type);\n\t    var model = view.model;\n\t    var magnet = relatedView.getEndMagnet(type);\n\t    var normalizedEvent = normalizeEvent(evt);\n\t    var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    var snapFn = this.options.snap;\n\t    if (typeof snapFn === 'function') {\n\t      coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n\t      coords = new Point(coords);\n\t    }\n\t    if (this.options.restrictArea) {\n\t      if (view.isNodeConnection(magnet)) {\n\t        // snap coords to the link's connection\n\t        var pointAtConnection = view.getClosestPoint(coords);\n\t        if (pointAtConnection) coords = pointAtConnection;\n\t      } else {\n\t        // snap coords within node bbox\n\t        var bbox = view.getNodeUnrotatedBBox(magnet);\n\t        var angle = model.angle();\n\t        var origin = model.getCenter();\n\t        var rotatedCoords = coords.clone().rotate(origin, angle);\n\t        if (!bbox.containsPoint(rotatedCoords)) {\n\t          coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n\t        }\n\t      }\n\t    }\n\t    var anchor;\n\t    var anchorFn = this.options.anchor;\n\t    if (typeof anchorFn === 'function') {\n\t      anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n\t    }\n\t    this.resetAnchor(anchor);\n\t    this.update();\n\t  },\n\t  onPointerUp: function (evt) {\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    this.paper.delegateEvents();\n\t    this.undelegateDocumentEvents();\n\t    this.blur();\n\t    this.toggleArea(false);\n\t    var linkView = this.relatedView;\n\t    if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t    linkView.checkMouseleave(normalizedEvent);\n\t    linkView.model.stopBatch('anchor-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerDblClick: function () {\n\t    var anchor = this.options.resetAnchor;\n\t    if (anchor === false) return; // reset anchor disabled\n\t    if (anchor === true) anchor = null; // remove the current anchor\n\t    this.resetAnchor(cloneDeep(anchor));\n\t    this.update();\n\t  }\n\t});\n\tconst SourceAnchor = Anchor.extend({\n\t  name: 'source-anchor',\n\t  type: 'source'\n\t});\n\tconst TargetAnchor = Anchor.extend({\n\t  name: 'target-anchor',\n\t  type: 'target'\n\t});\n\n\tconst Control = ToolView.extend({\n\t  tagName: 'g',\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'handle',\n\t    attributes: {\n\t      'cursor': 'pointer',\n\t      'stroke-width': 2,\n\t      'stroke': '#FFFFFF',\n\t      'fill': '#33334F',\n\t      'r': 6\n\t    }\n\t  }, {\n\t    tagName: 'rect',\n\t    selector: 'extras',\n\t    attributes: {\n\t      'pointer-events': 'none',\n\t      'fill': 'none',\n\t      'stroke': '#33334F',\n\t      'stroke-dasharray': '2,4',\n\t      'rx': 5,\n\t      'ry': 5\n\t    }\n\t  }],\n\t  events: {\n\t    mousedown: 'onPointerDown',\n\t    touchstart: 'onPointerDown',\n\t    dblclick: 'onPointerDblClick',\n\t    dbltap: 'onPointerDblClick'\n\t  },\n\t  documentEvents: {\n\t    mousemove: 'onPointerMove',\n\t    touchmove: 'onPointerMove',\n\t    mouseup: 'onPointerUp',\n\t    touchend: 'onPointerUp',\n\t    touchcancel: 'onPointerUp'\n\t  },\n\t  options: {\n\t    handleAttributes: null,\n\t    selector: 'root',\n\t    padding: 6,\n\t    scale: null\n\t  },\n\t  getPosition: function () {\n\t    // To be overridden\n\t  },\n\t  setPosition: function () {\n\t    // To be overridden\n\t  },\n\t  resetPosition: function () {\n\t    // To be overridden\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.toggleExtras(false);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    const {\n\t      handle,\n\t      extras\n\t    } = this.childNodes;\n\t    if (handle) {\n\t      this.updateHandle(handle);\n\t    } else {\n\t      throw new Error('Control: markup selector `handle` is required');\n\t    }\n\t    if (extras) {\n\t      this.updateExtras(extras);\n\t    }\n\t    return this;\n\t  },\n\t  updateHandle: function (handleNode) {\n\t    const {\n\t      options: {\n\t        handleAttributes\n\t      }\n\t    } = this;\n\t    handleNode.setAttribute('transform', this.getHandleTransformString());\n\t    if (handleAttributes) {\n\t      for (let attrName in handleAttributes) {\n\t        handleNode.setAttribute(attrName, handleAttributes[attrName]);\n\t      }\n\t    }\n\t  },\n\t  getHandleTransformString() {\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    const {\n\t      scale\n\t    } = options;\n\t    const {\n\t      model\n\t    } = relatedView;\n\t    const relativePos = this.getPosition(relatedView, this);\n\t    const translate = this.isOverlay()\n\t    // The tool is rendered in the coordinate system of the paper\n\t    ? model.getAbsolutePointFromRelative(relativePos)\n\t    // The tool is rendered in the coordinate system of the relatedView\n\t    : relativePos;\n\t    let transformString = `translate(${translate.x},${translate.y})`;\n\t    if (scale) {\n\t      transformString += ` scale(${scale})`;\n\t    }\n\t    return transformString;\n\t  },\n\t  updateExtras: function (extrasNode) {\n\t    const {\n\t      relatedView,\n\t      options\n\t    } = this;\n\t    const {\n\t      selector,\n\t      relative,\n\t      useModelGeometry\n\t    } = getToolOptions(this);\n\t    if (!selector) {\n\t      // Hide the extras if no selector is given.\n\t      this.toggleExtras(false);\n\t      return;\n\t    }\n\t    // Get the size for the extras rectangle and update it.\n\t    let bbox;\n\t    if (useModelGeometry) {\n\t      if (selector !== 'root') {\n\t        // A selector other than null or `root` was provided.\n\t        console.warn('Control: selector will be ignored when `useModelGeometry` is used.');\n\t      }\n\t      bbox = getViewBBox(relatedView, {\n\t        useModelGeometry,\n\t        relative\n\t      });\n\t    } else {\n\t      // The reference node for calculating the bounding box of the extras.\n\t      const el = relatedView.findNode(selector);\n\t      if (!el) throw new Error('Control: invalid selector.');\n\t      bbox = getViewBBox(relatedView, {\n\t        el\n\t      });\n\t    }\n\t    let padding = options.padding;\n\t    if (!isFinite(padding)) padding = 0;\n\t    const model = relatedView.model;\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    const angle = relative ? 0 : model.angle();\n\t    const center = bbox.center();\n\t    if (angle) center.rotate(model.getCenter(), -angle);\n\t    bbox.inflate(padding);\n\t    extrasNode.setAttribute('x', -bbox.width / 2);\n\t    extrasNode.setAttribute('y', -bbox.height / 2);\n\t    extrasNode.setAttribute('width', bbox.width);\n\t    extrasNode.setAttribute('height', bbox.height);\n\t    extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);\n\t  },\n\t  toggleExtras: function (visible) {\n\t    const {\n\t      extras\n\t    } = this.childNodes;\n\t    if (!extras) return;\n\t    extras.style.display = visible ? '' : 'none';\n\t  },\n\t  onPointerDown: function (evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    paper.undelegateEvents();\n\t    this.delegateDocumentEvents();\n\t    this.focus();\n\t    this.toggleExtras(true);\n\t    relatedView.model.startBatch('control-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerMove: function (evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    const {\n\t      model\n\t    } = relatedView;\n\t    const {\n\t      clientX,\n\t      clientY\n\t    } = normalizeEvent(evt);\n\t    const coords = paper.clientToLocalPoint(clientX, clientY);\n\t    const relativeCoords = model.getRelativePointFromAbsolute(coords);\n\t    this.setPosition(relatedView, relativeCoords, evt);\n\t    this.update();\n\t  },\n\t  onPointerUp: function (_evt) {\n\t    const {\n\t      relatedView,\n\t      paper\n\t    } = this;\n\t    paper.delegateEvents();\n\t    this.undelegateDocumentEvents();\n\t    this.blur();\n\t    this.toggleExtras(false);\n\t    relatedView.model.stopBatch('control-move', {\n\t      ui: true,\n\t      tool: this.cid\n\t    });\n\t  },\n\t  onPointerDblClick: function (evt) {\n\t    const {\n\t      relatedView\n\t    } = this;\n\t    this.resetPosition(relatedView, evt);\n\t    this.update();\n\t  }\n\t});\n\n\tconst RotateLabel = Control.extend({\n\t  xAxisVector: new Point(1, 0),\n\t  children() {\n\t    const {\n\t      buttonColor = '#333',\n\t      iconColor = '#fff',\n\t      outlineColor = '#fff'\n\t    } = this.options;\n\t    return [{\n\t      selector: 'handle',\n\t      tagName: 'g',\n\t      attributes: {\n\t        cursor: 'grab'\n\t      },\n\t      children: [{\n\t        tagName: 'circle',\n\t        attributes: {\n\t          r: 10,\n\t          fill: buttonColor,\n\t          stroke: outlineColor\n\t        }\n\t      }, {\n\t        tagName: 'path',\n\t        attributes: {\n\t          d: 'M -5 0 A 5 5 0 1 1 0 5',\n\t          fill: 'transparent',\n\t          stroke: iconColor,\n\t          strokeWidth: 2,\n\t          strokeLinecap: 'round'\n\t        }\n\t      }, {\n\t        tagName: 'path',\n\t        attributes: {\n\t          d: 'M -3 5 L 0 2.5 0 7.5 Z',\n\t          fill: iconColor,\n\t          stroke: iconColor,\n\t          strokeWidth: 1,\n\t          transform: 'rotate(-5, -3, 5)'\n\t        }\n\t      }]\n\t    }];\n\t  },\n\t  getPosition(view) {\n\t    const {\n\t      offset = 0\n\t    } = this.options;\n\t    const {\n\t      x = 0,\n\t      y = 0\n\t    } = typeof offset === 'number' ? {\n\t      x: 0,\n\t      y: offset\n\t    } : offset;\n\t    const label = this.getLabel();\n\t    const labelPosition = this.getLabelPosition(label);\n\t    const coords = view.getLabelCoordinates(labelPosition);\n\t    let {\n\t      angle = 0,\n\t      args = {}\n\t    } = labelPosition;\n\t    const keepGradient = args.keepGradient;\n\t    if (keepGradient) {\n\t      const tangent = view.getTangentAtRatio(view.getClosestPointRatio(coords));\n\t      if (tangent) {\n\t        // link slope angle\n\t        angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t      }\n\t    }\n\t    const matrix = new DOMMatrix().translate(coords.x, coords.y).rotate(angle).translate(x, y);\n\t    return new Point(matrix.e, matrix.f);\n\t  },\n\t  // Override the default `computeVisibility` method to hide the tool if the label is not present.\n\t  computeVisibility() {\n\t    const visibility = Control.prototype.computeVisibility.apply(this, arguments);\n\t    return visibility && !!this.getLabel();\n\t  },\n\t  setPosition(view, coordinates) {\n\t    const model = view.model;\n\t    const label = this.getLabel();\n\t    if (!label) return;\n\t    const labelPosition = this.getLabelPosition(label);\n\t    const position = view.getLabelCoordinates(labelPosition);\n\t    const angle = 90 - position.theta(coordinates);\n\t    const index = this.getLabelIndex();\n\t    model.prop(['labels', index, 'position', 'angle'], angle);\n\t  },\n\t  resetPosition(view) {\n\t    const model = view.model;\n\t    const index = this.getLabelIndex();\n\t    model.prop(['labels', index, 'position', 'angle'], 0);\n\t  },\n\t  getLabelIndex() {\n\t    return this.options.labelIndex || 0;\n\t  },\n\t  getLabel() {\n\t    return this.relatedView.model.label(this.getLabelIndex()) || null;\n\t  },\n\t  getLabelPosition(label) {\n\t    const view = this.relatedView;\n\t    const labelPosition = view._normalizeLabelPosition(label.position);\n\t    return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());\n\t  }\n\t});\n\n\tconst Button = ToolView.extend({\n\t  name: 'button',\n\t  events: {\n\t    'mousedown': 'onPointerDown',\n\t    'touchstart': 'onPointerDown'\n\t  },\n\t  options: {\n\t    distance: 0,\n\t    offset: 0,\n\t    scale: null,\n\t    rotate: false\n\t  },\n\t  onRender: function () {\n\t    this.renderChildren(this.options.markup);\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    this.position();\n\t    return this;\n\t  },\n\t  position: function () {\n\t    const {\n\t      vel\n\t    } = this;\n\t    vel.transform(this.getCellMatrix(), {\n\t      absolute: true\n\t    });\n\t  },\n\t  getCellMatrix() {\n\t    return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n\t  },\n\t  getElementMatrix() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    let {\n\t      x = 0,\n\t      y = 0,\n\t      offset = {},\n\t      useModelGeometry,\n\t      rotate,\n\t      scale,\n\t      relative\n\t    } = getToolOptions(this);\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry,\n\t      relative\n\t    });\n\t    const angle = view.model.angle();\n\t    if (!rotate) bbox = bbox.bbox(angle);\n\t    const {\n\t      x: offsetX = 0,\n\t      y: offsetY = 0\n\t    } = offset;\n\t    if (isPercentage(x)) {\n\t      x = parseFloat(x) / 100 * bbox.width;\n\t    } else if (isCalcExpression(x)) {\n\t      x = Number(evalCalcExpression(x, bbox));\n\t    }\n\t    if (isPercentage(y)) {\n\t      y = parseFloat(y) / 100 * bbox.height;\n\t    } else if (isCalcExpression(y)) {\n\t      y = Number(evalCalcExpression(y, bbox));\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    if (rotate && !relative) matrix = matrix.rotate(angle);\n\t    matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  getLinkMatrix() {\n\t    const {\n\t      relatedView: view,\n\t      options\n\t    } = this;\n\t    const {\n\t      offset = 0,\n\t      distance: distanceOpt = 0,\n\t      rotate,\n\t      scale\n\t    } = options;\n\t    const distance = typeof distanceOpt === 'function' ? distanceOpt.call(this, view, this) : distanceOpt;\n\t    let tangent, position, angle;\n\t    if (isPercentage(distance)) {\n\t      tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n\t    } else {\n\t      tangent = view.getTangentAtLength(distance);\n\t    }\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t    } else {\n\t      position = view.getConnection().start;\n\t      angle = 0;\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n\t    if (!rotate) matrix = matrix.rotate(-angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  onPointerDown: function (evt) {\n\t    if (this.guard(evt)) return;\n\t    evt.stopPropagation();\n\t    evt.preventDefault();\n\t    var actionFn = this.options.action;\n\t    if (typeof actionFn === 'function') {\n\t      actionFn.call(this.relatedView, evt, this.relatedView, this);\n\t    }\n\t  }\n\t});\n\tconst Remove = Button.extend({\n\t  name: 'remove',\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'button',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#FF1D00',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'icon',\n\t    attributes: {\n\t      'd': 'M -3 -3 3 3 M -3 3 3 -3',\n\t      'fill': 'none',\n\t      'stroke': '#FFFFFF',\n\t      'stroke-width': 2,\n\t      'pointer-events': 'none'\n\t    }\n\t  }],\n\t  options: {\n\t    distance: 60,\n\t    offset: 0,\n\t    action: function (evt, view, tool) {\n\t      view.model.remove({\n\t        ui: true,\n\t        tool: tool.cid\n\t      });\n\t    }\n\t  }\n\t});\n\n\tconst Boundary = ToolView.extend({\n\t  name: 'boundary',\n\t  tagName: 'rect',\n\t  options: {\n\t    padding: 10,\n\t    useModelGeometry: false\n\t  },\n\t  attributes: {\n\t    'fill': 'none',\n\t    'stroke': '#33334F',\n\t    'stroke-width': .5,\n\t    'stroke-dasharray': '5, 5',\n\t    'pointer-events': 'none'\n\t  },\n\t  onRender: function () {\n\t    this.update();\n\t  },\n\t  update: function () {\n\t    const {\n\t      relatedView: view,\n\t      vel\n\t    } = this;\n\t    const {\n\t      useModelGeometry,\n\t      rotate,\n\t      relative,\n\t      padding\n\t    } = getToolOptions(this);\n\t    const normalizedPadding = normalizeSides(padding);\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry,\n\t      relative\n\t    }).moveAndExpand({\n\t      x: -normalizedPadding.left,\n\t      y: -normalizedPadding.top,\n\t      width: normalizedPadding.left + normalizedPadding.right,\n\t      height: normalizedPadding.top + normalizedPadding.bottom\n\t    });\n\t    const model = view.model;\n\t    // With relative positioning, rotation is implicit\n\t    // (the tool rotates along with the element).\n\t    if (model.isElement() && !relative) {\n\t      const angle = model.angle();\n\t      if (angle) {\n\t        if (rotate) {\n\t          const origin = model.getCenter();\n\t          vel.rotate(angle, origin.x, origin.y, {\n\t            absolute: true\n\t          });\n\t        } else {\n\t          bbox = bbox.bbox(angle);\n\t        }\n\t      }\n\t    }\n\t    vel.attr(bbox.toJSON());\n\t    return this;\n\t  }\n\t});\n\n\tconst Connect = Button.extend({\n\t  name: 'connect',\n\t  documentEvents: {\n\t    mousemove: 'drag',\n\t    touchmove: 'drag',\n\t    mouseup: 'dragend',\n\t    touchend: 'dragend',\n\t    touchcancel: 'dragend'\n\t  },\n\t  children: [{\n\t    tagName: 'circle',\n\t    selector: 'button',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#333333',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    selector: 'icon',\n\t    attributes: {\n\t      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t      'fill': '#FFFFFF',\n\t      'stroke': 'none',\n\t      'stroke-width': 2,\n\t      'pointer-events': 'none'\n\t    }\n\t  }],\n\t  options: {\n\t    distance: 80,\n\t    offset: 0,\n\t    magnet: view => view.el,\n\t    action: (evt, _view, tool) => tool.dragstart(evt)\n\t  },\n\t  getMagnetNode: function () {\n\t    const {\n\t      options,\n\t      relatedView\n\t    } = this;\n\t    const {\n\t      magnet\n\t    } = options;\n\t    let magnetNode;\n\t    switch (typeof magnet) {\n\t      case 'function':\n\t        {\n\t          magnetNode = magnet.call(this, relatedView, this);\n\t          break;\n\t        }\n\t      case 'string':\n\t        {\n\t          magnetNode = relatedView.findNode(magnet);\n\t          break;\n\t        }\n\t      default:\n\t        {\n\t          magnetNode = magnet;\n\t          break;\n\t        }\n\t    }\n\t    if (!magnetNode) magnetNode = relatedView.el;\n\t    if (magnetNode instanceof SVGElement) return magnetNode;\n\t    throw new Error('Connect: magnet must be an SVGElement');\n\t  },\n\t  dragstart: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n\t    paper.undelegateEvents();\n\t    this.delegateDocumentEvents(null, normalizedEvent.data);\n\t    this.focus();\n\t  },\n\t  drag: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLink(normalizedEvent, x, y);\n\t  },\n\t  dragend: function (evt) {\n\t    const {\n\t      paper,\n\t      relatedView\n\t    } = this;\n\t    const normalizedEvent = normalizeEvent(evt);\n\t    const {\n\t      x,\n\t      y\n\t    } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t    relatedView.dragLinkEnd(normalizedEvent, x, y);\n\t    this.undelegateDocumentEvents();\n\t    paper.delegateEvents();\n\t    this.blur();\n\t    relatedView.checkMouseleave(normalizedEvent);\n\t  }\n\t});\n\n\tconst HoverConnect$1 = Connect.extend({\n\t  name: 'hover-connect',\n\t  defaultMarkup: [{\n\t    tagName: 'circle',\n\t    attributes: {\n\t      'r': 7,\n\t      'fill': '#333333',\n\t      'cursor': 'pointer'\n\t    }\n\t  }, {\n\t    tagName: 'path',\n\t    attributes: {\n\t      'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t      'fill': '#FFFFFF',\n\t      'stroke': 'none',\n\t      'stroke-width': 2\n\t    }\n\t  }],\n\t  children() {\n\t    const {\n\t      options,\n\t      defaultMarkup\n\t    } = this;\n\t    return [{\n\t      tagName: 'path',\n\t      selector: 'track',\n\t      attributes: {\n\t        'fill': 'none',\n\t        'stroke': 'transparent',\n\t        'stroke-width': options.trackWidth || 15,\n\t        'cursor': 'pointer'\n\t      }\n\t    }, {\n\t      tagName: 'g',\n\t      selector: 'button',\n\t      attributes: {\n\t        'pointer-events': 'none',\n\t        'display': 'none'\n\t      },\n\t      children: options.markup || defaultMarkup\n\t    }];\n\t  },\n\t  events: Object.assign({\n\t    mousemove: 'onMousemove',\n\t    mouseenter: 'onMouseenter',\n\t    mouseleave: 'onMouseleave'\n\t  }, Connect.prototype.events),\n\t  onRender: function () {\n\t    this.renderChildren();\n\t    this.update();\n\t  },\n\t  trackPath: null,\n\t  update() {\n\t    const {\n\t      childNodes\n\t    } = this;\n\t    this.trackPath = this.getTrackPath();\n\t    Connect.prototype.update.apply(this, arguments);\n\t    childNodes.track.setAttribute('d', this.trackPath.serialize());\n\t  },\n\t  position() {\n\t    const {\n\t      el,\n\t      childNodes\n\t    } = this;\n\t    childNodes.button.setAttribute('transform', V.matrixToTransformString(this.getButtonMatrix()));\n\t    el.setAttribute('transform', V.matrixToTransformString(this.getTrackMatrix()));\n\t  },\n\t  getButtonMatrix() {\n\t    const {\n\t      options,\n\t      trackPath\n\t    } = this;\n\t    const {\n\t      offset = 0,\n\t      distance = 0,\n\t      rotate,\n\t      scale\n\t    } = options;\n\t    let tangent, position, angle;\n\t    if (isPercentage(distance)) {\n\t      tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n\t    } else {\n\t      tangent = trackPath.tangentAtLength(distance);\n\t    }\n\t    if (tangent) {\n\t      position = tangent.start;\n\t      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t    } else {\n\t      position = trackPath.start;\n\t      angle = 0;\n\t    }\n\t    let matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n\t    if (!rotate) matrix = matrix.rotate(-angle);\n\t    if (scale) matrix = matrix.scale(scale);\n\t    return matrix;\n\t  },\n\t  getTrackPath() {\n\t    return this.relatedView.getConnection();\n\t  },\n\t  getTrackMatrix() {\n\t    return V.createSVGMatrix();\n\t  },\n\t  getTrackMatrixAbsolute() {\n\t    return this.getTrackMatrix();\n\t  },\n\t  getTrackRatioFromEvent(evt) {\n\t    const {\n\t      relatedView,\n\t      trackPath\n\t    } = this;\n\t    const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n\t    const trackPoint = V.transformPoint(localPoint, this.getTrackMatrixAbsolute().inverse());\n\t    return trackPath.closestPointLength(trackPoint);\n\t  },\n\t  canShowButton() {\n\t    // Has been the paper events undelegated? If so, we can't show the button.\n\t    // TODO: add a method to the paper to check if the events are delegated.\n\t    return $.event.has(this.paper.el);\n\t  },\n\t  showButton() {\n\t    this.childNodes.button.style.display = 'block';\n\t  },\n\t  hideButton() {\n\t    this.childNodes.button.style.display = '';\n\t  },\n\t  onMousemove(evt) {\n\t    const {\n\t      trackPath\n\t    } = this;\n\t    if (!trackPath) return;\n\t    const {\n\t      options\n\t    } = this;\n\t    options.distance = this.getTrackRatioFromEvent(evt);\n\t    this.position();\n\t  },\n\t  onMouseenter() {\n\t    if (!this.canShowButton()) return;\n\t    this.showButton();\n\t  },\n\t  onMouseleave() {\n\t    this.hideButton();\n\t  }\n\t});\n\n\tvar index$1 = {\n\t\t__proto__: null,\n\t\tBoundary: Boundary,\n\t\tButton: Button,\n\t\tConnect: Connect,\n\t\tControl: Control,\n\t\tHoverConnect: HoverConnect$1,\n\t\tRemove: Remove,\n\t\tRotateLabel: RotateLabel,\n\t\tSegments: Segments,\n\t\tSourceAnchor: SourceAnchor,\n\t\tSourceArrowhead: SourceArrowhead,\n\t\tTargetAnchor: TargetAnchor,\n\t\tTargetArrowhead: TargetArrowhead,\n\t\tVertices: Vertices\n\t};\n\n\tconst HoverConnect = HoverConnect$1.extend({\n\t  getTrackPath() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    let {\n\t      useModelGeometry,\n\t      relative,\n\t      trackPath = 'M 0 0 H calc(w) V calc(h) H 0 Z'\n\t    } = getToolOptions(this);\n\t    if (typeof trackPath === 'function') {\n\t      trackPath = trackPath.call(this, view);\n\t    }\n\t    if (isCalcExpression(trackPath)) {\n\t      const bbox = getViewBBox(view, {\n\t        useModelGeometry,\n\t        relative\n\t      });\n\t      trackPath = evalCalcExpression(trackPath, bbox);\n\t    }\n\t    return new Path$1(V.normalizePathData(trackPath));\n\t  },\n\t  getTrackMatrix() {\n\t    if (this.isOverlay()) return this.getTrackMatrixAbsolute();\n\t    return V.createSVGMatrix();\n\t  },\n\t  getTrackMatrixAbsolute() {\n\t    const {\n\t      relatedView: view\n\t    } = this;\n\t    let {\n\t      useModelGeometry,\n\t      rotate\n\t    } = getToolOptions(this);\n\t    let bbox = getViewBBox(view, {\n\t      useModelGeometry\n\t    });\n\t    const angle = view.model.angle();\n\t    if (!rotate) bbox = bbox.bbox(angle);\n\t    let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t    if (rotate) matrix = matrix.rotate(angle);\n\t    matrix = matrix.translate(-bbox.width / 2, -bbox.height / 2);\n\t    return matrix;\n\t  }\n\t});\n\n\tvar index = {\n\t\t__proto__: null,\n\t\tBoundary: Boundary,\n\t\tButton: Button,\n\t\tConnect: Connect,\n\t\tControl: Control,\n\t\tHoverConnect: HoverConnect,\n\t\tRemove: Remove\n\t};\n\n\tvar version = \"4.2.1\";\n\n\tconst Vectorizer = V;\n\tconst layout$1 = {\n\t  PortLabel,\n\t  Port\n\t};\n\tconst setTheme = function (theme, opt) {\n\t  opt = opt || {};\n\t  invoke(views, 'setTheme', theme, opt);\n\n\t  // Update the default theme on the view prototype.\n\t  View.prototype.defaultTheme = theme;\n\t};\n\n\tconst layout = {\n\t  PortLabel,\n\t  Port\n\t};\n\n\t// export empty namespaces - backward compatibility\n\tconst format = {};\n\tconst ui = {};\n\n\texports.V = V;\n\texports.Vectorizer = Vectorizer;\n\texports.anchors = anchors;\n\texports.config = config$3;\n\texports.connectionPoints = connectionPoints;\n\texports.connectionStrategies = index$3;\n\texports.connectors = connectors;\n\texports.dia = index$2;\n\texports.elementTools = index;\n\texports.env = env;\n\texports.format = format;\n\texports.g = g;\n\texports.highlighters = highlighters;\n\texports.layout = layout;\n\texports.linkAnchors = linkAnchors;\n\texports.linkTools = index$1;\n\texports.mvc = index$4;\n\texports.routers = routers;\n\texports.setTheme = setTheme;\n\texports.shapes = index$5;\n\texports.ui = ui;\n\texports.util = index$6;\n\texports.version = version;\n\n}));\nif (typeof joint !== 'undefined') { var g = joint.g, V = joint.V, Vectorizer = joint.V; }\n","import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","import { isShadowRoot } from \"./instanceOf.js\";\nexport default function contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}","import { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nimport getWindow from \"./getWindow.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}","import { viewport } from \"../enums.js\";\nimport getViewportRect from \"./getViewportRect.js\";\nimport getDocumentRect from \"./getDocumentRect.js\";\nimport listScrollParents from \"./listScrollParents.js\";\nimport getOffsetParent from \"./getOffsetParent.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport contains from \"./contains.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport rectToClientRect from \"../utils/rectToClientRect.js\";\nimport { max, min } from \"../utils/math.js\";\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nexport default function getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getNodeScroll from \"./getNodeScroll.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport { round } from \"../utils/math.js\";\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nexport default function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}","import getWindow from \"./getWindow.js\";\nexport default function getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}","import { isElement } from \"./instanceOf.js\";\nexport default function getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}","import getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nimport { max } from \"../utils/math.js\"; // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nexport default function getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}","export default function getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\"; // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nexport default function getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}","export default function getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}","import getWindowScroll from \"./getWindowScroll.js\";\nimport getWindow from \"./getWindow.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getHTMLElementScroll from \"./getHTMLElementScroll.js\";\nexport default function getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}","import getWindow from \"./getWindow.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isHTMLElement, isShadowRoot } from \"./instanceOf.js\";\nimport isTableElement from \"./isTableElement.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getUAString from \"../utils/userAgent.js\";\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}","import getParentNode from \"./getParentNode.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nexport default function getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}","import getWindow from \"./getWindow.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}","export default function getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}","import getWindow from \"./getWindow.js\";\nexport default function getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nexport default function getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}","import getWindow from \"./getWindow.js\";\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };","import getUAString from \"../utils/userAgent.js\";\nexport default function isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}","import getComputedStyle from \"./getComputedStyle.js\";\nexport default function isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}","import getNodeName from \"./getNodeName.js\";\nexport default function isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}","import getScrollParent from \"./getScrollParent.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getWindow from \"./getWindow.js\";\nimport isScrollParent from \"./isScrollParent.js\";\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nexport default function listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}","export var top = 'top';\nexport var bottom = 'bottom';\nexport var right = 'right';\nexport var left = 'left';\nexport var auto = 'auto';\nexport var basePlacements = [top, bottom, right, left];\nexport var start = 'start';\nexport var end = 'end';\nexport var clippingParents = 'clippingParents';\nexport var viewport = 'viewport';\nexport var popper = 'popper';\nexport var reference = 'reference';\nexport var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nexport var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nexport var beforeRead = 'beforeRead';\nexport var read = 'read';\nexport var afterRead = 'afterRead'; // pure-logic modifiers\n\nexport var beforeMain = 'beforeMain';\nexport var main = 'main';\nexport var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nexport var beforeWrite = 'beforeWrite';\nexport var write = 'write';\nexport var afterWrite = 'afterWrite';\nexport var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];","export * from \"./enums.js\";\nexport * from \"./modifiers/index.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport { popperGenerator, detectOverflow, createPopper as createPopperBase } from \"./createPopper.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper } from \"./popper.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper as createPopperLite } from \"./popper-lite.js\";","import getNodeName from \"../dom-utils/getNodeName.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n};","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport contains from \"../dom-utils/contains.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport { within } from \"../utils/within.js\";\nimport mergePaddingObject from \"../utils/mergePaddingObject.js\";\nimport expandToHashMap from \"../utils/expandToHashMap.js\";\nimport { left, right, basePlacements, top, bottom } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","import { top, left, right, bottom, end } from \"../enums.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getWindow from \"../dom-utils/getWindow.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getComputedStyle from \"../dom-utils/getComputedStyle.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport { round } from \"../utils/math.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","import getWindow from \"../dom-utils/getWindow.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};","import getOppositePlacement from \"../utils/getOppositePlacement.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getOppositeVariationPlacement from \"../utils/getOppositeVariationPlacement.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport computeAutoPlacement from \"../utils/computeAutoPlacement.js\";\nimport { bottom, top, start, right, left, auto } from \"../enums.js\";\nimport getVariation from \"../utils/getVariation.js\"; // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","import { top, bottom, left, right } from \"../enums.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};","export { default as applyStyles } from \"./applyStyles.js\";\nexport { default as arrow } from \"./arrow.js\";\nexport { default as computeStyles } from \"./computeStyles.js\";\nexport { default as eventListeners } from \"./eventListeners.js\";\nexport { default as flip } from \"./flip.js\";\nexport { default as hide } from \"./hide.js\";\nexport { default as offset } from \"./offset.js\";\nexport { default as popperOffsets } from \"./popperOffsets.js\";\nexport { default as preventOverflow } from \"./preventOverflow.js\";","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport { top, left, right, placements } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};","import computeOffsets from \"../utils/computeOffsets.js\";\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};","import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow };","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nimport offset from \"./modifiers/offset.js\";\nimport flip from \"./modifiers/flip.js\";\nimport preventOverflow from \"./modifiers/preventOverflow.js\";\nimport arrow from \"./modifiers/arrow.js\";\nimport hide from \"./modifiers/hide.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles, offset, flip, preventOverflow, arrow, hide];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow }; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper as createPopperLite } from \"./popper-lite.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport * from \"./modifiers/index.js\";","import getVariation from \"./getVariation.js\";\nimport { variationPlacements, basePlacements, placements as allPlacements } from \"../enums.js\";\nimport detectOverflow from \"./detectOverflow.js\";\nimport getBasePlacement from \"./getBasePlacement.js\";\nexport default function computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","import getBasePlacement from \"./getBasePlacement.js\";\nimport getVariation from \"./getVariation.js\";\nimport getMainAxisFromPlacement from \"./getMainAxisFromPlacement.js\";\nimport { top, right, bottom, left, start, end } from \"../enums.js\";\nexport default function computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}","export default function debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}","import getClippingRect from \"../dom-utils/getClippingRect.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getBoundingClientRect from \"../dom-utils/getBoundingClientRect.js\";\nimport computeOffsets from \"./computeOffsets.js\";\nimport rectToClientRect from \"./rectToClientRect.js\";\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from \"../enums.js\";\nimport { isElement } from \"../dom-utils/instanceOf.js\";\nimport mergePaddingObject from \"./mergePaddingObject.js\";\nimport expandToHashMap from \"./expandToHashMap.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport default function detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","export default function expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}","export default function getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}","import { auto } from \"../enums.js\";\nexport default function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}","export default function getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}","export default function getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}","var hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nexport default function getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}","var hash = {\n  start: 'end',\n  end: 'start'\n};\nexport default function getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}","export default function getVariation(placement) {\n  return placement.split('-')[1];\n}","export var max = Math.max;\nexport var min = Math.min;\nexport var round = Math.round;","export default function mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}","import getFreshSideObject from \"./getFreshSideObject.js\";\nexport default function mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}","import { modifierPhases } from \"../enums.js\"; // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nexport default function orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}","export default function rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}","export default function getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}","import { max as mathMax, min as mathMin } from \"./math.js\";\nexport function within(min, value, max) {\n  return mathMax(min, mathMin(value, max));\n}\nexport function withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}","/*!\n  * Bootstrap v5.3.8 (https://getbootstrap.com/)\n  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\nimport * as Popper from '@popperjs/core';\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/data.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * Constants\n */\n\nconst elementMap = new Map();\nconst Data = {\n  set(element, key, instance) {\n    if (!elementMap.has(element)) {\n      elementMap.set(element, new Map());\n    }\n    const instanceMap = elementMap.get(element);\n\n    // make it clear we only want one instance per element\n    // can be removed later when multiple key/instances are fine to be used\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\n      // eslint-disable-next-line no-console\n      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n      return;\n    }\n    instanceMap.set(key, instance);\n  },\n  get(element, key) {\n    if (elementMap.has(element)) {\n      return elementMap.get(element).get(key) || null;\n    }\n    return null;\n  },\n  remove(element, key) {\n    if (!elementMap.has(element)) {\n      return;\n    }\n    const instanceMap = elementMap.get(element);\n    instanceMap.delete(key);\n\n    // free up element references if there are no instances left for an element\n    if (instanceMap.size === 0) {\n      elementMap.delete(element);\n    }\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst MAX_UID = 1000000;\nconst MILLISECONDS_MULTIPLIER = 1000;\nconst TRANSITION_END = 'transitionend';\n\n/**\n * Properly escape IDs selectors to handle weird IDs\n * @param {string} selector\n * @returns {string}\n */\nconst parseSelector = selector => {\n  if (selector && window.CSS && window.CSS.escape) {\n    // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n    selector = selector.replace(/#([^\\s\"#']+)/g, (match, id) => `#${CSS.escape(id)}`);\n  }\n  return selector;\n};\n\n// Shout-out Angus Croll (https://goo.gl/pxwQGp)\nconst toType = object => {\n  if (object === null || object === undefined) {\n    return `${object}`;\n  }\n  return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\n\n/**\n * Public Util API\n */\n\nconst getUID = prefix => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID);\n  } while (document.getElementById(prefix));\n  return prefix;\n};\nconst getTransitionDurationFromElement = element => {\n  if (!element) {\n    return 0;\n  }\n\n  // Get transition-duration of the element\n  let {\n    transitionDuration,\n    transitionDelay\n  } = window.getComputedStyle(element);\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\n  const floatTransitionDelay = Number.parseFloat(transitionDelay);\n\n  // Return 0 if element or transition duration is not found\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0;\n  }\n\n  // If multiple durations are defined, take the first\n  transitionDuration = transitionDuration.split(',')[0];\n  transitionDelay = transitionDelay.split(',')[0];\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\nconst triggerTransitionEnd = element => {\n  element.dispatchEvent(new Event(TRANSITION_END));\n};\nconst isElement = object => {\n  if (!object || typeof object !== 'object') {\n    return false;\n  }\n  if (typeof object.jquery !== 'undefined') {\n    object = object[0];\n  }\n  return typeof object.nodeType !== 'undefined';\n};\nconst getElement = object => {\n  // it's a jQuery object or a node element\n  if (isElement(object)) {\n    return object.jquery ? object[0] : object;\n  }\n  if (typeof object === 'string' && object.length > 0) {\n    return document.querySelector(parseSelector(object));\n  }\n  return null;\n};\nconst isVisible = element => {\n  if (!isElement(element) || element.getClientRects().length === 0) {\n    return false;\n  }\n  const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';\n  // Handle `details` element as its content may falsie appear visible when it is closed\n  const closedDetails = element.closest('details:not([open])');\n  if (!closedDetails) {\n    return elementIsVisible;\n  }\n  if (closedDetails !== element) {\n    const summary = element.closest('summary');\n    if (summary && summary.parentNode !== closedDetails) {\n      return false;\n    }\n    if (summary === null) {\n      return false;\n    }\n  }\n  return elementIsVisible;\n};\nconst isDisabled = element => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n  if (element.classList.contains('disabled')) {\n    return true;\n  }\n  if (typeof element.disabled !== 'undefined') {\n    return element.disabled;\n  }\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n};\nconst findShadowRoot = element => {\n  if (!document.documentElement.attachShadow) {\n    return null;\n  }\n\n  // Can find the shadow root otherwise it'll return the document\n  if (typeof element.getRootNode === 'function') {\n    const root = element.getRootNode();\n    return root instanceof ShadowRoot ? root : null;\n  }\n  if (element instanceof ShadowRoot) {\n    return element;\n  }\n\n  // when we don't find a shadow root\n  if (!element.parentNode) {\n    return null;\n  }\n  return findShadowRoot(element.parentNode);\n};\nconst noop = () => {};\n\n/**\n * Trick to restart an element's animation\n *\n * @param {HTMLElement} element\n * @return void\n *\n * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n */\nconst reflow = element => {\n  element.offsetHeight; // eslint-disable-line no-unused-expressions\n};\nconst getjQuery = () => {\n  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n    return window.jQuery;\n  }\n  return null;\n};\nconst DOMContentLoadedCallbacks = [];\nconst onDOMContentLoaded = callback => {\n  if (document.readyState === 'loading') {\n    // add listener on the first call when the document is in loading state\n    if (!DOMContentLoadedCallbacks.length) {\n      document.addEventListener('DOMContentLoaded', () => {\n        for (const callback of DOMContentLoadedCallbacks) {\n          callback();\n        }\n      });\n    }\n    DOMContentLoadedCallbacks.push(callback);\n  } else {\n    callback();\n  }\n};\nconst isRTL = () => document.documentElement.dir === 'rtl';\nconst defineJQueryPlugin = plugin => {\n  onDOMContentLoaded(() => {\n    const $ = getjQuery();\n    /* istanbul ignore if */\n    if ($) {\n      const name = plugin.NAME;\n      const JQUERY_NO_CONFLICT = $.fn[name];\n      $.fn[name] = plugin.jQueryInterface;\n      $.fn[name].Constructor = plugin;\n      $.fn[name].noConflict = () => {\n        $.fn[name] = JQUERY_NO_CONFLICT;\n        return plugin.jQueryInterface;\n      };\n    }\n  });\n};\nconst execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {\n  return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;\n};\nconst executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\n  if (!waitForTransition) {\n    execute(callback);\n    return;\n  }\n  const durationPadding = 5;\n  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n  let called = false;\n  const handler = ({\n    target\n  }) => {\n    if (target !== transitionElement) {\n      return;\n    }\n    called = true;\n    transitionElement.removeEventListener(TRANSITION_END, handler);\n    execute(callback);\n  };\n  transitionElement.addEventListener(TRANSITION_END, handler);\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(transitionElement);\n    }\n  }, emulatedDuration);\n};\n\n/**\n * Return the previous/next element of a list.\n *\n * @param {array} list    The list of elements\n * @param activeElement   The active element\n * @param shouldGetNext   Choose to get next or previous element\n * @param isCycleAllowed\n * @return {Element|elem} The proper element\n */\nconst getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\n  const listLength = list.length;\n  let index = list.indexOf(activeElement);\n\n  // if the element does not exist in the list return an element\n  // depending on the direction and if cycle is allowed\n  if (index === -1) {\n    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n  }\n  index += shouldGetNext ? 1 : -1;\n  if (isCycleAllowed) {\n    index = (index + listLength) % listLength;\n  }\n  return list[Math.max(0, Math.min(index, listLength - 1))];\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/event-handler.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {}; // Events storage\nlet uidEvent = 1;\nconst customEvents = {\n  mouseenter: 'mouseover',\n  mouseleave: 'mouseout'\n};\nconst nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n\n/**\n * Private methods\n */\n\nfunction makeEventUid(element, uid) {\n  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n}\nfunction getElementEvents(element) {\n  const uid = makeEventUid(element);\n  element.uidEvent = uid;\n  eventRegistry[uid] = eventRegistry[uid] || {};\n  return eventRegistry[uid];\n}\nfunction bootstrapHandler(element, fn) {\n  return function handler(event) {\n    hydrateObj(event, {\n      delegateTarget: element\n    });\n    if (handler.oneOff) {\n      EventHandler.off(element, event.type, fn);\n    }\n    return fn.apply(element, [event]);\n  };\n}\nfunction bootstrapDelegationHandler(element, selector, fn) {\n  return function handler(event) {\n    const domElements = element.querySelectorAll(selector);\n    for (let {\n      target\n    } = event; target && target !== this; target = target.parentNode) {\n      for (const domElement of domElements) {\n        if (domElement !== target) {\n          continue;\n        }\n        hydrateObj(event, {\n          delegateTarget: target\n        });\n        if (handler.oneOff) {\n          EventHandler.off(element, event.type, selector, fn);\n        }\n        return fn.apply(target, [event]);\n      }\n    }\n  };\n}\nfunction findHandler(events, callable, delegationSelector = null) {\n  return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\n}\nfunction normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n  const isDelegated = typeof handler === 'string';\n  // TODO: tooltip passes `false` instead of selector, so we need to check\n  const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n  let typeEvent = getTypeEvent(originalTypeEvent);\n  if (!nativeEvents.has(typeEvent)) {\n    typeEvent = originalTypeEvent;\n  }\n  return [isDelegated, callable, typeEvent];\n}\nfunction addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n  if (typeof originalTypeEvent !== 'string' || !element) {\n    return;\n  }\n  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n\n  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n  // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n  if (originalTypeEvent in customEvents) {\n    const wrapFunction = fn => {\n      return function (event) {\n        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n          return fn.call(this, event);\n        }\n      };\n    };\n    callable = wrapFunction(callable);\n  }\n  const events = getElementEvents(element);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n  if (previousFunction) {\n    previousFunction.oneOff = previousFunction.oneOff && oneOff;\n    return;\n  }\n  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n  const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n  fn.delegationSelector = isDelegated ? handler : null;\n  fn.callable = callable;\n  fn.oneOff = oneOff;\n  fn.uidEvent = uid;\n  handlers[uid] = fn;\n  element.addEventListener(typeEvent, fn, isDelegated);\n}\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\n  if (!fn) {\n    return;\n  }\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n  delete events[typeEvent][fn.uidEvent];\n}\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {\n    if (handlerKey.includes(namespace)) {\n      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n    }\n  }\n}\nfunction getTypeEvent(event) {\n  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n  event = event.replace(stripNameRegex, '');\n  return customEvents[event] || event;\n}\nconst EventHandler = {\n  on(element, event, handler, delegationFunction) {\n    addHandler(element, event, handler, delegationFunction, false);\n  },\n  one(element, event, handler, delegationFunction) {\n    addHandler(element, event, handler, delegationFunction, true);\n  },\n  off(element, originalTypeEvent, handler, delegationFunction) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getElementEvents(element);\n    const storeElementEvent = events[typeEvent] || {};\n    const isNamespace = originalTypeEvent.startsWith('.');\n    if (typeof callable !== 'undefined') {\n      // Simplest case: handler is passed, remove that listener ONLY.\n      if (!Object.keys(storeElementEvent).length) {\n        return;\n      }\n      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n      return;\n    }\n    if (isNamespace) {\n      for (const elementEvent of Object.keys(events)) {\n        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n      }\n    }\n    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {\n      const handlerKey = keyHandlers.replace(stripUidRegex, '');\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  },\n  trigger(element, event, args) {\n    if (typeof event !== 'string' || !element) {\n      return null;\n    }\n    const $ = getjQuery();\n    const typeEvent = getTypeEvent(event);\n    const inNamespace = event !== typeEvent;\n    let jQueryEvent = null;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    if (inNamespace && $) {\n      jQueryEvent = $.Event(event, args);\n      $(element).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n    const evt = hydrateObj(new Event(event, {\n      bubbles,\n      cancelable: true\n    }), args);\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n    if (nativeDispatch) {\n      element.dispatchEvent(evt);\n    }\n    if (evt.defaultPrevented && jQueryEvent) {\n      jQueryEvent.preventDefault();\n    }\n    return evt;\n  }\n};\nfunction hydrateObj(obj, meta = {}) {\n  for (const [key, value] of Object.entries(meta)) {\n    try {\n      obj[key] = value;\n    } catch (_unused) {\n      Object.defineProperty(obj, key, {\n        configurable: true,\n        get() {\n          return value;\n        }\n      });\n    }\n  }\n  return obj;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/manipulator.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nfunction normalizeData(value) {\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  if (value === Number(value).toString()) {\n    return Number(value);\n  }\n  if (value === '' || value === 'null') {\n    return null;\n  }\n  if (typeof value !== 'string') {\n    return value;\n  }\n  try {\n    return JSON.parse(decodeURIComponent(value));\n  } catch (_unused) {\n    return value;\n  }\n}\nfunction normalizeDataKey(key) {\n  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n}\nconst Manipulator = {\n  setDataAttribute(element, key, value) {\n    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n  },\n  removeDataAttribute(element, key) {\n    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n  },\n  getDataAttributes(element) {\n    if (!element) {\n      return {};\n    }\n    const attributes = {};\n    const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\n    for (const key of bsKeys) {\n      let pureKey = key.replace(/^bs/, '');\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);\n      attributes[pureKey] = normalizeData(element.dataset[key]);\n    }\n    return attributes;\n  },\n  getDataAttribute(element, key) {\n    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {};\n  }\n  static get DefaultType() {\n    return {};\n  }\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    return config;\n  }\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n    return {\n      ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    };\n  }\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const [property, expectedTypes] of Object.entries(configTypes)) {\n      const value = config[property];\n      const valueType = isElement(value) ? 'element' : toType(value);\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n      }\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap base-component.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst VERSION = '5.3.8';\n\n/**\n * Class definition\n */\n\nclass BaseComponent extends Config {\n  constructor(element, config) {\n    super();\n    element = getElement(element);\n    if (!element) {\n      return;\n    }\n    this._element = element;\n    this._config = this._getConfig(config);\n    Data.set(this._element, this.constructor.DATA_KEY, this);\n  }\n\n  // Public\n  dispose() {\n    Data.remove(this._element, this.constructor.DATA_KEY);\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\n    for (const propertyName of Object.getOwnPropertyNames(this)) {\n      this[propertyName] = null;\n    }\n  }\n\n  // Private\n  _queueCallback(callback, element, isAnimated = true) {\n    executeAfterTransition(callback, element, isAnimated);\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config, this._element);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n\n  // Static\n  static getInstance(element) {\n    return Data.get(getElement(element), this.DATA_KEY);\n  }\n  static getOrCreateInstance(element, config = {}) {\n    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\n  }\n  static get VERSION() {\n    return VERSION;\n  }\n  static get DATA_KEY() {\n    return `bs.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n  static eventName(name) {\n    return `${name}${this.EVENT_KEY}`;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target');\n  if (!selector || selector === '#') {\n    let hrefAttribute = element.getAttribute('href');\n\n    // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n      return null;\n    }\n\n    // Just in case some CMS puts out a full URL with the anchor appended\n    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n      hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\n    }\n    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n  }\n  return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;\n};\nconst SelectorEngine = {\n  find(selector, element = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n  },\n  findOne(selector, element = document.documentElement) {\n    return Element.prototype.querySelector.call(element, selector);\n  },\n  children(element, selector) {\n    return [].concat(...element.children).filter(child => child.matches(selector));\n  },\n  parents(element, selector) {\n    const parents = [];\n    let ancestor = element.parentNode.closest(selector);\n    while (ancestor) {\n      parents.push(ancestor);\n      ancestor = ancestor.parentNode.closest(selector);\n    }\n    return parents;\n  },\n  prev(element, selector) {\n    let previous = element.previousElementSibling;\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n      previous = previous.previousElementSibling;\n    }\n    return [];\n  },\n  // TODO: this is now unused; remove later along with prev()\n  next(element, selector) {\n    let next = element.nextElementSibling;\n    while (next) {\n      if (next.matches(selector)) {\n        return [next];\n      }\n      next = next.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(element) {\n    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\n    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\n  },\n  getSelectorFromElement(element) {\n    const selector = getSelector(element);\n    if (selector) {\n      return SelectorEngine.findOne(selector) ? selector : null;\n    }\n    return null;\n  },\n  getElementFromSelector(element) {\n    const selector = getSelector(element);\n    return selector ? SelectorEngine.findOne(selector) : null;\n  },\n  getMultipleElementsFromSelector(element) {\n    const selector = getSelector(element);\n    return selector ? SelectorEngine.find(selector) : [];\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/component-functions.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst enableDismissTrigger = (component, method = 'hide') => {\n  const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n  const name = component.NAME;\n  EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n    const instance = component.getOrCreateInstance(target);\n\n    // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n    instance[method]();\n  });\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$f = 'alert';\nconst DATA_KEY$a = 'bs.alert';\nconst EVENT_KEY$b = `.${DATA_KEY$a}`;\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst CLASS_NAME_FADE$5 = 'fade';\nconst CLASS_NAME_SHOW$8 = 'show';\n\n/**\n * Class definition\n */\n\nclass Alert extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$f;\n  }\n\n  // Public\n  close() {\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n    if (closeEvent.defaultPrevented) {\n      return;\n    }\n    this._element.classList.remove(CLASS_NAME_SHOW$8);\n    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\n  }\n\n  // Private\n  _destroyElement() {\n    this._element.remove();\n    EventHandler.trigger(this._element, EVENT_CLOSED);\n    this.dispose();\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Alert.getOrCreateInstance(this);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nenableDismissTrigger(Alert, 'close');\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Alert);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$e = 'button';\nconst DATA_KEY$9 = 'bs.button';\nconst EVENT_KEY$a = `.${DATA_KEY$9}`;\nconst DATA_API_KEY$6 = '.data-api';\nconst CLASS_NAME_ACTIVE$3 = 'active';\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n\n/**\n * Class definition\n */\n\nclass Button extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$e;\n  }\n\n  // Public\n  toggle() {\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Button.getOrCreateInstance(this);\n      if (config === 'toggle') {\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n  event.preventDefault();\n  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n  const data = Button.getOrCreateInstance(button);\n  data.toggle();\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Button);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/swipe.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$d = 'swipe';\nconst EVENT_KEY$9 = '.bs.swipe';\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\nconst POINTER_TYPE_TOUCH = 'touch';\nconst POINTER_TYPE_PEN = 'pen';\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\nconst SWIPE_THRESHOLD = 40;\nconst Default$c = {\n  endCallback: null,\n  leftCallback: null,\n  rightCallback: null\n};\nconst DefaultType$c = {\n  endCallback: '(function|null)',\n  leftCallback: '(function|null)',\n  rightCallback: '(function|null)'\n};\n\n/**\n * Class definition\n */\n\nclass Swipe extends Config {\n  constructor(element, config) {\n    super();\n    this._element = element;\n    if (!element || !Swipe.isSupported()) {\n      return;\n    }\n    this._config = this._getConfig(config);\n    this._deltaX = 0;\n    this._supportPointerEvents = Boolean(window.PointerEvent);\n    this._initEvents();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$c;\n  }\n  static get DefaultType() {\n    return DefaultType$c;\n  }\n  static get NAME() {\n    return NAME$d;\n  }\n\n  // Public\n  dispose() {\n    EventHandler.off(this._element, EVENT_KEY$9);\n  }\n\n  // Private\n  _start(event) {\n    if (!this._supportPointerEvents) {\n      this._deltaX = event.touches[0].clientX;\n      return;\n    }\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX;\n    }\n  }\n  _end(event) {\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX - this._deltaX;\n    }\n    this._handleSwipe();\n    execute(this._config.endCallback);\n  }\n  _move(event) {\n    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n  }\n  _handleSwipe() {\n    const absDeltaX = Math.abs(this._deltaX);\n    if (absDeltaX <= SWIPE_THRESHOLD) {\n      return;\n    }\n    const direction = absDeltaX / this._deltaX;\n    this._deltaX = 0;\n    if (!direction) {\n      return;\n    }\n    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n  }\n  _initEvents() {\n    if (this._supportPointerEvents) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\n    }\n  }\n  _eventIsPointerPenTouch(event) {\n    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n  }\n\n  // Static\n  static isSupported() {\n    return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$c = 'carousel';\nconst DATA_KEY$8 = 'bs.carousel';\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\nconst DATA_API_KEY$5 = '.data-api';\nconst ARROW_LEFT_KEY$1 = 'ArrowLeft';\nconst ARROW_RIGHT_KEY$1 = 'ArrowRight';\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\nconst ORDER_NEXT = 'next';\nconst ORDER_PREV = 'prev';\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst EVENT_SLIDE = `slide${EVENT_KEY$8}`;\nconst EVENT_SLID = `slid${EVENT_KEY$8}`;\nconst EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\nconst EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\nconst EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\nconst EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst CLASS_NAME_CAROUSEL = 'carousel';\nconst CLASS_NAME_ACTIVE$2 = 'active';\nconst CLASS_NAME_SLIDE = 'slide';\nconst CLASS_NAME_END = 'carousel-item-end';\nconst CLASS_NAME_START = 'carousel-item-start';\nconst CLASS_NAME_NEXT = 'carousel-item-next';\nconst CLASS_NAME_PREV = 'carousel-item-prev';\nconst SELECTOR_ACTIVE = '.active';\nconst SELECTOR_ITEM = '.carousel-item';\nconst SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\nconst SELECTOR_INDICATORS = '.carousel-indicators';\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst KEY_TO_DIRECTION = {\n  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n};\nconst Default$b = {\n  interval: 5000,\n  keyboard: true,\n  pause: 'hover',\n  ride: false,\n  touch: true,\n  wrap: true\n};\nconst DefaultType$b = {\n  interval: '(number|boolean)',\n  // TODO:v6 remove boolean support\n  keyboard: 'boolean',\n  pause: '(string|boolean)',\n  ride: '(boolean|string)',\n  touch: 'boolean',\n  wrap: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._interval = null;\n    this._activeElement = null;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this._swipeHelper = null;\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._addEventListeners();\n    if (this._config.ride === CLASS_NAME_CAROUSEL) {\n      this.cycle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$b;\n  }\n  static get DefaultType() {\n    return DefaultType$b;\n  }\n  static get NAME() {\n    return NAME$c;\n  }\n\n  // Public\n  next() {\n    this._slide(ORDER_NEXT);\n  }\n  nextWhenVisible() {\n    // FIXME TODO use `document.visibilityState`\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n  prev() {\n    this._slide(ORDER_PREV);\n  }\n  pause() {\n    if (this._isSliding) {\n      triggerTransitionEnd(this._element);\n    }\n    this._clearInterval();\n  }\n  cycle() {\n    this._clearInterval();\n    this._updateInterval();\n    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\n  }\n  _maybeEnableCycle() {\n    if (!this._config.ride) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\n      return;\n    }\n    this.cycle();\n  }\n  to(index) {\n    const items = this._getItems();\n    if (index > items.length - 1 || index < 0) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n    const activeIndex = this._getItemIndex(this._getActive());\n    if (activeIndex === index) {\n      return;\n    }\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n    this._slide(order, items[index]);\n  }\n  dispose() {\n    if (this._swipeHelper) {\n      this._swipeHelper.dispose();\n    }\n    super.dispose();\n  }\n\n  // Private\n  _configAfterMerge(config) {\n    config.defaultInterval = config.interval;\n    return config;\n  }\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\n    }\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\n      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\n    }\n    if (this._config.touch && Swipe.isSupported()) {\n      this._addTouchEventListeners();\n    }\n  }\n  _addTouchEventListeners() {\n    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\n      EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\n    }\n    const endCallBack = () => {\n      if (this._config.pause !== 'hover') {\n        return;\n      }\n\n      // If it's a touch-enabled device, mouseenter/leave are fired as\n      // part of the mouse compatibility events on first tap - the carousel\n      // would stop cycling until user tapped out of it;\n      // here, we listen for touchend, explicitly pause the carousel\n      // (as if it's the second time we tap on it, mouseenter compat event\n      // is NOT fired) and after a timeout (to allow for mouse compatibility\n      // events to fire) we explicitly restart cycling\n\n      this.pause();\n      if (this.touchTimeout) {\n        clearTimeout(this.touchTimeout);\n      }\n      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n    };\n    const swipeConfig = {\n      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\n      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n      endCallback: endCallBack\n    };\n    this._swipeHelper = new Swipe(this._element, swipeConfig);\n  }\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n    const direction = KEY_TO_DIRECTION[event.key];\n    if (direction) {\n      event.preventDefault();\n      this._slide(this._directionToOrder(direction));\n    }\n  }\n  _getItemIndex(element) {\n    return this._getItems().indexOf(element);\n  }\n  _setActiveIndicatorElement(index) {\n    if (!this._indicatorsElement) {\n      return;\n    }\n    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n    activeIndicator.removeAttribute('aria-current');\n    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n    if (newActiveIndicator) {\n      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n      newActiveIndicator.setAttribute('aria-current', 'true');\n    }\n  }\n  _updateInterval() {\n    const element = this._activeElement || this._getActive();\n    if (!element) {\n      return;\n    }\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n    this._config.interval = elementInterval || this._config.defaultInterval;\n  }\n  _slide(order, element = null) {\n    if (this._isSliding) {\n      return;\n    }\n    const activeElement = this._getActive();\n    const isNext = order === ORDER_NEXT;\n    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n    if (nextElement === activeElement) {\n      return;\n    }\n    const nextElementIndex = this._getItemIndex(nextElement);\n    const triggerEvent = eventName => {\n      return EventHandler.trigger(this._element, eventName, {\n        relatedTarget: nextElement,\n        direction: this._orderToDirection(order),\n        from: this._getItemIndex(activeElement),\n        to: nextElementIndex\n      });\n    };\n    const slideEvent = triggerEvent(EVENT_SLIDE);\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      // TODO: change tests that use empty divs to avoid this check\n      return;\n    }\n    const isCycling = Boolean(this._interval);\n    this.pause();\n    this._isSliding = true;\n    this._setActiveIndicatorElement(nextElementIndex);\n    this._activeElement = nextElement;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n    nextElement.classList.add(orderClassName);\n    reflow(nextElement);\n    activeElement.classList.add(directionalClassName);\n    nextElement.classList.add(directionalClassName);\n    const completeCallBack = () => {\n      nextElement.classList.remove(directionalClassName, orderClassName);\n      nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n      this._isSliding = false;\n      triggerEvent(EVENT_SLID);\n    };\n    this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_SLIDE);\n  }\n  _getActive() {\n    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n  }\n  _getItems() {\n    return SelectorEngine.find(SELECTOR_ITEM, this._element);\n  }\n  _clearInterval() {\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n  }\n  _directionToOrder(direction) {\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n  _orderToDirection(order) {\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Carousel.getOrCreateInstance(this, config);\n      if (typeof config === 'number') {\n        data.to(config);\n        return;\n      }\n      if (typeof config === 'string') {\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n    return;\n  }\n  event.preventDefault();\n  const carousel = Carousel.getOrCreateInstance(target);\n  const slideIndex = this.getAttribute('data-bs-slide-to');\n  if (slideIndex) {\n    carousel.to(slideIndex);\n    carousel._maybeEnableCycle();\n    return;\n  }\n  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n    carousel.next();\n    carousel._maybeEnableCycle();\n    return;\n  }\n  carousel.prev();\n  carousel._maybeEnableCycle();\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n  for (const carousel of carousels) {\n    Carousel.getOrCreateInstance(carousel);\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Carousel);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$b = 'collapse';\nconst DATA_KEY$7 = 'bs.collapse';\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\nconst DATA_API_KEY$4 = '.data-api';\nconst EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\nconst EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\nconst EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\nconst EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst CLASS_NAME_SHOW$7 = 'show';\nconst CLASS_NAME_COLLAPSE = 'collapse';\nconst CLASS_NAME_COLLAPSING = 'collapsing';\nconst CLASS_NAME_COLLAPSED = 'collapsed';\nconst CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\nconst CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\nconst WIDTH = 'width';\nconst HEIGHT = 'height';\nconst SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\nconst Default$a = {\n  parent: null,\n  toggle: true\n};\nconst DefaultType$a = {\n  parent: '(null|element)',\n  toggle: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Collapse extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._isTransitioning = false;\n    this._triggerArray = [];\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n    for (const elem of toggleList) {\n      const selector = SelectorEngine.getSelectorFromElement(elem);\n      const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\n      if (selector !== null && filterElement.length) {\n        this._triggerArray.push(elem);\n      }\n    }\n    this._initializeChildren();\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n    }\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$a;\n  }\n  static get DefaultType() {\n    return DefaultType$a;\n  }\n  static get NAME() {\n    return NAME$b;\n  }\n\n  // Public\n  toggle() {\n    if (this._isShown()) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  show() {\n    if (this._isTransitioning || this._isShown()) {\n      return;\n    }\n    let activeChildren = [];\n\n    // find active children\n    if (this._config.parent) {\n      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\n        toggle: false\n      }));\n    }\n    if (activeChildren.length && activeChildren[0]._isTransitioning) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    for (const activeInstance of activeChildren) {\n      activeInstance.hide();\n    }\n    const dimension = this._getDimension();\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.style[dimension] = 0;\n    this._addAriaAndCollapsedClass(this._triggerArray, true);\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n      this._element.style[dimension] = '';\n      EventHandler.trigger(this._element, EVENT_SHOWN$6);\n    };\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n    const scrollSize = `scroll${capitalizedDimension}`;\n    this._queueCallback(complete, this._element, true);\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown()) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    const dimension = this._getDimension();\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n    for (const trigger of this._triggerArray) {\n      const element = SelectorEngine.getElementFromSelector(trigger);\n      if (element && !this._isShown(element)) {\n        this._addAriaAndCollapsedClass([trigger], false);\n      }\n    }\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\n      EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n    };\n    this._element.style[dimension] = '';\n    this._queueCallback(complete, this._element, true);\n  }\n\n  // Private\n  _isShown(element = this._element) {\n    return element.classList.contains(CLASS_NAME_SHOW$7);\n  }\n  _configAfterMerge(config) {\n    config.toggle = Boolean(config.toggle); // Coerce string values\n    config.parent = getElement(config.parent);\n    return config;\n  }\n  _getDimension() {\n    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n  }\n  _initializeChildren() {\n    if (!this._config.parent) {\n      return;\n    }\n    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n    for (const element of children) {\n      const selected = SelectorEngine.getElementFromSelector(element);\n      if (selected) {\n        this._addAriaAndCollapsedClass([element], this._isShown(selected));\n      }\n    }\n  }\n  _getFirstLevelChildren(selector) {\n    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n    // remove children if greater depth\n    return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\n  }\n  _addAriaAndCollapsedClass(triggerArray, isOpen) {\n    if (!triggerArray.length) {\n      return;\n    }\n    for (const element of triggerArray) {\n      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n      element.setAttribute('aria-expanded', isOpen);\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    const _config = {};\n    if (typeof config === 'string' && /show|hide/.test(config)) {\n      _config.toggle = false;\n    }\n    return this.each(function () {\n      const data = Collapse.getOrCreateInstance(this, _config);\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n    event.preventDefault();\n  }\n  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {\n    Collapse.getOrCreateInstance(element, {\n      toggle: false\n    }).toggle();\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Collapse);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$a = 'dropdown';\nconst DATA_KEY$6 = 'bs.dropdown';\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\nconst DATA_API_KEY$3 = '.data-api';\nconst ESCAPE_KEY$2 = 'Escape';\nconst TAB_KEY$1 = 'Tab';\nconst ARROW_UP_KEY$1 = 'ArrowUp';\nconst ARROW_DOWN_KEY$1 = 'ArrowDown';\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\nconst EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst CLASS_NAME_SHOW$6 = 'show';\nconst CLASS_NAME_DROPUP = 'dropup';\nconst CLASS_NAME_DROPEND = 'dropend';\nconst CLASS_NAME_DROPSTART = 'dropstart';\nconst CLASS_NAME_DROPUP_CENTER = 'dropup-center';\nconst CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\nconst SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\nconst SELECTOR_MENU = '.dropdown-menu';\nconst SELECTOR_NAVBAR = '.navbar';\nconst SELECTOR_NAVBAR_NAV = '.navbar-nav';\nconst SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\nconst PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\nconst PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\nconst PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\nconst PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\nconst PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\nconst PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\nconst PLACEMENT_TOPCENTER = 'top';\nconst PLACEMENT_BOTTOMCENTER = 'bottom';\nconst Default$9 = {\n  autoClose: true,\n  boundary: 'clippingParents',\n  display: 'dynamic',\n  offset: [0, 2],\n  popperConfig: null,\n  reference: 'toggle'\n};\nconst DefaultType$9 = {\n  autoClose: '(boolean|string)',\n  boundary: '(string|element)',\n  display: 'string',\n  offset: '(array|string|function)',\n  popperConfig: '(null|object|function)',\n  reference: '(string|element|object)'\n};\n\n/**\n * Class definition\n */\n\nclass Dropdown extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._popper = null;\n    this._parent = this._element.parentNode; // dropdown wrapper\n    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n    this._inNavbar = this._detectNavbar();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$9;\n  }\n  static get DefaultType() {\n    return DefaultType$9;\n  }\n  static get NAME() {\n    return NAME$a;\n  }\n\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (isDisabled(this._element) || this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._createPopper();\n\n    // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n    if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.on(element, 'mouseover', noop);\n      }\n    }\n    this._element.focus();\n    this._element.setAttribute('aria-expanded', true);\n    this._menu.classList.add(CLASS_NAME_SHOW$6);\n    this._element.classList.add(CLASS_NAME_SHOW$6);\n    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n  }\n  hide() {\n    if (isDisabled(this._element) || !this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    this._completeHide(relatedTarget);\n  }\n  dispose() {\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar();\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n\n  // Private\n  _completeHide(relatedTarget) {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.off(element, 'mouseover', noop);\n      }\n    }\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    this._menu.classList.remove(CLASS_NAME_SHOW$6);\n    this._element.classList.remove(CLASS_NAME_SHOW$6);\n    this._element.setAttribute('aria-expanded', 'false');\n    Manipulator.removeDataAttribute(this._menu, 'popper');\n    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n  }\n  _getConfig(config) {\n    config = super._getConfig(config);\n    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n      // Popper virtual elements require a getBoundingClientRect method\n      throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n    }\n    return config;\n  }\n  _createPopper() {\n    if (typeof Popper === 'undefined') {\n      throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');\n    }\n    let referenceElement = this._element;\n    if (this._config.reference === 'parent') {\n      referenceElement = this._parent;\n    } else if (isElement(this._config.reference)) {\n      referenceElement = getElement(this._config.reference);\n    } else if (typeof this._config.reference === 'object') {\n      referenceElement = this._config.reference;\n    }\n    const popperConfig = this._getPopperConfig();\n    this._popper = Popper.createPopper(referenceElement, this._menu, popperConfig);\n  }\n  _isShown() {\n    return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n  }\n  _getPlacement() {\n    const parentDropdown = this._parent;\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n      return PLACEMENT_RIGHT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n      return PLACEMENT_LEFT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n      return PLACEMENT_TOPCENTER;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n      return PLACEMENT_BOTTOMCENTER;\n    }\n\n    // We need to trim the value because custom properties can also include spaces\n    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n    }\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n  }\n  _detectNavbar() {\n    return this._element.closest(SELECTOR_NAVBAR) !== null;\n  }\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n    if (typeof offset === 'string') {\n      return offset.split(',').map(value => Number.parseInt(value, 10));\n    }\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n    return offset;\n  }\n  _getPopperConfig() {\n    const defaultBsPopperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }]\n    };\n\n    // Disable Popper if we have a static display or Dropdown is in Navbar\n    if (this._inNavbar || this._config.display === 'static') {\n      Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove\n      defaultBsPopperConfig.modifiers = [{\n        name: 'applyStyles',\n        enabled: false\n      }];\n    }\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\n    };\n  }\n  _selectMenuItem({\n    key,\n    target\n  }) {\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\n    if (!items.length) {\n      return;\n    }\n\n    // if target isn't included in items (e.g. when expanding the dropdown)\n    // allow cycling to get the last item in case key equals ARROW_UP_KEY\n    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Dropdown.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n  static clearMenus(event) {\n    if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n      return;\n    }\n    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n    for (const toggle of openToggles) {\n      const context = Dropdown.getInstance(toggle);\n      if (!context || context._config.autoClose === false) {\n        continue;\n      }\n      const composedPath = event.composedPath();\n      const isMenuTarget = composedPath.includes(context._menu);\n      if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n        continue;\n      }\n\n      // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n      if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n        continue;\n      }\n      const relatedTarget = {\n        relatedTarget: context._element\n      };\n      if (event.type === 'click') {\n        relatedTarget.clickEvent = event;\n      }\n      context._completeHide(relatedTarget);\n    }\n  }\n  static dataApiKeydownHandler(event) {\n    // If not an UP | DOWN | ESCAPE key => not a dropdown command\n    // If input/textarea && if key is other than ESCAPE => not a dropdown command\n\n    const isInput = /input|textarea/i.test(event.target.tagName);\n    const isEscapeEvent = event.key === ESCAPE_KEY$2;\n    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n    if (!isUpOrDownEvent && !isEscapeEvent) {\n      return;\n    }\n    if (isInput && !isEscapeEvent) {\n      return;\n    }\n    event.preventDefault();\n\n    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n    const instance = Dropdown.getOrCreateInstance(getToggleButton);\n    if (isUpOrDownEvent) {\n      event.stopPropagation();\n      instance.show();\n      instance._selectMenuItem(event);\n      return;\n    }\n    if (instance._isShown()) {\n      // else is escape and we check if it is shown\n      event.stopPropagation();\n      instance.hide();\n      getToggleButton.focus();\n    }\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n  event.preventDefault();\n  Dropdown.getOrCreateInstance(this).toggle();\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Dropdown);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/backdrop.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$9 = 'backdrop';\nconst CLASS_NAME_FADE$4 = 'fade';\nconst CLASS_NAME_SHOW$5 = 'show';\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\nconst Default$8 = {\n  className: 'modal-backdrop',\n  clickCallback: null,\n  isAnimated: false,\n  isVisible: true,\n  // if false, we use the backdrop helper without adding any element to the dom\n  rootElement: 'body' // give the choice to place backdrop under different elements\n};\nconst DefaultType$8 = {\n  className: 'string',\n  clickCallback: '(function|null)',\n  isAnimated: 'boolean',\n  isVisible: 'boolean',\n  rootElement: '(element|string)'\n};\n\n/**\n * Class definition\n */\n\nclass Backdrop extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isAppended = false;\n    this._element = null;\n  }\n\n  // Getters\n  static get Default() {\n    return Default$8;\n  }\n  static get DefaultType() {\n    return DefaultType$8;\n  }\n  static get NAME() {\n    return NAME$9;\n  }\n\n  // Public\n  show(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._append();\n    const element = this._getElement();\n    if (this._config.isAnimated) {\n      reflow(element);\n    }\n    element.classList.add(CLASS_NAME_SHOW$5);\n    this._emulateAnimation(() => {\n      execute(callback);\n    });\n  }\n  hide(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n    this._emulateAnimation(() => {\n      this.dispose();\n      execute(callback);\n    });\n  }\n  dispose() {\n    if (!this._isAppended) {\n      return;\n    }\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\n    this._element.remove();\n    this._isAppended = false;\n  }\n\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const backdrop = document.createElement('div');\n      backdrop.className = this._config.className;\n      if (this._config.isAnimated) {\n        backdrop.classList.add(CLASS_NAME_FADE$4);\n      }\n      this._element = backdrop;\n    }\n    return this._element;\n  }\n  _configAfterMerge(config) {\n    // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n    config.rootElement = getElement(config.rootElement);\n    return config;\n  }\n  _append() {\n    if (this._isAppended) {\n      return;\n    }\n    const element = this._getElement();\n    this._config.rootElement.append(element);\n    EventHandler.on(element, EVENT_MOUSEDOWN, () => {\n      execute(this._config.clickCallback);\n    });\n    this._isAppended = true;\n  }\n  _emulateAnimation(callback) {\n    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/focustrap.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$8 = 'focustrap';\nconst DATA_KEY$5 = 'bs.focustrap';\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\nconst TAB_KEY = 'Tab';\nconst TAB_NAV_FORWARD = 'forward';\nconst TAB_NAV_BACKWARD = 'backward';\nconst Default$7 = {\n  autofocus: true,\n  trapElement: null // The element to trap focus inside of\n};\nconst DefaultType$7 = {\n  autofocus: 'boolean',\n  trapElement: 'element'\n};\n\n/**\n * Class definition\n */\n\nclass FocusTrap extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isActive = false;\n    this._lastTabNavDirection = null;\n  }\n\n  // Getters\n  static get Default() {\n    return Default$7;\n  }\n  static get DefaultType() {\n    return DefaultType$7;\n  }\n  static get NAME() {\n    return NAME$8;\n  }\n\n  // Public\n  activate() {\n    if (this._isActive) {\n      return;\n    }\n    if (this._config.autofocus) {\n      this._config.trapElement.focus();\n    }\n    EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n    EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\n    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\n    this._isActive = true;\n  }\n  deactivate() {\n    if (!this._isActive) {\n      return;\n    }\n    this._isActive = false;\n    EventHandler.off(document, EVENT_KEY$5);\n  }\n\n  // Private\n  _handleFocusin(event) {\n    const {\n      trapElement\n    } = this._config;\n    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n      return;\n    }\n    const elements = SelectorEngine.focusableChildren(trapElement);\n    if (elements.length === 0) {\n      trapElement.focus();\n    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n      elements[elements.length - 1].focus();\n    } else {\n      elements[0].focus();\n    }\n  }\n  _handleKeydown(event) {\n    if (event.key !== TAB_KEY) {\n      return;\n    }\n    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\nconst PROPERTY_PADDING = 'padding-right';\nconst PROPERTY_MARGIN = 'margin-right';\n\n/**\n * Class definition\n */\n\nclass ScrollBarHelper {\n  constructor() {\n    this._element = document.body;\n  }\n\n  // Public\n  getWidth() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n    const documentWidth = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - documentWidth);\n  }\n  hide() {\n    const width = this.getWidth();\n    this._disableOverFlow();\n    // give padding to element to balance the hidden scrollbar width\n    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\n  }\n  reset() {\n    this._resetElementAttributes(this._element, 'overflow');\n    this._resetElementAttributes(this._element, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n\n  // Private\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, 'overflow');\n    this._element.style.overflow = 'hidden';\n  }\n  _setElementAttributes(selector, styleProperty, callback) {\n    const scrollbarWidth = this.getWidth();\n    const manipulationCallBack = element => {\n      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n        return;\n      }\n      this._saveInitialAttribute(element, styleProperty);\n      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _saveInitialAttribute(element, styleProperty) {\n    const actualValue = element.style.getPropertyValue(styleProperty);\n    if (actualValue) {\n      Manipulator.setDataAttribute(element, styleProperty, actualValue);\n    }\n  }\n  _resetElementAttributes(selector, styleProperty) {\n    const manipulationCallBack = element => {\n      const value = Manipulator.getDataAttribute(element, styleProperty);\n      // We only want to remove the property if the value is `null`; the value can also be zero\n      if (value === null) {\n        element.style.removeProperty(styleProperty);\n        return;\n      }\n      Manipulator.removeDataAttribute(element, styleProperty);\n      element.style.setProperty(styleProperty, value);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _applyManipulationCallback(selector, callBack) {\n    if (isElement(selector)) {\n      callBack(selector);\n      return;\n    }\n    for (const sel of SelectorEngine.find(selector, this._element)) {\n      callBack(sel);\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$7 = 'modal';\nconst DATA_KEY$4 = 'bs.modal';\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\nconst DATA_API_KEY$2 = '.data-api';\nconst ESCAPE_KEY$1 = 'Escape';\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\nconst EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\nconst EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\nconst EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\nconst CLASS_NAME_OPEN = 'modal-open';\nconst CLASS_NAME_FADE$3 = 'fade';\nconst CLASS_NAME_SHOW$4 = 'show';\nconst CLASS_NAME_STATIC = 'modal-static';\nconst OPEN_SELECTOR$1 = '.modal.show';\nconst SELECTOR_DIALOG = '.modal-dialog';\nconst SELECTOR_MODAL_BODY = '.modal-body';\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\nconst Default$6 = {\n  backdrop: true,\n  focus: true,\n  keyboard: true\n};\nconst DefaultType$6 = {\n  backdrop: '(boolean|string)',\n  focus: 'boolean',\n  keyboard: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Modal extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._isShown = false;\n    this._isTransitioning = false;\n    this._scrollBar = new ScrollBarHelper();\n    this._addEventListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$6;\n  }\n  static get DefaultType() {\n    return DefaultType$6;\n  }\n  static get NAME() {\n    return NAME$7;\n  }\n\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown || this._isTransitioning) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n      relatedTarget\n    });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._isTransitioning = true;\n    this._scrollBar.hide();\n    document.body.classList.add(CLASS_NAME_OPEN);\n    this._adjustDialog();\n    this._backdrop.show(() => this._showElement(relatedTarget));\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = false;\n    this._isTransitioning = true;\n    this._focustrap.deactivate();\n    this._element.classList.remove(CLASS_NAME_SHOW$4);\n    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\n  }\n  dispose() {\n    EventHandler.off(window, EVENT_KEY$4);\n    EventHandler.off(this._dialog, EVENT_KEY$4);\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n\n  // Private\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: Boolean(this._config.backdrop),\n      // 'static' option will be translated to true, and booleans will keep their value,\n      isAnimated: this._isAnimated()\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _showElement(relatedTarget) {\n    // try to append dynamic modal\n    if (!document.body.contains(this._element)) {\n      document.body.append(this._element);\n    }\n    this._element.style.display = 'block';\n    this._element.removeAttribute('aria-hidden');\n    this._element.setAttribute('aria-modal', true);\n    this._element.setAttribute('role', 'dialog');\n    this._element.scrollTop = 0;\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n    if (modalBody) {\n      modalBody.scrollTop = 0;\n    }\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW$4);\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._focustrap.activate();\n      }\n      this._isTransitioning = false;\n      EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n        relatedTarget\n      });\n    };\n    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n      if (event.key !== ESCAPE_KEY$1) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      this._triggerBackdropTransition();\n    });\n    EventHandler.on(window, EVENT_RESIZE$1, () => {\n      if (this._isShown && !this._isTransitioning) {\n        this._adjustDialog();\n      }\n    });\n    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\n      // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n      EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {\n        if (this._element !== event.target || this._element !== event2.target) {\n          return;\n        }\n        if (this._config.backdrop === 'static') {\n          this._triggerBackdropTransition();\n          return;\n        }\n        if (this._config.backdrop) {\n          this.hide();\n        }\n      });\n    });\n  }\n  _hideModal() {\n    this._element.style.display = 'none';\n    this._element.setAttribute('aria-hidden', true);\n    this._element.removeAttribute('aria-modal');\n    this._element.removeAttribute('role');\n    this._isTransitioning = false;\n    this._backdrop.hide(() => {\n      document.body.classList.remove(CLASS_NAME_OPEN);\n      this._resetAdjustments();\n      this._scrollBar.reset();\n      EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n    });\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_FADE$3);\n  }\n  _triggerBackdropTransition() {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const initialOverflowY = this._element.style.overflowY;\n    // return if the following background transition hasn't yet completed\n    if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n      return;\n    }\n    if (!isModalOverflowing) {\n      this._element.style.overflowY = 'hidden';\n    }\n    this._element.classList.add(CLASS_NAME_STATIC);\n    this._queueCallback(() => {\n      this._element.classList.remove(CLASS_NAME_STATIC);\n      this._queueCallback(() => {\n        this._element.style.overflowY = initialOverflowY;\n      }, this._dialog);\n    }, this._dialog);\n    this._element.focus();\n  }\n\n  /**\n   * The following methods are used to handle overflowing modals\n   */\n\n  _adjustDialog() {\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const scrollbarWidth = this._scrollBar.getWidth();\n    const isBodyOverflowing = scrollbarWidth > 0;\n    if (isBodyOverflowing && !isModalOverflowing) {\n      const property = isRTL() ? 'paddingLeft' : 'paddingRight';\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n    if (!isBodyOverflowing && isModalOverflowing) {\n      const property = isRTL() ? 'paddingRight' : 'paddingLeft';\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = '';\n    this._element.style.paddingRight = '';\n  }\n\n  // Static\n  static jQueryInterface(config, relatedTarget) {\n    return this.each(function () {\n      const data = Modal.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](relatedTarget);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  EventHandler.one(target, EVENT_SHOW$4, showEvent => {\n    if (showEvent.defaultPrevented) {\n      // only register focus restorer if modal will actually get shown\n      return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$4, () => {\n      if (isVisible(this)) {\n        this.focus();\n      }\n    });\n  });\n\n  // avoid conflict when clicking modal toggler while another one is open\n  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n  if (alreadyOpen) {\n    Modal.getInstance(alreadyOpen).hide();\n  }\n  const data = Modal.getOrCreateInstance(target);\n  data.toggle(this);\n});\nenableDismissTrigger(Modal);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Modal);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap offcanvas.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$6 = 'offcanvas';\nconst DATA_KEY$3 = 'bs.offcanvas';\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\nconst DATA_API_KEY$1 = '.data-api';\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst ESCAPE_KEY = 'Escape';\nconst CLASS_NAME_SHOW$3 = 'show';\nconst CLASS_NAME_SHOWING$1 = 'showing';\nconst CLASS_NAME_HIDING = 'hiding';\nconst CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\nconst OPEN_SELECTOR = '.offcanvas.show';\nconst EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$3}`;\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\nconst Default$5 = {\n  backdrop: true,\n  keyboard: true,\n  scroll: false\n};\nconst DefaultType$5 = {\n  backdrop: '(boolean|string)',\n  keyboard: 'boolean',\n  scroll: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Offcanvas extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._isShown = false;\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._addEventListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$5;\n  }\n  static get DefaultType() {\n    return DefaultType$5;\n  }\n  static get NAME() {\n    return NAME$6;\n  }\n\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n      relatedTarget\n    });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._backdrop.show();\n    if (!this._config.scroll) {\n      new ScrollBarHelper().hide();\n    }\n    this._element.setAttribute('aria-modal', true);\n    this._element.setAttribute('role', 'dialog');\n    this._element.classList.add(CLASS_NAME_SHOWING$1);\n    const completeCallBack = () => {\n      if (!this._config.scroll || this._config.backdrop) {\n        this._focustrap.activate();\n      }\n      this._element.classList.add(CLASS_NAME_SHOW$3);\n      this._element.classList.remove(CLASS_NAME_SHOWING$1);\n      EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n        relatedTarget\n      });\n    };\n    this._queueCallback(completeCallBack, this._element, true);\n  }\n  hide() {\n    if (!this._isShown) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._focustrap.deactivate();\n    this._element.blur();\n    this._isShown = false;\n    this._element.classList.add(CLASS_NAME_HIDING);\n    this._backdrop.hide();\n    const completeCallback = () => {\n      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n      this._element.removeAttribute('aria-modal');\n      this._element.removeAttribute('role');\n      if (!this._config.scroll) {\n        new ScrollBarHelper().reset();\n      }\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n    };\n    this._queueCallback(completeCallback, this._element, true);\n  }\n  dispose() {\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n\n  // Private\n  _initializeBackDrop() {\n    const clickCallback = () => {\n      if (this._config.backdrop === 'static') {\n        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n        return;\n      }\n      this.hide();\n    };\n\n    // 'static' option will be translated to true, and booleans will keep their value\n    const isVisible = Boolean(this._config.backdrop);\n    return new Backdrop({\n      className: CLASS_NAME_BACKDROP,\n      isVisible,\n      isAnimated: true,\n      rootElement: this._element.parentNode,\n      clickCallback: isVisible ? clickCallback : null\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n      if (event.key !== ESCAPE_KEY) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n    });\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Offcanvas.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  if (isDisabled(this)) {\n    return;\n  }\n  EventHandler.one(target, EVENT_HIDDEN$3, () => {\n    // focus on trigger when it is closed\n    if (isVisible(this)) {\n      this.focus();\n    }\n  });\n\n  // avoid conflict when clicking a toggler of an offcanvas, while another is open\n  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n  if (alreadyOpen && alreadyOpen !== target) {\n    Offcanvas.getInstance(alreadyOpen).hide();\n  }\n  const data = Offcanvas.getOrCreateInstance(target);\n  data.toggle(this);\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\n    Offcanvas.getOrCreateInstance(selector).show();\n  }\n});\nEventHandler.on(window, EVENT_RESIZE, () => {\n  for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\n    if (getComputedStyle(element).position !== 'fixed') {\n      Offcanvas.getOrCreateInstance(element).hide();\n    }\n  }\n});\nenableDismissTrigger(Offcanvas);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Offcanvas);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n// js-docs-start allow-list\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\nconst DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  a: ['target', 'href', 'title', 'rel'],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  dd: [],\n  div: [],\n  dl: [],\n  dt: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\n// js-docs-end allow-list\n\nconst uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n */\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\nconst allowedAttribute = (attribute, allowedAttributeList) => {\n  const attributeName = attribute.nodeName.toLowerCase();\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n    }\n    return true;\n  }\n\n  // Check if a regular expression validates the attribute.\n  return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n  if (!unsafeHtml.length) {\n    return unsafeHtml;\n  }\n  if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n    return sanitizeFunction(unsafeHtml);\n  }\n  const domParser = new window.DOMParser();\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n  for (const element of elements) {\n    const elementName = element.nodeName.toLowerCase();\n    if (!Object.keys(allowList).includes(elementName)) {\n      element.remove();\n      continue;\n    }\n    const attributeList = [].concat(...element.attributes);\n    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element.removeAttribute(attribute.nodeName);\n      }\n    }\n  }\n  return createdDocument.body.innerHTML;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/template-factory.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$5 = 'TemplateFactory';\nconst Default$4 = {\n  allowList: DefaultAllowlist,\n  content: {},\n  // { selector : text ,  selector2 : text2 , }\n  extraClass: '',\n  html: false,\n  sanitize: true,\n  sanitizeFn: null,\n  template: '<div></div>'\n};\nconst DefaultType$4 = {\n  allowList: 'object',\n  content: 'object',\n  extraClass: '(string|function)',\n  html: 'boolean',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  template: 'string'\n};\nconst DefaultContentType = {\n  entry: '(string|element|function|null)',\n  selector: '(string|element)'\n};\n\n/**\n * Class definition\n */\n\nclass TemplateFactory extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n  }\n\n  // Getters\n  static get Default() {\n    return Default$4;\n  }\n  static get DefaultType() {\n    return DefaultType$4;\n  }\n  static get NAME() {\n    return NAME$5;\n  }\n\n  // Public\n  getContent() {\n    return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\n  }\n  hasContent() {\n    return this.getContent().length > 0;\n  }\n  changeContent(content) {\n    this._checkContent(content);\n    this._config.content = {\n      ...this._config.content,\n      ...content\n    };\n    return this;\n  }\n  toHtml() {\n    const templateWrapper = document.createElement('div');\n    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n    for (const [selector, text] of Object.entries(this._config.content)) {\n      this._setContent(templateWrapper, text, selector);\n    }\n    const template = templateWrapper.children[0];\n    const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n    if (extraClass) {\n      template.classList.add(...extraClass.split(' '));\n    }\n    return template;\n  }\n\n  // Private\n  _typeCheckConfig(config) {\n    super._typeCheckConfig(config);\n    this._checkContent(config.content);\n  }\n  _checkContent(arg) {\n    for (const [selector, content] of Object.entries(arg)) {\n      super._typeCheckConfig({\n        selector,\n        entry: content\n      }, DefaultContentType);\n    }\n  }\n  _setContent(template, content, selector) {\n    const templateElement = SelectorEngine.findOne(selector, template);\n    if (!templateElement) {\n      return;\n    }\n    content = this._resolvePossibleFunction(content);\n    if (!content) {\n      templateElement.remove();\n      return;\n    }\n    if (isElement(content)) {\n      this._putElementInTemplate(getElement(content), templateElement);\n      return;\n    }\n    if (this._config.html) {\n      templateElement.innerHTML = this._maybeSanitize(content);\n      return;\n    }\n    templateElement.textContent = content;\n  }\n  _maybeSanitize(arg) {\n    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [undefined, this]);\n  }\n  _putElementInTemplate(element, templateElement) {\n    if (this._config.html) {\n      templateElement.innerHTML = '';\n      templateElement.append(element);\n      return;\n    }\n    templateElement.textContent = element.textContent;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$4 = 'tooltip';\nconst DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\nconst CLASS_NAME_FADE$2 = 'fade';\nconst CLASS_NAME_MODAL = 'modal';\nconst CLASS_NAME_SHOW$2 = 'show';\nconst SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\nconst SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\nconst EVENT_MODAL_HIDE = 'hide.bs.modal';\nconst TRIGGER_HOVER = 'hover';\nconst TRIGGER_FOCUS = 'focus';\nconst TRIGGER_CLICK = 'click';\nconst TRIGGER_MANUAL = 'manual';\nconst EVENT_HIDE$2 = 'hide';\nconst EVENT_HIDDEN$2 = 'hidden';\nconst EVENT_SHOW$2 = 'show';\nconst EVENT_SHOWN$2 = 'shown';\nconst EVENT_INSERTED = 'inserted';\nconst EVENT_CLICK$1 = 'click';\nconst EVENT_FOCUSIN$1 = 'focusin';\nconst EVENT_FOCUSOUT$1 = 'focusout';\nconst EVENT_MOUSEENTER = 'mouseenter';\nconst EVENT_MOUSELEAVE = 'mouseleave';\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: isRTL() ? 'left' : 'right',\n  BOTTOM: 'bottom',\n  LEFT: isRTL() ? 'right' : 'left'\n};\nconst Default$3 = {\n  allowList: DefaultAllowlist,\n  animation: true,\n  boundary: 'clippingParents',\n  container: false,\n  customClass: '',\n  delay: 0,\n  fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n  html: false,\n  offset: [0, 6],\n  placement: 'top',\n  popperConfig: null,\n  sanitize: true,\n  sanitizeFn: null,\n  selector: false,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n  title: '',\n  trigger: 'hover focus'\n};\nconst DefaultType$3 = {\n  allowList: 'object',\n  animation: 'boolean',\n  boundary: '(string|element)',\n  container: '(string|element|boolean)',\n  customClass: '(string|function)',\n  delay: '(number|object)',\n  fallbackPlacements: 'array',\n  html: 'boolean',\n  offset: '(array|string|function)',\n  placement: '(string|function)',\n  popperConfig: '(null|object|function)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  selector: '(string|boolean)',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string'\n};\n\n/**\n * Class definition\n */\n\nclass Tooltip extends BaseComponent {\n  constructor(element, config) {\n    if (typeof Popper === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org/docs/v2/)');\n    }\n    super(element, config);\n\n    // Private\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._isHovered = null;\n    this._activeTrigger = {};\n    this._popper = null;\n    this._templateFactory = null;\n    this._newContent = null;\n\n    // Protected\n    this.tip = null;\n    this._setListeners();\n    if (!this._config.selector) {\n      this._fixTitle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$3;\n  }\n  static get DefaultType() {\n    return DefaultType$3;\n  }\n  static get NAME() {\n    return NAME$4;\n  }\n\n  // Public\n  enable() {\n    this._isEnabled = true;\n  }\n  disable() {\n    this._isEnabled = false;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle() {\n    if (!this._isEnabled) {\n      return;\n    }\n    if (this._isShown()) {\n      this._leave();\n      return;\n    }\n    this._enter();\n  }\n  dispose() {\n    clearTimeout(this._timeout);\n    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n    if (this._element.getAttribute('data-bs-original-title')) {\n      this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\n    }\n    this._disposePopper();\n    super.dispose();\n  }\n  show() {\n    if (this._element.style.display === 'none') {\n      throw new Error('Please use show on visible elements');\n    }\n    if (!(this._isWithContent() && this._isEnabled)) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n    const shadowRoot = findShadowRoot(this._element);\n    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n    if (showEvent.defaultPrevented || !isInTheDom) {\n      return;\n    }\n\n    // TODO: v6 remove this or make it optional\n    this._disposePopper();\n    const tip = this._getTipElement();\n    this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n    const {\n      container\n    } = this._config;\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n      container.append(tip);\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n    }\n    this._popper = this._createPopper(tip);\n    tip.classList.add(CLASS_NAME_SHOW$2);\n\n    // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.on(element, 'mouseover', noop);\n      }\n    }\n    const complete = () => {\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n      if (this._isHovered === false) {\n        this._leave();\n      }\n      this._isHovered = false;\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  hide() {\n    if (!this._isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const tip = this._getTipElement();\n    tip.classList.remove(CLASS_NAME_SHOW$2);\n\n    // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.off(element, 'mouseover', noop);\n      }\n    }\n    this._activeTrigger[TRIGGER_CLICK] = false;\n    this._activeTrigger[TRIGGER_FOCUS] = false;\n    this._activeTrigger[TRIGGER_HOVER] = false;\n    this._isHovered = null; // it is a trick to support manual triggering\n\n    const complete = () => {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n      if (!this._isHovered) {\n        this._disposePopper();\n      }\n      this._element.removeAttribute('aria-describedby');\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  update() {\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n\n  // Protected\n  _isWithContent() {\n    return Boolean(this._getTitle());\n  }\n  _getTipElement() {\n    if (!this.tip) {\n      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n    }\n    return this.tip;\n  }\n  _createTipElement(content) {\n    const tip = this._getTemplateFactory(content).toHtml();\n\n    // TODO: remove this check in v6\n    if (!tip) {\n      return null;\n    }\n    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n    // TODO: v6 the following can be achieved with CSS only\n    tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n    const tipId = getUID(this.constructor.NAME).toString();\n    tip.setAttribute('id', tipId);\n    if (this._isAnimated()) {\n      tip.classList.add(CLASS_NAME_FADE$2);\n    }\n    return tip;\n  }\n  setContent(content) {\n    this._newContent = content;\n    if (this._isShown()) {\n      this._disposePopper();\n      this.show();\n    }\n  }\n  _getTemplateFactory(content) {\n    if (this._templateFactory) {\n      this._templateFactory.changeContent(content);\n    } else {\n      this._templateFactory = new TemplateFactory({\n        ...this._config,\n        // the `content` var has to be after `this._config`\n        // to override config.content in case of popover\n        content,\n        extraClass: this._resolvePossibleFunction(this._config.customClass)\n      });\n    }\n    return this._templateFactory;\n  }\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n    };\n  }\n  _getTitle() {\n    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\n  }\n\n  // Private\n  _initializeOnDelegatedTarget(event) {\n    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n  }\n  _isAnimated() {\n    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n  }\n  _isShown() {\n    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n  }\n  _createPopper(tip) {\n    const placement = execute(this._config.placement, [this, tip, this._element]);\n    const attachment = AttachmentMap[placement.toUpperCase()];\n    return Popper.createPopper(this._element, tip, this._getPopperConfig(attachment));\n  }\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n    if (typeof offset === 'string') {\n      return offset.split(',').map(value => Number.parseInt(value, 10));\n    }\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n    return offset;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [this._element, this._element]);\n  }\n  _getPopperConfig(attachment) {\n    const defaultBsPopperConfig = {\n      placement: attachment,\n      modifiers: [{\n        name: 'flip',\n        options: {\n          fallbackPlacements: this._config.fallbackPlacements\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }, {\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: `.${this.constructor.NAME}-arrow`\n        }\n      }, {\n        name: 'preSetPlacement',\n        enabled: true,\n        phase: 'beforeMain',\n        fn: data => {\n          // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n          // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n          this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n        }\n      }]\n    };\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\n    };\n  }\n  _setListeners() {\n    const triggers = this._config.trigger.split(' ');\n    for (const trigger of triggers) {\n      if (trigger === 'click') {\n        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);\n          context.toggle();\n        });\n      } else if (trigger !== TRIGGER_MANUAL) {\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n        EventHandler.on(this._element, eventIn, this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n          context._enter();\n        });\n        EventHandler.on(this._element, eventOut, this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n          context._leave();\n        });\n      }\n    }\n    this._hideModalHandler = () => {\n      if (this._element) {\n        this.hide();\n      }\n    };\n    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n  }\n  _fixTitle() {\n    const title = this._element.getAttribute('title');\n    if (!title) {\n      return;\n    }\n    if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n      this._element.setAttribute('aria-label', title);\n    }\n    this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\n    this._element.removeAttribute('title');\n  }\n  _enter() {\n    if (this._isShown() || this._isHovered) {\n      this._isHovered = true;\n      return;\n    }\n    this._isHovered = true;\n    this._setTimeout(() => {\n      if (this._isHovered) {\n        this.show();\n      }\n    }, this._config.delay.show);\n  }\n  _leave() {\n    if (this._isWithActiveTrigger()) {\n      return;\n    }\n    this._isHovered = false;\n    this._setTimeout(() => {\n      if (!this._isHovered) {\n        this.hide();\n      }\n    }, this._config.delay.hide);\n  }\n  _setTimeout(handler, timeout) {\n    clearTimeout(this._timeout);\n    this._timeout = setTimeout(handler, timeout);\n  }\n  _isWithActiveTrigger() {\n    return Object.values(this._activeTrigger).includes(true);\n  }\n  _getConfig(config) {\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\n    for (const dataAttribute of Object.keys(dataAttributes)) {\n      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n        delete dataAttributes[dataAttribute];\n      }\n    }\n    config = {\n      ...dataAttributes,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    config.container = config.container === false ? document.body : getElement(config.container);\n    if (typeof config.delay === 'number') {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n    if (typeof config.title === 'number') {\n      config.title = config.title.toString();\n    }\n    if (typeof config.content === 'number') {\n      config.content = config.content.toString();\n    }\n    return config;\n  }\n  _getDelegateConfig() {\n    const config = {};\n    for (const [key, value] of Object.entries(this._config)) {\n      if (this.constructor.Default[key] !== value) {\n        config[key] = value;\n      }\n    }\n    config.selector = false;\n    config.trigger = 'manual';\n\n    // In the future can be replaced with:\n    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n    // `Object.fromEntries(keysWithDifferentValues)`\n    return config;\n  }\n  _disposePopper() {\n    if (this._popper) {\n      this._popper.destroy();\n      this._popper = null;\n    }\n    if (this.tip) {\n      this.tip.remove();\n      this.tip = null;\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Tooltip.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Tooltip);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$3 = 'popover';\nconst SELECTOR_TITLE = '.popover-header';\nconst SELECTOR_CONTENT = '.popover-body';\nconst Default$2 = {\n  ...Tooltip.Default,\n  content: '',\n  offset: [0, 8],\n  placement: 'right',\n  template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n  trigger: 'click'\n};\nconst DefaultType$2 = {\n  ...Tooltip.DefaultType,\n  content: '(null|string|element|function)'\n};\n\n/**\n * Class definition\n */\n\nclass Popover extends Tooltip {\n  // Getters\n  static get Default() {\n    return Default$2;\n  }\n  static get DefaultType() {\n    return DefaultType$2;\n  }\n  static get NAME() {\n    return NAME$3;\n  }\n\n  // Overrides\n  _isWithContent() {\n    return this._getTitle() || this._getContent();\n  }\n\n  // Private\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TITLE]: this._getTitle(),\n      [SELECTOR_CONTENT]: this._getContent()\n    };\n  }\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Popover.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Popover);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$2 = 'scrollspy';\nconst DATA_KEY$2 = 'bs.scrollspy';\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\nconst DATA_API_KEY = '.data-api';\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\nconst EVENT_CLICK = `click${EVENT_KEY$2}`;\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\nconst CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\nconst CLASS_NAME_ACTIVE$1 = 'active';\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\nconst SELECTOR_TARGET_LINKS = '[href]';\nconst SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\nconst SELECTOR_NAV_LINKS = '.nav-link';\nconst SELECTOR_NAV_ITEMS = '.nav-item';\nconst SELECTOR_LIST_ITEMS = '.list-group-item';\nconst SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\nconst SELECTOR_DROPDOWN = '.dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\nconst Default$1 = {\n  offset: null,\n  // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: '0px 0px -25%',\n  smoothScroll: false,\n  target: null,\n  threshold: [0.1, 0.5, 1]\n};\nconst DefaultType$1 = {\n  offset: '(number|null)',\n  // TODO v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: 'string',\n  smoothScroll: 'boolean',\n  target: 'element',\n  threshold: 'array'\n};\n\n/**\n * Class definition\n */\n\nclass ScrollSpy extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n\n    // this._element is the observablesContainer and config.target the menu links wrapper\n    this._targetLinks = new Map();\n    this._observableSections = new Map();\n    this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\n    this._activeTarget = null;\n    this._observer = null;\n    this._previousScrollData = {\n      visibleEntryTop: 0,\n      parentScrollTop: 0\n    };\n    this.refresh(); // initialize\n  }\n\n  // Getters\n  static get Default() {\n    return Default$1;\n  }\n  static get DefaultType() {\n    return DefaultType$1;\n  }\n  static get NAME() {\n    return NAME$2;\n  }\n\n  // Public\n  refresh() {\n    this._initializeTargetsAndObservables();\n    this._maybeEnableSmoothScroll();\n    if (this._observer) {\n      this._observer.disconnect();\n    } else {\n      this._observer = this._getNewObserver();\n    }\n    for (const section of this._observableSections.values()) {\n      this._observer.observe(section);\n    }\n  }\n  dispose() {\n    this._observer.disconnect();\n    super.dispose();\n  }\n\n  // Private\n  _configAfterMerge(config) {\n    // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n    config.target = getElement(config.target) || document.body;\n\n    // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n    if (typeof config.threshold === 'string') {\n      config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));\n    }\n    return config;\n  }\n  _maybeEnableSmoothScroll() {\n    if (!this._config.smoothScroll) {\n      return;\n    }\n\n    // unregister any previous listeners\n    EventHandler.off(this._config.target, EVENT_CLICK);\n    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\n      const observableSection = this._observableSections.get(event.target.hash);\n      if (observableSection) {\n        event.preventDefault();\n        const root = this._rootElement || window;\n        const height = observableSection.offsetTop - this._element.offsetTop;\n        if (root.scrollTo) {\n          root.scrollTo({\n            top: height,\n            behavior: 'smooth'\n          });\n          return;\n        }\n\n        // Chrome 60 doesn't support `scrollTo`\n        root.scrollTop = height;\n      }\n    });\n  }\n  _getNewObserver() {\n    const options = {\n      root: this._rootElement,\n      threshold: this._config.threshold,\n      rootMargin: this._config.rootMargin\n    };\n    return new IntersectionObserver(entries => this._observerCallback(entries), options);\n  }\n\n  // The logic of selection\n  _observerCallback(entries) {\n    const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\n    const activate = entry => {\n      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n      this._process(targetElement(entry));\n    };\n    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n    this._previousScrollData.parentScrollTop = parentScrollTop;\n    for (const entry of entries) {\n      if (!entry.isIntersecting) {\n        this._activeTarget = null;\n        this._clearActiveClass(targetElement(entry));\n        continue;\n      }\n      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n      // if we are scrolling down, pick the bigger offsetTop\n      if (userScrollsDown && entryIsLowerThanPrevious) {\n        activate(entry);\n        // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n        if (!parentScrollTop) {\n          return;\n        }\n        continue;\n      }\n\n      // if we are scrolling up, pick the smallest offsetTop\n      if (!userScrollsDown && !entryIsLowerThanPrevious) {\n        activate(entry);\n      }\n    }\n  }\n  _initializeTargetsAndObservables() {\n    this._targetLinks = new Map();\n    this._observableSections = new Map();\n    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n    for (const anchor of targetLinks) {\n      // ensure that the anchor has an id and is not disabled\n      if (!anchor.hash || isDisabled(anchor)) {\n        continue;\n      }\n      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n\n      // ensure that the observableSection exists & is visible\n      if (isVisible(observableSection)) {\n        this._targetLinks.set(decodeURI(anchor.hash), anchor);\n        this._observableSections.set(anchor.hash, observableSection);\n      }\n    }\n  }\n  _process(target) {\n    if (this._activeTarget === target) {\n      return;\n    }\n    this._clearActiveClass(this._config.target);\n    this._activeTarget = target;\n    target.classList.add(CLASS_NAME_ACTIVE$1);\n    this._activateParents(target);\n    EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n      relatedTarget: target\n    });\n  }\n  _activateParents(target) {\n    // Activate dropdown parents\n    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n      return;\n    }\n    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\n      // Set triggered links parents as active\n      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\n        item.classList.add(CLASS_NAME_ACTIVE$1);\n      }\n    }\n  }\n  _clearActiveClass(parent) {\n    parent.classList.remove(CLASS_NAME_ACTIVE$1);\n    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n    for (const node of activeNodes) {\n      node.classList.remove(CLASS_NAME_ACTIVE$1);\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = ScrollSpy.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\n    ScrollSpy.getOrCreateInstance(spy);\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(ScrollSpy);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$1 = 'tab';\nconst DATA_KEY$1 = 'bs.tab';\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\nconst ARROW_LEFT_KEY = 'ArrowLeft';\nconst ARROW_RIGHT_KEY = 'ArrowRight';\nconst ARROW_UP_KEY = 'ArrowUp';\nconst ARROW_DOWN_KEY = 'ArrowDown';\nconst HOME_KEY = 'Home';\nconst END_KEY = 'End';\nconst CLASS_NAME_ACTIVE = 'active';\nconst CLASS_NAME_FADE$1 = 'fade';\nconst CLASS_NAME_SHOW$1 = 'show';\nconst CLASS_DROPDOWN = 'dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\nconst SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\nconst NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\nconst SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\nconst SELECTOR_OUTER = '.nav-item, .list-group-item';\nconst SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\nconst SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n\n/**\n * Class definition\n */\n\nclass Tab extends BaseComponent {\n  constructor(element) {\n    super(element);\n    this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n    if (!this._parent) {\n      return;\n      // TODO: should throw exception in v6\n      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n    }\n\n    // Set up initial aria attributes\n    this._setInitialAttributes(this._parent, this._getChildren());\n    EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n  }\n\n  // Getters\n  static get NAME() {\n    return NAME$1;\n  }\n\n  // Public\n  show() {\n    // Shows this elem and deactivate the active sibling if exists\n    const innerElem = this._element;\n    if (this._elemIsActive(innerElem)) {\n      return;\n    }\n\n    // Search for active tab on same parent to deactivate it\n    const active = this._getActiveElem();\n    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n      relatedTarget: innerElem\n    }) : null;\n    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n      relatedTarget: active\n    });\n    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n      return;\n    }\n    this._deactivate(active, innerElem);\n    this._activate(innerElem, active);\n  }\n\n  // Private\n  _activate(element, relatedElem) {\n    if (!element) {\n      return;\n    }\n    element.classList.add(CLASS_NAME_ACTIVE);\n    this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n\n    const complete = () => {\n      if (element.getAttribute('role') !== 'tab') {\n        element.classList.add(CLASS_NAME_SHOW$1);\n        return;\n      }\n      element.removeAttribute('tabindex');\n      element.setAttribute('aria-selected', true);\n      this._toggleDropDown(element, true);\n      EventHandler.trigger(element, EVENT_SHOWN$1, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n  }\n  _deactivate(element, relatedElem) {\n    if (!element) {\n      return;\n    }\n    element.classList.remove(CLASS_NAME_ACTIVE);\n    element.blur();\n    this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n\n    const complete = () => {\n      if (element.getAttribute('role') !== 'tab') {\n        element.classList.remove(CLASS_NAME_SHOW$1);\n        return;\n      }\n      element.setAttribute('aria-selected', false);\n      element.setAttribute('tabindex', '-1');\n      this._toggleDropDown(element, false);\n      EventHandler.trigger(element, EVENT_HIDDEN$1, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n  }\n  _keydown(event) {\n    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {\n      return;\n    }\n    event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n    event.preventDefault();\n    const children = this._getChildren().filter(element => !isDisabled(element));\n    let nextActiveElement;\n    if ([HOME_KEY, END_KEY].includes(event.key)) {\n      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n    } else {\n      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n    }\n    if (nextActiveElement) {\n      nextActiveElement.focus({\n        preventScroll: true\n      });\n      Tab.getOrCreateInstance(nextActiveElement).show();\n    }\n  }\n  _getChildren() {\n    // collection of inner elements\n    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n  }\n  _getActiveElem() {\n    return this._getChildren().find(child => this._elemIsActive(child)) || null;\n  }\n  _setInitialAttributes(parent, children) {\n    this._setAttributeIfNotExists(parent, 'role', 'tablist');\n    for (const child of children) {\n      this._setInitialAttributesOnChild(child);\n    }\n  }\n  _setInitialAttributesOnChild(child) {\n    child = this._getInnerElement(child);\n    const isActive = this._elemIsActive(child);\n    const outerElem = this._getOuterElement(child);\n    child.setAttribute('aria-selected', isActive);\n    if (outerElem !== child) {\n      this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n    }\n    if (!isActive) {\n      child.setAttribute('tabindex', '-1');\n    }\n    this._setAttributeIfNotExists(child, 'role', 'tab');\n\n    // set attributes to the related panel too\n    this._setInitialAttributesOnTargetPanel(child);\n  }\n  _setInitialAttributesOnTargetPanel(child) {\n    const target = SelectorEngine.getElementFromSelector(child);\n    if (!target) {\n      return;\n    }\n    this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n    if (child.id) {\n      this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);\n    }\n  }\n  _toggleDropDown(element, open) {\n    const outerElem = this._getOuterElement(element);\n    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n      return;\n    }\n    const toggle = (selector, className) => {\n      const element = SelectorEngine.findOne(selector, outerElem);\n      if (element) {\n        element.classList.toggle(className, open);\n      }\n    };\n    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n    outerElem.setAttribute('aria-expanded', open);\n  }\n  _setAttributeIfNotExists(element, attribute, value) {\n    if (!element.hasAttribute(attribute)) {\n      element.setAttribute(attribute, value);\n    }\n  }\n  _elemIsActive(elem) {\n    return elem.classList.contains(CLASS_NAME_ACTIVE);\n  }\n\n  // Try to get the inner element (usually the .nav-link)\n  _getInnerElement(elem) {\n    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n  }\n\n  // Try to get the outer element (usually the .nav-item)\n  _getOuterElement(elem) {\n    return elem.closest(SELECTOR_OUTER) || elem;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Tab.getOrCreateInstance(this);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  if (isDisabled(this)) {\n    return;\n  }\n  Tab.getOrCreateInstance(this).show();\n});\n\n/**\n * Initialize on focus\n */\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\n    Tab.getOrCreateInstance(element);\n  }\n});\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Tab);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME = 'toast';\nconst DATA_KEY = 'bs.toast';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW = `show${EVENT_KEY}`;\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\nconst CLASS_NAME_FADE = 'fade';\nconst CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\nconst CLASS_NAME_SHOW = 'show';\nconst CLASS_NAME_SHOWING = 'showing';\nconst DefaultType = {\n  animation: 'boolean',\n  autohide: 'boolean',\n  delay: 'number'\n};\nconst Default = {\n  animation: true,\n  autohide: true,\n  delay: 5000\n};\n\n/**\n * Class definition\n */\n\nclass Toast extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._timeout = null;\n    this._hasMouseInteraction = false;\n    this._hasKeyboardInteraction = false;\n    this._setListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default;\n  }\n  static get DefaultType() {\n    return DefaultType;\n  }\n  static get NAME() {\n    return NAME;\n  }\n\n  // Public\n  show() {\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._clearTimeout();\n    if (this._config.animation) {\n      this._element.classList.add(CLASS_NAME_FADE);\n    }\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_SHOWING);\n      EventHandler.trigger(this._element, EVENT_SHOWN);\n      this._maybeScheduleHide();\n    };\n    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  hide() {\n    if (!this.isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const complete = () => {\n      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\n    };\n    this._element.classList.add(CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  dispose() {\n    this._clearTimeout();\n    if (this.isShown()) {\n      this._element.classList.remove(CLASS_NAME_SHOW);\n    }\n    super.dispose();\n  }\n  isShown() {\n    return this._element.classList.contains(CLASS_NAME_SHOW);\n  }\n\n  // Private\n  _maybeScheduleHide() {\n    if (!this._config.autohide) {\n      return;\n    }\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n      return;\n    }\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n  _onInteraction(event, isInteracting) {\n    switch (event.type) {\n      case 'mouseover':\n      case 'mouseout':\n        {\n          this._hasMouseInteraction = isInteracting;\n          break;\n        }\n      case 'focusin':\n      case 'focusout':\n        {\n          this._hasKeyboardInteraction = isInteracting;\n          break;\n        }\n    }\n    if (isInteracting) {\n      this._clearTimeout();\n      return;\n    }\n    const nextElement = event.relatedTarget;\n    if (this._element === nextElement || this._element.contains(nextElement)) {\n      return;\n    }\n    this._maybeScheduleHide();\n  }\n  _setListeners() {\n    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n  }\n  _clearTimeout() {\n    clearTimeout(this._timeout);\n    this._timeout = null;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Toast.getOrCreateInstance(this, config);\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](this);\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nenableDismissTrigger(Toast);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Toast);\n\nexport { Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip };\n//# sourceMappingURL=bootstrap.esm.js.map\n","/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '164';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\nconst DisplayP3ColorSpace = 'display-p3';\nconst LinearDisplayP3ColorSpace = 'display-p3-linear';\n\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\n\nconst Rec709Primaries = 'rec709';\nconst P3Primaries = 'p3';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\n/**\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\n * or clipping. Based on W3C specifications for sRGB and Display P3,\n * and ICC specifications for the D50 connection space. Values in/out\n * are _linear_ sRGB and _linear_ Display P3.\n *\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\n *\n * Reference:\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\n */\n\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(\n\t0.8224621, 0.177538, 0.0,\n\t0.0331941, 0.9668058, 0.0,\n\t0.0170827, 0.0723974, 0.9105199,\n);\n\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(\n\t1.2249401, - 0.2249404, 0.0,\n\t- 0.0420569, 1.0420571, 0.0,\n\t- 0.0196376, - 0.0786361, 1.0982735\n);\n\n/**\n * Defines supported color spaces by transfer function and primaries,\n * and provides conversions to/from the Linear-sRGB reference space.\n */\nconst COLOR_SPACES = {\n\t[ LinearSRGBColorSpace ]: {\n\t\ttransfer: LinearTransfer,\n\t\tprimaries: Rec709Primaries,\n\t\ttoReference: ( color ) => color,\n\t\tfromReference: ( color ) => color,\n\t},\n\t[ SRGBColorSpace ]: {\n\t\ttransfer: SRGBTransfer,\n\t\tprimaries: Rec709Primaries,\n\t\ttoReference: ( color ) => color.convertSRGBToLinear(),\n\t\tfromReference: ( color ) => color.convertLinearToSRGB(),\n\t},\n\t[ LinearDisplayP3ColorSpace ]: {\n\t\ttransfer: LinearTransfer,\n\t\tprimaries: P3Primaries,\n\t\ttoReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),\n\t\tfromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),\n\t},\n\t[ DisplayP3ColorSpace ]: {\n\t\ttransfer: SRGBTransfer,\n\t\tprimaries: P3Primaries,\n\t\ttoReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),\n\t\tfromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),\n\t},\n};\n\nconst SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );\n\nconst ColorManagement = {\n\n\tenabled: true,\n\n\t_workingColorSpace: LinearSRGBColorSpace,\n\n\tget workingColorSpace() {\n\n\t\treturn this._workingColorSpace;\n\n\t},\n\n\tset workingColorSpace( colorSpace ) {\n\n\t\tif ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {\n\n\t\t\tthrow new Error( `Unsupported working color space, \"${ colorSpace }\".` );\n\n\t\t}\n\n\t\tthis._workingColorSpace = colorSpace;\n\n\t},\n\n\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\treturn color;\n\n\t\t}\n\n\t\tconst sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;\n\t\tconst targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;\n\n\t\treturn targetFromReference( sourceToReference( color ) );\n\n\t},\n\n\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\treturn this.convert( color, this._workingColorSpace, targetColorSpace );\n\n\t},\n\n\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\treturn this.convert( color, sourceColorSpace, this._workingColorSpace );\n\n\t},\n\n\tgetPrimaries: function ( colorSpace ) {\n\n\t\treturn COLOR_SPACES[ colorSpace ].primaries;\n\n\t},\n\n\tgetTransfer: function ( colorSpace ) {\n\n\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\treturn COLOR_SPACES[ colorSpace ].transfer;\n\n\t},\n\n};\n\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet _sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\t\tthis.dataReady = true;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet _textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tthis.colorSpace = colorSpace;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1\n\t\t}, options );\n\n\t\tconst texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\ttexture.flipY = false;\n\t\ttexture.generateMipmaps = options.generateMipmaps;\n\t\ttexture.internalFormat = options.internalFormat;\n\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\tthis.depthBuffer = options.depthBuffer;\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\tthis.samples = options.samples;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass WebGLRenderTarget extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector$b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector$b.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector$b.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector$b );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box$4.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box$4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$b ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$4 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$3 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$3.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$4.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$4.elements[ 0 ] *= invSX;\n\t\t_m1$4.elements[ 1 ] *= invSX;\n\t\t_m1$4.elements[ 2 ] *= invSX;\n\n\t\t_m1$4.elements[ 4 ] *= invSY;\n\t\t_m1$4.elements[ 5 ] *= invSY;\n\t\t_m1$4.elements[ 6 ] *= invSY;\n\n\t\t_m1$4.elements[ 8 ] *= invSZ;\n\t\t_m1$4.elements[ 9 ] *= invSZ;\n\t\t_m1$4.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$4 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$4 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$2 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$3 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nconst _childaddedEvent = { type: 'childadded', child: null };\nconst _childremovedEvent = { type: 'childremoved', child: null };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$3.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$3.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$3 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$3.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$3 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t_childremovedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t_childremovedEvent.child = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\treturn this.remove( ... this.children );\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$3.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$3.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$3 );\n\n\t\tobject.removeFromParent();\n\t\tobject.parent = this;\n\t\tthis.children.push( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t_childaddedEvent.child = object;\n\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t_childaddedEvent.child = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tif ( child.matrixWorldAutoUpdate === true || force === true ) {\n\n\t\t\t\tchild.updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tif ( child.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tobject.type = 'BatchedMesh';\n\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\tobject.visibility = this._visibility;\n\t\t\tobject.active = this._active;\n\t\t\tobject.bounds = this._bounds.map( bound => ( {\n\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\tboxMin: bound.box.min.toArray(),\n\t\t\t\tboxMax: bound.box.max.toArray(),\n\n\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\tsphereRadius: bound.sphere.radius,\n\t\t\t\tsphereCenter: bound.sphere.center.toArray()\n\t\t\t} ) );\n\n\t\t\tobject.maxGeometryCount = this._maxGeometryCount;\n\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tobject.boundingSphere = {\n\t\t\t\t\tcenter: object.boundingSphere.center.toArray(),\n\t\t\t\t\tradius: object.boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tobject.boundingBox = {\n\t\t\t\t\tmin: object.boundingBox.min.toArray(),\n\t\t\t\t\tmax: object.boundingBox.max.toArray()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations.slice();\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$2 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$2.x );\n\t\ttarget.addScaledVector( v2, _v3$2.y );\n\t\ttarget.addScaledVector( v3, _v3$2.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nlet _materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\tthis.blendColor = new Color( 0, 0, 0 );\n\t\tthis.blendAlpha = 0;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.dispersion !== undefined ) data.dispersion = this.dispersion;\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors === true ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = true;\n\n\t\tif ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;\n\t\tif ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;\n\t\tif ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;\n\t\tif ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;\n\t\tif ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;\n\t\tif ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;\n\t\tif ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();\n\t\tif ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;\n\n\t\tif ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;\n\t\tif ( this.depthTest === false ) data.depthTest = this.depthTest;\n\t\tif ( this.depthWrite === false ) data.depthWrite = this.depthWrite;\n\t\tif ( this.colorWrite === false ) data.colorWrite = this.colorWrite;\n\n\t\tif ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;\n\t\tif ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;\n\t\tif ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;\n\t\tif ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;\n\t\tif ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;\n\t\tif ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;\n\t\tif ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;\n\t\tif ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = true;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = true;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = true;\n\n\t\tif ( this.wireframe === true ) data.wireframe = true;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\tthis.blendColor.copy( source.blendColor );\n\t\tthis.blendAlpha = source.blendAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis._updateRange = { offset: 0, count: - 1 };\n\t\tthis.updateRanges = [];\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tget updateRange() {\n\n\t\twarnOnce( 'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159\n\t\treturn this._updateRange;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$2 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1$2.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1$2.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1$2.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1$2.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1$2.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1$2.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1$2 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$2.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$2.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$2.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$2.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$6 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/ new Vector2();\nconst _uvB$1 = /*@__PURE__*/ new Vector2();\nconst _uvC$1 = /*@__PURE__*/ new Vector2();\n\nconst _normalA = /*@__PURE__*/ new Vector3();\nconst _normalB = /*@__PURE__*/ new Vector3();\nconst _normalC = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$6.copy( geometry.boundingSphere );\n\t\t_sphere$6.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv1, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv1, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\tif ( currentRenderTarget === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/issues/27868\n\tif ( currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\treturn currentRenderTarget.texture.colorSpace;\n\n\t}\n\n\treturn ColorManagement.workingColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\treturn super.getWorldDirection( target ).negate();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _v3$1 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t\t_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Copies the result into the target Vector2, where x is width and y is height.\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$5.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$5.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$5 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$5.center.set( 0, 0, 0 );\n\t\t_sphere$5.radius = 0.7071067811865476;\n\t\t_sphere$5.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$5 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$7 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl ) {\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\t\tconst size = array.byteLength;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tsize: size\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute._updateRange; // @deprecated, r159\n\t\tconst updateRanges = attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 && updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t}\n\n\t\tif ( updateRanges.length !== 0 ) {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tattribute.clearUpdateRanges();\n\n\t\t}\n\n\t\t// @deprecated, r159\n\t\tif ( updateRange.count !== - 1 ) {\n\n\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tif ( data.size !== attribute.array.byteLength ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );\n\n\t\t\t}\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nvar alphahash_fragment = \"#ifdef USE_ALPHAHASH\\n\\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\\n#endif\";\n\nvar alphahash_pars_fragment = \"#ifdef USE_ALPHAHASH\\n\\tconst float ALPHA_HASH_SCALE = 0.05;\\n\\tfloat hash2D( vec2 value ) {\\n\\t\\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\\t}\\n\\tfloat hash3D( vec3 value ) {\\n\\t\\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\\n\\t}\\n\\tfloat getAlphaHashThreshold( vec3 position ) {\\n\\t\\tfloat maxDeriv = max(\\n\\t\\t\\tlength( dFdx( position.xyz ) ),\\n\\t\\t\\tlength( dFdy( position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\\n\\t\\tvec2 pixScales = vec2(\\n\\t\\t\\texp2( floor( log2( pixScale ) ) ),\\n\\t\\t\\texp2( ceil( log2( pixScale ) ) )\\n\\t\\t);\\n\\t\\tvec2 alpha = vec2(\\n\\t\\t\\thash3D( floor( pixScales.x * position.xyz ) ),\\n\\t\\t\\thash3D( floor( pixScales.y * position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat lerpFactor = fract( log2( pixScale ) );\\n\\t\\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\\n\\t\\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\\n\\t\\tvec3 cases = vec3(\\n\\t\\t\\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\\n\\t\\t\\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\\t\\t\\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\\t\\t);\\n\\t\\tfloat threshold = ( x < ( 1.0 - a ) )\\n\\t\\t\\t? ( ( x < a ) ? cases.x : cases.y )\\n\\t\\t\\t: cases.z;\\n\\t\\treturn clamp( threshold , 1.0e-6, 1.0 );\\n\\t}\\n#endif\";\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\\n\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n\\t#endif\\n#endif\";\n\nvar alphatest_pars_fragment = \"#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_CLEARCOAT ) \\n\\t\\tclearcoatSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_SHEEN ) \\n\\t\\tsheenSpecularIndirect *= ambientOcclusion;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar batching_pars_vertex = \"#ifdef USE_BATCHING\\n\\tattribute float batchId;\\n\\tuniform highp sampler2D batchingTexture;\\n\\tmat4 getBatchingMatrix( const in float i ) {\\n\\t\\tint size = textureSize( batchingTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\";\n\nvar batching_vertex = \"#ifdef USE_BATCHING\\n\\tmat4 batchingMatrix = getBatchingMatrix( batchId );\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\\n#ifdef USE_ALPHAHASH\\n\\tvPosition = vec3( position );\\n#endif\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n} // validated\";\n\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\\tconst mat3 XYZ_TO_REC709 = mat3(\\n\\t\\t 3.2404542, -0.9692660,  0.0556434,\\n\\t\\t-1.5371385,  1.8760108, -0.2040259,\\n\\t\\t-0.4985314,  0.0415560,  1.0572252\\n\\t);\\n\\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n\\t\\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\\t\\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n\\t}\\n\\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n\\t}\\n\\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n\\t}\\n\\tvec3 evalSensitivity( float OPD, vec3 shift ) {\\n\\t\\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\\t\\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\\t\\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n\\t\\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n\\t\\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\\n\\t\\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\\n\\t\\txyz /= 1.0685e-7;\\n\\t\\tvec3 rgb = XYZ_TO_REC709 * xyz;\\n\\t\\treturn rgb;\\n\\t}\\n\\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n\\t\\tvec3 I;\\n\\t\\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\\t\\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\\t\\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\\t\\tif ( cosTheta2Sq < 0.0 ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t}\\n\\t\\tfloat cosTheta2 = sqrt( cosTheta2Sq );\\n\\t\\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n\\t\\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\\t\\tfloat T121 = 1.0 - R12;\\n\\t\\tfloat phi12 = 0.0;\\n\\t\\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n\\t\\tfloat phi21 = PI - phi12;\\n\\t\\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\\t\\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n\\t\\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n\\t\\tvec3 phi23 = vec3( 0.0 );\\n\\t\\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\\n\\t\\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\\n\\t\\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\\t\\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\\t\\tvec3 phi = vec3( phi21 ) + phi23;\\n\\t\\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n\\t\\tvec3 r123 = sqrt( R123 );\\n\\t\\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n\\t\\tvec3 C0 = R12 + Rs;\\n\\t\\tI = C0;\\n\\t\\tvec3 Cm = Rs - T121;\\n\\t\\tfor ( int m = 1; m <= 2; ++ m ) {\\n\\t\\t\\tCm *= r123;\\n\\t\\t\\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n\\t\\t\\tI += Cm * Sm;\\n\\t\\t}\\n\\t\\treturn max( I, vec3( 0.0 ) );\\n\\t}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vBumpMapUv );\\n\\t\\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\\n\\t\\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#ifdef ALPHA_TO_COVERAGE\\n\\t\\tfloat distanceToPlane, distanceGradient;\\n\\t\\tfloat clipOpacity = 1.0;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\tif ( clipOpacity == 0.0 ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tfloat unionClipOpacity = 1.0;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\\t\\t\\t\\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\\t\\t\\t\\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tclipOpacity *= 1.0 - unionClipOpacity;\\n\\t\\t#endif\\n\\t\\tdiffuseColor.a *= clipOpacity;\\n\\t\\tif ( diffuseColor.a == 0.0 ) discard;\\n\\t#else\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\t\\tbool clipped = true;\\n\\t\\t\\t#pragma unroll_loop_start\\n\\t\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t\\t}\\n\\t\\t\\t#pragma unroll_loop_end\\n\\t\\t\\tif ( clipped ) discard;\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\n#ifdef USE_ALPHAHASH\\n\\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat luminance( const in vec3 rgb ) {\\n\\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\\n\\treturn dot( weights, rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // validated\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\\t\\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\\t\\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\\t\\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\\t\\t#ifdef texture2DGradEXT\\n\\t\\t\\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( envMap, uv ).rgb;\\n\\t\\t#endif\\n\\t}\\n\\t#define cubeUV_r0 1.0\\n\\t#define cubeUV_m0 - 2.0\\n\\t#define cubeUV_r1 0.8\\n\\t#define cubeUV_m1 - 1.0\\n\\t#define cubeUV_r4 0.4\\n\\t#define cubeUV_m4 2.0\\n\\t#define cubeUV_r5 0.305\\n\\t#define cubeUV_m5 3.0\\n\\t#define cubeUV_r6 0.21\\n\\t#define cubeUV_m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= cubeUV_r1 ) {\\n\\t\\t\\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\\n\\t\\t} else if ( roughness >= cubeUV_r4 ) {\\n\\t\\t\\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\\n\\t\\t} else if ( roughness >= cubeUV_r5 ) {\\n\\t\\t\\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\\n\\t\\t} else if ( roughness >= cubeUV_r6 ) {\\n\\t\\t\\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = objectTangent;\\n#endif\\n#ifdef USE_BATCHING\\n\\tmat3 bm = mat3( batchingMatrix );\\n\\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\\n\\ttransformedNormal = bm * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = bm * transformedTangent;\\n\\t#endif\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmat3 im = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\\n\\ttransformedNormal = im * transformedNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\ttransformedTangent = im * transformedTangent;\\n\\t#endif\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar colorspace_pars_fragment = \"\\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\\n\\tvec3( 0.8224621, 0.177538, 0.0 ),\\n\\tvec3( 0.0331941, 0.9668058, 0.0 ),\\n\\tvec3( 0.0170827, 0.0723974, 0.9105199 )\\n);\\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\\n\\tvec3( 1.2249401, - 0.2249404, 0.0 ),\\n\\tvec3( - 0.0420569, 1.0420571, 0.0 ),\\n\\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\\n);\\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\\n\\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\\n}\\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\\n\\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\\n}\\nvec4 LinearTransferOETF( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 sRGBTransferOETF( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn sRGBTransferOETF( value );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform mat3 envMapRotation;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn vec3( texture2D( gradientMap, coord ).r );\\n\\t#else\\n\\t\\tvec2 fw = fwidth( coord ) * 0.5;\\n\\t\\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\\n\\t#endif\\n}\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_fragment = \"LambertMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct LambertMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Lambert\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Lambert\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\n#if defined( USE_LIGHT_PROBES )\\n\\tuniform vec3 lightProbe[ 9 ];\\n#endif\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t#if defined ( LEGACY_LIGHTS )\\n\\t\\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\t\\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t#else\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t}\\n\\t\\treturn distanceFalloff;\\n\\t#endif\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometryPosition;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 reflectVec = reflect( - viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\\n\\t\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t\\tvec3 bentNormal = cross( bitangent, viewDir );\\n\\t\\t\\t\\tbentNormal = normalize( cross( bentNormal, bitangent ) );\\n\\t\\t\\t\\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\\t\\t\\t\\treturn getIBLRadiance( viewDir, bentNormal, roughness );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\tmaterial.ior = ior;\\n\\t#ifdef USE_SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\t\\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_DISPERSION\\n\\tmaterial.dispersion = dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tmaterial.iridescence = iridescence;\\n\\tmaterial.iridescenceIOR = iridescenceIOR;\\n\\t#ifdef USE_IRIDESCENCEMAP\\n\\t\\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\t\\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\\n\\t#else\\n\\t\\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\\n\\t\\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\\n\\t\\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\\n\\t#else\\n\\t\\tvec2 anisotropyV = anisotropyVector;\\n\\t#endif\\n\\tmaterial.anisotropy = length( anisotropyV );\\n\\tif( material.anisotropy == 0.0 ) {\\n\\t\\tanisotropyV = vec2( 1.0, 0.0 );\\n\\t} else {\\n\\t\\tanisotropyV /= material.anisotropy;\\n\\t\\tmaterial.anisotropy = saturate( material.anisotropy );\\n\\t}\\n\\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\\n\\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\\n\\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\tfloat dispersion;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tfloat iridescence;\\n\\t\\tfloat iridescenceIOR;\\n\\t\\tfloat iridescenceThickness;\\n\\t\\tvec3 iridescenceFresnel;\\n\\t\\tvec3 iridescenceF0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n\\t#ifdef IOR\\n\\t\\tfloat ior;\\n\\t#endif\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat transmission;\\n\\t\\tfloat transmissionAlpha;\\n\\t\\tfloat thickness;\\n\\t\\tfloat attenuationDistance;\\n\\t\\tvec3 attenuationColor;\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat anisotropy;\\n\\t\\tfloat alphaT;\\n\\t\\tvec3 anisotropyT;\\n\\t\\tvec3 anisotropyB;\\n\\t#endif\\n};\\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\\nvec3 sheenSpecularDirect = vec3( 0.0 );\\nvec3 sheenSpecularIndirect = vec3(0.0 );\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\\n\\t\\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\\n\\t\\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\\n\\t\\tfloat v = 0.5 / ( gv + gl );\\n\\t\\treturn saturate(v);\\n\\t}\\n\\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\\n\\t\\tfloat a2 = alphaT * alphaB;\\n\\t\\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\\n\\t\\thighp float v2 = dot( v, v );\\n\\t\\tfloat w2 = a2 / v2;\\n\\t\\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\\n\\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\\n\\t\\tvec3 f0 = material.clearcoatF0;\\n\\t\\tfloat f90 = material.clearcoatF90;\\n\\t\\tfloat roughness = material.clearcoatRoughness;\\n\\t\\tfloat alpha = pow2( roughness );\\n\\t\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\t\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\t\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\t\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\t\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\t\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t\\treturn F * ( V * D );\\n\\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\\n\\tvec3 f0 = material.specularColor;\\n\\tfloat f90 = material.specularF90;\\n\\tfloat roughness = material.roughness;\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tF = mix( F, material.iridescenceFresnel, material.iridescence );\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat dotTL = dot( material.anisotropyT, lightDir );\\n\\t\\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\\t\\tfloat dotTH = dot( material.anisotropyT, halfDir );\\n\\t\\tfloat dotBL = dot( material.anisotropyB, lightDir );\\n\\t\\tfloat dotBV = dot( material.anisotropyB, viewDir );\\n\\t\\tfloat dotBH = dot( material.anisotropyB, halfDir );\\n\\t\\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\\n\\t\\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\\t#else\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t#endif\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat r2 = roughness * roughness;\\n\\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\\t#else\\n\\t\\tvec3 Fr = specularColor;\\n\\t#endif\\n\\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometryNormal;\\n\\t\\tvec3 viewDir = geometryViewDir;\\n\\t\\tvec3 position = geometryPosition;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\\t#else\\n\\t\\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\t#endif\\n\\tvec3 totalScattering = singleScattering + multiScattering;\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nvec3 geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n#ifdef USE_CLEARCOAT\\n\\tgeometryClearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\\n\\tif ( material.iridescenceThickness == 0.0 ) {\\n\\t\\tmaterial.iridescence = 0.0;\\n\\t} else {\\n\\t\\tmaterial.iridescence = saturate( material.iridescence );\\n\\t}\\n\\tif ( material.iridescence > 0.0 ) {\\n\\t\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\t\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\\t}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometryPosition, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tvec4 spotColor;\\n\\tvec3 spotLightCoord;\\n\\tbool inSpotLightMap;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\\n\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\\t\\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\\t\\t#else\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#endif\\n\\t\\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\\t\\t\\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\\t\\t\\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\\t\\t\\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\\t\\t\\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\\t\\t#endif\\n\\t\\t#undef SPOT_LIGHT_MAP_INDEX\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if defined( USE_LIGHT_PROBES )\\n\\t\\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometryNormal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\\n\\t#else\\n\\t\\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tvFragDepth = 1.0 + gl_Position.w;\\n\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\\n\\t\\n\\t#endif\\n\\tdiffuseColor *= sampledDiffuseColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t#if defined( USE_POINTS_UV )\\n\\t\\tvec2 uv = vUv;\\n\\t#else\\n\\t\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_POINTS_UV )\\n\\tvarying vec2 vUv;\\n#else\\n\\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t\\tuniform mat3 uvTransform;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphinstance_vertex = \"#ifdef USE_INSTANCING_MORPH\\n\\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\\n\\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\\n\\t}\\n#endif\";\n\nvar morphcolor_vertex = \"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\\n\\tvColor *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t#if defined( USE_COLOR_ALPHA )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t#elif defined( USE_COLOR )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\t\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\t\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\t\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_INSTANCING_MORPH\\n\\t\\tuniform float morphTargetBaseInfluence;\\n\\t#endif\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\t#ifndef USE_INSTANCING_MORPH\\n\\t\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t\\t#endif\\n\\t\\tuniform sampler2DArray morphTargetsTexture;\\n\\t\\tuniform ivec2 morphTargetsTextureSize;\\n\\t\\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\\t\\t\\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\\t\\t\\tint y = texelIndex / morphTargetsTextureSize.x;\\n\\t\\t\\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\t\\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\\t\\t\\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\\t\\t}\\n\\t#else\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t\\t#else\\n\\t\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\t\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\t\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\t\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = dFdx( vViewPosition );\\n\\tvec3 fdy = dFdy( vViewPosition );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal *= faceDirection;\\n\\t#endif\\n#endif\\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\\n\\t\\t#if defined( USE_NORMALMAP )\\n\\t\\t\\tvNormalMapUv\\n\\t\\t#elif defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tvClearcoatNormalMapUv\\n\\t\\t#else\\n\\t\\t\\tvUv\\n\\t\\t#endif\\n\\t\\t);\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn[0] *= faceDirection;\\n\\t\\ttbn[1] *= faceDirection;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn2[0] *= faceDirection;\\n\\t\\ttbn2[1] *= faceDirection;\\n\\t#endif\\n#endif\\nvec3 nonPerturbedNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\tnormal = normalize( tbn * mapN );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normal_pars_fragment = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_pars_vertex = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_vertex = \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\\n\\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( uv.st );\\n\\t\\tvec2 st1 = dFdy( uv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\\n\\t\\treturn mat3( T * scale, B * scale, N );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = nonPerturbedNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\";\n\nvar iridescence_pars_fragment = \"#ifdef USE_IRIDESCENCEMAP\\n\\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform sampler2D iridescenceThicknessMap;\\n#endif\";\n\nvar opaque_fragment = \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec2 packDepthToRG( in highp float v ) {\\n\\treturn packDepthToRGBA( v ).yx;\\n}\\nfloat unpackRGToDepth( const in highp vec2 v ) {\\n\\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * depth - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_BATCHING\\n\\tmvPosition = batchingMatrix * mvPosition;\\n#endif\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\\n\\t\\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\t\\n\\t\\tfloat lightToPositionLength = length( lightToPosition );\\n\\t\\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\\n\\t\\t\\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\t\\tdp += shadowBias;\\n\\t\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\t\\tshadow = (\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP )\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition;\\n\\t\\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t\\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\\n\\t\\t#endif\\n\\t\\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\tuniform highp sampler2D boneTexture;\\n\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\tint size = textureSize( boneTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\\n\\tvec3( 1.6605, - 0.1246, - 0.0182 ),\\n\\tvec3( - 0.5876, 1.1329, - 0.1006 ),\\n\\tvec3( - 0.0728, - 0.0083, 1.1187 )\\n);\\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\\n\\tvec3( 0.6274, 0.0691, 0.0164 ),\\n\\tvec3( 0.3293, 0.9195, 0.0880 ),\\n\\tvec3( 0.0433, 0.0113, 0.8956 )\\n);\\nvec3 agxDefaultContrastApprox( vec3 x ) {\\n\\tvec3 x2 = x * x;\\n\\tvec3 x4 = x2 * x2;\\n\\treturn + 15.5 * x4 * x2\\n\\t\\t- 40.14 * x4 * x\\n\\t\\t+ 31.96 * x4\\n\\t\\t- 6.868 * x2 * x\\n\\t\\t+ 0.4298 * x2\\n\\t\\t+ 0.1191 * x\\n\\t\\t- 0.00232;\\n}\\nvec3 AgXToneMapping( vec3 color ) {\\n\\tconst mat3 AgXInsetMatrix = mat3(\\n\\t\\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\\n\\t\\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\\n\\t\\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\\n\\t);\\n\\tconst mat3 AgXOutsetMatrix = mat3(\\n\\t\\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\\n\\t\\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\\n\\t\\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\\n\\t);\\n\\tconst float AgxMinEv = - 12.47393;\\tconst float AgxMaxEv = 4.026069;\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\\n\\tcolor = AgXInsetMatrix * color;\\n\\tcolor = max( color, 1e-10 );\\tcolor = log2( color );\\n\\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\tcolor = agxDefaultContrastApprox( color );\\n\\tcolor = AgXOutsetMatrix * color;\\n\\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\\n\\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\\n\\tcolor = clamp( color, 0.0, 1.0 );\\n\\treturn color;\\n}\\nvec3 NeutralToneMapping( vec3 color ) {\\n\\tconst float StartCompression = 0.8 - 0.04;\\n\\tconst float Desaturation = 0.15;\\n\\tcolor *= toneMappingExposure;\\n\\tfloat x = min( color.r, min( color.g, color.b ) );\\n\\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\\n\\tcolor -= offset;\\n\\tfloat peak = max( color.r, max( color.g, color.b ) );\\n\\tif ( peak < StartCompression ) return color;\\n\\tfloat d = 1. - StartCompression;\\n\\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\\n\\tcolor *= newPeak / peak;\\n\\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\\n\\treturn mix( color, vec3( newPeak ), g );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tmaterial.transmission = transmission;\\n\\tmaterial.transmissionAlpha = 1.0;\\n\\tmaterial.thickness = thickness;\\n\\tmaterial.attenuationDistance = attenuationDistance;\\n\\tmaterial.attenuationColor = attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmitted = getIBLVolumeRefraction(\\n\\t\\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\\n\\t\\tmaterial.attenuationColor, material.attenuationDistance );\\n\\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\\n\\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\\n#endif\";\n\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tfloat w0( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w1( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\\n\\t}\\n\\tfloat w2( float a ){\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w3( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\\t}\\n\\tfloat g0( float a ) {\\n\\t\\treturn w0( a ) + w1( a );\\n\\t}\\n\\tfloat g1( float a ) {\\n\\t\\treturn w2( a ) + w3( a );\\n\\t}\\n\\tfloat h0( float a ) {\\n\\t\\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\\t}\\n\\tfloat h1( float a ) {\\n\\t\\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\\n\\t}\\n\\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\\n\\t\\tuv = uv * texelSize.zw + 0.5;\\n\\t\\tvec2 iuv = floor( uv );\\n\\t\\tvec2 fuv = fract( uv );\\n\\t\\tfloat g0x = g0( fuv.x );\\n\\t\\tfloat g1x = g1( fuv.x );\\n\\t\\tfloat h0x = h0( fuv.x );\\n\\t\\tfloat h1x = h1( fuv.x );\\n\\t\\tfloat h0y = h0( fuv.y );\\n\\t\\tfloat h1y = h1( fuv.y );\\n\\t\\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\\n\\t\\t\\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\\n\\t}\\n\\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\\n\\t\\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\\n\\t\\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\\n\\t\\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\\t\\tvec2 cLodSizeInv = 1.0 / cLodSize;\\n\\t\\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\\t\\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\\t\\treturn mix( fSample, cSample, fract( lod ) );\\n\\t}\\n\\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\\t\\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\\n\\t}\\n\\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tif ( isinf( attenuationDistance ) ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\\t\\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\\t\\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\\n\\t\\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tvec4 transmittedLight;\\n\\t\\tvec3 transmittance;\\n\\t\\t#ifdef USE_DISPERSION\\n\\t\\t\\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\\n\\t\\t\\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\\n\\t\\t\\tfor ( int i = 0; i < 3; i ++ ) {\\n\\t\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\\n\\t\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\n\\t\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\n\\t\\t\\t\\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\\n\\t\\t\\t\\ttransmittedLight[ i ] = transmissionSample[ i ];\\n\\t\\t\\t\\ttransmittedLight.a += transmissionSample.a;\\n\\t\\t\\t\\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\\n\\t\\t\\t}\\n\\t\\t\\ttransmittedLight.a /= 3.0;\\n\\t\\t\\n\\t\\t#else\\n\\t\\t\\n\\t\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\t\\trefractionCoords += 1.0;\\n\\t\\t\\trefractionCoords /= 2.0;\\n\\t\\t\\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\t\\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\t\\n\\t\\t#endif\\n\\t\\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\\n\\t}\\n#endif\";\n\nvar uv_pars_fragment = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform mat3 mapTransform;\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform mat3 alphaMapTransform;\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tuniform mat3 lightMapTransform;\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tuniform mat3 aoMapTransform;\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tuniform mat3 bumpMapTransform;\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tuniform mat3 normalMapTransform;\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tuniform mat3 displacementMapTransform;\\n\\tvarying vec2 vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tuniform mat3 emissiveMapTransform;\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tuniform mat3 metalnessMapTransform;\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tuniform mat3 roughnessMapTransform;\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tuniform mat3 anisotropyMapTransform;\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tuniform mat3 clearcoatMapTransform;\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform mat3 clearcoatNormalMapTransform;\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform mat3 clearcoatRoughnessMapTransform;\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tuniform mat3 sheenColorMapTransform;\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tuniform mat3 sheenRoughnessMapTransform;\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tuniform mat3 iridescenceMapTransform;\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform mat3 iridescenceThicknessMapTransform;\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tuniform mat3 specularMapTransform;\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tuniform mat3 specularColorMapTransform;\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tuniform mat3 specularIntensityMapTransform;\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvUv = vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_BATCHING\\n\\t\\tworldPosition = batchingMatrix * worldPosition;\\n\\t#endif\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nconst vertex$h = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nconst fragment$h = \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$g = \"#ifdef ENVMAP_TYPE_CUBE\\n\\tuniform samplerCube envMap;\\n#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\tuniform sampler2D envMap;\\n#endif\\nuniform float flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float backgroundIntensity;\\nuniform mat3 backgroundRotation;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\\n\\t#else\\n\\t\\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$f = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$f = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = texColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$e = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nconst fragment$e = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\nconst vertex$d = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nconst fragment$d = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nconst vertex$c = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nconst fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$b = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$a = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$a = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$9 = \"#define LAMBERT\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_lambert_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_lambert_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$8 = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nconst fragment$8 = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$7 = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$7 = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\\n\\t#ifdef OPAQUE\\n\\t\\tgl_FragColor.a = 1.0;\\n\\t#endif\\n}\";\n\nconst vertex$6 = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$6 = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$5 = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef USE_SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_DISPERSION\\n\\tuniform float dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tuniform float iridescence;\\n\\tuniform float iridescenceIOR;\\n\\tuniform float iridescenceThicknessMinimum;\\n\\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\tuniform vec2 anisotropyVector;\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tuniform sampler2D anisotropyMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_SHEEN\\n\\t\\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\\t\\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\\n\\t#endif\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$4 = \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$4 = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$3 = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef USE_POINTS_UV\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\nvoid main() {\\n\\t#ifdef USE_POINTS_UV\\n\\t\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\t#endif\\n\\t#include <color_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$3 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$2 = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <batching_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphinstance_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$2 = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst vertex$1 = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$1 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst ShaderChunk = {\n\talphahash_fragment: alphahash_fragment,\n\talphahash_pars_fragment: alphahash_pars_fragment,\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\talphatest_pars_fragment: alphatest_pars_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbatching_pars_vertex: batching_pars_vertex,\n\tbatching_vertex: batching_vertex,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tiridescence_fragment: iridescence_fragment,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tcolorspace_fragment: colorspace_fragment,\n\tcolorspace_pars_fragment: colorspace_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_fragment: lights_lambert_fragment,\n\tlights_lambert_pars_fragment: lights_lambert_pars_fragment,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphinstance_vertex: morphinstance_vertex,\n\tmorphcolor_vertex: morphcolor_vertex,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormal_pars_fragment: normal_pars_fragment,\n\tnormal_pars_vertex: normal_pars_vertex,\n\tnormal_vertex: normal_vertex,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tiridescence_pars_fragment: iridescence_pars_fragment,\n\topaque_fragment: opaque_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmission_fragment: transmission_fragment,\n\ttransmission_pars_fragment: transmission_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_vert: vertex$h,\n\tbackground_frag: fragment$h,\n\tbackgroundCube_vert: vertex$g,\n\tbackgroundCube_frag: fragment$g,\n\tcube_vert: vertex$f,\n\tcube_frag: fragment$f,\n\tdepth_vert: vertex$e,\n\tdepth_frag: fragment$e,\n\tdistanceRGBA_vert: vertex$d,\n\tdistanceRGBA_frag: fragment$d,\n\tequirect_vert: vertex$c,\n\tequirect_frag: fragment$c,\n\tlinedashed_vert: vertex$b,\n\tlinedashed_frag: fragment$b,\n\tmeshbasic_vert: vertex$a,\n\tmeshbasic_frag: fragment$a,\n\tmeshlambert_vert: vertex$9,\n\tmeshlambert_frag: fragment$9,\n\tmeshmatcap_vert: vertex$8,\n\tmeshmatcap_frag: fragment$8,\n\tmeshnormal_vert: vertex$7,\n\tmeshnormal_frag: fragment$7,\n\tmeshphong_vert: vertex$6,\n\tmeshphong_frag: fragment$6,\n\tmeshphysical_vert: vertex$5,\n\tmeshphysical_frag: fragment$5,\n\tmeshtoon_vert: vertex$4,\n\tmeshtoon_frag: fragment$4,\n\tpoints_vert: vertex$3,\n\tpoints_frag: fragment$3,\n\tshadow_vert: vertex$2,\n\tshadow_frag: fragment$2,\n\tsprite_vert: vertex$1,\n\tsprite_frag: fragment$1\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaTest: { value: 0 }\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\t\tspecularMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tenvMapRotation: { value: /*@__PURE__*/ new Matrix3() },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 }, // basic, lambert, phong\n\t\tior: { value: 1.5 }, // physical\n\t\trefractionRatio: { value: 0.98 }, // basic, lambert, phong\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 },\n\t\taoMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 },\n\t\tlightMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tnormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null },\n\t\temissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null },\n\t\tmetalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null },\n\t\troughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotLightMap: { value: [] },\n\t\tspotShadowMap: { value: [] },\n\t\tspotLightMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 },\n\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: /*@__PURE__*/ new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshnormal_vert,\n\t\tfragmentShader: ShaderChunk.meshnormal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t\tbackgroundIntensity: { value: 1 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\n\tbackgroundCube: {\n\n\t\tuniforms: {\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\tbackgroundBlurriness: { value: 0 },\n\t\t\tbackgroundIntensity: { value: 1 },\n\t\t\tbackgroundRotation: { value: /*@__PURE__*/ new Matrix3() }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.backgroundCube_vert,\n\t\tfragmentShader: ShaderChunk.backgroundCube_frag\n\n\t},\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: /*@__PURE__*/ new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: /*@__PURE__*/ new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tclearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tdispersion: { value: 0 },\n\t\t\tiridescence: { value: 0 },\n\t\t\tiridescenceMap: { value: null },\n\t\t\tiridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tiridescenceIOR: { value: 1.3 },\n\t\t\tiridescenceThicknessMinimum: { value: 100 },\n\t\t\tiridescenceThicknessMaximum: { value: 400 },\n\t\t\tiridescenceThicknessMap: { value: null },\n\t\t\tiridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheen: { value: 0 },\n\t\t\tsheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tsheenColorMap: { value: null },\n\t\t\tsheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheenRoughness: { value: 1 },\n\t\t\tsheenRoughnessMap: { value: null },\n\t\t\tsheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t\ttransmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },\n\t\t\ttransmissionSamplerMap: { value: null },\n\t\t\tthickness: { value: 0 },\n\t\t\tthicknessMap: { value: null },\n\t\t\tthicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tattenuationDistance: { value: 0 },\n\t\t\tattenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tspecularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },\n\t\t\tspecularColorMap: { value: null },\n\t\t\tspecularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tspecularIntensity: { value: 1 },\n\t\t\tspecularIntensityMap: { value: null },\n\t\t\tspecularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tanisotropyVector: { value: /*@__PURE__*/ new Vector2() },\n\t\t\tanisotropyMap: { value: null },\n\t\t\tanisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nconst _rgb = { r: 0, b: 0, g: 0 };\nconst _e1$1 = /*@__PURE__*/ new Euler();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction getBackground( scene ) {\n\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\treturn background;\n\n\t}\n\n\tfunction render( scene ) {\n\n\t\tlet forceClear = false;\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\tstate.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t}\n\n\tfunction addToRenderList( renderList, scene ) {\n\n\t\tconst background = getBackground( scene );\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\t_e1$1.copy( scene.backgroundRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;\n\n\t\t\tif ( background.isCubeTexture && background.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1$1.y *= - 1;\n\t\t\t\t_e1$1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tboxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );\n\t\t\tboxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tplaneMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render,\n\t\taddToRenderList: addToRenderList\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, attributes ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\tlet forceUpdate = false;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tconst state = getBindingState( geometry, program, material );\n\n\t\tif ( currentState !== state ) {\n\n\t\t\tcurrentState = state;\n\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t}\n\n\t\tupdateBuffers = needsUpdate( object, geometry, program, index );\n\n\t\tif ( updateBuffers ) saveCache( object, geometry, program, index );\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers || forceUpdate ) {\n\n\t\t\tforceUpdate = false;\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\treturn gl.createVertexArray();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\treturn gl.bindVertexArray( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\treturn gl.deleteVertexArray( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( object, geometry, program, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tconst cachedAttribute = cachedAttributes[ name ];\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\t\tif ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( object, geometry, program, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif ( attribute && attribute.data ) {\n\n\t\t\t\t\tdata.data = attribute.data;\n\n\t\t\t\t}\n\n\t\t\t\tcache[ name ] = data;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tgl.vertexAttribDivisor( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {\n\n\t\tif ( integer === true ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t// check for integer attributes\n\n\t\t\t\t\tconst integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\t\tforceUpdate = true;\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatibility\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < primcount.length; i ++ ) {\n\n\t\t\t\tinfo.update( elementCount, mode, primcount[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters, utils ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction textureFormatReadable( textureFormat ) {\n\n\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction textureTypeReadable( textureType ) {\n\n\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );\n\n\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\ttextureType !== FloatType && ! halfFloatSupportedByExt ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tconst maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tconst maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tconst maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tconst maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tconst maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tconst maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tconst maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\n\tconst maxSamples = gl.getParameter( gl.MAX_SAMPLES );\n\n\treturn {\n\n\t\tisWebGL2: true, // keeping this for backwards compatibility\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\ttextureFormatReadable: textureFormatReadable,\n\t\ttextureTypeReadable: textureTypeReadable,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\n\t};\n\n\tthis.setGlobalState = function ( planes, camera ) {\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = CubeReflectionMapping;\n\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\nlet _oldXrEnabled = false;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported equirectangular image size is 64 x 32.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t * The smallest supported cube size is 16 x 16.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\tthis._renderer.xr.enabled = _oldXrEnabled;\n\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\t\t_oldXrEnabled = this._renderer.xr.enabled;\n\n\t\tthis._renderer.xr.enabled = false;\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction WebGLCubeUVMaps( renderer ) {\n\n\tlet cubeUVmaps = new WeakMap();\n\n\tlet pmremGenerator = null;\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tconst isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );\n\t\t\tconst isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t\t\t// equirect/cube map to cubeUV conversion\n\n\t\t\tif ( isEquirectMap || isCubeMap ) {\n\n\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\n\n\t\t\t\tconst currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;\n\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {\n\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\n\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( renderTarget !== undefined ) {\n\n\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\n\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\n\t\t\t\t\t\t\trenderTarget.texture.pmremVersion = texture.pmremVersion;\n\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction isCubeTextureComplete( image ) {\n\n\t\tlet count = 0;\n\t\tconst length = 6;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t\t}\n\n\t\treturn count === length;\n\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\n\n\t\tif ( cubemapUV !== undefined ) {\n\n\t\t\tcubeUVmaps.delete( texture );\n\t\t\tcubemapUV.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubeUVmaps = new WeakMap();\n\n\t\tif ( pmremGenerator !== null ) {\n\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremGenerator = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function () {\n\n\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\t\t\tgetExtension( 'WEBGL_clip_cull_distance' );\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\t\t\tgetExtension( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tgetExtension( 'WEBGL_render_shared_exponent' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tconst array = geometry.morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.remove( array[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else if ( geometryPosition !== undefined ) {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info ) {\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tgl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\tfunction renderMultiDraw( starts, counts, drawCount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ] / bytesPerElement, counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\tfunction renderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < starts.length; i ++ ) {\n\n\t\t\t\trenderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < primcount.length; i ++ ) {\n\n\t\t\t\tinfo.update( elementCount, mode, primcount[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\tthis.renderMultiDraw = renderMultiDraw;\n\tthis.renderMultiDrawInstances = renderMultiDrawInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase gl.TRIANGLES:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINES:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_STRIP:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_LOOP:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.POINTS:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\n\n\tconst morphTextures = new WeakMap();\n\tconst morph = new Vector4();\n\n\tfunction update( object, geometry, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t\t// into an array of data textures. Each layer represents a single morph target.\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet entry = morphTextures.get( geometry );\n\n\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\t\tlet vertexDataCount = 0;\n\n\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\t\tlet height = 1;\n\n\t\t\tif ( width > capabilities.maxTextureSize ) {\n\n\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\n\t\t\t\twidth = capabilities.maxTextureSize;\n\n\t\t\t}\n\n\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\t\tconst texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\t\ttexture.type = FloatType;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\t// fill buffer\n\n\t\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\n\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\n\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\n\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tentry = {\n\t\t\t\tcount: morphTargetsCount,\n\t\t\t\ttexture: texture,\n\t\t\t\tsize: new Vector2( width, height )\n\t\t\t};\n\n\t\t\tmorphTextures.set( geometry, entry );\n\n\t\t\tfunction disposeTexture() {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tmorphTextures.delete( geometry );\n\n\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t\t}\n\n\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\t//\n\t\tif ( object.isInstancedMesh === true && object.morphTexture !== null ) {\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );\n\n\t\t} else {\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\n\n\t\t}\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tif ( updateMap.get( object ) !== frame ) {\n\n\t\t\t\tattributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );\n\n\t\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\t\tattributes.update( object.instanceColor, gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t\tupdateMap.set( object, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( updateMap.get( skeleton ) !== frame ) {\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\tupdateMap.set( skeleton, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\n\nconst emptyTexture = /*@__PURE__*/ new Texture();\n\nconst emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );\nemptyShadowTexture.compareFunction = LessEqualCompare;\n\nconst emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();\nconst empty3dTexture = /*@__PURE__*/ new Data3DTexture();\nconst emptyCubeTexture = /*@__PURE__*/ new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array or THREE.VectorN)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2i( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3i( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4i( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array or THREE.VectorN)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2ui( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3ui( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\tconst emptyTexture2D = ( this.type === gl.SAMPLER_2D_SHADOW ) ? emptyShadowTexture : emptyTexture;\n\n\ttextures.setTexture2D( v || emptyTexture2D, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || empty3dTexture, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyArrayTexture, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / 3D / Cube / 2DArray)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT3DArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT2DArrayArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );\n\n\t}\n\n}\n\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3DArray;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArrayArray;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nclass SingleUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass PureArrayUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.type = activeInfo.type;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass StructuredUniform {\n\n\tconstructor( id ) {\n\n\t\tthis.id = id;\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\tsetValue( gl, value, textures ) {\n\n\t\tconst seq = this.seq;\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t\t}\n\n\t}\n\n}\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nclass WebGLUniforms {\n\n\tconstructor( gl, program ) {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t\tconst n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tsetValue( gl, name, value, textures ) {\n\n\t\tconst u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n\t}\n\n\tsetOptional( gl, object, name ) {\n\n\t\tconst v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t}\n\n\tstatic upload( gl, seq, values, textures ) {\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic seqWithValue( seq, values ) {\n\n\t\tconst r = [];\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n}\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\n// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/\nconst COMPLETION_STATUS_KHR = 0x91B1;\n\nlet programIdCount = 0;\n\nfunction handleSource( string, errorLine ) {\n\n\tconst lines = string.split( '\\n' );\n\tconst lines2 = [];\n\n\tconst from = Math.max( errorLine - 6, 0 );\n\tconst to = Math.min( errorLine + 6, lines.length );\n\n\tfor ( let i = from; i < to; i ++ ) {\n\n\t\tconst line = i + 1;\n\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t}\n\n\treturn lines2.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( colorSpace ) {\n\n\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\tconst encodingPrimaries = ColorManagement.getPrimaries( colorSpace );\n\n\tlet gamutMapping;\n\n\tif ( workingPrimaries === encodingPrimaries ) {\n\n\t\tgamutMapping = '';\n\n\t} else if ( workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ) {\n\n\t\tgamutMapping = 'LinearDisplayP3ToLinearSRGB';\n\n\t} else if ( workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries ) {\n\n\t\tgamutMapping = 'LinearSRGBToLinearDisplayP3';\n\n\t}\n\n\tswitch ( colorSpace ) {\n\n\t\tcase LinearSRGBColorSpace:\n\t\tcase LinearDisplayP3ColorSpace:\n\t\t\treturn [ gamutMapping, 'LinearTransferOETF' ];\n\n\t\tcase SRGBColorSpace:\n\t\tcase DisplayP3ColorSpace:\n\t\t\treturn [ gamutMapping, 'sRGBTransferOETF' ];\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );\n\t\t\treturn [ gamutMapping, 'LinearTransferOETF' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && errors === '' ) return '';\n\n\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\tif ( errorMatches ) {\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t} else {\n\n\t\treturn errors;\n\n\t}\n\n}\n\nfunction getTexelEncodingFunction( functionName, colorSpace ) {\n\n\tconst components = getEncodingComponents( colorSpace );\n\treturn `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`;\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase AgXToneMapping:\n\t\t\ttoneMappingName = 'AgX';\n\t\t\tbreak;\n\n\t\tcase NeutralToneMapping:\n\t\t\ttoneMappingName = 'Neutral';\n\t\t\tbreak;\n\n\t\tcase CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateVertexExtensions( parameters ) {\n\n\tconst chunks = [\n\t\tparameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',\n\t\tparameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\tlet locationSize = 1;\n\t\tif ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;\n\t\tif ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;\n\t\tif ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = {\n\t\t\ttype: info.type,\n\t\t\tlocation: gl.getAttribLocation( program, name ),\n\t\t\tlocationSize: locationSize\n\t\t};\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\tconst numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nconst shaderChunkMap = new Map();\n\nfunction includeReplacer( match, include ) {\n\n\tlet string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tconst newInclude = shaderChunkMap.get( include );\n\n\t\tif ( newInclude !== undefined ) {\n\n\t\t\tstring = ShaderChunk[ newInclude ];\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, newInclude );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string.replace( unrollLoopPattern, loopReplacer );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = `precision ${parameters.precision} float;\n\tprecision ${parameters.precision} int;\n\tprecision ${parameters.precision} sampler2D;\n\tprecision ${parameters.precision} samplerCube;\n\tprecision ${parameters.precision} sampler3D;\n\tprecision ${parameters.precision} sampler2DArray;\n\tprecision ${parameters.precision} sampler2DShadow;\n\tprecision ${parameters.precision} samplerCubeShadow;\n\tprecision ${parameters.precision} sampler2DArrayShadow;\n\tprecision ${parameters.precision} isampler2D;\n\tprecision ${parameters.precision} isampler3D;\n\tprecision ${parameters.precision} isamplerCube;\n\tprecision ${parameters.precision} isampler2DArray;\n\tprecision ${parameters.precision} usampler2D;\n\tprecision ${parameters.precision} usampler3D;\n\tprecision ${parameters.precision} usamplerCube;\n\tprecision ${parameters.precision} usampler2DArray;\n\t`;\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction generateCubeUVSize( parameters ) {\n\n\tconst imageHeight = parameters.envMapCubeUVHeight;\n\n\tif ( imageHeight === null ) return null;\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\t// TODO Send this event to Three.js DevTools\n\t// console.log( 'WebGLProgram', cacheKey );\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\tconst envMapCubeUVSize = generateCubeUVSize( parameters );\n\n\tconst customVertexExtensions = generateVertexExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',\n\t\t\tparameters.batching ? '#define USE_BATCHING' : '',\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\t\t\tparameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\t//\n\n\t\t\tparameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',\n\t\t\tparameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',\n\t\t\tparameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',\n\t\t\tparameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',\n\t\t\tparameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',\n\t\t\tparameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',\n\t\t\tparameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',\n\t\t\tparameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',\n\n\t\t\tparameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',\n\t\t\tparameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',\n\n\t\t\tparameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',\n\n\t\t\tparameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',\n\t\t\tparameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',\n\t\t\tparameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',\n\n\t\t\tparameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',\n\t\t\tparameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',\n\n\t\t\tparameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',\n\t\t\tparameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',\n\n\t\t\tparameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',\n\t\t\tparameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',\n\t\t\tparameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',\n\n\t\t\tparameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',\n\t\t\tparameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',\n\n\t\t\t//\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE' : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',\n\t\t\t( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_MORPH',\n\n\t\t\t'\tuniform sampler2D morphTexture;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_UV1',\n\n\t\t\t'\tattribute vec2 uv1;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV2',\n\n\t\t\t'\tattribute vec2 uv2;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV3',\n\n\t\t\t'\tattribute vec2 uv3;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoat ? '#define USE_CLEARCOAT' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.dispersion ? '#define USE_DISPERSION' : '',\n\n\t\t\tparameters.iridescence ? '#define USE_IRIDESCENCE' : '',\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaTest ? '#define USE_ALPHATEST' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',\n\n\t\t\tparameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',\n\n\t\t\tparameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\t\t\tparameters.opaque ? '#define OPAQUE' : '',\n\n\t\t\tShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),\n\n\t\t\tparameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\tcustomVertexExtensions,\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\tfunction onFirstUse( self ) {\n\n\t\t// check for link errors\n\t\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\t\trunnable = false;\n\n\t\t\t\tif ( typeof renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\trenderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Material Name: ' + self.name + '\\n' +\n\t\t\t\t\t\t'Material Type: ' + self.type + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\t\thaveDiagnostics = false;\n\n\t\t\t}\n\n\t\t\tif ( haveDiagnostics ) {\n\n\t\t\t\tself.diagnostics = {\n\n\t\t\t\t\trunnable: runnable,\n\n\t\t\t\t\tprogramLog: programLog,\n\n\t\t\t\t\tvertexShader: {\n\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfragmentShader: {\n\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Clean up\n\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t}\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t// Populates cachedUniforms and cachedAttributes\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t// Populates cachedAttributes and cachedUniforms\n\t\t\tonFirstUse( this );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,\n\t// flag the program as ready immediately. It may cause a stall when it's first used.\n\n\tlet programReady = ( parameters.rendererExtensionParallelShaderCompile === false );\n\n\tthis.isReady = function () {\n\n\t\tif ( programReady === false ) {\n\n\t\t\tprogramReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );\n\n\t\t}\n\n\t\treturn programReady;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.type = parameters.shaderType;\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nlet _id$1 = 0;\n\nclass WebGLShaderCache {\n\n\tconstructor() {\n\n\t\tthis.shaderCache = new Map();\n\t\tthis.materialCache = new Map();\n\n\t}\n\n\tupdate( material ) {\n\n\t\tconst vertexShader = material.vertexShader;\n\t\tconst fragmentShader = material.fragmentShader;\n\n\t\tconst vertexShaderStage = this._getShaderStage( vertexShader );\n\t\tconst fragmentShaderStage = this._getShaderStage( fragmentShader );\n\n\t\tconst materialShaders = this._getShaderCacheForMaterial( material );\n\n\t\tif ( materialShaders.has( vertexShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( vertexShaderStage );\n\t\t\tvertexShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\tif ( materialShaders.has( fragmentShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( fragmentShaderStage );\n\t\t\tfragmentShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( material ) {\n\n\t\tconst materialShaders = this.materialCache.get( material );\n\n\t\tfor ( const shaderStage of materialShaders ) {\n\n\t\t\tshaderStage.usedTimes --;\n\n\t\t\tif ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );\n\n\t\t}\n\n\t\tthis.materialCache.delete( material );\n\n\t\treturn this;\n\n\t}\n\n\tgetVertexShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.vertexShader ).id;\n\n\t}\n\n\tgetFragmentShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.fragmentShader ).id;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shaderCache.clear();\n\t\tthis.materialCache.clear();\n\n\t}\n\n\t_getShaderCacheForMaterial( material ) {\n\n\t\tconst cache = this.materialCache;\n\t\tlet set = cache.get( material );\n\n\t\tif ( set === undefined ) {\n\n\t\t\tset = new Set();\n\t\t\tcache.set( material, set );\n\n\t\t}\n\n\t\treturn set;\n\n\t}\n\n\t_getShaderStage( code ) {\n\n\t\tconst cache = this.shaderCache;\n\t\tlet stage = cache.get( code );\n\n\t\tif ( stage === undefined ) {\n\n\t\t\tstage = new WebGLShaderStage( code );\n\t\t\tcache.set( code, stage );\n\n\t\t}\n\n\t\treturn stage;\n\n\t}\n\n}\n\nclass WebGLShaderStage {\n\n\tconstructor( code ) {\n\n\t\tthis.id = _id$1 ++;\n\n\t\tthis.code = code;\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst _programLayers = new Layers();\n\tconst _customShaders = new WebGLShaderCache();\n\tconst _activeChannels = new Set();\n\tconst programs = [];\n\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tfunction getChannel( value ) {\n\n\t\t_activeChannels.add( value );\n\n\t\tif ( value === 0 ) return 'uv';\n\n\t\treturn `uv${ value }`;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst geometry = object.geometry;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\tconst envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet morphTextureStride = 0;\n\n\t\tif ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;\n\t\tif ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;\n\t\tif ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;\n\n\t\t//\n\n\t\tlet vertexShader, fragmentShader;\n\t\tlet customVertexShaderID, customFragmentShaderID;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t\t_customShaders.update( material );\n\n\t\t\tcustomVertexShaderID = _customShaders.getVertexShaderID( material );\n\t\t\tcustomFragmentShaderID = _customShaders.getFragmentShaderID( material );\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst IS_INSTANCEDMESH = object.isInstancedMesh === true;\n\t\tconst IS_BATCHEDMESH = object.isBatchedMesh === true;\n\n\t\tconst HAS_MAP = !! material.map;\n\t\tconst HAS_MATCAP = !! material.matcap;\n\t\tconst HAS_ENVMAP = !! envMap;\n\t\tconst HAS_AOMAP = !! material.aoMap;\n\t\tconst HAS_LIGHTMAP = !! material.lightMap;\n\t\tconst HAS_BUMPMAP = !! material.bumpMap;\n\t\tconst HAS_NORMALMAP = !! material.normalMap;\n\t\tconst HAS_DISPLACEMENTMAP = !! material.displacementMap;\n\t\tconst HAS_EMISSIVEMAP = !! material.emissiveMap;\n\n\t\tconst HAS_METALNESSMAP = !! material.metalnessMap;\n\t\tconst HAS_ROUGHNESSMAP = !! material.roughnessMap;\n\n\t\tconst HAS_ANISOTROPY = material.anisotropy > 0;\n\t\tconst HAS_CLEARCOAT = material.clearcoat > 0;\n\t\tconst HAS_DISPERSION = material.dispersion > 0;\n\t\tconst HAS_IRIDESCENCE = material.iridescence > 0;\n\t\tconst HAS_SHEEN = material.sheen > 0;\n\t\tconst HAS_TRANSMISSION = material.transmission > 0;\n\n\t\tconst HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;\n\n\t\tconst HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;\n\t\tconst HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;\n\t\tconst HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;\n\n\t\tconst HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;\n\t\tconst HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;\n\n\t\tconst HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;\n\t\tconst HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;\n\n\t\tconst HAS_SPECULARMAP = !! material.specularMap;\n\t\tconst HAS_SPECULAR_COLORMAP = !! material.specularColorMap;\n\t\tconst HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;\n\n\t\tconst HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;\n\t\tconst HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;\n\n\t\tconst HAS_GRADIENTMAP = !! material.gradientMap;\n\n\t\tconst HAS_ALPHAMAP = !! material.alphaMap;\n\n\t\tconst HAS_ALPHATEST = material.alphaTest > 0;\n\n\t\tconst HAS_ALPHAHASH = !! material.alphaHash;\n\n\t\tconst HAS_EXTENSIONS = !! material.extensions;\n\n\t\tlet toneMapping = NoToneMapping;\n\n\t\tif ( material.toneMapped ) {\n\n\t\t\tif ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\ttoneMapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst parameters = {\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderType: material.type,\n\t\t\tshaderName: material.name,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tcustomVertexShaderID: customVertexShaderID,\n\t\t\tcustomFragmentShaderID: customFragmentShaderID,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tbatching: IS_BATCHEDMESH,\n\t\t\tinstancing: IS_INSTANCEDMESH,\n\t\t\tinstancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,\n\t\t\tinstancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,\n\n\t\t\tsupportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,\n\t\t\toutputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),\n\t\t\talphaToCoverage: !! material.alphaToCoverage,\n\n\t\t\tmap: HAS_MAP,\n\t\t\tmatcap: HAS_MATCAP,\n\t\t\tenvMap: HAS_ENVMAP,\n\t\t\tenvMapMode: HAS_ENVMAP && envMap.mapping,\n\t\t\tenvMapCubeUVHeight: envMapCubeUVHeight,\n\t\t\taoMap: HAS_AOMAP,\n\t\t\tlightMap: HAS_LIGHTMAP,\n\t\t\tbumpMap: HAS_BUMPMAP,\n\t\t\tnormalMap: HAS_NORMALMAP,\n\t\t\tdisplacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,\n\t\t\temissiveMap: HAS_EMISSIVEMAP,\n\n\t\t\tnormalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,\n\t\t\tnormalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,\n\n\t\t\tmetalnessMap: HAS_METALNESSMAP,\n\t\t\troughnessMap: HAS_ROUGHNESSMAP,\n\n\t\t\tanisotropy: HAS_ANISOTROPY,\n\t\t\tanisotropyMap: HAS_ANISOTROPYMAP,\n\n\t\t\tclearcoat: HAS_CLEARCOAT,\n\t\t\tclearcoatMap: HAS_CLEARCOATMAP,\n\t\t\tclearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n\t\t\tclearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,\n\n\t\t\tdispersion: HAS_DISPERSION,\n\n\t\t\tiridescence: HAS_IRIDESCENCE,\n\t\t\tiridescenceMap: HAS_IRIDESCENCEMAP,\n\t\t\tiridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n\n\t\t\tsheen: HAS_SHEEN,\n\t\t\tsheenColorMap: HAS_SHEEN_COLORMAP,\n\t\t\tsheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n\n\t\t\tspecularMap: HAS_SPECULARMAP,\n\t\t\tspecularColorMap: HAS_SPECULAR_COLORMAP,\n\t\t\tspecularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n\n\t\t\ttransmission: HAS_TRANSMISSION,\n\t\t\ttransmissionMap: HAS_TRANSMISSIONMAP,\n\t\t\tthicknessMap: HAS_THICKNESSMAP,\n\n\t\t\tgradientMap: HAS_GRADIENTMAP,\n\n\t\t\topaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,\n\n\t\t\talphaMap: HAS_ALPHAMAP,\n\t\t\talphaTest: HAS_ALPHATEST,\n\t\t\talphaHash: HAS_ALPHAHASH,\n\n\t\t\tcombine: material.combine,\n\n\t\t\t//\n\n\t\t\tmapUv: HAS_MAP && getChannel( material.map.channel ),\n\t\t\taoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),\n\t\t\tlightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),\n\t\t\tbumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),\n\t\t\tnormalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),\n\t\t\tdisplacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),\n\t\t\temissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),\n\n\t\t\tmetalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),\n\t\t\troughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),\n\n\t\t\tanisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),\n\n\t\t\tclearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),\n\t\t\tclearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),\n\t\t\tclearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),\n\n\t\t\tiridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),\n\t\t\tiridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),\n\n\t\t\tsheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),\n\t\t\tsheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),\n\n\t\t\tspecularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),\n\t\t\tspecularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),\n\t\t\tspecularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),\n\n\t\t\ttransmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),\n\t\t\tthicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),\n\n\t\t\talphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),\n\n\t\t\t//\n\n\t\t\tvertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n\n\t\t\tpointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog === true,\n\t\t\tfogExp2: ( !! fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading === true,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation === true,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tskinning: object.isSkinnedMesh === true,\n\n\t\t\tmorphTargets: geometry.morphAttributes.position !== undefined,\n\t\t\tmorphNormals: geometry.morphAttributes.normal !== undefined,\n\t\t\tmorphColors: geometry.morphAttributes.color !== undefined,\n\t\t\tmorphTargetsCount: morphTargetsCount,\n\t\t\tmorphTextureStride: morphTextureStride,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumSpotLightMaps: lights.spotLightMap.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\tnumSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,\n\n\t\t\tnumLightProbes: lights.numLightProbes,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: toneMapping,\n\t\t\tuseLegacyLights: renderer._useLegacyLights,\n\n\t\t\tdecodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tuseDepthPacking: material.depthPacking >= 0,\n\t\t\tdepthPacking: material.depthPacking || 0,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),\n\t\t\textensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === true && extensions.has( 'WEBGL_multi_draw' ),\n\n\t\t\trendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\t// the usage of getChannel() determines the active texture channels for this shader\n\n\t\tparameters.vertexUv1s = _activeChannels.has( 1 );\n\t\tparameters.vertexUv2s = _activeChannels.has( 2 );\n\t\tparameters.vertexUv3s = _activeChannels.has( 3 );\n\n\t\t_activeChannels.clear();\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.customVertexShaderID );\n\t\t\tarray.push( parameters.customFragmentShaderID );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tgetProgramCacheKeyParameters( array, parameters );\n\t\t\tgetProgramCacheKeyBooleans( array, parameters );\n\t\t\tarray.push( renderer.outputColorSpace );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getProgramCacheKeyParameters( array, parameters ) {\n\n\t\tarray.push( parameters.precision );\n\t\tarray.push( parameters.outputColorSpace );\n\t\tarray.push( parameters.envMapMode );\n\t\tarray.push( parameters.envMapCubeUVHeight );\n\t\tarray.push( parameters.mapUv );\n\t\tarray.push( parameters.alphaMapUv );\n\t\tarray.push( parameters.lightMapUv );\n\t\tarray.push( parameters.aoMapUv );\n\t\tarray.push( parameters.bumpMapUv );\n\t\tarray.push( parameters.normalMapUv );\n\t\tarray.push( parameters.displacementMapUv );\n\t\tarray.push( parameters.emissiveMapUv );\n\t\tarray.push( parameters.metalnessMapUv );\n\t\tarray.push( parameters.roughnessMapUv );\n\t\tarray.push( parameters.anisotropyMapUv );\n\t\tarray.push( parameters.clearcoatMapUv );\n\t\tarray.push( parameters.clearcoatNormalMapUv );\n\t\tarray.push( parameters.clearcoatRoughnessMapUv );\n\t\tarray.push( parameters.iridescenceMapUv );\n\t\tarray.push( parameters.iridescenceThicknessMapUv );\n\t\tarray.push( parameters.sheenColorMapUv );\n\t\tarray.push( parameters.sheenRoughnessMapUv );\n\t\tarray.push( parameters.specularMapUv );\n\t\tarray.push( parameters.specularColorMapUv );\n\t\tarray.push( parameters.specularIntensityMapUv );\n\t\tarray.push( parameters.transmissionMapUv );\n\t\tarray.push( parameters.thicknessMapUv );\n\t\tarray.push( parameters.combine );\n\t\tarray.push( parameters.fogExp2 );\n\t\tarray.push( parameters.sizeAttenuation );\n\t\tarray.push( parameters.morphTargetsCount );\n\t\tarray.push( parameters.morphAttributeCount );\n\t\tarray.push( parameters.numDirLights );\n\t\tarray.push( parameters.numPointLights );\n\t\tarray.push( parameters.numSpotLights );\n\t\tarray.push( parameters.numSpotLightMaps );\n\t\tarray.push( parameters.numHemiLights );\n\t\tarray.push( parameters.numRectAreaLights );\n\t\tarray.push( parameters.numDirLightShadows );\n\t\tarray.push( parameters.numPointLightShadows );\n\t\tarray.push( parameters.numSpotLightShadows );\n\t\tarray.push( parameters.numSpotLightShadowsWithMaps );\n\t\tarray.push( parameters.numLightProbes );\n\t\tarray.push( parameters.shadowMapType );\n\t\tarray.push( parameters.toneMapping );\n\t\tarray.push( parameters.numClippingPlanes );\n\t\tarray.push( parameters.numClipIntersection );\n\t\tarray.push( parameters.depthPacking );\n\n\t}\n\n\tfunction getProgramCacheKeyBooleans( array, parameters ) {\n\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.supportsVertexTextures )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.instancing )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.instancingColor )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.instancingMorph )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.matcap )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.envMap )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.normalMapObjectSpace )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.normalMapTangentSpace )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.clearcoat )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.iridescence )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.alphaTest )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.vertexColors )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.vertexAlphas )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.vertexUv1s )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.vertexUv2s )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.vertexUv3s )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.vertexTangents )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.anisotropy )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.alphaHash )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.batching )\n\t\t\t_programLayers.enable( 19 );\n\t\tif ( parameters.dispersion )\n\t\t\t_programLayers.enable( 20 );\n\n\t\tarray.push( _programLayers.mask );\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.fog )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.useFog )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.flatShading )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.logarithmicDepthBuffer )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.skinning )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.morphTargets )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.morphNormals )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.morphColors )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.premultipliedAlpha )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.shadowMapEnabled )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.useLegacyLights )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.doubleSided )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.flipSided )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.useDepthPacking )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.dithering )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.transmission )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.sheen )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.opaque )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.pointsUvs )\n\t\t\t_programLayers.enable( 18 );\n\t\tif ( parameters.decodeVideoTexture )\n\t\t\t_programLayers.enable( 19 );\n\t\tif ( parameters.alphaToCoverage )\n\t\t\t_programLayers.enable( 20 );\n\n\t\tarray.push( _programLayers.mask );\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\tfunction releaseShaderCache( material ) {\n\n\t\t_customShaders.remove( material );\n\n\t}\n\n\tfunction dispose() {\n\n\t\t_customShaders.dispose();\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\treleaseShaderCache: releaseShaderCache,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transmissive = [];\n\tconst transparent = [];\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransmissive.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.push( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.unshift( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransmissive: transmissive,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tconst listArray = lists.get( scene );\n\t\tlet list;\n\n\t\tif ( listArray === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= listArray.length ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tlistArray.push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = listArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingAndTexturingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1,\n\t\t\tnumSpotMaps: - 1,\n\n\t\t\tnumLightProbes: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotLightMap: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotLightMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\t\tnumSpotLightShadowsWithMaps: 0,\n\t\tnumLightProbes: 0\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights, useLegacyLights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\t\tlet numSpotMaps = 0;\n\t\tlet numSpotShadowsWithMaps = 0;\n\n\t\tlet numLightProbes = 0;\n\n\t\t// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n\t\tlights.sort( shadowCastingAndTexturingLightsFirst );\n\n\t\t// artist-friendly light intensity scaling factor\n\t\tconst scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity * scaleFactor;\n\t\t\t\tg += color.g * intensity * scaleFactor;\n\t\t\t\tb += color.b * intensity * scaleFactor;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t\tnumLightProbes ++;\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif ( light.map ) {\n\n\t\t\t\t\tstate.spotLightMap[ numSpotMaps ] = light.map;\n\t\t\t\t\tnumSpotMaps ++;\n\n\t\t\t\t\t// make sure the lightMatrix is up to date\n\t\t\t\t\t// TODO : do it if required only\n\t\t\t\t\tshadow.updateMatrices( light );\n\n\t\t\t\t\tif ( light.castShadow ) numSpotShadowsWithMaps ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotLightMatrix[ spotLength ] = shadow.matrix;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ||\n\t\t\thash.numSpotMaps !== numSpotMaps ||\n\t\t\thash.numLightProbes !== numLightProbes ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n\t\t\tstate.spotLightMap.length = numSpotMaps;\n\t\t\tstate.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n\t\t\tstate.numLightProbes = numLightProbes;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\thash.numSpotMaps = numSpotMaps;\n\n\t\t\thash.numLightProbes = numLightProbes;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions ) {\n\n\tconst lights = new WebGLLights( extensions );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init( camera ) {\n\n\t\tstate.camera = camera;\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights( useLegacyLights ) {\n\n\t\tlights.setup( lightsArray, useLegacyLights );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tcamera: null,\n\n\t\tlights: lights,\n\n\t\ttransmissionRenderTarget: {}\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tconst renderStateArray = renderStates.get( scene );\n\t\tlet renderState;\n\n\t\tif ( renderStateArray === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStateArray.length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions );\n\t\t\t\trenderStateArray.push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStateArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst vertex = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nconst fragment = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nfunction WebGLShadowMap( renderer, objects, capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = capabilities.maxTextureSize;\n\n\tconst shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vertex,\n\t\tfragmentShader: fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\tlet _previousType = this.type;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst activeCubeFace = renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst _state = renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// check for shadow map type changes\n\n\t\tconst toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );\n\t\tconst fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null || toVSM === true || fromVSM === true ) {\n\n\t\t\t\tconst pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n\n\t\t\t\tif ( shadow.map !== null ) {\n\n\t\t\t\t\tshadow.map.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( shadow.map );\n\t\t\trenderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\t_previousType = this.type;\n\n\t\tscope.needsUpdate = false;\n\n\t\trenderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.mapPass );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\trenderer.setRenderTarget( shadow.map );\n\t\trenderer.clear();\n\t\trenderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t\tif ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t\t( material.map && material.alphaTest > 0 ) ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = material.alphaTest;\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tconst materialProperties = renderer.properties.get( result );\n\t\t\tmaterialProperties.light = light;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, type );\n\n\t\t\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, type );\n\n\t\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t\trenderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t// make sure to remove the unique distance/depth materials used for shadow map rendering\n\n\t\tfor ( const id in _materialCache ) {\n\n\t\t\tconst cache = _materialCache[ id ];\n\n\t\t\tconst uuid = event.target.uuid;\n\n\t\t\tif ( uuid in cache ) {\n\n\t\t\t\tconst shadowMaterial = cache[ uuid ];\n\t\t\t\tshadowMaterial.dispose();\n\t\t\t\tdelete cache[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction WebGLState( gl ) {\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tconst uboBindings = new WeakMap();\n\tconst uboProgramMap = new WeakMap();\n\n\tlet enabledCapabilities = {};\n\n\tlet currentBoundFramebuffers = {};\n\tlet currentDrawbuffers = new WeakMap();\n\tlet defaultDrawbuffers = [];\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentBlendColor = new Color( 0, 0, 0 );\n\tlet currentBlendAlpha = 0;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( gl.VERSION );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\tconst currentScissor = new Vector4().fromArray( scissorParam );\n\tconst currentViewport = new Vector4().fromArray( viewportParam );\n\n\tfunction createTexture( type, target, count, dimensions ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tif ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tgl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t} else {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\temptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );\n\temptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( gl.DEPTH_TEST );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( gl.CULL_FACE );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction drawBuffers( renderTarget, framebuffer ) {\n\n\t\tlet drawBuffers = defaultDrawbuffers;\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tdrawBuffers = currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tcurrentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t};\n\n\tequationToGL[ MinEquation ] = gl.MIN;\n\tequationToGL[ MaxEquation ] = gl.MAX;\n\n\tconst factorToGL = {\n\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t[ OneFactor ]: gl.ONE,\n\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,\n\t\t[ ConstantColorFactor ]: gl.CONSTANT_COLOR,\n\t\t[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,\n\t\t[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,\n\t\t[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( gl.BLEND );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( gl.BLEND );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\tcurrentBlendColor.set( 0, 0, 0 );\n\t\t\t\tcurrentBlendAlpha = 0;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tif ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {\n\n\t\t\tgl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );\n\n\t\t\tcurrentBlendColor.copy( blendColor );\n\t\t\tcurrentBlendAlpha = blendAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = false;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( gl.CULL_FACE )\n\t\t\t: enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\tfunction updateUBOMapping( uniformsGroup, program ) {\n\n\t\tlet mapping = uboProgramMap.get( program );\n\n\t\tif ( mapping === undefined ) {\n\n\t\t\tmapping = new WeakMap();\n\n\t\t\tuboProgramMap.set( program, mapping );\n\n\t\t}\n\n\t\tlet blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( blockIndex === undefined ) {\n\n\t\t\tblockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );\n\n\t\t\tmapping.set( uniformsGroup, blockIndex );\n\n\t\t}\n\n\t}\n\n\tfunction uniformBlockBinding( uniformsGroup, program ) {\n\n\t\tconst mapping = uboProgramMap.get( program );\n\t\tconst blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( uboBindings.get( program ) !== blockIndex ) {\n\n\t\t\t// bind shader specific block index to global block point\n\t\t\tgl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );\n\n\t\t\tuboBindings.set( program, blockIndex );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( gl.BLEND );\n\t\tgl.disable( gl.CULL_FACE );\n\t\tgl.disable( gl.DEPTH_TEST );\n\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\n\t\tgl.disable( gl.SCISSOR_TEST );\n\t\tgl.disable( gl.STENCIL_TEST );\n\t\tgl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\tgl.blendFunc( gl.ONE, gl.ZERO );\n\t\tgl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );\n\t\tgl.blendColor( 0, 0, 0, 0 );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( gl.LESS );\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );\n\t\tgl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( gl.BACK );\n\t\tgl.frontFace( gl.CCW );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( gl.TEXTURE0 );\n\n\t\tgl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBoundFramebuffers = {};\n\t\tcurrentDrawbuffers = new WeakMap();\n\t\tdefaultDrawbuffers = [];\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentBlendColor = new Color( 0, 0, 0 );\n\t\tcurrentBlendAlpha = 0;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tdrawBuffers: drawBuffers,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\tcompressedTexImage3D: compressedTexImage3D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tupdateUBOMapping: updateUBOMapping,\n\t\tuniformBlockBinding: uniformBlockBinding,\n\n\t\ttexStorage2D: texStorage2D,\n\t\ttexStorage3D: texStorage3D,\n\t\ttexSubImage2D: texSubImage2D,\n\t\ttexSubImage3D: texSubImage3D,\n\t\tcompressedTexSubImage2D: compressedTexSubImage2D,\n\t\tcompressedTexSubImage3D: compressedTexSubImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;\n\tconst supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\tconst _imageDimensions = new Vector2();\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\tconst _sources = new WeakMap(); // maps WebglTexture objects to instances of Source\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\tnew OffscreenCanvas( width, height ) : createElementNS( 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\tconst dimensions = getDimensions( image );\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( dimensions.width > maxSize || dimensions.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( dimensions.width, dimensions.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {\n\n\t\t\t\tconst width = Math.floor( scale * dimensions.width );\n\t\t\t\tconst height = Math.floor( scale * dimensions.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture ) {\n\n\t\treturn texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === _gl.RED ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.R8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.R16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;\n\t\t\tif ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;\n\t\t\tif ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;\n\t\t\tif ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;\n\t\t\tif ( glType === _gl.INT ) internalFormat = _gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGB ) {\n\n\t\t\tif ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGBA ) {\n\n\t\t\tconst transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||\n\t\t\tinternalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||\n\t\t\tinternalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tfunction getMipLevels( texture, image ) {\n\n\t\tif ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {\n\n\t\t\treturn Math.log2( Math.max( image.width, image.height ) ) + 1;\n\n\t\t} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {\n\n\t\t\t// user-defined mipmaps\n\n\t\t\treturn texture.mipmaps.length;\n\n\t\t} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {\n\n\t\t\treturn image.mipmaps.length;\n\n\t\t} else {\n\n\t\t\t// texture without mipmaps (only base level)\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t// check if it's necessary to remove the WebGLTexture object\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures ) {\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\t\t\twebglTexture.usedTimes --;\n\n\t\t\t// the WebGLTexture object is not used anymore, remove it\n\n\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\tdeleteTexture( texture );\n\n\t\t\t}\n\n\t\t\t// remove the weak map entry if no WebGLTexture uses the source anymore\n\n\t\t\tif ( Object.keys( webglTextures ).length === 0 ) {\n\n\t\t\t\t_sources.delete( source );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deleteTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\t\tdelete webglTextures[ textureProperties.__cacheKey ];\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {\n\n\t\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {\n\n\t\t\t\tfor ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) {\n\n\t\t\t\tfor ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\tif ( attachmentProperties.__webglTexture ) {\n\n\t\t\t\t_gl.deleteTexture( attachmentProperties.__webglTexture );\n\n\t\t\t\tinfo.memory.textures --;\n\n\t\t\t}\n\n\t\t\tproperties.remove( textures[ i ] );\n\n\t\t}\n\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tfunction getTextureCacheKey( texture ) {\n\n\t\tconst array = [];\n\n\t\tarray.push( texture.wrapS );\n\t\tarray.push( texture.wrapT );\n\t\tarray.push( texture.wrapR || 0 );\n\t\tarray.push( texture.magFilter );\n\t\tarray.push( texture.minFilter );\n\t\tarray.push( texture.anisotropy );\n\t\tarray.push( texture.internalFormat );\n\t\tarray.push( texture.format );\n\t\tarray.push( texture.type );\n\t\tarray.push( texture.generateMipmaps );\n\t\tarray.push( texture.premultiplyAlpha );\n\t\tarray.push( texture.flipY );\n\t\tarray.push( texture.unpackAlignment );\n\t\tarray.push( texture.colorSpace );\n\n\t\treturn array.join();\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ RepeatWrapping ]: _gl.REPEAT,\n\t\t[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,\n\t\t[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT\n\t};\n\n\tconst filterToGL = {\n\t\t[ NearestFilter ]: _gl.NEAREST,\n\t\t[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t[ LinearFilter ]: _gl.LINEAR,\n\t\t[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR\n\t};\n\n\tconst compareToGL = {\n\t\t[ NeverCompare ]: _gl.NEVER,\n\t\t[ AlwaysCompare ]: _gl.ALWAYS,\n\t\t[ LessCompare ]: _gl.LESS,\n\t\t[ LessEqualCompare ]: _gl.LEQUAL,\n\t\t[ EqualCompare ]: _gl.EQUAL,\n\t\t[ GreaterEqualCompare ]: _gl.GEQUAL,\n\t\t[ GreaterCompare ]: _gl.GREATER,\n\t\t[ NotEqualCompare ]: _gl.NOTEQUAL\n\t};\n\n\tfunction setTextureParameters( textureType, texture ) {\n\n\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&\n\t\t\t( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tlet forceUpload = false;\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t}\n\n\t\t// create Source <-> WebGLTextures mapping if necessary\n\n\t\tconst source = texture.source;\n\t\tlet webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures === undefined ) {\n\n\t\t\twebglTextures = {};\n\t\t\t_sources.set( source, webglTextures );\n\n\t\t}\n\n\t\t// check if there is already a WebGLTexture object for the given texture parameters\n\n\t\tconst textureCacheKey = getTextureCacheKey( texture );\n\n\t\tif ( textureCacheKey !== textureProperties.__cacheKey ) {\n\n\t\t\t// if not, create a new instance of WebGLTexture\n\n\t\t\tif ( webglTextures[ textureCacheKey ] === undefined ) {\n\n\t\t\t\t// create new entry\n\n\t\t\t\twebglTextures[ textureCacheKey ] = {\n\t\t\t\t\ttexture: _gl.createTexture(),\n\t\t\t\t\tusedTimes: 0\n\t\t\t\t};\n\n\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t// when a new instance of WebGLTexture was created, a texture upload is required\n\t\t\t\t// even if the image contents are identical\n\n\t\t\t\tforceUpload = true;\n\n\t\t\t}\n\n\t\t\twebglTextures[ textureCacheKey ].usedTimes ++;\n\n\t\t\t// every time the texture cache key changes, it's necessary to check if an instance of\n\t\t\t// WebGLTexture can be deleted in order to avoid a memory leak.\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\n\t\t\tif ( webglTexture !== undefined ) {\n\n\t\t\t\twebglTextures[ textureProperties.__cacheKey ].usedTimes --;\n\n\t\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// store references to cache key and WebGLTexture object\n\n\t\t\ttextureProperties.__cacheKey = textureCacheKey;\n\t\t\ttextureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;\n\n\t\t}\n\n\t\treturn forceUpload;\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = _gl.TEXTURE_2D;\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\tif ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tlet image = resizeImage( texture.image, false, capabilities.maxTextureSize );\n\t\t\timage = verifyColorSpace( texture, image );\n\n\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\n\t\t\tconst glType = utils.convert( texture.type );\n\t\t\tlet glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\t\tsetTextureParameters( textureType, texture );\n\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tconst levels = getMipLevels( texture, image );\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t\t} else if ( texture.type === UnsignedInt248Type ) {\n\n\t\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isFramebufferTexture ) {\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet width = image.width, height = image.height;\n\n\t\t\t\t\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t\t\t\t\twidth >>= 1;\n\t\t\t\t\t\t\theight >>= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tconst dimensions = getDimensions( mipmaps[ 0 ] );\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tconst dimensions = getDimensions( image );\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( textureType );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\t\t\tconst texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );\n\t\t\tconst unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\t\tconst isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );\n\t\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );\n\n\t\t\t}\n\n\t\t\tconst image = cubeImage[ 0 ],\n\t\t\t\tglFormat = utils.convert( texture.format, texture.colorSpace ),\n\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\n\t\t\tconst useTexStorage = ( texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst dataReady = source.dataReady;\n\t\t\tlet levels = getMipLevels( texture, image );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tlet mipmaps;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t// TODO: Uniformly handle mipmap definitions\n\t\t\t\t\t// Normal textures and compressed cube textures define base level + mips with their mipmap array\n\t\t\t\t\t// Uncompressed cube textures use their mipmap array only for mips (no base level)\n\n\t\t\t\t\tif ( mipmaps.length > 0 ) levels ++;\n\n\t\t\t\t\tconst dimensions = getDimensions( cubeImage[ 0 ] );\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tif ( dataReady ) {\n\n\t\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {\n\n\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( ! renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\tconst width = Math.max( 1, renderTarget.width >> level );\n\t\t\tconst height = Math.max( 1, renderTarget.height >> level );\n\n\t\t\tif ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tstate.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );\n\n\t\t} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753\n\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( isMultisample || useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === FloatType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t} else if ( depthTexture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );\n\n\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\tconst textures = renderTarget.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\tif ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// rebind framebuffer with external textures\n\tfunction rebindTextures( renderTarget, colorTexture, depthTexture ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( colorTexture !== undefined ) {\n\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );\n\n\t\t}\n\n\t\tif ( depthTexture !== undefined ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\tif ( ! isMultipleRenderTargets ) {\n\n\t\t\tif ( textureProperties.__webglTexture === undefined ) {\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = [];\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\t\t\tif ( attachmentProperties.__webglTexture === undefined ) {\n\n\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = [];\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else if ( isMultipleRenderTargets ) {\n\n\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachment = textures[ i ];\n\t\t\t\tconst attachmentProperties = properties.get( attachment );\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, attachment );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( attachment ) ) {\n\n\t\t\t\t\tgenerateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else {\n\n\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\tif ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {\n\n\t\t\t\tglTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture );\n\n\t\t\tif ( texture.mipmaps && texture.mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let level = 0; level < texture.mipmaps.length; level ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tgenerateMipmap( glTextureType );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture ) ) {\n\n\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\tgenerateMipmap( target );\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst invalidationArrayRead = [];\n\tconst invalidationArrayDraw = [];\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.samples > 0 ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\tconst textures = renderTarget.textures;\n\t\t\t\tconst width = renderTarget.width;\n\t\t\t\tconst height = renderTarget.height;\n\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tconst isMultipleRenderTargets = ( textures.length > 1 );\n\n\t\t\t\t// If MRT we need to remove FBO attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTarget.resolveDepthBuffer ) {\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;\n\n\t\t\t\t\t\t// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)\n\n\t\t\t\t\t\tif ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );\n\n\t\t\t\t\tif ( supportsInvalidateFramebuffer === true ) {\n\n\t\t\t\t\t\tinvalidationArrayRead.length = 0;\n\t\t\t\t\t\tinvalidationArrayDraw.length = 0;\n\n\t\t\t\t\t\tinvalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {\n\n\t\t\t\t\t\t\tinvalidationArrayRead.push( depthStyle );\n\t\t\t\t\t\t\tinvalidationArrayDraw.push( depthStyle );\n\n\t\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t\t// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\n\t\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {\n\n\t\t\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn Math.min( capabilities.maxSamples, renderTarget.samples );\n\n\t}\n\n\tfunction useMultisampledRTT( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\treturn renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\tfunction verifyColorSpace( texture, image ) {\n\n\t\tconst colorSpace = texture.colorSpace;\n\t\tconst format = texture.format;\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;\n\n\t\tif ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {\n\n\t\t\t// sRGB\n\n\t\t\tif ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {\n\n\t\t\t\t// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n\n\t\t\t\tif ( format !== RGBAFormat || type !== UnsignedByteType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction getDimensions( image ) {\n\n\t\tif ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {\n\n\t\t\t// if intrinsic data are not available, fallback to width/height\n\n\t\t\t_imageDimensions.width = image.naturalWidth || image.width;\n\t\t\t_imageDimensions.height = image.naturalHeight || image.height;\n\n\t\t} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {\n\n\t\t\t_imageDimensions.width = image.displayWidth;\n\t\t\t_imageDimensions.height = image.displayHeight;\n\n\t\t} else {\n\n\t\t\t_imageDimensions.width = image.width;\n\t\t\t_imageDimensions.height = image.height;\n\n\t\t}\n\n\t\treturn _imageDimensions;\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.rebindTextures = rebindTextures;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\tthis.setupDepthRenderbuffer = setupDepthRenderbuffer;\n\tthis.setupFrameBufferTexture = setupFrameBufferTexture;\n\tthis.useMultisampledRTT = useMultisampledRTT;\n\n}\n\nfunction WebGLUtils( gl, extensions ) {\n\n\tfunction convert( p, colorSpace = NoColorSpace ) {\n\n\t\tlet extension;\n\n\t\tconst transfer = ColorManagement.getTransfer( colorSpace );\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\t\tif ( p === HalfFloatType ) return gl.HALF_FLOAT;\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( transfer === SRGBTransfer ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\t\t\t\tif ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;\n\t\t\t\tif ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tconnect( inputSource ) {\n\n\t\tif ( inputSource && inputSource.hand ) {\n\n\t\t\tconst hand = this._hand;\n\n\t\t\tif ( hand ) {\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Initialize hand with joints when connected\n\t\t\t\t\tthis._getHandJoint( hand, inputjoint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\tconst joint = this._getHandJoint( hand, inputjoint );\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\t\t\t\t\t\tgrip.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\t// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n\t\t\t\tif ( inputPose === null && gripPose !== null ) {\n\n\t\t\t\t\tinputPose = gripPose;\n\n\t\t\t\t}\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\t\t\t\t\ttargetRay.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// private method\n\n\t_getHandJoint( hand, inputjoint ) {\n\n\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\tconst joint = new Group();\n\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\tjoint.visible = false;\n\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\n\t\t\thand.add( joint );\n\n\t\t}\n\n\t\treturn hand.joints[ inputjoint.jointName ];\n\n\t}\n\n}\n\nconst _occlusion_vertex = `\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}`;\n\nconst _occlusion_fragment = `\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}`;\n\nclass WebXRDepthSensing {\n\n\tconstructor() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t\tthis.depthNear = 0;\n\t\tthis.depthFar = 0;\n\n\t}\n\n\tinit( renderer, depthData, renderState ) {\n\n\t\tif ( this.texture === null ) {\n\n\t\t\tconst texture = new Texture();\n\n\t\t\tconst texProps = renderer.properties.get( texture );\n\t\t\ttexProps.__webglTexture = depthData.texture;\n\n\t\t\tif ( ( depthData.depthNear != renderState.depthNear ) || ( depthData.depthFar != renderState.depthFar ) ) {\n\n\t\t\t\tthis.depthNear = depthData.depthNear;\n\t\t\t\tthis.depthFar = depthData.depthFar;\n\n\t\t\t}\n\n\t\t\tthis.texture = texture;\n\n\t\t}\n\n\t}\n\n\trender( renderer, cameraXR ) {\n\n\t\tif ( this.texture !== null ) {\n\n\t\t\tif ( this.mesh === null ) {\n\n\t\t\t\tconst viewport = cameraXR.cameras[ 0 ].viewport;\n\t\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\t\tvertexShader: _occlusion_vertex,\n\t\t\t\t\tfragmentShader: _occlusion_fragment,\n\t\t\t\t\tuniforms: {\n\t\t\t\t\t\tdepthColor: { value: this.texture },\n\t\t\t\t\t\tdepthWidth: { value: viewport.z },\n\t\t\t\t\t\tdepthHeight: { value: viewport.w }\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tthis.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );\n\n\t\t\t}\n\n\t\t\trenderer.render( this.mesh, cameraXR );\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.texture = null;\n\t\tthis.mesh = null;\n\n\t}\n\n}\n\nclass WebXRManager extends EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\n\t\tlet session = null;\n\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\t\t// Set default foveation to maximum.\n\t\tlet foveation = 1.0;\n\t\tlet customReferenceSpace = null;\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glProjLayer = null;\n\t\tlet glBaseLayer = null;\n\t\tlet xrFrame = null;\n\n\t\tconst depthSensing = new WebXRDepthSensing();\n\t\tconst attributes = gl.getContextAttributes();\n\n\t\tlet initialRenderTarget = null;\n\t\tlet newRenderTarget = null;\n\n\t\tconst controllers = [];\n\t\tconst controllerInputSources = [];\n\n\t\tconst currentSize = new Vector2();\n\t\tlet currentPixelRatio = null;\n\n\t\t//\n\n\t\tconst cameraL = new PerspectiveCamera();\n\t\tcameraL.layers.enable( 1 );\n\t\tcameraL.viewport = new Vector4();\n\n\t\tconst cameraR = new PerspectiveCamera();\n\t\tcameraR.layers.enable( 2 );\n\t\tcameraR.viewport = new Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraXR = new ArrayCamera();\n\t\tcameraXR.layers.enable( 1 );\n\t\tcameraXR.layers.enable( 2 );\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controllerIndex = controllerInputSources.indexOf( event.inputSource );\n\n\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\tif ( controller !== undefined ) {\n\n\t\t\t\tcontroller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tsession.removeEventListener( 'select', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'end', onSessionEnd );\n\t\t\tsession.removeEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\n\t\t\t\tif ( inputSource === null ) continue;\n\n\t\t\t\tcontrollerInputSources[ i ] = null;\n\n\t\t\t\tcontrollers[ i ].disconnect( inputSource );\n\n\t\t\t}\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\tdepthSensing.reset();\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\n\n\t\t\tglBaseLayer = null;\n\t\t\tglProjLayer = null;\n\t\t\tglBinding = null;\n\t\t\tsession = null;\n\t\t\tnewRenderTarget = null;\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\trenderer.setPixelRatio( currentPixelRatio );\n\t\t\trenderer.setSize( currentSize.width, currentSize.height, false );\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn customReferenceSpace || referenceSpace;\n\n\t\t};\n\n\t\tthis.setReferenceSpace = function ( space ) {\n\n\t\t\tcustomReferenceSpace = space;\n\n\t\t};\n\n\t\tthis.getBaseLayer = function () {\n\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\n\n\t\t};\n\n\t\tthis.getBinding = function () {\n\n\t\t\treturn glBinding;\n\n\t\t};\n\n\t\tthis.getFrame = function () {\n\n\t\t\treturn xrFrame;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\t\trenderer.getSize( currentSize );\n\n\t\t\t\tif ( session.renderState.layers === undefined ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: true,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = null;\n\t\t\t\t\tlet depthType = null;\n\t\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\t\tdepthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\t\trenderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0,\n\t\t\t\t\t\t\tresolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )\n\t\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n\t\t\t\tthis.setFoveation( foveation );\n\n\t\t\t\tcustomReferenceSpace = null;\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getEnvironmentBlendMode = function () {\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\treturn session.environmentBlendMode;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\n\t\t\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t\t\t}\n\n\t\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.connect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new Vector3();\n\t\tconst cameraRPos = new Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t// although must now be relative to the new union camera.\n\t\t\tconst near2 = near + zOffset;\n\t\t\tconst far2 = far + zOffset;\n\t\t\tconst left2 = left - xOffset;\n\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tif ( depthSensing.texture !== null ) {\n\n\t\t\t\tcamera.near = depthSensing.depthNear;\n\t\t\t\tcamera.far = depthSensing.depthFar;\n\n\t\t\t}\n\n\t\t\tcameraXR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\tcameraXR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\tif ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\t\tdepthFar: cameraXR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraXR.near;\n\t\t\t\t_currentDepthFar = cameraXR.far;\n\n\t\t\t\tcameraL.near = _currentDepthNear;\n\t\t\t\tcameraL.far = _currentDepthFar;\n\t\t\t\tcameraR.near = _currentDepthNear;\n\t\t\t\tcameraR.far = _currentDepthFar;\n\n\t\t\t\tcameraL.updateProjectionMatrix();\n\t\t\t\tcameraR.updateProjectionMatrix();\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraXR.cameras;\n\n\t\t\tupdateCamera( cameraXR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t\t// update user camera and its children\n\n\t\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\t\t};\n\n\t\tfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\t\t\tcamera.matrix.invert();\n\t\t\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t\t\t}\n\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.updateMatrixWorld( true );\n\n\t\t\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tcamera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\t\t\tcamera.zoom = 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraXR;\n\n\t\t};\n\n\t\tthis.getFoveation = function () {\n\n\t\t\tif ( glProjLayer === null && glBaseLayer === null ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn foveation;\n\n\t\t};\n\n\t\tthis.setFoveation = function ( value ) {\n\n\t\t\t// 0 = no foveation = full resolution\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\n\n\t\t\tfoveation = value;\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\tglProjLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\t\tglBaseLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.hasDepthSensing = function () {\n\n\t\t\treturn depthSensing.texture !== null;\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( customReferenceSpace || referenceSpace );\n\t\t\txrFrame = frame;\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\t\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\t\t\tcameraXR.cameras.length = 0;\n\t\t\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\n\t\t\t\t\t\t\t\tnewRenderTarget,\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet camera = cameras[ i ];\n\n\t\t\t\t\tif ( camera === undefined ) {\n\n\t\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\t\tcamera.layers.enable( i );\n\t\t\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\t\t\tcameras[ i ] = camera;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tconst enabledFeatures = session.enabledFeatures;\n\n\t\t\t\tif ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {\n\n\t\t\t\t\tconst depthData = glBinding.getDepthInformation( views[ 0 ] );\n\n\t\t\t\t\tif ( depthData && depthData.isValid && depthData.texture ) {\n\n\t\t\t\t\t\tdepthSensing.init( renderer, depthData, session.renderState );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\t\t\t\tconst controller = controllers[ i ];\n\n\t\t\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\t\t\tcontroller.update( inputSource, frame, customReferenceSpace || referenceSpace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdepthSensing.render( renderer, cameraXR );\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t\tif ( frame.detectedPlanes ) {\n\n\t\t\t\tscope.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t\t\t}\n\n\t\t\txrFrame = null;\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\nfunction WebGLMaterials( renderer, properties ) {\n\n\tfunction refreshTransformUniform( map, uniform ) {\n\n\t\tif ( map.matrixAutoUpdate === true ) {\n\n\t\t\tmap.updateMatrix();\n\n\t\t}\n\n\t\tuniform.value.copy( map.matrix );\n\n\t}\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tfog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material, transmissionRenderTarget );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\n\t\t\trefreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );\n\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.bumpScale.value *= - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\trefreshTransformUniform( material.normalMap, uniforms.normalMapTransform );\n\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.normalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\n\t\t\trefreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );\n\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\trefreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t\trefreshTransformUniform( material.specularMap, uniforms.specularMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst envMap = materialProperties.envMap;\n\t\tconst envMapRotation = materialProperties.envMapRotation;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\t_e1.copy( envMapRotation );\n\n\t\t\t// accommodate left-handed frame\n\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\tif ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {\n\n\t\t\t\t// environment maps which are not cube render targets or PMREMs follow a different convention\n\t\t\t\t_e1.y *= - 1;\n\t\t\t\t_e1.z *= - 1;\n\n\t\t\t}\n\n\t\t\tuniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.ior.value = material.ior;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\n\t\t\t// artist-friendly light intensity scaling factor\n\t\t\tconst scaleFactor = ( renderer._useLegacyLights === true ) ? Math.PI : 1;\n\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;\n\n\t\t\trefreshTransformUniform( material.lightMap, uniforms.lightMapTransform );\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\trefreshTransformUniform( material.aoMap, uniforms.aoMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.uvTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\trefreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );\n\n\t\t}\n\n\t\tuniforms.roughness.value = material.roughness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\trefreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {\n\n\t\tuniforms.ior.value = material.ior; // also part of uniforms common\n\n\t\tif ( material.sheen > 0 ) {\n\n\t\t\tuniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );\n\n\t\t\tuniforms.sheenRoughness.value = material.sheenRoughness;\n\n\t\t\tif ( material.sheenColorMap ) {\n\n\t\t\t\tuniforms.sheenColorMap.value = material.sheenColorMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\t\tuniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.clearcoat > 0 ) {\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n\t\t\tif ( material.clearcoatMap ) {\n\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.dispersion > 0 ) {\n\n\t\t\tuniforms.dispersion.value = material.dispersion;\n\n\t\t}\n\n\t\tif ( material.iridescence > 0 ) {\n\n\t\t\tuniforms.iridescence.value = material.iridescence;\n\t\t\tuniforms.iridescenceIOR.value = material.iridescenceIOR;\n\t\t\tuniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];\n\t\t\tuniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];\n\n\t\t\tif ( material.iridescenceMap ) {\n\n\t\t\t\tuniforms.iridescenceMap.value = material.iridescenceMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tuniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.transmission > 0 ) {\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\tuniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t\t\trefreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy( material.attenuationColor );\n\n\t\t}\n\n\t\tif ( material.anisotropy > 0 ) {\n\n\t\t\tuniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n\t\t\tif ( material.anisotropyMap ) {\n\n\t\t\t\tuniforms.anisotropyMap.value = material.anisotropyMap;\n\n\t\t\t\trefreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.specularIntensity.value = material.specularIntensity;\n\t\tuniforms.specularColor.value.copy( material.specularColor );\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tuniforms.specularColorMap.value = material.specularColorMap;\n\n\t\t\trefreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tuniforms.specularIntensityMap.value = material.specularIntensityMap;\n\n\t\t\trefreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tconst light = properties.get( material ).light;\n\n\t\tuniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );\n\t\tuniforms.nearDistance.value = light.shadow.camera.near;\n\t\tuniforms.farDistance.value = light.shadow.camera.far;\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tif ( hasUniformChanged( uniform, i, j, cache ) === true ) {\n\n\t\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\t\tlet arrayOffset = 0;\n\n\t\t\t\t\tfor ( let k = 0; k < values.length; k ++ ) {\n\n\t\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t\t// TODO add integer and struct support\n\t\t\t\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );\n\n\t\t\t\t\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\t\tuniform.__data[ 0 ] = value.elements[ 0 ];\n\t\t\t\t\t\t\tuniform.__data[ 1 ] = value.elements[ 1 ];\n\t\t\t\t\t\t\tuniform.__data[ 2 ] = value.elements[ 2 ];\n\t\t\t\t\t\t\tuniform.__data[ 3 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 4 ] = value.elements[ 3 ];\n\t\t\t\t\t\t\tuniform.__data[ 5 ] = value.elements[ 4 ];\n\t\t\t\t\t\t\tuniform.__data[ 6 ] = value.elements[ 5 ];\n\t\t\t\t\t\t\tuniform.__data[ 7 ] = 0;\n\t\t\t\t\t\t\tuniform.__data[ 8 ] = value.elements[ 6 ];\n\t\t\t\t\t\t\tuniform.__data[ 9 ] = value.elements[ 7 ];\n\t\t\t\t\t\t\tuniform.__data[ 10 ] = value.elements[ 8 ];\n\t\t\t\t\t\t\tuniform.__data[ 11 ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue.toArray( uniform.__data, arrayOffset );\n\n\t\t\t\t\t\t\tarrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, indexArray, cache ) {\n\n\t\tconst value = uniform.value;\n\t\tconst indexString = index + '_' + indexArray;\n\n\t\tif ( cache[ indexString ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tcache[ indexString ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tcache[ indexString ] = value.clone();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\tconst cachedObject = cache[ indexString ];\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t\tif ( cachedObject !== value ) {\n\n\t\t\t\t\tcache[ indexString ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( cachedObject.equals( value ) === false ) {\n\n\t\t\t\t\tcachedObject.copy( value );\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];\n\n\t\t\tfor ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uniform = uniformArray[ j ];\n\n\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\tfor ( let k = 0, kl = values.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst value = values[ k ];\n\n\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\t// Calculate the chunk offset\n\t\t\t\t\tconst chunkOffsetUniform = offset % chunkSize;\n\n\t\t\t\t\t// Check for chunk overflow\n\t\t\t\t\tif ( chunkOffsetUniform !== 0 && ( chunkSize - chunkOffsetUniform ) < info.boundary ) {\n\n\t\t\t\t\t\t// Add padding and adjust offset\n\t\t\t\t\t\toffset += ( chunkSize - chunkOffsetUniform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following two properties will be used for partial buffer updates\n\n\t\t\t\t\tuniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\t\t\tuniform.__offset = offset;\n\n\n\t\t\t\t\t// Update the global offset\n\t\t\t\t\toffset += info.storage;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tconst chunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( value ) {\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' || typeof value === 'boolean' ) {\n\n\t\t\t// float/int/bool\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass WebGLRenderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tconst {\n\t\t\tcanvas = createCanvasElement(),\n\t\t\tcontext = null,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\talpha = false,\n\t\t\tantialias = false,\n\t\t\tpremultipliedAlpha = true,\n\t\t\tpreserveDrawingBuffer = false,\n\t\t\tpowerPreference = 'default',\n\t\t\tfailIfMajorPerformanceCaveat = false,\n\t\t} = parameters;\n\n\t\tthis.isWebGLRenderer = true;\n\n\t\tlet _alpha;\n\n\t\tif ( context !== null ) {\n\n\t\t\tif ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {\n\n\t\t\t\tthrow new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );\n\n\t\t\t}\n\n\t\t\t_alpha = context.getContextAttributes().alpha;\n\n\t\t} else {\n\n\t\t\t_alpha = alpha;\n\n\t\t}\n\n\t\tconst uintClearColor = new Uint32Array( 4 );\n\t\tconst intClearColor = new Int32Array( 4 );\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null;\n\n\t\t// render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = canvas;\n\n\t\t// Debug configuration container\n\t\tthis.debug = {\n\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true,\n\t\t\t/**\n\t\t\t * Callback for custom error reporting.\n\t\t\t * @type {?Function}\n\t\t\t */\n\t\t\tonShaderError: null\n\t\t};\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis._outputColorSpace = SRGBColorSpace;\n\n\t\t// physical lights\n\n\t\tthis._useLegacyLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t// internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false;\n\n\t\t// internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\t\tlet _currentMaterialId = - 1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\t\tconst _currentScissor = new Vector4();\n\t\tlet _currentScissorTest = null;\n\n\t\tconst _currentClearColor = new Color( 0x000000 );\n\t\tlet _currentClearAlpha = 0;\n\n\t\t//\n\n\t\tlet _width = canvas.width;\n\t\tlet _height = canvas.height;\n\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\t\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\t\tlet _scissorTest = false;\n\n\t\t// frustum\n\n\t\tconst _frustum = new Frustum();\n\n\t\t// clipping\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false;\n\n\t\t// camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tlet _gl = context;\n\n\t\tfunction getContext( contextName, contextAttributes ) {\n\n\t\t\treturn canvas.getContext( contextName, contextAttributes );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: true,\n\t\t\t\tdepth,\n\t\t\t\tstencil,\n\t\t\t\tantialias,\n\t\t\t\tpremultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer,\n\t\t\t\tpowerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat,\n\t\t\t};\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t\tcanvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tconst contextName = 'webgl2';\n\n\t\t\t\t_gl = getContext( contextName, contextAttributes );\n\n\t\t\t\tif ( _gl === null ) {\n\n\t\t\t\t\tif ( getContext( contextName ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\t\tthrow error;\n\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\t\tlet utils, bindingStates, uniformsGroups;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\textensions.init();\n\n\t\t\tutils = new WebGLUtils( _gl, extensions );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );\n\n\t\t\tstate = new WebGLState( _gl );\n\n\t\t\tinfo = new WebGLInfo( _gl );\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\tbindingStates = new WebGLBindingStates( _gl, attributes );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\t\tclipping = new WebGLClipping( properties );\n\t\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates( extensions );\n\t\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );\n\t\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );\n\n\t\t\tinfo.programs = programCache.programs;\n\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// xr\n\n\t\tconst xr = new WebXRManager( _this, _gl );\n\n\t\tthis.xr = xr;\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn target.set( _width, _height );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle = true ) {\n\n\t\t\tif ( xr.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\tcanvas.width = Math.floor( width * _pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * _pixelRatio );\n\n\t\t\tif ( updateStyle === true ) {\n\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\tcanvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\tcanvas.width = Math.floor( width * pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * pixelRatio );\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getCurrentViewport = function ( target ) {\n\n\t\t\treturn target.copy( _currentViewport );\n\n\t\t};\n\n\t\tthis.getViewport = function ( target ) {\n\n\t\t\treturn target.copy( _viewport );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissor = function ( target ) {\n\n\t\t\treturn target.copy( _scissor );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );\n\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\n\t\t\treturn _scissorTest;\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\tthis.setOpaqueSort = function ( method ) {\n\n\t\t\t_opaqueSort = method;\n\n\t\t};\n\n\t\tthis.setTransparentSort = function ( method ) {\n\n\t\t\t_transparentSort = method;\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function ( target ) {\n\n\t\t\treturn target.copy( background.getClearColor() );\n\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\t\tlet bits = 0;\n\n\t\t\tif ( color ) {\n\n\t\t\t\t// check if we're trying to clear an integer target\n\t\t\t\tlet isIntegerFormat = false;\n\t\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t\tconst targetFormat = _currentRenderTarget.texture.format;\n\t\t\t\t\tisIntegerFormat = targetFormat === RGBAIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RGIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RedIntegerFormat;\n\n\t\t\t\t}\n\n\t\t\t\t// use the appropriate clear functions to clear the target if it's a signed\n\t\t\t\t// or unsigned integer target\n\t\t\t\tif ( isIntegerFormat ) {\n\n\t\t\t\t\tconst targetType = _currentRenderTarget.texture.type;\n\t\t\t\t\tconst isUnsignedType = targetType === UnsignedByteType ||\n\t\t\t\t\t\ttargetType === UnsignedIntType ||\n\t\t\t\t\t\ttargetType === UnsignedShortType ||\n\t\t\t\t\t\ttargetType === UnsignedInt248Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort4444Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort5551Type;\n\n\t\t\t\t\tconst clearColor = background.getClearColor();\n\t\t\t\t\tconst a = background.getClearAlpha();\n\t\t\t\t\tconst r = clearColor.r;\n\t\t\t\t\tconst g = clearColor.g;\n\t\t\t\t\tconst b = clearColor.b;\n\n\t\t\t\t\tif ( isUnsignedType ) {\n\n\t\t\t\t\t\tuintClearColor[ 0 ] = r;\n\t\t\t\t\t\tuintClearColor[ 1 ] = g;\n\t\t\t\t\t\tuintClearColor[ 2 ] = b;\n\t\t\t\t\t\tuintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintClearColor[ 0 ] = r;\n\t\t\t\t\t\tintClearColor[ 1 ] = g;\n\t\t\t\t\t\tintClearColor[ 2 ] = b;\n\t\t\t\t\t\tintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbits |= _gl.COLOR_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil ) {\n\n\t\t\t\tbits |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\tthis.state.buffers.stencil.setMask( 0xffffffff );\n\n\t\t\t}\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\t//\n\n\t\tthis.dispose = function () {\n\n\t\t\tcanvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tcubeuvmaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\tuniformsGroups.dispose();\n\t\t\tprogramCache.dispose();\n\n\t\t\txr.dispose();\n\n\t\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t\tanimation.stop();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\n\t\t\tinitGLContext();\n\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\n\t\t}\n\n\t\tfunction onContextCreationError( event ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tconst material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReferences( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\t\tconst programs = properties.get( material ).programs;\n\n\t\t\tif ( programs !== undefined ) {\n\n\t\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t//\n\n\t\t\tlet index = geometry.index;\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\n\t\t\t\tif ( index === undefined ) return;\n\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst drawRange = geometry.drawRange;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\t\tif ( group !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t\t}\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t\t}\n\n\t\t\tconst drawCount = drawEnd - drawStart;\n\n\t\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t\t//\n\n\t\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isInstancedMesh ) {\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Compile\n\n\t\tfunction prepareMaterial( material, scene, object ) {\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.compile = function ( scene, camera, targetScene = null ) {\n\n\t\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\t\tcurrentRenderState = renderStates.get( targetScene );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t// gather lights from both the target scene and the new object that will be added to the scene.\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( scene !== targetScene ) {\n\n\t\t\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tcurrentRenderState.setupLights( _this._useLegacyLights );\n\n\t\t\t// Only initialize materials in the new scene, not the targetScene.\n\n\t\t\tconst materials = new Set();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\t\tprepareMaterial( material2, targetScene, object );\n\t\t\t\t\t\t\tmaterials.add( material2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprepareMaterial( material, targetScene, object );\n\t\t\t\t\t\tmaterials.add( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trenderStateStack.pop();\n\t\t\tcurrentRenderState = null;\n\n\t\t\treturn materials;\n\n\t\t};\n\n\t\t// compileAsync\n\n\t\tthis.compileAsync = function ( scene, camera, targetScene = null ) {\n\n\t\t\tconst materials = this.compile( scene, camera, targetScene );\n\n\t\t\t// Wait for all the materials in the new object to indicate that they're\n\t\t\t// ready to be used before resolving the promise.\n\n\t\t\treturn new Promise( ( resolve ) => {\n\n\t\t\t\tfunction checkMaterialsReady() {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tconst materialProperties = properties.get( material );\n\t\t\t\t\t\tconst program = materialProperties.currentProgram;\n\n\t\t\t\t\t\tif ( program.isReady() ) {\n\n\t\t\t\t\t\t\t// remove any programs that report they're ready to use from the list\n\t\t\t\t\t\t\tmaterials.delete( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// once the list of compiling materials is empty, call the callback\n\n\t\t\t\t\tif ( materials.size === 0 ) {\n\n\t\t\t\t\t\tresolve( scene );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if some materials are still not ready, wait a bit and check again\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {\n\n\t\t\t\t\t// If we can check the compilation status of the materials without\n\t\t\t\t\t// blocking then do so right away.\n\n\t\t\t\t\tcheckMaterialsReady();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise start by waiting a bit to give the materials we just\n\t\t\t\t\t// initialized a chance to finish.\n\n\t\t\t\t\tsetTimeout( checkMaterialsReady, 10 );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time ) {\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\n\t\t\tanimation.start();\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop( callback );\n\n\t\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t\t};\n\n\t\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost === true ) return;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\t\tcurrentRenderState.init( camera );\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\t\tcurrentRenderList.init();\n\n\t\t\trenderListStack.push( currentRenderList );\n\n\t\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t\t}\n\n\t\t\tconst renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;\n\t\t\tif ( renderBackground ) {\n\n\t\t\t\tbackground.addToRenderList( currentRenderList, scene );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.info.render.frame ++;\n\n\t\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\t// render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\n\t\t\tcurrentRenderState.setupLights( _this._useLegacyLights );\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\t\trenderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderBackground ) background.render( scene );\n\n\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );\n\n\t\t\t\tif ( renderBackground ) background.render( scene );\n\n\t\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t\t// _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\trenderStateStack.pop();\n\n\t\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderState = null;\n\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderList = null;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tconst visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isGroup ) {\n\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( object.boundingSphere.center );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( geometry.boundingSphere.center );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_vector3\n\t\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t}\n\n\t\tfunction renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tif ( overrideMaterial !== null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {\n\n\t\t\t\tcurrentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\ttype: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tsamples: 4,\n\t\t\t\t\tstencilBuffer: stencil,\n\t\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\t\tresolveStencilBuffer: false\n\t\t\t\t} );\n\n\t\t\t\t// debug\n\n\t\t\t\t/*\n\t\t\t\tconst geometry = new PlaneGeometry();\n\t\t\t\tconst material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );\n\n\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tconst transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];\n\n\t\t\tconst activeViewport = camera.viewport || _currentViewport;\n\t\t\ttransmissionRenderTarget.setSize( activeViewport.z, activeViewport.w );\n\n\t\t\t//\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t\t_this.setRenderTarget( transmissionRenderTarget );\n\n\t\t\t_this.getClearColor( _currentClearColor );\n\t\t\t_currentClearAlpha = _this.getClearAlpha();\n\t\t\tif ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );\n\n\t\t\t_this.clear();\n\n\t\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\t\tconst currentToneMapping = _this.toneMapping;\n\t\t\t_this.toneMapping = NoToneMapping;\n\n\t\t\t// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).\n\t\t\t// Transmission render pass requires viewport to match the transmissionRenderTarget.\n\t\t\tconst currentCameraViewport = camera.viewport;\n\t\t\tif ( camera.viewport !== undefined ) camera.viewport = undefined;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131\n\n\t\t\t\tlet renderTargetNeedsUpdate = false;\n\n\t\t\t\tfor ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst renderItem = transmissiveObjects[ i ];\n\n\t\t\t\t\tconst object = renderItem.object;\n\t\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\t\tconst material = renderItem.material;\n\t\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\t\tif ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\t\tconst currentSide = material.side;\n\n\t\t\t\t\t\tmaterial.side = BackSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t\t\tmaterial.side = currentSide;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t\trenderTargetNeedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTargetNeedsUpdate === true ) {\n\n\t\t\t\t\ttextures.updateMultisampleRenderTarget( transmissionRenderTarget );\n\t\t\t\t\ttextures.updateRenderTargetMipmap( transmissionRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t\t\t_this.setClearColor( _currentClearColor, _currentClearAlpha );\n\n\t\t\tif ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;\n\n\t\t\t_this.toneMapping = currentToneMapping;\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t\t}\n\n\t\tfunction getProgram( material, scene, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tconst lightsStateVersion = lights.state.version;\n\n\t\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\t\tlet programs = materialProperties.programs;\n\n\t\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\t\t\tmaterialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;\n\n\t\t\tif ( programs === undefined ) {\n\n\t\t\t\t// new material\n\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\n\t\t\t}\n\n\t\t\tlet program = programs.get( programCacheKey );\n\n\t\t\tif ( program !== undefined ) {\n\n\t\t\t\t// early out if program and light state is identical\n\n\t\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\t\treturn program;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\t\tmaterial.onBuild( object, parameters, _this );\n\n\t\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = null;\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction getUniformList( materialProperties ) {\n\n\t\t\tif ( materialProperties.uniformsList === null ) {\n\n\t\t\t\tconst progUniforms = materialProperties.currentProgram.getUniforms();\n\t\t\t\tmaterialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );\n\n\t\t\t}\n\n\t\t\treturn materialProperties.uniformsList;\n\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tmaterialProperties.outputColorSpace = parameters.outputColorSpace;\n\t\t\tmaterialProperties.batching = parameters.batching;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.instancingColor = parameters.instancingColor;\n\t\t\tmaterialProperties.instancingMorph = parameters.instancingMorph;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t\t}\n\n\t\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );\n\t\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\t\tconst vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );\n\t\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\t\tconst morphColors = !! geometry.morphAttributes.color;\n\n\t\t\tlet toneMapping = NoToneMapping;\n\n\t\t\tif ( material.toneMapped ) {\n\n\t\t\t\tif ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\t\t\ttoneMapping = _this.toneMapping;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tconst materialProperties = properties.get( material );\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled === true ) {\n\n\t\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\t\tconst useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.outputColorSpace !== colorSpace ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isBatchedMesh && materialProperties.batching === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif ( needsProgramChange === true ) {\n\n\t\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\t\t// common camera uniforms\n\n\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'batchingTexture' );\n\t\t\t\tp_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );\n\n\t\t\t}\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, program );\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {\n\n\t\t\t\tm_uniforms.envMapIntensity.value = scene.environmentIntensity;\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\t// UBOs\n\n\t\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\tfunction materialNeedsLights( material ) {\n\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\n\t\t\treturn _currentActiveCubeFace;\n\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\n\t\t\treturn _currentActiveMipmapLevel;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\n\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tlet useDefaultFramebuffer = true;\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Array.isArray( __webglFramebuffer ) ) {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ activeMipmapLevel ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( framebufferBound && useDefaultFramebuffer ) {\n\n\t\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t\t}\n\n\t\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( ! capabilities.textureFormatReadable( textureFormat ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! capabilities.textureTypeReadable( textureType ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\n\n\t\t\tconst levelScale = Math.pow( 2, - level );\n\t\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\n\n\t\t\tconst width = srcTexture.image.width;\n\t\t\tconst height = srcTexture.image.height;\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t\t// As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\n\n\t\t\tconst width = sourceBox.max.x - sourceBox.min.x;\n\t\t\tconst height = sourceBox.max.y - sourceBox.min.y;\n\t\t\tconst depth = sourceBox.max.z - sourceBox.min.z;\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\t\t\tlet glTarget;\n\n\t\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t\t} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tconst unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );\n\n\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.initTexture = function ( texture ) {\n\n\t\t\tif ( texture.isCubeTexture ) {\n\n\t\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.resetState = function () {\n\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\n\t\t};\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\tget outputColorSpace() {\n\n\t\treturn this._outputColorSpace;\n\n\t}\n\n\tset outputColorSpace( colorSpace ) {\n\n\t\tthis._outputColorSpace = colorSpace;\n\n\t\tconst gl = this.getContext();\n\t\tgl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';\n\t\tgl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';\n\n\t}\n\n\tget useLegacyLights() { // @deprecated, r155\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );\n\t\treturn this._useLegacyLights;\n\n\t}\n\n\tset useLegacyLights( value ) { // @deprecated, r155\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );\n\t\tthis._useLegacyLights = value;\n\n\t}\n\n}\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\t\tthis.backgroundRotation = new Euler();\n\n\t\tthis.environmentIntensity = 1;\n\t\tthis.environmentRotation = new Euler();\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\t\tthis.backgroundRotation.copy( source.backgroundRotation );\n\n\t\tthis.environmentIntensity = source.environmentIntensity;\n\t\tthis.environmentRotation.copy( source.environmentRotation );\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\t\tdata.object.backgroundRotation = this.backgroundRotation.toArray();\n\n\t\tif ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;\n\t\tdata.object.environmentRotation = this.environmentRotation.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis._updateRange = { offset: 0, count: - 1 };\n\t\tthis.updateRanges = [];\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tget updateRange() {\n\n\t\twarnOnce( 'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159\n\t\treturn this._updateRange;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.fromBufferAttribute( this, i );\n\n\t\t\t_vector$6.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material = new SpriteMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = material;\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = AttachedBindMode;\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$4.copy( this.boundingSphere );\n\t\t_sphere$4.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix$1 = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\t\tthis.morphTexture = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$3 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh$1.geometry = this.geometry;\n\t\t_mesh$1.material = this.material;\n\n\t\tif ( _mesh$1.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$3.copy( this.boundingSphere );\n\t\t_sphere$3.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh$1.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh$1.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( drawRange, z ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = drawRange.start;\n\t\titem.count = drawRange.count;\n\t\titem.z = z;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst ID_ATTR_NAME = 'batchId';\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _invMatrixWorld = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\nconst _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = [];\n\n// @TODO: SkinnedMesh support?\n// @TODO: geometry.groups support?\n// @TODO: geometry.drawRange support?\n// @TODO: geometry.morphAttributes support?\n// @TODO: Support uniform parameter per geometry\n// @TODO: Add an \"optimize\" function to pack geometry and remove data gaps\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\nclass BatchedMesh extends Mesh {\n\n\tget maxGeometryCount() {\n\n\t\treturn this._maxGeometryCount;\n\n\t}\n\n\tconstructor( maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\tthis.isBatchedMesh = true;\n\t\tthis.perObjectFrustumCulled = true;\n\t\tthis.sortObjects = true;\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\tthis.customSort = null;\n\n\t\tthis._drawRanges = [];\n\t\tthis._reservedRanges = [];\n\n\t\tthis._visibility = [];\n\t\tthis._active = [];\n\t\tthis._bounds = [];\n\n\t\tthis._maxGeometryCount = maxGeometryCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tthis._geometryInitialized = false;\n\t\tthis._geometryCount = 0;\n\t\tthis._multiDrawCounts = new Int32Array( maxGeometryCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxGeometryCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\t\tthis._visibilityChanged = true;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\n\t\tthis._initMatricesTexture();\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxGeometryCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxGeometryCount = this._maxGeometryCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\tconst indexArray = maxVertexCount > 65536\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tconst idArray = maxGeometryCount > 65536\n\t\t\t\t? new Uint32Array( maxVertexCount )\n\t\t\t\t: new Uint16Array( maxVertexCount );\n\t\t\tgeometry.setAttribute( ID_ATTR_NAME, new BufferAttribute( idArray, 1 ) );\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check that the geometry doesn't have a version of our reserved id attribute\n\t\tif ( geometry.getAttribute( ID_ATTR_NAME ) ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry cannot use attribute \"${ ID_ATTR_NAME }\"` );\n\n\t\t}\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( attributeName === ID_ATTR_NAME ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst active = this._active;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( active[ i ] === false ) continue;\n\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingBoxAt( i, _box$1 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingBox.union( _box$1 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst active = this._active;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( active[ i ] === false ) continue;\n\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\taddGeometry( geometry, vertexCount = - 1, indexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\t// ensure we're not over geometry\n\t\tif ( this._geometryCount >= this._maxGeometryCount ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\t// get the necessary range fo the geometry\n\t\tconst reservedRange = {\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t};\n\n\t\tlet lastRange = null;\n\t\tconst reservedRanges = this._reservedRanges;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst bounds = this._bounds;\n\t\tif ( this._geometryCount !== 0 ) {\n\n\t\t\tlastRange = reservedRanges[ reservedRanges.length - 1 ];\n\n\t\t}\n\n\t\tif ( vertexCount === - 1 ) {\n\n\t\t\treservedRange.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\t} else {\n\n\t\t\treservedRange.vertexCount = vertexCount;\n\n\t\t}\n\n\t\tif ( lastRange === null ) {\n\n\t\t\treservedRange.vertexStart = 0;\n\n\t\t} else {\n\n\t\t\treservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n\n\t\t}\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tif ( indexCount\t=== - 1 ) {\n\n\t\t\t\treservedRange.indexCount = index.count;\n\n\t\t\t} else {\n\n\t\t\t\treservedRange.indexCount = indexCount;\n\n\t\t\t}\n\n\t\t\tif ( lastRange === null ) {\n\n\t\t\t\treservedRange.indexStart = 0;\n\n\t\t\t} else {\n\n\t\t\t\treservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (\n\t\t\treservedRange.indexStart !== - 1 &&\n\t\t\treservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount ||\n\t\t\treservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\n\t\t// push new visibility states\n\t\tvisibility.push( true );\n\t\tactive.push( true );\n\n\t\t// update id\n\t\tconst geometryId = this._geometryCount;\n\t\tthis._geometryCount ++;\n\n\t\t// initialize matrix information\n\t\t_identityMatrix.toArray( matricesArray, geometryId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\t// add the reserved range and draw range objects\n\t\treservedRanges.push( reservedRange );\n\t\tdrawRanges.push( {\n\t\t\tstart: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,\n\t\t\tcount: - 1\n\t\t} );\n\t\tbounds.push( {\n\t\t\tboxInitialized: false,\n\t\t\tbox: new Box3(),\n\n\t\t\tsphereInitialized: false,\n\t\t\tsphere: new Sphere()\n\t\t} );\n\n\t\t// set the id for the geometry\n\t\tconst idAttribute = this.geometry.getAttribute( ID_ATTR_NAME );\n\t\tfor ( let i = 0; i < reservedRange.vertexCount; i ++ ) {\n\n\t\t\tidAttribute.setX( reservedRange.vertexStart + i, geometryId );\n\n\t\t}\n\n\t\tidAttribute.needsUpdate = true;\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\treturn geometryId;\n\n\t}\n\n\tsetGeometryAt( id, geometry ) {\n\n\t\tif ( id >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst reservedRange = this._reservedRanges[ id ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > reservedRange.indexCount ||\n\t\t\tgeometry.attributes.position.count > reservedRange.vertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry over\n\t\tconst vertexStart = reservedRange.vertexStart;\n\t\tconst vertexCount = reservedRange.vertexCount;\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( attributeName === ID_ATTR_NAME ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = vertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, vertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = reservedRange.indexStart;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedRange.indexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, reservedRange.indexCount );\n\n\t\t}\n\n\t\t// store the bounding boxes\n\t\tconst bound = this._bounds[ id ];\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbound.box.copy( geometry.boundingBox );\n\t\t\tbound.boxInitialized = true;\n\n\t\t} else {\n\n\t\t\tbound.boxInitialized = false;\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbound.sphere.copy( geometry.boundingSphere );\n\t\t\tbound.sphereInitialized = true;\n\n\t\t} else {\n\n\t\t\tbound.sphereInitialized = false;\n\n\t\t}\n\n\t\t// set drawRange count\n\t\tconst drawRange = this._drawRanges[ id ];\n\t\tconst posAttr = geometry.getAttribute( 'position' );\n\t\tdrawRange.count = hasIndex ? srcIndex.count : posAttr.count;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn id;\n\n\t}\n\n\tdeleteGeometry( geometryId ) {\n\n\t\t// Note: User needs to call optimize() afterward to pack the data.\n\n\t\tconst active = this._active;\n\t\tif ( geometryId >= active.length || active[ geometryId ] === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tactive[ geometryId ] = false;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetInstanceCountAt( id ) {\n\n\t\tif ( this._multiDrawInstances === null ) return null;\n\n\t\treturn this._multiDrawInstances[ id ];\n\n\t}\n\n\tsetInstanceCountAt( id, instanceCount ) {\n\n\t\tif ( this._multiDrawInstances === null ) {\n\n\t\t\tthis._multiDrawInstances = new Int32Array( this._maxGeometryCount ).fill( 1 );\n\n\t\t}\n\n\t\tthis._multiDrawInstances[ id ] = instanceCount;\n\n\t\treturn id;\n\n\t}\n\n\t// get bounding box and compute it if it doesn't exist\n\tgetBoundingBoxAt( id, target ) {\n\n\t\tconst active = this._active;\n\t\tif ( active[ id ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst bound = this._bounds[ id ];\n\t\tconst box = bound.box;\n\t\tconst geometry = this.geometry;\n\t\tif ( bound.boxInitialized === false ) {\n\n\t\t\tbox.makeEmpty();\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst drawRange = this._drawRanges[ id ];\n\t\t\tfor ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tbound.boxInitialized = true;\n\n\t\t}\n\n\t\ttarget.copy( box );\n\t\treturn target;\n\n\t}\n\n\t// get bounding sphere and compute it if it doesn't exist\n\tgetBoundingSphereAt( id, target ) {\n\n\t\tconst active = this._active;\n\t\tif ( active[ id ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst bound = this._bounds[ id ];\n\t\tconst sphere = bound.sphere;\n\t\tconst geometry = this.geometry;\n\t\tif ( bound.sphereInitialized === false ) {\n\n\t\t\tsphere.makeEmpty();\n\n\t\t\tthis.getBoundingBoxAt( id, _box$1 );\n\t\t\t_box$1.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst drawRange = this._drawRanges[ id ];\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector$5.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tbound.sphereInitialized = true;\n\n\t\t}\n\n\t\ttarget.copy( sphere );\n\t\treturn target;\n\n\t}\n\n\tsetMatrixAt( geometryId, matrix ) {\n\n\t\t// @TODO: Map geometryId to index of the arrays because\n\t\t//        optimize() can make geometryId mismatch the index\n\n\t\tconst active = this._active;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tmatrix.toArray( matricesArray, geometryId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetMatrixAt( geometryId, matrix ) {\n\n\t\tconst active = this._active;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn matrix.fromArray( matricesArray, geometryId * 16 );\n\n\t}\n\n\tsetVisibleAt( geometryId, value ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst geometryCount = this._geometryCount;\n\n\t\t// if the geometry is out of range, not active, or visibility state\n\t\t// does not change then return early\n\t\tif (\n\t\t\tgeometryId >= geometryCount ||\n\t\t\tactive[ geometryId ] === false ||\n\t\t\tvisibility[ geometryId ] === value\n\t\t) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvisibility[ geometryId ] = value;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetVisibleAt( geometryId ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst geometryCount = this._geometryCount;\n\n\t\t// return early if the geometry is out of range or not active\n\t\tif ( geometryId >= geometryCount || active[ geometryId ] === false ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn visibility[ geometryId ];\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst visibility = this._visibility;\n\t\tconst active = this._active;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst geometryCount = this._geometryCount;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\tif ( ! visibility[ i ] || ! active[ i ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst drawRange = drawRanges[ i ];\n\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t// ge the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( i, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( i, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._drawRanges = source._drawRanges.map( range => ( { ...range } ) );\n\t\tthis._reservedRanges = source._reservedRanges.map( range => ( { ...range } ) );\n\n\t\tthis._visibility = source._visibility.slice();\n\t\tthis._active = source._active.slice();\n\t\tthis._bounds = source._bounds.map( bound => ( {\n\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\tbox: bound.box.clone(),\n\n\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\tsphere: bound.sphere.clone()\n\t\t} ) );\n\n\t\tthis._maxGeometryCount = source._maxGeometryCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._geometryCount = source._geometryCount;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.slice();\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst active = this._active;\n\t\tconst visibility = this._visibility;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t_projScreenMatrix$2\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_projScreenMatrix$2,\n\t\t\t\trenderer.coordinateSystem\n\t\t\t);\n\n\t\t}\n\n\t\tlet count = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_invMatrixWorld.copy( this.matrixWorld ).invert();\n\t\t\t_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _invMatrixWorld );\n\n\t\t\tfor ( let i = 0, l = visibility.length; i < l; i ++ ) {\n\n\t\t\t\tif ( visibility[ i ] && active[ i ] ) {\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst z = _vector$5.distanceTo( _sphere$2.center );\n\t\t\t\t\t\t_renderList.push( drawRanges[ i ], z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ count ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ count ] = item.count;\n\t\t\t\tcount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = visibility.length; i < l; i ++ ) {\n\n\t\t\t\tif ( visibility[ i ] && active[ i ] ) {\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\t\tthis.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst range = drawRanges[ i ];\n\t\t\t\t\t\tmultiDrawStarts[ count ] = range.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ count ] = range.count;\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._multiDrawCount = count;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: a,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tobject: object\n\n\t};\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends Texture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends CompressedTexture {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t}\n\n}\n\nclass CompressedCubeTexture extends CompressedTexture {\n\n\tconstructor( images, format, type ) {\n\n\t\tsuper( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );\n\n\t\tthis.isCompressedCubeTexture = true;\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.image = images;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tlength: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._dispersion = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget dispersion() {\n\n\t\treturn this._dispersion;\n\n\t}\n\n\tset dispersion( value ) {\n\n\t\tif ( this._dispersion > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._dispersion = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.dispersion = source.dispersion;\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = MaterialLoader.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.dispersion !== undefined ) material.dispersion = json.dispersion;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;\n\t\tif ( json.blendDst !== undefined ) material.blendDst = json.blendDst;\n\t\tif ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;\n\t\tif ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;\n\t\tif ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;\n\t\tif ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;\n\t\tif ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );\n\t\tif ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== undefined ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog.name !== '' ) {\n\n\t\t\t\t\t\tobject.fog.name = data.fog.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\t\t\t\tif ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );\n\n\t\t\t\tif ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;\n\t\t\t\tif ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BatchedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new BatchedMesh( data.maxGeometryCount, data.maxVertexCount, data.maxIndexCount, material );\n\t\t\t\tobject.geometry = geometry;\n\t\t\t\tobject.perObjectFrustumCulled = data.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = data.sortObjects;\n\n\t\t\t\tobject._drawRanges = data.drawRanges;\n\t\t\t\tobject._reservedRanges = data.reservedRanges;\n\n\t\t\t\tobject._visibility = data.visibility;\n\t\t\t\tobject._active = data.active;\n\t\t\t\tobject._bounds = data.bounds.map( bound => {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tbox.min.fromArray( bound.boxMin );\n\t\t\t\t\tbox.max.fromArray( bound.boxMax );\n\n\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\tsphere.radius = bound.sphereRadius;\n\t\t\t\t\tsphere.center.fromArray( bound.sphereCenter );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\t\t\tbox: box,\n\n\t\t\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\t\t\tsphere: sphere\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t\tobject._maxGeometryCount = data.maxGeometryCount;\n\t\t\t\tobject._maxVertexCount = data.maxVertexCount;\n\t\t\t\tobject._maxIndexCount = data.maxIndexCount;\n\n\t\t\t\tobject._geometryInitialized = data.geometryInitialized;\n\t\t\t\tobject._geometryCount = data.geometryCount;\n\n\t\t\t\tobject._matricesTexture = getTexture( data.matricesTexture.uuid );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\t// If cached is a promise, wait for it to resolve\n\t\t\tif ( cached.then ) {\n\n\t\t\t\tcached.then( imageBitmap => {\n\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t} );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// If cached is not a promise (i.e., it's already an imageBitmap)\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tconst promise = fetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t\treturn imageBitmap;\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tCache.remove( url );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tCache.add( url, promise );\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} ).catch( handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this._connected === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.isPlaying === true && this.source.detune !== undefined ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass UniformsGroup extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tconst uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];\n\n\t\t\tfor ( let j = 0; j < uniforms.length; j ++ ) {\n\n\t\t\t\tthis.uniforms.push( uniforms[ j ].clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162\n\n\tconstructor( width = 1, height = 1, count = 1, options = {} ) {\n\n\t\tconsole.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the \"count\" parameter to enable MRT.' );\n\n\t\tsuper( width, height, { ...options, count } );\n\n\t\tthis.isWebGLMultipleRenderTargets = true;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures;\n\n\t}\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearDisplayP3ColorSpace, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, P3Primaries, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, Rec709Primaries, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, createCanvasElement };\n","import {\n\tEventDispatcher,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3,\n\tPlane,\n\tRay,\n\tMathUtils\n} from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\nclass OrbitControls extends EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new Vector3();\n\n\t\t// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n\t\tthis.cursor = new Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// Limit camera target within a spherical area around the cursor\n\t\tthis.minTargetRadius = 0;\n\t\tthis.maxTargetRadius = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\tthis.zoomToCursor = false;\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.stopListenToKeyEvents = function () {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new Vector3();\n\t\t\tconst lastQuaternion = new Quaternion();\n\t\t\tconst lastTargetPosition = new Vector3();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update( deltaTime = null ) {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle( deltaTime ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\t// Limit the target distance from the cursor to create a sphere around the center of interest\n\t\t\t\tscope.target.sub( scope.cursor );\n\t\t\t\tscope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );\n\t\t\t\tscope.target.add( scope.cursor );\n\n\t\t\t\tlet zoomChanged = false;\n\t\t\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t\t\t// we adjust zoom later in these cases\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst prevRadius = spherical.radius;\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius * scale );\n\t\t\t\t\tzoomChanged = prevRadius != spherical.radius;\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// adjust camera position\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom ) {\n\n\t\t\t\t\tlet newRadius = null;\n\t\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t\t\t// this method avoids floating point error\n\t\t\t\t\t\tconst prevRadius = offset.length();\n\t\t\t\t\t\tnewRadius = clampDistance( prevRadius * scale );\n\n\t\t\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\t\t\tscope.object.position.addScaledVector( dollyDirection, radiusDelta );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tzoomChanged = !! radiusDelta;\n\n\t\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\t\t\tconst mouseBefore = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseBefore.unproject( scope.object );\n\n\t\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\n\t\t\t\t\t\tzoomChanged = prevZoom !== scope.object.zoom;\n\n\t\t\t\t\t\tconst mouseAfter = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseAfter.unproject( scope.object );\n\n\t\t\t\t\t\tscope.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tnewRadius = offset.length();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\t\t\tscope.zoomToCursor = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle the placement of the target\n\t\t\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\t\t\tscope.target.set( 0, 0, - 1 )\n\t\t\t\t\t\t\t\t.transformDirection( scope.object.matrix )\n\t\t\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t\t\t.add( scope.object.position );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t\t\t_ray.origin.copy( scope.object.position );\n\t\t\t\t\t\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );\n\n\t\t\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t\t\t// extremely large values\n\t\t\t\t\t\t\tif ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {\n\n\t\t\t\t\t\t\t\tobject.lookAt( scope.target );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );\n\t\t\t\t\t\t\t\t_ray.intersectPlane( _plane, scope.target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tconst prevZoom = scope.object.zoom;\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\n\t\t\t\t\tif ( prevZoom !== scope.object.zoom ) {\n\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tperformCursorZoom = false;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||\n\t\t\t\t\tlastTargetPosition.distanceToSquared( scope.target ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tlastTargetPosition.copy( scope.target );\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\tdocument.removeEventListener( 'keydown', interceptControlDown, { capture: true } );\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\t\tscope._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new Spherical();\n\t\tconst sphericalDelta = new Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new Vector3();\n\n\t\tconst rotateStart = new Vector2();\n\t\tconst rotateEnd = new Vector2();\n\t\tconst rotateDelta = new Vector2();\n\n\t\tconst panStart = new Vector2();\n\t\tconst panEnd = new Vector2();\n\t\tconst panDelta = new Vector2();\n\n\t\tconst dollyStart = new Vector2();\n\t\tconst dollyEnd = new Vector2();\n\t\tconst dollyDelta = new Vector2();\n\n\t\tconst dollyDirection = new Vector3();\n\t\tconst mouse = new Vector2();\n\t\tlet performCursorZoom = false;\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tlet controlActive = false;\n\n\t\tfunction getAutoRotationAngle( deltaTime ) {\n\n\t\t\tif ( deltaTime !== null ) {\n\n\t\t\t\treturn ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;\n\n\t\t\t} else {\n\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getZoomScale( delta ) {\n\n\t\t\tconst normalizedDelta = Math.abs( delta * 0.01 );\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateZoomParameters( x, y ) {\n\n\t\t\tif ( ! scope.zoomToCursor ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tperformCursorZoom = true;\n\n\t\t\tconst rect = scope.domElement.getBoundingClientRect();\n\t\t\tconst dx = x - rect.left;\n\t\t\tconst dy = y - rect.top;\n\t\t\tconst w = rect.width;\n\t\t\tconst h = rect.height;\n\n\t\t\tmouse.x = ( dx / w ) * 2 - 1;\n\t\t\tmouse.y = - ( dy / h ) * 2 + 1;\n\n\t\t\tdollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();\n\n\t\t}\n\n\t\tfunction clampDistance( dist ) {\n\n\t\t\treturn Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientX );\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( dollyDelta.y ) );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( dollyDelta.y ) );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tupdateZoomParameters( event.clientX, event.clientY );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale( event.deltaY ) );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale( event.deltaY ) );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan( event );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tconst centerX = ( event.pageX + position.x ) * 0.5;\n\t\t\tconst centerY = ( event.pageY + position.y ) * 0.5;\n\n\t\t\tupdateZoomParameters( centerX, centerY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( isTrackingPointer( event ) ) return;\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tconst pointerId = pointers[ 0 ];\n\t\t\t\t\tconst position = pointerPositions[ pointerId ];\n\n\t\t\t\t\t// minimal placeholder event - allows state correction on pointer-up\n\t\t\t\t\tonTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( customWheelEvent( event ) );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction customWheelEvent( event ) {\n\n\t\t\tconst mode = event.deltaMode;\n\n\t\t\t// minimal wheel event altered to meet delta-zoom demand\n\t\t\tconst newEvent = {\n\t\t\t\tclientX: event.clientX,\n\t\t\t\tclientY: event.clientY,\n\t\t\t\tdeltaY: event.deltaY,\n\t\t\t};\n\n\t\t\tswitch ( mode ) {\n\n\t\t\t\tcase 1: // LINE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // PAGE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 100;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// detect if event was triggered by pinching\n\t\t\tif ( event.ctrlKey && ! controlActive ) {\n\n\t\t\t\tnewEvent.deltaY *= 10;\n\n\t\t\t}\n\n\t\t\treturn newEvent;\n\n\t\t}\n\n\t\tfunction interceptControlDown( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = true;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interceptControlUp( event ) {\n\n\t\t\tif ( event.key === 'Control' ) {\n\n\t\t\t\tcontrolActive = false;\n\n\n\t\t\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\t\tdocument.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event.pointerId );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTrackingPointer( event ) {\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ] == event.pointerId ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerUp );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\tconst document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\tdocument.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\nexport { OrbitControls };\n","import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3,\n\tQuaternion,\n\tREVISION\n} from 'three';\nimport { decompress } from './../utils/TextureUtils.js';\n\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = decompress( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = decompress( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tlet byteStride = attribute.itemSize * componentSize;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n\t\t\t// inside a bufferView\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\n\n\t\t\t\toffset += byteStride - ( offset % byteStride );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = byteStride;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpending.push(\n\n\t\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t\t} )\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = decompress( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: this.processTexture( metalRoughTexture ),\n\t\t\t\tchannel: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: this.processTexture( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: this.processTexture( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: this.processTexture( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tuv2: 'TEXCOORD_2',\n\t\t\tuv3: 'TEXCOORD_3',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tlet didForceIndices = false;\n\n\t\tif ( isMultiMaterial && geometry.index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\tindices[ i ] = i;\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tdidForceIndices = true;\n\n\t\t}\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tif ( didForceIndices === true ) {\n\n\t\t\tgeometry.setIndex( null );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_dispersion';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.dispersion = material.dispersion;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: writer.processTexture( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: writer.processTexture( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_materials_bump';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || (\n\t\t       material.bumpScale === 1 &&\n\t\t     ! material.bumpMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tconst bumpMapDef = {\n\t\t\t\tindex: writer.processTexture( material.bumpMap ),\n\t\t\t\ttexCoord: material.bumpMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\n\t\t\textensionDef.bumpTexture = bumpMapDef;\n\n\t\t}\n\n\t\textensionDef.bumpFactor = material.bumpScale;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\n\n\t}\n\n\twriteNode( object, nodeDef ) {\n\n\t\tif ( ! object.isInstancedMesh ) return;\n\n\t\tconst writer = this.writer;\n\n\t\tconst mesh = object;\n\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\n\n\t\tconst matrix = new Matrix4();\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tmesh.getMatrixAt( i, matrix );\n\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\tposition.toArray( translationAttr, i * 3 );\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\n\t\t\tscale.toArray( scaleAttr, i * 3 );\n\n\t\t}\n\n\t\tconst attributes = {\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\n\t\t};\n\n\t\tif ( mesh.instanceColor )\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { attributes };\n\n\t\twriter.extensionsUsed[ this.name ] = true;\n\t\twriter.extensionsRequired[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n","/**\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  depth: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n *  bevelOffset: <float> // how far from text outline does bevel start\n * }\n */\n\nimport {\n\tExtrudeGeometry\n} from 'three';\n\nclass TextGeometry extends ExtrudeGeometry {\n\n\tconstructor( text, parameters = {} ) {\n\n\t\tconst font = parameters.font;\n\n\t\tif ( font === undefined ) {\n\n\t\t\tsuper(); // generate default extrude geometry\n\n\t\t} else {\n\n\t\t\tconst shapes = font.generateShapes( text, parameters.size );\n\n\t\t\t// translate parameters to ExtrudeGeometry API\n\n\t\t\tif ( parameters.depth === undefined && parameters.height !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.TextGeometry: .height is now depreciated. Please use .depth instead' ); // @deprecated, r163\n\n\t\t\t}\n\n\t\t\tparameters.depth = parameters.depth !== undefined ?\n\t\t\t\tparameters.depth : parameters.height !== undefined ?\n\t\t\t\t\tparameters.height : 50;\n\n\t\t\t// defaults\n\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\t\tsuper( shapes, parameters );\n\n\t\t}\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n}\n\n\nexport { TextGeometry };\n","/**\n * lil-gui\n * https://lil-gui.georgealways.com\n * @version 0.17.0\n * @author George Michael Brower\n * @license MIT\n */\nclass t{constructor(i,e,s,n,l=\"div\"){this.parent=i,this.object=e,this.property=s,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(\"div\"),this.domElement.classList.add(\"controller\"),this.domElement.classList.add(n),this.$name=document.createElement(\"div\"),this.$name.classList.add(\"name\"),t.nextNameID=t.nextNameID||0,this.$name.id=\"lil-gui-name-\"+ ++t.nextNameID,this.$widget=document.createElement(l),this.$widget.classList.add(\"widget\"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(s)}name(t){return this._name=t,this.$name.innerHTML=t,this}onChange(t){return this._onChange=t,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(t=!0){return this.disable(!t)}disable(t=!0){return t===this._disabled||(this._disabled=t,this.domElement.classList.toggle(\"disabled\",t),this.$disable.toggleAttribute(\"disabled\",t)),this}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?\"none\":\"\",this}hide(){return this.show(!1)}options(t){const i=this.parent.add(this.object,this.property,t);return i.name(this._name),this.destroy(),i}min(t){return this}max(t){return this}step(t){return this}decimals(t){return this}listen(t=!0){return this._listening=t,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const t=this.save();t!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=t}getValue(){return this.object[this.property]}setValue(t){return this.object[this.property]=t,this._callOnChange(),this.updateDisplay(),this}updateDisplay(){return this}load(t){return this.setValue(t),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class i extends t{constructor(t,i,e){super(t,i,e,\"boolean\",\"label\"),this.$input=document.createElement(\"input\"),this.$input.setAttribute(\"type\",\"checkbox\"),this.$input.setAttribute(\"aria-labelledby\",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener(\"change\",()=>{this.setValue(this.$input.checked),this._callOnFinishChange()}),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function e(t){let i,e;return(i=t.match(/(#|0x)?([a-f0-9]{6})/i))?e=i[2]:(i=t.match(/rgb\\(\\s*(\\d*)\\s*,\\s*(\\d*)\\s*,\\s*(\\d*)\\s*\\)/))?e=parseInt(i[1]).toString(16).padStart(2,0)+parseInt(i[2]).toString(16).padStart(2,0)+parseInt(i[3]).toString(16).padStart(2,0):(i=t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(e=i[1]+i[1]+i[2]+i[2]+i[3]+i[3]),!!e&&\"#\"+e}const s={isPrimitive:!0,match:t=>\"string\"==typeof t,fromHexString:e,toHexString:e},n={isPrimitive:!0,match:t=>\"number\"==typeof t,fromHexString:t=>parseInt(t.substring(1),16),toHexString:t=>\"#\"+t.toString(16).padStart(6,0)},l={isPrimitive:!1,match:Array.isArray,fromHexString(t,i,e=1){const s=n.fromHexString(t);i[0]=(s>>16&255)/255*e,i[1]=(s>>8&255)/255*e,i[2]=(255&s)/255*e},toHexString:([t,i,e],s=1)=>n.toHexString(t*(s=255/s)<<16^i*s<<8^e*s<<0)},r={isPrimitive:!1,match:t=>Object(t)===t,fromHexString(t,i,e=1){const s=n.fromHexString(t);i.r=(s>>16&255)/255*e,i.g=(s>>8&255)/255*e,i.b=(255&s)/255*e},toHexString:({r:t,g:i,b:e},s=1)=>n.toHexString(t*(s=255/s)<<16^i*s<<8^e*s<<0)},o=[s,n,l,r];class a extends t{constructor(t,i,s,n){var l;super(t,i,s,\"color\"),this.$input=document.createElement(\"input\"),this.$input.setAttribute(\"type\",\"color\"),this.$input.setAttribute(\"tabindex\",-1),this.$input.setAttribute(\"aria-labelledby\",this.$name.id),this.$text=document.createElement(\"input\"),this.$text.setAttribute(\"type\",\"text\"),this.$text.setAttribute(\"spellcheck\",\"false\"),this.$text.setAttribute(\"aria-labelledby\",this.$name.id),this.$display=document.createElement(\"div\"),this.$display.classList.add(\"display\"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(l=this.initialValue,o.find(t=>t.match(l))),this._rgbScale=n,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener(\"input\",()=>{this._setValueFromHexString(this.$input.value)}),this.$input.addEventListener(\"blur\",()=>{this._callOnFinishChange()}),this.$text.addEventListener(\"input\",()=>{const t=e(this.$text.value);t&&this._setValueFromHexString(t)}),this.$text.addEventListener(\"focus\",()=>{this._textFocused=!0,this.$text.select()}),this.$text.addEventListener(\"blur\",()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()}),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(t){if(this._format.isPrimitive){const i=this._format.fromHexString(t);this.setValue(i)}else this._format.fromHexString(t,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(t){return this._setValueFromHexString(t),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class h extends t{constructor(t,i,e){super(t,i,e,\"function\"),this.$button=document.createElement(\"button\"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener(\"click\",t=>{t.preventDefault(),this.getValue().call(this.object)}),this.$button.addEventListener(\"touchstart\",()=>{},{passive:!0}),this.$disable=this.$button}}class d extends t{constructor(t,i,e,s,n,l){super(t,i,e,\"number\"),this._initInput(),this.min(s),this.max(n);const r=void 0!==l;this.step(r?l:this._getImplicitStep(),r),this.updateDisplay()}decimals(t){return this._decimals=t,this.updateDisplay(),this}min(t){return this._min=t,this._onUpdateMinMax(),this}max(t){return this._max=t,this._onUpdateMinMax(),this}step(t,i=!0){return this._step=t,this._stepExplicit=i,this}updateDisplay(){const t=this.getValue();if(this._hasSlider){let i=(t-this._min)/(this._max-this._min);i=Math.max(0,Math.min(i,1)),this.$fill.style.width=100*i+\"%\"}return this._inputFocused||(this.$input.value=void 0===this._decimals?t:t.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement(\"input\"),this.$input.setAttribute(\"type\",\"number\"),this.$input.setAttribute(\"step\",\"any\"),this.$input.setAttribute(\"aria-labelledby\",this.$name.id),this.$widget.appendChild(this.$input),this.$disable=this.$input;const t=t=>{const i=parseFloat(this.$input.value);isNaN(i)||(this._snapClampSetValue(i+t),this.$input.value=this.getValue())};let i,e,s,n,l,r=!1;const o=t=>{if(r){const s=t.clientX-i,n=t.clientY-e;Math.abs(n)>5?(t.preventDefault(),this.$input.blur(),r=!1,this._setDraggingStyle(!0,\"vertical\")):Math.abs(s)>5&&a()}if(!r){const i=t.clientY-s;l-=i*this._step*this._arrowKeyMultiplier(t),n+l>this._max?l=this._max-n:n+l<this._min&&(l=this._min-n),this._snapClampSetValue(n+l)}s=t.clientY},a=()=>{this._setDraggingStyle(!1,\"vertical\"),this._callOnFinishChange(),window.removeEventListener(\"mousemove\",o),window.removeEventListener(\"mouseup\",a)};this.$input.addEventListener(\"input\",()=>{let t=parseFloat(this.$input.value);isNaN(t)||(this._stepExplicit&&(t=this._snap(t)),this.setValue(this._clamp(t)))}),this.$input.addEventListener(\"keydown\",i=>{\"Enter\"===i.code&&this.$input.blur(),\"ArrowUp\"===i.code&&(i.preventDefault(),t(this._step*this._arrowKeyMultiplier(i))),\"ArrowDown\"===i.code&&(i.preventDefault(),t(this._step*this._arrowKeyMultiplier(i)*-1))}),this.$input.addEventListener(\"wheel\",i=>{this._inputFocused&&(i.preventDefault(),t(this._step*this._normalizeMouseWheel(i)))},{passive:!1}),this.$input.addEventListener(\"mousedown\",t=>{i=t.clientX,e=s=t.clientY,r=!0,n=this.getValue(),l=0,window.addEventListener(\"mousemove\",o),window.addEventListener(\"mouseup\",a)}),this.$input.addEventListener(\"focus\",()=>{this._inputFocused=!0}),this.$input.addEventListener(\"blur\",()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()})}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement(\"div\"),this.$slider.classList.add(\"slider\"),this.$fill=document.createElement(\"div\"),this.$fill.classList.add(\"fill\"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add(\"hasSlider\");const t=t=>{const i=this.$slider.getBoundingClientRect();let e=(s=t,n=i.left,l=i.right,r=this._min,o=this._max,(s-n)/(l-n)*(o-r)+r);var s,n,l,r,o;this._snapClampSetValue(e)},i=i=>{t(i.clientX)},e=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener(\"mousemove\",i),window.removeEventListener(\"mouseup\",e)};let s,n,l=!1;const r=i=>{i.preventDefault(),this._setDraggingStyle(!0),t(i.touches[0].clientX),l=!1},o=i=>{if(l){const t=i.touches[0].clientX-s,e=i.touches[0].clientY-n;Math.abs(t)>Math.abs(e)?r(i):(window.removeEventListener(\"touchmove\",o),window.removeEventListener(\"touchend\",a))}else i.preventDefault(),t(i.touches[0].clientX)},a=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener(\"touchmove\",o),window.removeEventListener(\"touchend\",a)},h=this._callOnFinishChange.bind(this);let d;this.$slider.addEventListener(\"mousedown\",s=>{this._setDraggingStyle(!0),t(s.clientX),window.addEventListener(\"mousemove\",i),window.addEventListener(\"mouseup\",e)}),this.$slider.addEventListener(\"touchstart\",t=>{t.touches.length>1||(this._hasScrollBar?(s=t.touches[0].clientX,n=t.touches[0].clientY,l=!0):r(t),window.addEventListener(\"touchmove\",o,{passive:!1}),window.addEventListener(\"touchend\",a))},{passive:!1}),this.$slider.addEventListener(\"wheel\",t=>{if(Math.abs(t.deltaX)<Math.abs(t.deltaY)&&this._hasScrollBar)return;t.preventDefault();const i=this._normalizeMouseWheel(t)*this._step;this._snapClampSetValue(this.getValue()+i),this.$input.value=this.getValue(),clearTimeout(d),d=setTimeout(h,400)},{passive:!1})}_setDraggingStyle(t,i=\"horizontal\"){this.$slider&&this.$slider.classList.toggle(\"active\",t),document.body.classList.toggle(\"lil-gui-dragging\",t),document.body.classList.toggle(\"lil-gui-\"+i,t)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(t){let{deltaX:i,deltaY:e}=t;Math.floor(t.deltaY)!==t.deltaY&&t.wheelDelta&&(i=0,e=-t.wheelDelta/120,e*=this._stepExplicit?1:10);return i+-e}_arrowKeyMultiplier(t){let i=this._stepExplicit?1:10;return t.shiftKey?i*=10:t.altKey&&(i/=10),i}_snap(t){const i=Math.round(t/this._step)*this._step;return parseFloat(i.toPrecision(15))}_clamp(t){return t<this._min&&(t=this._min),t>this._max&&(t=this._max),t}_snapClampSetValue(t){this.setValue(this._clamp(this._snap(t)))}get _hasScrollBar(){const t=this.parent.root.$children;return t.scrollHeight>t.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class c extends t{constructor(t,i,e,s){super(t,i,e,\"option\"),this.$select=document.createElement(\"select\"),this.$select.setAttribute(\"aria-labelledby\",this.$name.id),this.$display=document.createElement(\"div\"),this.$display.classList.add(\"display\"),this._values=Array.isArray(s)?s:Object.values(s),this._names=Array.isArray(s)?s:Object.keys(s),this._names.forEach(t=>{const i=document.createElement(\"option\");i.innerHTML=t,this.$select.appendChild(i)}),this.$select.addEventListener(\"change\",()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()}),this.$select.addEventListener(\"focus\",()=>{this.$display.classList.add(\"focus\")}),this.$select.addEventListener(\"blur\",()=>{this.$display.classList.remove(\"focus\")}),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.updateDisplay()}updateDisplay(){const t=this.getValue(),i=this._values.indexOf(t);return this.$select.selectedIndex=i,this.$display.innerHTML=-1===i?t:this._names[i],this}}class u extends t{constructor(t,i,e){super(t,i,e,\"string\"),this.$input=document.createElement(\"input\"),this.$input.setAttribute(\"type\",\"text\"),this.$input.setAttribute(\"aria-labelledby\",this.$name.id),this.$input.addEventListener(\"input\",()=>{this.setValue(this.$input.value)}),this.$input.addEventListener(\"keydown\",t=>{\"Enter\"===t.code&&this.$input.blur()}),this.$input.addEventListener(\"blur\",()=>{this._callOnFinishChange()}),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let p=!1;class g{constructor({parent:t,autoPlace:i=void 0===t,container:e,width:s,title:n=\"Controls\",injectStyles:l=!0,touchStyles:r=!0}={}){if(this.parent=t,this.root=t?t.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement(\"div\"),this.domElement.classList.add(\"lil-gui\"),this.$title=document.createElement(\"div\"),this.$title.classList.add(\"title\"),this.$title.setAttribute(\"role\",\"button\"),this.$title.setAttribute(\"aria-expanded\",!0),this.$title.setAttribute(\"tabindex\",0),this.$title.addEventListener(\"click\",()=>this.openAnimated(this._closed)),this.$title.addEventListener(\"keydown\",t=>{\"Enter\"!==t.code&&\"Space\"!==t.code||(t.preventDefault(),this.$title.click())}),this.$title.addEventListener(\"touchstart\",()=>{},{passive:!0}),this.$children=document.createElement(\"div\"),this.$children.classList.add(\"children\"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(n),r&&this.domElement.classList.add(\"allow-touch-styles\"),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add(\"root\"),!p&&l&&(!function(t){const i=document.createElement(\"style\");i.innerHTML=t;const e=document.querySelector(\"head link[rel=stylesheet], head style\");e?document.head.insertBefore(i,e):document.head.appendChild(i)}('.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,\"Droid Sans Mono\",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:\"\";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:\"\";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:\"\"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:\"Empty\";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:\"\";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url(\"data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==\") format(\"woff\")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:\" \";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}'),p=!0),e?e.appendChild(this.domElement):i&&(this.domElement.classList.add(\"autoPlace\"),document.body.appendChild(this.domElement)),s&&this.domElement.style.setProperty(\"--width\",s+\"px\"),this.domElement.addEventListener(\"keydown\",t=>t.stopPropagation()),this.domElement.addEventListener(\"keyup\",t=>t.stopPropagation())}add(t,e,s,n,l){if(Object(s)===s)return new c(this,t,e,s);const r=t[e];switch(typeof r){case\"number\":return new d(this,t,e,s,n,l);case\"boolean\":return new i(this,t,e);case\"string\":return new u(this,t,e);case\"function\":return new h(this,t,e)}console.error(\"gui.add failed\\n\\tproperty:\",e,\"\\n\\tobject:\",t,\"\\n\\tvalue:\",r)}addColor(t,i,e=1){return new a(this,t,i,e)}addFolder(t){return new g({parent:this,title:t})}load(t,i=!0){return t.controllers&&this.controllers.forEach(i=>{i instanceof h||i._name in t.controllers&&i.load(t.controllers[i._name])}),i&&t.folders&&this.folders.forEach(i=>{i._title in t.folders&&i.load(t.folders[i._title])}),this}save(t=!0){const i={controllers:{},folders:{}};return this.controllers.forEach(t=>{if(!(t instanceof h)){if(t._name in i.controllers)throw new Error(`Cannot save GUI with duplicate property \"${t._name}\"`);i.controllers[t._name]=t.save()}}),t&&this.folders.forEach(t=>{if(t._title in i.folders)throw new Error(`Cannot save GUI with duplicate folder \"${t._title}\"`);i.folders[t._title]=t.save()}),i}open(t=!0){return this._closed=!t,this.$title.setAttribute(\"aria-expanded\",!this._closed),this.domElement.classList.toggle(\"closed\",this._closed),this}close(){return this.open(!1)}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?\"none\":\"\",this}hide(){return this.show(!1)}openAnimated(t=!0){return this._closed=!t,this.$title.setAttribute(\"aria-expanded\",!this._closed),requestAnimationFrame(()=>{const i=this.$children.clientHeight;this.$children.style.height=i+\"px\",this.domElement.classList.add(\"transition\");const e=t=>{t.target===this.$children&&(this.$children.style.height=\"\",this.domElement.classList.remove(\"transition\"),this.$children.removeEventListener(\"transitionend\",e))};this.$children.addEventListener(\"transitionend\",e);const s=t?this.$children.scrollHeight:0;this.domElement.classList.toggle(\"closed\",!t),requestAnimationFrame(()=>{this.$children.style.height=s+\"px\"})}),this}title(t){return this._title=t,this.$title.innerHTML=t,this}reset(t=!0){return(t?this.controllersRecursive():this.controllers).forEach(t=>t.reset()),this}onChange(t){return this._onChange=t,this}_callOnChange(t){this.parent&&this.parent._callOnChange(t),void 0!==this._onChange&&this._onChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(t){this.parent&&this.parent._callOnFinishChange(t),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach(t=>t.destroy())}controllersRecursive(){let t=Array.from(this.controllers);return this.folders.forEach(i=>{t=t.concat(i.controllersRecursive())}),t}foldersRecursive(){let t=Array.from(this.folders);return this.folders.forEach(i=>{t=t.concat(i.foldersRecursive())}),t}}export default g;export{i as BooleanController,a as ColorController,t as Controller,h as FunctionController,g as GUI,d as NumberController,c as OptionController,u as StringController};\n","import {\n\tFileLoader,\n\tLoader,\n\tShapePath\n} from 'three';\n\nclass FontLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tconst font = scope.parse( JSON.parse( text ) );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\treturn new Font( json );\n\n\t}\n\n}\n\n//\n\nclass Font {\n\n\tconstructor( data ) {\n\n\t\tthis.isFont = true;\n\n\t\tthis.type = 'Font';\n\n\t\tthis.data = data;\n\n\t}\n\n\tgenerateShapes( text, size = 100 ) {\n\n\t\tconst shapes = [];\n\t\tconst paths = createPaths( text, size, this.data );\n\n\t\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tshapes.push( ...paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nfunction createPaths( text, size, data ) {\n\n\tconst chars = Array.from( text );\n\tconst scale = size / data.resolution;\n\tconst line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tconst paths = [];\n\n\tlet offsetX = 0, offsetY = 0;\n\n\tfor ( let i = 0; i < chars.length; i ++ ) {\n\n\t\tconst char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tconst ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tconst glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) {\n\n\t\tconsole.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' );\n\n\t\treturn;\n\n\t}\n\n\tconst path = new ShapePath();\n\n\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tconst outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( let i = 0, l = outline.length; i < l; ) {\n\n\t\t\tconst action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\nexport { FontLoader, Font };\n","import {\n\tPlaneGeometry,\n\tShaderMaterial,\n\tUniform,\n\tMesh,\n\tPerspectiveCamera,\n\tScene,\n\tWebGLRenderer,\n\tCanvasTexture,\n\tSRGBColorSpace\n} from 'three';\n\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\n\nexport function decompress( texture, maxTextureSize = Infinity, renderer = null ) {\n\n\tif ( ! fullscreenQuadGeometry ) fullscreenQuadGeometry = new PlaneGeometry( 2, 2, 1, 1 );\n\tif ( ! fullscreenQuadMaterial ) fullscreenQuadMaterial = new ShaderMaterial( {\n\t\tuniforms: { blitTexture: new Uniform( texture ) },\n\t\tvertexShader: `\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main(){\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = vec4(position.xy * 1.0,0.,.999999);\n\t\t\t}`,\n\t\tfragmentShader: `\n\t\t\tuniform sampler2D blitTexture; \n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main(){ \n\t\t\t\tgl_FragColor = vec4(vUv.xy, 0, 1);\n\t\t\t\t\n\t\t\t\t#ifdef IS_SRGB\n\t\t\t\tgl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n\t\t\t\t#else\n\t\t\t\tgl_FragColor = texture2D( blitTexture, vUv);\n\t\t\t\t#endif\n\t\t\t}`\n\t} );\n\n\tfullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n\tfullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;\n\tfullscreenQuadMaterial.needsUpdate = true;\n\n\tif ( ! fullscreenQuad ) {\n\n\t\tfullscreenQuad = new Mesh( fullscreenQuadGeometry, fullscreenQuadMaterial );\n\t\tfullscreenQuad.frustumCulled = false;\n\n\t}\n\n\tconst _camera = new PerspectiveCamera();\n\tconst _scene = new Scene();\n\t_scene.add( fullscreenQuad );\n\n\tif ( renderer === null ) {\n\n\t\trenderer = _renderer = new WebGLRenderer( { antialias: false } );\n\n\t}\n\n\tconst width = Math.min( texture.image.width, maxTextureSize );\n\tconst height = Math.min( texture.image.height, maxTextureSize );\n\n\trenderer.setSize( width, height );\n\trenderer.clear();\n\trenderer.render( _scene, _camera );\n\n\tconst canvas = document.createElement( 'canvas' );\n\tconst context = canvas.getContext( '2d' );\n\n\tcanvas.width = width;\n\tcanvas.height = height;\n\n\tcontext.drawImage( renderer.domElement, 0, 0, width, height );\n\n\tconst readableTexture = new CanvasTexture( canvas );\n\n\treadableTexture.minFilter = texture.minFilter;\n\treadableTexture.magFilter = texture.magFilter;\n\treadableTexture.wrapS = texture.wrapS;\n\treadableTexture.wrapT = texture.wrapT;\n\treadableTexture.name = texture.name;\n\n\tif ( _renderer ) {\n\n\t\t_renderer.forceContextLoss();\n\t\t_renderer.dispose();\n\t\t_renderer = null;\n\n\t}\n\n\treturn readableTexture;\n\n}\n","let currentDotNetHelper;\nlet currentModalDialogElement; // Store the element reference passed from Blazor\n\n// We don't need setupDraggableModal anymore, as positioning is done via drag.\n// If you want initial centering, it's better done in CSS or after rendering using modalDialogElementRef.\n\nexport const getModalDialogRect = (element) => { // Now accepts an ElementReference\n    if (element) {\n        return element.getBoundingClientRect();\n    }\n    return null;\n};\n\nexport const startModalDrag = (dotNetHelper, element) => { // Now accepts ElementReference\n    currentDotNetHelper = dotNetHelper;\n    currentModalDialogElement = element; // Store the passed element\n\n    if (currentModalDialogElement) {\n        // Ensure the modal dialog is position: absolute for dragging\n        currentModalDialogElement.style.position = 'absolute';\n        currentModalDialogElement.style.margin = '0'; // Remove default margin (if Bootstrap is applying it)\n\n        // Set initial position if it hasn't been set by CSS transform\n        // Or if you want it centered initially, you can set it here based on window size\n        // This is more complex to do reliably in JS without knowing viewport,\n        // so rely on initial CSS transform if possible.\n\n        document.onmousemove = (e) => {\n            currentDotNetHelper.invokeMethodAsync('HandleMouseMove', e.clientX, e.clientY);\n        };\n        document.onmouseup = () => {\n            currentDotNetHelper.invokeMethodAsync('HandleMouseUp');\n            stopModalDrag();\n        };\n    }\n};\n\nexport const stopModalDrag = () => {\n    document.onmousemove = null;\n    document.onmouseup = null;\n    currentDotNetHelper = null;\n    currentModalDialogElement = null; // Clear the stored element\n};\n\n// getModalDialogElement is now removed as it's no longer needed\n\nexport const setModalPosition = (x, y) => { // No longer accepts element, uses stored one\n    if (currentModalDialogElement) {\n        currentModalDialogElement.style.left = `${x}px`;\n        currentModalDialogElement.style.top = `${y}px`;\n    }\n};\n\nexport const focusElement = (element) => {\n    if (element) {\n        element.focus();\n    }\n};","import {dia, elementTools, linkTools, shapes} from '@joint/core';\n\nexport {drawSLD, updateSLD, updateSLDItem, updateSLDWithStudyResults}\n\nvar dotNetObjDraw;\nvar dotNetObjSLD;\nvar graph, paper;\nvar sldComponentsJS = [];\nvar sldComponentsString1;\n\n\nvar propertyButton = new elementTools.Button({\n    focusOpacity: 0.5,\n    // slightly right corner\n    x: '0%',\n    y: '50%',\n    offset: {x: 10, y: 0},\n    action: function (evt) {\n        if (dotNetObjSLD) dotNetObjSLD.invokeMethodAsync('PropertyUpdate', this.model.tag, this.model.type);\n    },\n    markup: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#001DFF',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -2 4 2 4 M 0 3 0 0 M -2 -1 1 -1 M -1 -4 1 -4',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }]\n});\n\n\nvar infoButton = new linkTools.Button({\n    markup: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {'r': 7, 'fill': '#001DFF', 'cursor': 'pointer'}\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -2 4 2 4 M 0 3 0 0 M -2 -1 1 -1 M -1 -4 1 -4',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    distance: '50%',\n    offset: 0,\n    action: function (evt) {\n        console.log('View id: ' + this.id + '\\n' + 'Model id: ' + this.model.id);\n    }\n});\n\nvar removeButton = new linkTools.Button({\n    markup: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {'r': 7, 'fill': 'red', 'cursor': 'pointer'}\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -4 4 L 4 -4 M 4 4 L -4 -4',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    distance: '25%',\n    offset: 0,\n    action: function (evt) {\n        // Get the link by its ID\n        const link = graph.getCell(this.model.id);\n        if (link && link.isLink()) {\n            removeLink(link);\n        } else {\n            console.log(`Link id '${this.id}' of link model '${this.model.id}' not available.`);\n        }\n    }\n});\n\nvar validateButton = new linkTools.Button({\n    markup: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {'r': 7, 'fill': 'green', 'cursor': 'pointer'}\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -2.5 -0.2 l 0.23 -0.24 c 0.34 0.1 1 0.35 1.7 0.72 c 0.6 -0.8 2 -1.9 2.7 -2.4 l 0.2 0.2 l -2.8 3.78 l -2 -2 z',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    distance: '75%',\n    offset: 0,\n    action: function (evt) {\n        // Get the link by its ID\n        const link = graph.getCell(this.model.id);\n        if (link && link.isLink()) {\n            validateLinkFromServer(link);\n        } else {\n            console.log(`Link id '${this.id}' of link model '${this.model.id}' not available.`);\n        }\n    }\n});\n\n\nfunction updateSLD() {\n    console.log(\"Client side Update SLD\");\n    var allChildren = graph.getElements();\n    console.log(`Graph has ${allChildren.length} children. sldComponents has ${sldComponentsJS.length} items.`);\n    for (let i = 0; i < sldComponentsJS.length; i += 10) {\n        var sldComponentsString = JSON.stringify(sldComponentsJS.slice(i, Math.min(sldComponentsJS.length, i + 9)));\n        //sldComponentsString = \"\";\n        if (dotNetObjSLD) dotNetObjSLD.invokeMethodAsync('SLDComponentUpdate', sldComponentsString);\n    }\n    sldComponentsJS = [];\n}\n\n\nfunction updateSLDItem(itemJSON, modalType, originalTag, branchesString) {\n    console.log(\"Client side Update SLDItem\", modalType, itemJSON);\n    let item = JSON.parse(itemJSON);\n    let branches = JSON.parse(branchesString);\n    let itemModel = graph.getElements().find(el => el.tag === originalTag);\n\n    switch (modalType) {\n        case \"Bus\":\n            itemModel = updateBus(itemModel, item, branches);\n            break;\n        case \"Transformer\":\n            itemModel = updateTransformer(itemModel, item, branches);\n            break;\n        case \"CableBranch\":\n            itemModel = updateCable(itemModel, item, branches);\n            break;\n        case \"BusDuct\":\n            itemModel = updateBusDuct(itemModel, item, branches);\n            break;\n        case \"Switch\":\n            itemModel = updateSwitch(itemModel, item, branches);\n            break;\n        case \"Capacitor\":\n            itemModel = updateCapacitor(itemModel, item, branches);\n            break;\n        case \"Motor\":\n            itemModel = updateMotor(itemModel, item, branches);\n            break;\n        case \"Heater\":\n            itemModel = updateHeater(itemModel, item, branches);\n            break;\n        case \"LumpLoad\":\n            itemModel = updateLumpLoad(itemModel, item, branches);\n            break;\n        default:\n            //itemModel = updateBus(itemModel, item, branches);\n            break;\n    }\n\n    // check if there is any change in the tag of the item\n    // then the link tag connecting to the item should be updated\n    var itemModels = graph.getLinks().filter(el =>\n        el.source && el.source.hasOwnProperty('tag') && el.source.tag === originalTag ||\n        el.target && el.target.hasOwnProperty('tag') && el.target.tag === originalTag);\n    var itemModels1 = graph.getLinks().filter(el =>\n        el.source && el.source.hasOwnProperty('tag') && el.source.tag === item.Tag ||\n        el.target && el.target.hasOwnProperty('tag') && el.target.tag === item.Tag);\n\n    // Retrieve all link models in the graph\n    const links = graph.getLinks(); // or graph.getElements() if you want all elements\n\n    // Filter links based on the property value\n    const filteredLinks = links.filter(link => link.attr('source/tag') === originalTag);\n\n\n    itemModels.forEach(itemModel => itemModel = getLinkTag(itemModel));\n}\n\n\nfunction updateSLDWithStudyResults(busesString, switchboardString, switchString, branchesString, loadsString, transformersString, cableBranchesString, busDuctsString) {\n\n\n    let buses = JSON.parse(busesString);\n    let switchboards = JSON.parse(switchboardString);\n    let switches = JSON.parse(switchString);\n    let branches = JSON.parse(branchesString);\n    let loads = JSON.parse(loadsString);\n    let transformers = JSON.parse(transformersString);\n    let cableBranches = JSON.parse(cableBranchesString);\n    let busDucts = JSON.parse(busDuctsString);\n\n\n    buses.forEach(item => {\n        let itemModel = graph.getElements().find(el => el.tag && el.tag === item.Tag);\n        if (itemModel) itemModel = updateBus(itemModel, item);\n    })\n\n    transformers.forEach(item => {\n        if (!branches.find(br => br.Tag === item.Tag)) return;\n        let itemModel = graph.getElements().find(el => el.tag && el.tag === item.Tag);\n        if (itemModel) itemModel = updateTransformer(itemModel, item, branches);\n    })\n\n    cableBranches.forEach(item => {\n        if (!branches.find(br => br.Tag === item.Tag)) return;\n        let itemModel = graph.getElements().find(el => el.tag && el.tag === item.Tag);\n        if (itemModel) itemModel = updateCable(itemModel, item, branches);\n    })\n\n    busDucts.forEach(item => {\n        if (!branches.find(br => br.Tag === item.Tag)) return;\n        let itemModel = graph.getElements().find(el => el.tag && el.tag === item.Tag);\n        if (itemModel) itemModel = updateBusDuct(itemModel, item, branches);\n    })\n\n    loads.forEach(item => {\n        var itemModel = graph.getElements().find(el => el.tag && el.tag === item.Tag);\n        if (itemModel) {\n            if (item.Category === \"Motor\") {\n                itemModel = updateMotor(itemModel, item, branches);\n            } else if (item.Category === \"Heater\") {\n                itemModel = updateHeater(itemModel, item, branches);\n            } else if (item.Category === \"LumpLoad\") {\n                itemModel = updateLumpLoad(itemModel, item, branches);\n            }\n        }\n    })\n\n    switches.forEach(item => {\n        let itemModel = graph.getElements().find(el => el.tag === item.Tag);\n        if (itemModel) itemModel = updateSwitch(itemModel, item, branches);\n    })\n\n\n}\n\n\nfunction drawSLD(divString, xGridSize, yGridSize, leftSpacing, topSpacing, xGridSpacing, yGridSpacing,\n                 busesString, switchboardString, branchesString, loadsString, transformersString, cablesString,\n                 busDuctsString, xyString, sldComponentsString, dotNetObjRef, dotNetObjSLDRef) {\n\n\n    // Define the custom drawing elements\n    // grid   \n    let GridElement = dia.Element.define('CustomGridElement', {\n        attrs: {\n            // size 40 x 40\n            body: {refWidth: '100%', refHeight: '100%', refX: '50%', refY: '10%',},\n            // textAnchor: middle: Align text to the middle horizontally\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'middle', fontSize: 10, refX: '50%', refY: -45,},\n            // textAnchor end: Right align text// Adjust horizontal position relative to refX\n            ratedSC: {fill: 'black', textAnchor: 'end', fontSize: 10, refX: '50%', refY: -35, dx: -2,},\n            ratedVoltage: {fill: 'black', textAnchor: 'start', fontSize: 10, refX: '50%', refY: -35, dx: 2,},\n            busFaultkA: {\n                fill: 'red',\n                fontWeight: 'bold',\n                textAnchor: 'end',\n                fontSize: 10,\n                refX: '50%',\n                refY: 5,\n                dx: -10,\n            },\n            operatingVoltage: {fill: 'blue', textAnchor: 'start', fontSize: 10, refX: '50%', refY: 5, dx: 10,}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '50%', y: 10}},\n                    label: {\n                        position: {name: 'right', args: {x: 10, y: -5}},\n                        markup: [{tagName: 'text', selector: 'label'}]\n                    },\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n            },\n            items: [{id: '1', group: 'in'}] // bus can have muliple ports\n        },\n    }, {\n        markup: [\n            {\n                //https://yqnn.github.io/svg-path-editor/\n                tagName: 'path', selector: 'body',\n                attributes: {\n                    d: 'M 0 0 v -6 h -9 v -18 h 18 v 18 h -9 m -3 0 l -6 -6 l 12 -12 l 6 6 l -12 12 m 6 0 l -12 -12 l 6 -6 l 12 12 l -6 6 m 6 0 l -18 -18 m 18 0 l -18 18 z',\n                    stroke: 'blue', strokeWidth: 1, fill: 'none'\n                },\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'ratedSC'},\n            {tagName: 'text', selector: 'ratedVoltage'},\n            {tagName: 'text', selector: 'busFaultkA'},\n            {tagName: 'text', selector: 'operatingVoltage'},\n        ]\n    });\n\n    // switchboard    \n    let SwitchboardElement = dia.Element.define('SwitchboardElement', {\n        attrs: {\n            root: {magnet: false},\n            body: { refWidth: '100%', refHeight: '100%', refCx: '0%', refCy: '100%', strokeWidth: 1, strokeDasharray: '5,5', stroke: 'brown', fill: 'none', refX: '0%', refY: '0%',  alphaValue: 0.4},\n            tag: {ref: 'body', fill: 'blue', fontWeight: 'bold', textAnchor: 'start', fontSize: 8, refX: 5, refY: 5,},\n            '.': {'pointer-events': 'none'}\n        }\n    }, {\n        markup: [\n            {tagName: 'rect', selector: 'body'},\n            {tagName: 'text', selector: 'tag'},\n        ]\n    });\n\n    // node \n    let NodeElement = dia.Element.define('CustomNodeElement', {\n        attrs: {\n            root: {magnet: false},\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'start', fontSize: 8, refX: '0%', refY: -12},\n            ratedSC: {textAnchor: 'start', fontSize: 8, fill: 'brown', refX: '0%', refY: 5},\n            ratedVoltage: {textAnchor: 'start', fontSize: 8, fill: 'blue', refX: 25, refY: 5},\n            busFault: {textAnchor: 'end', fontSize: 8, fill: 'red', refX: '100%', refY: -12},\n            operatingVoltage: {textAnchor: 'end', fontSize: 8, fill: 'blue', refX: '100%', refY: 5}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {name: 'absolute', args: {x: '50%', y: 0}},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n            },\n            items: [{id: '1', group: 'in'}] // node has only one port\n        }\n    }, {\n        markup: [\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'ratedSC'},\n            {tagName: 'text', selector: 'ratedVoltage'},\n            {tagName: 'text', selector: 'busFault'},\n            {tagName: 'text', selector: 'operatingVoltage'},\n        ]\n    });\n\n    // bus\n    let BusElement = dia.Element.define('CustomBusElement', {\n        attrs: {\n            root: {magnet: false},\n            body: {stroke: 'blue', strokeWidth: 5, fill: 'transparent'},\n            label: {ref: 'body', fill: 'blue', fontWeight: 'bold', textAnchor: 'start', fontSize: 8, refX: '0%', refY: -12},\n            ratedSC: {ref: 'body', textAnchor: 'start', fontSize: 8, fill: 'brown', refX: '0%', refY: 5},\n            ratedVoltage: { ref: 'body',textAnchor: 'start',fontSize: 8, fill: 'blue', refX: 25, refY: 5},\n            busFault: {ref: 'body',textAnchor: 'end',fontSize: 8, fill: 'red', refX: '100%', refY: -12 },\n            operatingVoltage: {ref: 'body', textAnchor: 'end', fontSize: 8, fill: 'blue', refX: '100%', refY: 5}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '50%', y: 0}},\n                    label: {\n                        position: {name: 'right', args: {x: 10, y: -5}},\n                        markup: [{tagName: 'text', selector: 'label'}]\n                    },\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n                //'out': {\n                //    position: { name: 'absolute', args: { x: '50%', y: 2 } },\n                //    label: { position: { name: 'right', args: { x: 10, y: 5 } }, markup: [{ tagName: 'text', selector: 'label' }] },\n                //    attrs: { portBody: { magnet: true, r: 3, fill: '#E6A502', stroke: '#023047' }, label: { text: 'to', fontSize: 8, } },\n                //    markup: [{ tagName: 'circle', selector: 'portBody' }],\n                //}\n            },\n            items: [{id: '1', group: 'in'}] // bus can have muliple ports\n        }\n    }, {\n        markup: [\n            {tagName: 'line', selector: 'body'},\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'ratedSC'},\n            {tagName: 'text', selector: 'ratedVoltage'},\n            {tagName: 'text', selector: 'busFault'},\n            {tagName: 'text', selector: 'operatingVoltage'},\n        ]\n    });\n\n    // node \n    let BusNodeElement = dia.Element.define('BusNodeElement', {\n        attrs: {\n            body: {\n                r: 14, // Radius of the circle\n                cx: '50%', // Center x-coordinate (relative to the element's width)\n                cy: '50%', // Center y-coordinate (relative to the element's height)\n                strokeWidth: 1,\n                stroke: '#000000',\n                fill: 'yellow',\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: 'circle',\n                selector: 'body'\n            }\n        ]\n    });\n\n    // load\n    let LoadElement = dia.Element.define('LoadElement', {\n        attrs: {\n            body: {\n                refWidth: '100%', // Full width of the element\n                refHeight: '100%', // Full height of the element\n                strokeWidth: 1,\n                stroke: '#000000',\n                fill: 'pink'\n            },\n            label: {\n                fill: 'blue',\n                fontWeight: 'bold',\n                textAnchor: 'middle', // Center-align text\n                fontSize: 8,\n                refX: 0, // Center alignment horizontally\n                refY: 35, // Adjust as needed\n            },\n            operatingPower: {\n                fill: 'blue',\n                textAnchor: 'middle', // Center-align text\n                fontSize: 8,\n                refX: 0, // Center alignment horizontally\n                refY: 45, // Adjust as needed\n            },\n            rating: {\n                fill: 'black',\n                textAnchor: 'middle', // Center-align text\n                fontSize: 8,\n                refX: 0, // Center alignment horizontally\n                refY: 55, // Adjust as needed\n            }\n        }\n    }, {\n        markup: [\n            {tagName: 'rect', selector: 'body'},\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'operatingPower'}, // Adjusted order\n            {tagName: 'text', selector: 'rating'} // Adjusted order\n        ]\n    });\n\n    // lump load \n    let LumpLoadElement = dia.Element.define('LumpLoadElement', {\n        attrs: {\n            root: {magnet: false},\n            body1: {refRCircumscribed: '25%', refCx: '0%', refCy: '50%', strokeWidth: 1, stroke: 'black', fill: 'cyan', refX: '0%',refY: '-15%', alphaValue: 0.4 },\n            body2: {refWidth: '100%', refHeight: '100%', refX: '0%', refY: '0%', stroke: 'black', strokeWidth: 1, fill: 'none' },\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 15, refY: -25,},\n            operatingPower: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -15,},\n            rating: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -5,},\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '0%', y: -10}},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}]\n        }\n    }, {\n        markup: [\n            {tagName: 'circle', selector: 'body1'},\n            {\n                tagName: 'path',\n                selector: 'body2',\n                attributes: {d: 'm 0 15 L -15 15 L 0 38 L 15 15 L 0 15 m 0 0 v -20 Z'},\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'operatingPower'},\n            {tagName: 'text', selector: 'rating'},\n        ]\n    });\n\n    // capacitor \n    let CapacitorElement = dia.Element.define('CapacitorElement', {\n        attrs: {\n            root: {magnet: false},\n            body: {refWidth: '100%', refHeight: '100%', refX: '0%', refY: '0%', stroke: 'black', strokeWidth: 2},\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 15, refY: -25,},\n            operatingPower: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -15,},\n            rating: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -5,},\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '0%', y: -10}},\n                    label: {\n                        position: {name: 'right', args: {x: 10, y: -5}},\n                        markup: [{tagName: 'text', selector: 'label'}]\n                    },\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}]\n        }\n    }, {\n        markup: [\n            {\n                tagName: 'path',\n                selector: 'body',\n                attributes: {d: 'M -20 15 L 20 15 L -20 15 Z M -21 30 C -10 16 10 16 20 30 m 0 0 C 10 16 -10 16 -21 30 M 0 20 L 0 37 M 0 15 L 0 0 Z'},\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'operatingPower'},\n            {tagName: 'text', selector: 'rating'},\n        ]\n    });\n\n    // transformer element   \n    let TransformerElement = dia.Element.define('TransformerElement', {\n        attrs: {\n            root: {magnet: false},\n            // primary: 100%/sqrt(2), i.e., radious is 100% of the width/heght of the element size width\n            primary: {\n                refRCircumscribed: '71%',\n                refCx: '0%',\n                refCy: '50%',\n                strokeWidth: 1,\n                stroke: 'black',\n                fill: 'aquamarine',\n                refX: '0%',\n                refY: '-75%',\n                alphaValue: 0.4\n            },\n            secondary: {\n                refRCircumscribed: '71%',\n                refCx: '0%',\n                refCy: '50%',\n                strokeWidth: 1,\n                stroke: 'black',\n                fill: 'aquamarine',\n                refX: '%',\n                refY: '75%',\n            },\n            tag: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: '150%', refY: -15,},\n            voltage: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: '150%', refY: -5,},\n            kVArating: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: '150%', refY: 5,},\n            impedance: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: '150%', refY: 15,},\n            loading: {fill: 'blue', textAnchor: 'right', fontSize: 8, refX: '150%', refY: 25,}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {name: 'left', args: {y: -22}},\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: 'black'},\n                        label: {text: 'from', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n                'out': {\n                    position: {name: 'left', args: {y: 37}},\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: 'black'},\n                        label: {text: 'to', fontSize: 8,}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}, {id: 'portOut', group: 'out'}]\n        }\n    }, {\n        markup: [\n            {tagName: 'circle', selector: 'primary'},\n            {tagName: 'circle', selector: 'secondary'},\n            {tagName: 'text', selector: 'tag'},\n            {tagName: 'text', selector: 'voltage'},\n            {tagName: 'text', selector: 'kVArating'},\n            {tagName: 'text', selector: 'impedance'},\n            {tagName: 'text', selector: 'loading'}\n        ]\n    });\n\n    // bus duct\n    let BusDuctElement = dia.Element.define('BusDuctElement', {\n        attrs: {\n            root: {magnet: false},\n            body: {refWidth: '100%', refHeight: '100%', refX: '0%', refY: '0%', stroke: 'black', strokeWidth: 1},\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 15, refY: -25,},\n            size: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -15,},\n            length: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -5,},\n            impedance: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: 5,},\n            operatingCurrent: {fill: 'blue', textAnchor: 'right', fontSize: 8, refX: 15, refY: 15,}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {name: 'left', args: {y: '-50%'}},\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'white', stroke: 'black'},\n                        label: {text: 'from', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n                'out': {\n                    position: {name: 'left', args: {y: '50%'}},\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'white', stroke: 'black'},\n                        label: {text: 'to', fontSize: 8,}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}, {id: 'portOut', group: 'out'}]\n        }\n    }, {\n        markup: [\n            {\n                //https://yqnn.github.io/svg-path-editor/\n                tagName: 'path',\n                selector: 'body',\n                attributes: {d: 'M -3 15 L -5 25 L -3 15 L -3 -15 L -5 -25 L -3 -15 M 0 -25 L 0 25 M 3 15 L 5 25 L 3 15 L 3 -15 L 5 -25 L 3 -15'},\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'size'},\n            {tagName: 'text', selector: 'length'},\n            {tagName: 'text', selector: 'impedance'},\n            {tagName: 'text', selector: 'operatingCurrent'}\n        ]\n    });\n\n\n    // cable \n    let CableElement = dia.Element.define('CableElement', {\n        attrs: {\n            root: {magnet: false},\n            //body: { refWidth: '100%', refHeight: '100%', strokeWidth: 1, stroke: '#A00000', fill: 'orange', refX: 0, refY: -25 },\n            body: {refWidth: '100%', refHeight: '100%', refX: '50%', refY: '10%',},\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 25, refY: -20},\n            size: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 25, refY: -10},\n            length: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 25, refY: 0},\n            impedance: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 25, refY: 10},\n            operatingCurrent: {fill: 'blue', textAnchor: 'right', fontSize: 8, refX: 25, refY: 20}\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {name: 'left', args: {x: 5, y: -25}},\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: 'from', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                },\n                'out': {\n                    position: {name: 'left', args: {x: 5, y: 32}}, // size 10x60\n                    label: {position: {name: 'right', args: {x: 10}}, markup: [{tagName: 'text', selector: 'label'}]},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: '#E6A502', stroke: '#023047'},\n                        label: {text: 'to', fontSize: 8,}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}, {id: 'portOut', group: 'out'}]\n        }\n    }, {\n        markup: [\n            {\n                //https://yqnn.github.io/svg-path-editor/\n                tagName: 'path', selector: 'body',\n                attributes: {\n                    d: 'M 5 -25 C 3 -20 -3 -20 -5 -25 L -5 20 C -3 15 3 15 5 20 L 5 -25 C 3 -30 -3 -30 -5 -25 M -5 20 C -3 25 3 25 5 20',\n                    stroke: 'black', strokeWidth: 1, fill: 'orange'\n                },\n            },\n            //{ tagName: 'rect', selector: 'body' },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'size'},\n            {tagName: 'text', selector: 'length'},\n            {tagName: 'text', selector: 'impedance'},\n            {tagName: 'text', selector: 'operatingCurrent'}\n        ]\n    });\n\n    // motor\n    let MotorElement = dia.Element.define('MotorElement', {\n        attrs: {\n            root: {magnet: false},\n            body1: { refRCircumscribed: '25%', refCx: '0%', refCy: '50%', strokeWidth: 1, stroke: 'black', fill: 'azure', refX: '0%', refY: '-15%', alphaValue: 0.4},\n            body2: { refWidth: '100%', refHeight: '100%', refX: '0%', refY: '0%', stroke: 'black', strokeWidth: 1, fill: 'none' },\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 15, refY: -25,},\n            operatingPower: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -15,},\n            rating: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -5,},\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '0%', y: -10}},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}]\n        }\n    }, {\n        markup: [\n            {tagName: 'circle', selector: 'body1'},\n            {\n                tagName: 'path',\n                selector: 'body2',\n                attributes: {d: 'm -8 30 L -8 15 L 0 25 L 8 15 L 8 30 L 8 15 L 0 25 L -8 15 L -8 30  m 8 -25 v -13 Z'},\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'operatingPower'},\n            {tagName: 'text', selector: 'rating'},\n        ]\n    });\n\n    // heater\n    let HeaterElement = dia.Element.define('Heaterlement', {\n        attrs: {\n            root: {magnet: false},\n            body: {\n                refWidth: '100%',\n                refHeight: '100%',\n                refX: '0%',\n                refY: '0%',\n                stroke: 'black',\n                strokeWidth: 1,\n                fill: 'cornsilk'\n            },\n            label: {fill: 'blue', fontWeight: 'bold', textAnchor: 'right', fontSize: 8, refX: 15, refY: -25,},\n            operatingPower: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -15,},\n            rating: {fill: 'black', textAnchor: 'right', fontSize: 8, refX: 15, refY: -5,},\n        },\n        ports: {\n            groups: {\n                'in': {\n                    position: {ref: 'body', name: 'absolute', args: {x: '0%', y: -10}},\n                    attrs: {\n                        portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                        label: {text: '1', fontSize: 8}\n                    },\n                    markup: [{tagName: 'circle', selector: 'portBody'}],\n                }\n            },\n            items: [{id: 'portIn', group: 'in'}]\n        }\n    }, {\n        markup: [\n            {\n                tagName: 'path',\n                selector: 'body',\n                attributes: {d: 'm -15 5 L 15 5 L 15 55 L -15 55 L -15 5 m 0 10 L 15 15 M 15 25 L -15 25 M -15 35 L 15 35 M 15 45 L -15 45 m 15 -40 v -14 Z'},\n            },\n            {tagName: 'text', selector: 'label'},\n            {tagName: 'text', selector: 'operatingPower'},\n            {tagName: 'text', selector: 'rating'},\n        ]\n    });\n\n    // link\n    let branchLink = new shapes.standard.Link({\n        router: {name: 'manhattan'},\n        connector: {name: 'rounded', args: {radius: 2}, jumpover: {size: 6}},\n        attrs: {\n            line: {\n                stroke: '#333333',\n                strokeWidth: 2,\n                sourceMarker: {type: 'circle', r: 2, fill: 'none'},\n                targetMarker: {type: 'circle', r: 2, fill: 'none'},\n            },\n        }\n    });\n\n\n\n\n\n\n\n\n\n    dotNetObjDraw = dotNetObjRef;\n    dotNetObjSLD = dotNetObjSLDRef;\n\n    let buses = JSON.parse(busesString);\n    let branches = JSON.parse(branchesString);\n    let loads = JSON.parse(loadsString);\n    let transformers = JSON.parse(transformersString);\n    let cables = JSON.parse(cablesString);\n    let busDucts = JSON.parse(busDuctsString);\n    let sldComponents = JSON.parse(sldComponentsString);\n    sldComponentsString1 = sldComponentsString;\n    let switchboards = JSON.parse(switchboardString);\n\n    //var xy = JSON.parse(xyString);\n    //console.log(\"hello\" + JSON.stringify(buses));\n\n    // define namespace, includes default imported joint standrad namespace 'shapes'\n    // and other shapes (e.g.,RectangleTwoLabels) under 'custom' namespace\n    const namespace = {\n        shapes, BusElement, SwitchboardElement, CableElement, TransformerElement, LoadElement, BusNodeElement,\n        BusDuctElement, GridElement, LumpLoadElement, CapacitorElement, NodeElement\n    };\n\n    let defaultGrid = buses.filter(item => item.Category === \"Swing\")[0];\n    let defaultBus = buses.filter(item => item.Category !== \"Swing\")[0];\n    let defaultCable = cables[0];\n    let defaultTransformer = transformers[0];\n    let defaultBusduct = busDucts[0];\n\n    graph = new dia.Graph({}, {cellNamespace: namespace});\n\n    paper = new dia.Paper({\n        el: document.getElementById(divString),\n        model: graph,\n        width: xGridSize,\n        height: yGridSize,\n        gridSize: 5,\n        drawGrid: true,\n        background: {color: '#F5F5F5'},\n        cellViewNamespace: namespace,\n        interactive: function (cellView) {\n            if (cellView.model.isElement()) {\n                return {elementMove: interaction};\n            }\n            return true;\n        },\n        defaultLink: () => new shapes.standard.Link({\n            router: {name: 'manhattan'},\n            connector: {name: 'rounded', args: {radius: 3}, jumpover: {size: 6}},\n            attrs: {\n                line: {\n                    stroke: '#000000', // Ensure the line is visible with a color\n                    strokeWidth: 2, // Adjust stroke width as needed\n                    sourceMarker: {type: 'circle', r: 3, fill: 'yellow'},\n                    targetMarker: {type: 'circle', r: 3, fill: 'green'}\n                },\n                label: {\n                    textAnchor: 'middle', // Center the text horizontally\n                    refX: 0.5, // Adjust as needed\n                    refY: -10, // Position label above the line\n                    fontSize: 12, // Adjust font size as needed\n                    fill: '#000000', // Color for the label text\n                }\n            }\n        }, {\n            markup: [\n                {tagName: 'path', selector: 'line'},\n                {tagName: 'text', selector: 'label'}\n            ]\n        }),\n        linkPinning: false,\n        validateConnection: function (cellViewS, magnetS, cellViewT, magnetT, end, linkView) {\n            // Prevent loop linking\n            if (magnetS === magnetT) return false;\n            // Prevent the link to self\n            if (cellViewS === cellViewT) return false;\n\n            // Prevent linking more than one link\n            const sourcePortId = linkView.model.prop('source/port');\n            const targetPortId = linkView.model.prop('target/port');\n\n            const allLinksSource = graph.getConnectedLinks(cellViewS.model);\n            const sourcePortLinks = allLinksSource.filter(link => link.prop('source/port') == sourcePortId);\n\n            const allLinksTarget = graph.getConnectedLinks(cellViewT.model);\n            const targetPortLinks = allLinksTarget.filter(link => link.prop('target/port') == targetPortId);\n\n            console.log(`Source Element '${cellViewS.model.tag}' at port '${sourcePortId}' has ${sourcePortLinks.length} connections and ` +\n                `Target Element '${cellViewT.model.tag}' at port '${targetPortId}' has ${targetPortLinks.length} connections.`);\n            if (sourcePortLinks.length > 3) return false;\n            if (targetPortLinks && targetPortLinks.length > 3) return false;\n\n            linkView.model.on('change', function () {\n                console.log('link changed');\n            })\n\n            // Prevent linking from input ports\n            //if (magnetS && magnetS.getAttribute('port-group') === 'in') return false;\n            // Prevent linking from output ports to input ports within one element\n            //if (cellViewS === cellViewT) return false;\n            // Prevent linking to output ports\n            //return magnetT && magnetT.getAttribute('port-group') === 'in';\n\n            // end of linking\n            var sM, tM, sPort, tPort, linkM;\n\n            sM = cellViewS.model;\n            tM = cellViewT.model;\n            linkM = linkView.model;\n            sPort = linkM.prop('source/port');\n            tPort = linkM.prop('target/port');\n            return true;\n        },\n        validateMagnet: function (cellView, magnet, _evt) {\n            // Note that this is the default behaviour. It is shown for reference purposes.\n            // Disable linking interaction for magnets marked as passive\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n        // Enable link snapping within 20px lookup radius\n        snapLinks: {radius: 20},\n\n    });\n    paper.el.style.border = '1px solid #2E2E2E';\n\n\n    // Function to check if a port has links\n    function hasLink(element, portName) {\n        // Get all links (edges) connected to the element\n        const links = graph.getLinks();\n\n        // Check if any link uses the specified port as source or target\n        return links.some(link =>\n            link.get('source').id === element.id && link.get('source').port === portName ||\n            link.get('target').id === element.id && link.get('target').port === portName\n        );\n    }\n\n\n    // Function to get the port ID from an element and a magnet\n    function getPortId(element, magnet) {\n        // Iterate over all ports of the element\n        for (let portName in element.getPorts()) {\n            const port = element.getPort(portName);\n            // Check if the magnet matches the port element\n            if (port && port.attrs.body.el === magnet) {\n                return portName; // Return the port ID (name)\n            }\n        }\n        return null; // Port not found\n    }\n\n\n    //const rect11 = new Rectangle();\n    //rect11.addTo(graph);\n\n\n\n    //var Container = shapes.container.Parent;\n    //var Child = shapes.container.Child;\n    //var Link = shapes.container.Link;\n    //var BusElement = shapes.standard.Rectangle;\n    var saveDataButton = new shapes.standard.Rectangle();\n    saveDataButton.resize(100, 30);\n    saveDataButton.position(50, 30);\n    saveDataButton.attr('root/title', 'joint.shapes.standard.Rectangle');\n    saveDataButton.attr('label/text', 'Save Data');\n    saveDataButton.attr('label/text/fill', 'white');\n    saveDataButton.attr('body/fill', 'blue');\n    saveDataButton.tag = \"saveData\";\n    saveDataButton.addTo(graph);\n\n    // create template custom shapes\n    var templateGridElement = new GridElement;\n    templateGridElement.type = \"grid\";\n    templateGridElement.tag = \"templateGridElement\";\n    templateGridElement.clicked = false;\n    templateGridElement.position(50, 100);\n    templateGridElement.resize(20, 80);\n    templateGridElement.addTo(graph);\n    let newGridElement = templateGridElement.clone();\n    newGridElement.type = \"grid\";\n    newGridElement.tag = \"templateGridElement\";\n    newGridElement.addTo(graph);\n    //\n    var templateBusElement = new BusElement({\n        position: {x: 25, y: 200},\n        size: {width: 50, height: 0},\n        attrs: {body: {x1: 0, y1: 0, x2: 50, y2: 0},}\n    });\n    templateBusElement.type = \"bus\";\n    templateBusElement.tag = \"templateBusElement\";\n    templateBusElement.clicked = false;\n    templateBusElement.addTo(graph);\n    let newBusElement = templateBusElement.clone();\n    newBusElement.type = \"bus\";\n    newBusElement.tag = \"templateBusElement\";\n    newBusElement.addTo(graph);\n\n    var templateCableElement = new CableElement();\n    templateCableElement.type = \"cable\";\n    templateCableElement.tag = \"templateCableElement\";\n    templateCableElement.clicked = false;\n    templateCableElement.position(50, 300);\n    templateCableElement.resize(10, 60);\n    templateCableElement.addTo(graph);\n    let newCableElement = templateCableElement.clone();\n    newCableElement.type = \"cable\";\n    newCableElement.tag = \"templateCableElement\";\n    newCableElement.addTo(graph);\n\n    var templateTransformerElement = new TransformerElement();\n    templateTransformerElement.type = \"transformer\";\n    templateTransformerElement.tag = \"templateTransformerElement\";\n    templateTransformerElement.clicked = false;\n    templateTransformerElement.position(50, 400);\n    templateTransformerElement.resize(15, 15);\n    templateTransformerElement.addTo(graph);\n    let newTransformerElement = templateTransformerElement.clone();\n    newTransformerElement.type = \"transformer\";\n    newTransformerElement.tag = \"templateTransformerElement\";\n    newTransformerElement.addTo(graph);\n\n    var templateBusDuctElement = new BusDuctElement();\n    templateBusDuctElement.type = \"busduct\";\n    templateBusDuctElement.tag = \"templateBusDuctElement\";\n    templateBusDuctElement.clicked = false;\n    templateBusDuctElement.position(50, 500);\n    templateBusDuctElement.resize(10, 60);\n    templateBusDuctElement.addTo(graph);\n    let newBusDuctElement = templateBusDuctElement.clone();\n    newBusDuctElement.type = \"busduct\";\n    newBusDuctElement.tag = \"templateBusDuctElement\";\n    newBusDuctElement.addTo(graph);\n\n    var templateCapacitorElement = new CapacitorElement();\n    templateCapacitorElement.type = \"capacitor\";\n    templateCapacitorElement.tag = \"templateCapacitorElement\";\n    templateCapacitorElement.clicked = false;\n    templateCapacitorElement.position(50, 600);\n    templateCapacitorElement.resize(30, 60);\n    templateCapacitorElement.addTo(graph);\n    let newCapacitorElement = templateCapacitorElement.clone();\n    newCapacitorElement.type = \"capacitor\";\n    newCapacitorElement.tag = \"templateCapacitorElement\";\n    newCapacitorElement.addTo(graph);\n\n    var templateMotorElement = new MotorElement();\n    templateMotorElement.type = \"motor\";\n    templateMotorElement.tag = \"templateMotorElement\";\n    templateMotorElement.clicked = false;\n    templateMotorElement.position(50, 700);\n    templateMotorElement.resize(30, 60);\n    templateMotorElement.addTo(graph);\n    let newMotorElement = templateMotorElement.clone();\n    newMotorElement.type = \"motor\";\n    newMotorElement.tag = \"templateMotorElement\";\n    newMotorElement.addTo(graph);\n\n    var templateHeaterElement = new HeaterElement();\n    templateHeaterElement.type = \"heater\";\n    templateHeaterElement.tag = \"templateHeaterElement\";\n    templateHeaterElement.clicked = false;\n    templateHeaterElement.position(50, 800);\n    templateHeaterElement.resize(30, 60);\n    templateHeaterElement.addTo(graph);\n    let newHeaterElement = templateHeaterElement.clone();\n    newHeaterElement.type = \"heater\";\n    newHeaterElement.tag = \"templateHeaterElement\";\n    newHeaterElement.addTo(graph);\n\n    var templateLumpLoadElement = new LumpLoadElement();\n    templateLumpLoadElement.type = \"lumpload\";\n    templateLumpLoadElement.tag = \"templateLumpLoadElement\";\n    templateLumpLoadElement.clicked = false;\n    templateLumpLoadElement.position(50, 900);\n    templateLumpLoadElement.resize(30, 60);\n    templateLumpLoadElement.addTo(graph);\n    let newLumpLoadElement = templateLumpLoadElement.clone();\n    newLumpLoadElement.type = \"lumpload\";\n    newLumpLoadElement.tag = \"templateLumpLoadElement\";\n    newLumpLoadElement.addTo(graph);\n\n\n    var container = [];\n    var child = [];\n    var link = [];\n    var linkCount = 0;\n    var branchElement = [];\n    var busesDone = [];\n    var busesElement = [];\n    var swbdElement = [];\n    var busesNodeElement = []; // dots on bus\n    var loadElement = [];\n\n\n    // new items - drag from template\n    paper.on('element:pointerup', (elementView, event, x, y) => {\n        if (!elementView.model.tag.includes('template')) return;\n        console.log('Template Element ' + elementView.model.tag + 'moved to ' + x + ',' + y);\n        if (isOverlapping(elementView.model, graph)) {\n            // Move the element to the nearest empty position\n            const newPosition = findNearestEmptyPosition(elementView.model, graph, 50);\n            elementView.model.set('position', newPosition);\n        }\n\n        if (elementView.model.tag == 'templateGridElement') {\n            busesElement.push(elementView.model);\n            busesElement.at(-1).tag = `Grid-${busesElement.filter(br => br.type = \"grid\").length.toString().padStart(3, '0')}`;\n\n            busesElement.at(-1).attr({\n                label: {text: busesElement.at(-1).tag},\n                ratedSC: {text: \"0kA\"},\n                ratedVoltage: {text: \"0kV\"},\n                busFaultkA: {text: \"0kA\"},\n                operatingVoltage: {text: \"0% 0\"}\n            });\n\n            let newGridElement = templateGridElement.clone();\n            newGridElement.type = \"gid\";\n            newGridElement.tag = \"templateGridElement\";\n            newGridElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateBusElement') {\n            busesElement.push(elementView.model);\n            busesElement.at(-1).tag = `Bus-${busesElement.filter(br => br.type = \"bus\").length.toString().padStart(3, '0')}`;\n\n            busesElement.at(-1).attr({\n                label: {text: busesElement.at(-1).tag},\n                ratedSC: {text: \"0kA\"},\n                ratedVoltage: {text: \"0kV\"},\n                busFaultkA: {text: \"0kA\"},\n                operatingVoltage: {text: \"0% 0\"}\n            });\n\n            let newBusElement = templateBusElement.clone();\n            newBusElement.type = \"gid\";\n            newBusElement.tag = \"templateBusElement\";\n            newBusElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateCableElement') {\n            branchElement.push(elementView.model);\n            branchElement.at(-1).tag = `Cablebranch-${branchElement.filter(br => br.type = \"cable\").length.toString().padStart(3, '0')}`;\n\n            branchElement.at(-1).attr({\n                label: {text: branchElement.at(-1).tag},\n                size: {text: '3Cx16'},\n                length: {text: `300m, .04l-j.07/km`},\n                impedance: {text: `R:.2, X:.3`},\n                operatingCurrent: {text: `0A 0`}\n            });\n            let newCableElement = templateCableElement.clone();\n            newCableElement.type = \"cable\";\n            newCableElement.tag = \"templateCableElement\";\n            newCableElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateTransformerElement') {\n            branchElement.push(elementView.model);\n            branchElement.at(-1).tag = `Transformer-${branchElement.filter(br => br.type = \"transformer\").length.toString().padStart(3, '0')}`;\n            branchElement.at(-1).attr({\n                label: {text: branchElement.at(-1).tag},\n                voltage: {text: `0kV`},\n                kVArating: {text: `0kVA`},\n                impedance: {text: `0%`},\n                loading: {text: `0kW 0kVAR`},\n            });\n            let newTransformerElement = templateTransformerElement.clone();\n            newTransformerElement.type = \"lumpload\";\n            newTransformerElement.tag = \"templateTransformerElement\";\n            newTransformerElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateBusDuctElement') {\n            branchElement.push(elementView.model);\n            branchElement.at(-1).tag = `BusDuct-${branchElement.filter(br => br.type = \"transformer\").length.toString().padStart(3, '0')}`;\n            branchElement.at(-1).attr({\n                label: {text: branchElement.at(-1).tag},\n                voltage: {text: `0kV`},\n                kVArating: {text: `0kVA`},\n                impedance: {text: `0%`},\n                loading: {text: `0kW 0kVAR`},\n            });\n            let newBusDuctElement = templateBusDuctElement.clone();\n            newBusDuctElement.type = \"busduct\";\n            newBusDuctElement.tag = \"templateBusDuctElement\";\n            newBusDuctElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateCapacitorElement') {\n            loadElement.push(elementView.model);\n            loadElement.at(-1).tag = `Capacitor-${capacitorElement.length.toString().padStart(3, '0')}`;\n            loadElement.at(-1).attr({\n                label: {text: capacitorElement.at(-1).tag},\n                operatingPower: {text: `0kVAR`},\n                rating: {text: `0kVAR`},\n            });\n\n            let newCapacitorElement = templateCapacitorElement.clone();\n            newCapacitorElement.type = \"capacitor\";\n            newCapacitorElement.tag = \"templateCapacitorElement\";\n            newCapacitorElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateMotorElement') {\n            loadElement.push(elementView.model);\n            loadElement.at(-1).tag = `Motor-${loadElement.filter(br => br.type = \"motor\").length.toString().padStart(3, '0')}`;\n            loadElement.at(-1).attr({\n                label: {text: loadElement.at(-1).tag},\n            });\n\n            let newMotorElement = templateMotorElement.clone();\n            newMotorElement.type = \"motor\";\n            newMotorElement.tag = \"templateMotorElement\";\n            newMotorElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateHeaterlement') {\n            loadElement.push(elementView.model);\n            loadElement.at(-1).tag = `Heater-${loadElement.filter(br => br.type = \"heater\").length.toString().padStart(3, '0')}`;\n            loadElement.at(-1).attr({\n                label: {text: loadElement.at(-1).tag},\n            });\n            let newHeaterElement = templateHeaterElement.clone();\n            newHeaterElement.type = \"heater\";\n            newHeaterElement.tag = \"templateHeaterElement\";\n            newHeaterElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateLumpLoadElement') {\n            loadElement.push(elementView.model);\n            loadElement.at(-1).tag = `LumpLoad-${loadElement.filter(br => br.type = \"lumpload\").length.toString().padStart(3, '0')}`;\n            loadElement.at(-1).attr({\n                label: {text: loadElement.at(-1).tag},\n                operatingPower: {text: `${4}kW ${3}kVAR`},\n                rating: {text: `${5}kVA`},\n            });\n\n            newLumpLoadElement = templateLumpLoadElement.clone();\n            newLumpLoadElement.type = \"lumpload\";\n            newLumpLoadElement.tag = \"templateLumpLoadElement\";\n            newLumpLoadElement.addTo(graph);\n\n        } else if (elementView.model.tag == 'templateOtherElement') {\n\n        }\n    });\n\n\n    // delete items\n\n\n    buses.forEach((bus, index) => {\n\n        if (bus.Category === \"Swing\") {\n            // grid            \n            busesElement[index] = new GridElement;\n            busesElement[index].type = \"swing\";\n            busesElement[index].tag = bus.Tag;\n            busesElement[index].clicked = false;\n            busesElement[index].position(bus.CordX, bus.CordY);\n            busesElement[index].resize(40, 40);\n\n            //busesElement[index] = updateBus(busesElement[index], bus);\n\n\n            busesElement[index].attr({\n                label: {text: \"Grid\" + bus.Tag},\n                ratedSC: {text: Math.round(10 * bus.ISC) / 10 + \"kA\"},\n                ratedVoltage: {text: bus.VR / 1000 + \"kV\"},\n                busFaultkA: {text: Math.round(10 * bus.SCkAaMax) / 10 + \"kA\"},\n                operatingVoltage: {text: Math.round(10000 * bus.Vo.Magnitude) / 100 + \"% \" + Math.round(bus.Vo.Phase * 1800 / Math.PI) / 10 + \"\"}\n            });\n            busesElement[index].addTo(graph);\n\n        } else {\n            // for node, the bus line and parameter display is off\n            // other bus\n            // one way to draw the bus by \"Expanding parent area to cover its children\"\n            // where children are at both ends\n            // another was is to draw two edge and draw a link as the bus\n            // in this way all the links can be perpendicular to the bus bar (link)\n\n            busesElement.push(new BusElement({\n                position: {x: bus.CordX - bus.Length / 2, y: bus.CordY},\n                // Width represents the length of the line\n                size: {width: bus.Length, height: 0},\n                attrs: {\n                    body: {x1: 0, y1: 0, x2: bus.Length, y2: 0},\n                    label: {text: bus.Tag},\n                    ratedSC: {text: Math.round(10 * bus.ISC) / 10 + \"kA\"},\n                    ratedVoltage: {text: bus.VR / 1000 + \"kV\"},\n                    busFault: {text: Math.round(10 * bus.SCkAaMax) / 10 + \"kA\"},\n                    operatingVoltage: {text: Math.round(10000 * bus.Vo.Magnitude) / 100 + \"% \" + Math.round(bus.Vo.Phase * 1800 / Math.PI) / 10 + \"\"}\n                }\n            }));\n\n            //busesElement.at(-1) = updateBus(busesElement.at(-1), bus);\n\n            busesElement.at(-1).type = \"bus\";\n            busesElement.at(-1).tag = bus.Tag;\n            busesElement.at(-1).clicked = false;\n            busesElement.at(-1).addTo(graph);\n        }\n\n        // check if exising server data has customised bus position and length for this bus\n        busesElement[index] = updatePositionLength(busesElement[index], sldComponents);\n    });\n\n    // toggle bus and node by double clicking\n    paper.on('element:pointerdblclick', (elementView) => {\n        if (elementView.model.type != \"bus\") return;\n\n        var ports = elementView.model.getGroupPorts('in');\n\n        // if this bus has more than two ports or\n        if (ports.length > 2) return;\n\n        // two ports are not catering to the top or bottom links\n        // (i.e., their positions are different, then this shall remain as bus)\n        if (ports.length == 2) {\n            var b = elementView.model.getPortsPositions('in');\n            if (b[1].x != b[2].x) return;\n        }\n\n        // also no node if the bus is part of a switchboard whihc has more than one buses\n        var swbd = switchboards.find(item => JSON.parse(item[1]).includes(elementView.model.tag));\n        if (swbd) {\n            var busTags = JSON.parse(swbd[1]);\n            if (busTags.length > 1) return;\n        }\n\n        if (elementView.model.node) {\n            // already a node, change to bus\n            elementView.model.node = false;\n        } else {\n            // its bus, change to a node\n            elementView.model.node = true;\n        }\n        elementView.model = updateNodeOrBus(elementView.model);\n        // update SLDComponent for sending updated Bus data to server\n        // remove existing sldComponentStrings with this bus tag, if exists\n        sldComponentsJS = sldComponentsJS.filter(item => item.Tag != elementView.model.tag || item.Type != \"bus\" || item.SLD != \"key\");\n        var props = {\n            'node': elementView.model.node,\n            'position': elementView.model.attributes.position,\n            'length': cwidth\n        };\n        sldComponentsJS.push({\n            'Type': \"bus\",\n            'Tag': elementView.model.tag,\n            'SLD': \"key\",\n            'PropertyJSON': JSON.stringify(props)\n        });\n    });\n\n    //\n    // by default element interaction is enabled for all items\n    let interaction = true;\n    // original x and y\n    let ox;\n    let oy;\n    let clickedBusTag;\n    let end;\n    let x1;\n    let x2;\n    let oposx;\n    let owidth;\n    let cposx;\n    let cwidth;\n    // bus ends drag\n    paper.on('element:pointerdown', (elementView, event, x, y) => {\n        if (elementView.model.type != \"bus\") return;\n        // disable element movement for template items\n        if (elementView.model.type && elementView.model.tag.includes(\"template\")) {\n            interaction = false;\n        }\n            // check if its a bus\n        // if the clicked point is either left or right end, then prevent element movement\n        else if (elementView.model.type && elementView.model.type == \"bus\") {\n\n            // check the location of the click\n            var pos = elementView.model.prop('position');\n            var width = elementView.model.prop('size/width');\n            oposx = elementView.model.prop('position/x');\n            owidth = elementView.model.prop('size/width');\n            end = x - pos.x < 10 ? \"left\" : pos.x + width - x < 10 ? \"right\" : \"middle\";\n            x1 = elementView.model.prop('attrs/body/x1');\n            x2 = elementView.model.prop('attrs/body/x2');\n            // prevent bus element movement only if the position is not middle\n            if (end != \"middle\") {\n                interaction = false;\n            } else {\n                interaction = true;\n            }\n            clickedBusTag = elementView.model.tag;\n            console.log(`Bus '${clickedBusTag}', position: (${pos.x},${pos.y}), width:${width}, x1-x2:${x2 - x1} ` +\n                `clicked at (${x},${y}), '${end}' end, (ox,oy): (${ox},${oy}), x1: ${x1}, x2: ${x2}), interaction: ${interaction}`);\n        } else {\n            // if clicked on any ther than bus element, restore interaction\n            interaction = true;\n        }\n    });\n\n\n    let toWrite = true;\n    paper.on('element:pointermove', (elementView, event, x, y) => {\n        if (elementView.model.type != \"bus\") return;\n        // bus left/right end movement\n        if (elementView.model.type && elementView.model.type == \"bus\" && elementView.model.tag == clickedBusTag) {\n            if (toWrite) {\n                toWrite = false;\n                setTimeout(function () {\n                    if (end == \"left\") {\n                        cposx = Math.min(x, oposx + owidth - 50);\n                        cwidth = oposx + owidth - cposx;\n                    }\n                    if (end == \"right\") {\n                        cposx = oposx;\n                        cwidth = Math.max(x, oposx + 50) - oposx;\n                    }\n                    if (end == \"right\" || end == \"left\") {\n\n                        console.log(`Bus '${clickedBusTag}', ${end} end changing ` +\n                            `pos: ${oposx}-> ${cposx}, width: ${owidth} -> ${cwidth}`);\n\n                        elementView.model.prop('position/x', cposx);\n                        elementView.model.prop('size/width', cwidth);\n                        elementView.model.prop('attrs/body/x2', cwidth);\n                        // X1 is always = 0;\n                        // Y1 and Y2 are not changed for a hirizontally oriented bus\n\n                        // update SLDComponent for sending updated Bus data to server\n                        // remove existing sldComponentStrings with this bus tag, if exists\n                        sldComponentsJS = sldComponentsJS.filter(item => item.Tag != elementView.model.tag || item.Type != \"bus\" || item.SLD != \"key\");\n                        var props = {\n                            'node': elementView.model.node,\n                            'position': elementView.model.attributes.position,\n                            'length': cwidth\n                        };\n                        sldComponentsJS.push({\n                            'Type': \"bus\",\n                            'Tag': elementView.model.tag,\n                            'SLD': \"key\",\n                            'PropertyJSON': JSON.stringify(props)\n                        });\n\n                    }\n                    toWrite = true;\n\n                    // update switchboard, if any, for this bus\n                    var swbd = switchboards.find(item => JSON.parse(item[1]).includes(elementView.model.tag));\n                    if (swbd) {\n                        var swbdModel = swbdElement.find(item => item.tag == swbd[0]);\n                        swbdModel = updateSwbdPositionSizeByBus(elementView.model.tag, busesElement, switchboards, swbdElement, 30, 20, 30, 20);\n                    }\n\n                }, 10);\n            }\n        }\n    });\n\n\n    // switchboards\n\n    switchboards.forEach((swbd, index) => {\n        swbdElement[index] = new SwitchboardElement();\n        swbdElement[index].type = \"swbd\";\n        swbdElement[index].tag = swbd[0];\n        var anyBusTagOfThisBoard = JSON.parse(swbd[1])[0];\n        swbdElement[index] = updateSwbdPositionSizeByBus(anyBusTagOfThisBoard, busesElement, switchboards, swbdElement, 30, 20, 30, 20)\n        swbdElement[index].attr({tag: {text: swbd[0]}});\n        swbdElement[index].addTo(graph);\n    });\n\n    function updateSwbdPositionSizeByBus(busTag, busesElement, switchboards, swbdElement, dx1, dx2, dy1, dy2) {\n        var swbd = switchboards.find(item => JSON.parse(item[1]).includes(busTag));\n        var swbdModel = swbdElement.find(item => item.tag == swbd[0]);\n        var busTags = JSON.parse(swbd[1]);\n        // var busSections = JSON.parse(swbd[2]); not used\n        // find the enclosing area\n        var x1 = Number.MAX_SAFE_INTEGER;\n        var y1 = Number.MAX_SAFE_INTEGER;\n        var x2 = 0;\n        var y2 = 0;\n        busTags.forEach(bustag => {\n            const bbox = busesElement.find(item => item.tag == bustag).getBBox();\n            x1 = Math.min(x1, bbox.x);\n            y1 = Math.min(y1, bbox.y);\n            x2 = Math.max(x2, bbox.x + bbox.width);\n            y2 = Math.max(y2, bbox.y + bbox.height);\n        });\n        x2 += dx2;\n        y2 += dy2;\n        x1 -= dx1;\n        y1 -= dy1;\n        swbdModel.position(x1, y1);\n        swbdModel.resize(x2 - x1, y2 - y1);\n        return swbdModel;\n    }\n\n    branches.forEach((branch, index) => {\n        var sourceBus = buses.find(bus => bus.Tag == branch.BfT);\n        var targetBus = buses.find(bus => bus.Tag == branch.BtT);\n        var sourceBusNode = busesNodeElement.find(item => item.tag == `${sourceBus.Tag}_${branch.Tag}`);\n        var targetBusNode = busesNodeElement.find(item => item.tag == `${targetBus.Tag}_${branch.Tag}`);\n\n        // Handle branch elements based on type\n        if (branch.Category === \"Cable\") {\n            var cable = cables.find(cbl => cbl.Tag == branch.Tag);\n            branchElement[index] = new CableElement();\n\n\n            branchElement[index].type = \"cable\";\n            branchElement[index].tag = cable.Tag;\n            branchElement[index].clicked = false;\n            branchElement[index].position(targetBus.CordX - 5, targetBus.CordY - yGridSpacing / 2 - 20);\n            branchElement[index].resize(10, 60);\n\n            branchElement[index] = updateCable(branchElement[index], cable, branches);\n            //branchElement[index].attr({\n            //    label: { text: cable.Tag },\n            //    size: { text: cable.CblDesc },\n            //    length: { text: `${cable.L}m, ${cable.Rl}-j${cable.Xl}/km` },\n            //    impedance: { text: `R:${cable.R}, X:${cable.X}` },\n            //    operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}` }\n            //});\n        } else if (branch.Category === \"Transformer\") {\n            var transformer = transformers.find(tr => tr.Tag === branch.Tag);\n            branchElement[index] = new TransformerElement();\n            branchElement[index].type = \"transformer\";\n            branchElement[index].tag = transformer.Tag;\n            branchElement[index].clicked = false;\n            branchElement[index].position((targetBus.CordX + sourceBus.CordX) / 2, (targetBus.CordY + sourceBus.CordY) / 2);\n            branchElement[index].resize(15, 15);\n\n            branchElement[index] = updateTransformer(branchElement[index], transformer, branches);\n\n\n            //branchElement[index].attr({\n            //    tag: { text: transformer.Tag },\n            //    voltage: { text: `${transformer.V1}/${transformer.V2}kV` },\n            //    kVArating: { text: `${transformer.KVA}kVA` },\n            //    impedance: { text: `Z:${transformer.Z}%` },\n            //    loading: { text: `${Math.round(10 * branch.KW) / 10}KW ${Math.round(10 * branch.KVAR) / 10}kVAR` }\n            //});\n        } else if (branch.Category === \"BusDuct\") {\n            var busDuct = busDucts.find(busDuct => busDuct.Tag == branch.Tag);\n            branchElement[index] = new BusDuctElement();\n            branchElement[index].type = \"busduct\";\n            branchElement[index].tag = busDuct.Tag;\n            branchElement[index].clicked = false;\n            branchElement[index].position(targetBus.CordX - 5, targetBus.CordY - yGridSpacing / 2 - 20);\n            branchElement[index].resize(10, 60);\n\n            branchElement[index] = updateBusDuct(branchElement[index], busDuct, branches);\n\n        } else {\n\n            // Handle other branch types\n            //\n            //\n        }\n\n\n        // check if exising server data has customized position data for this branch cell\n        branchElement[index] = updateItemPosition(branchElement[index], sldComponents);\n\n        branchElement[index].addTo(graph);\n\n\n        // Create top and bottom links for every branch connection\n        // once this branch element is created\n        // time to create the links dynamically\n        // Create top and bottom links for this branch connections\n\n        let fromLink = branchLink.clone();\n        let toLink = branchLink.clone();\n        // bus-side port index shall be the default 0\n        // later it shall be distributed as per total connection\n\n\n        var sourceBusElement = busesElement.find(item => item.tag == branch.BfT);\n        var targetBusElement = busesElement.find(item => item.tag == branch.BtT);\n        var thisbranchElement = branchElement.find(item => item.tag == branch.Tag);\n\n        fromLink.set({\n            source: {id: sourceBusElement.id, port: sourceBusElement.getPorts()[0].id},\n            target: {id: thisbranchElement.id, port: thisbranchElement.getPorts()[0].id}\n        });\n\n        toLink.set({\n            source: {id: targetBusElement.id, port: targetBusElement.getPorts()[0].id},\n            target: {id: thisbranchElement.id, port: thisbranchElement.getPorts()[1].id}\n        });\n\n        fromLink.attr({target: {magnet: false}});\n        toLink.attr({target: {magnet: false}});\n\n        fromLink.tag = getLinkTag(fromLink);\n        toLink.tag = getLinkTag(toLink);\n\n        // check if exising server data has customised vertices for this link\n        fromLink = updateLinkVertices(fromLink, sldComponents);\n        toLink = updateLinkVertices(toLink, sldComponents);\n        fromLink.type = \"link\";\n        toLink.type = \"link\";\n        // Add the link to the graph\n        graph.addCell(fromLink);\n        graph.addCell(toLink);\n\n    });\n\n    // once all the links are created, time to create required no of ports as per the connections\n    // and distribute the port along the length of the bus\n    busesElement.forEach((busElement, index) => {\n        busPortDistribution(busElement.id);\n        console.log(`Distributing ports for bus '${busElement.tag}'.`);\n    });\n\n\n    function updateLinkVertices(link, sldComponents) {\n        // check if exising server data has customised vertices for this link\n        var existingLinkData = sldComponents.find(item => item.Tag == link.tag && item.Type == \"link\");\n        if (existingLinkData) {\n            //var verticesText = existingData.propertyJSON.replace(/'/g, '\"');\n            var newVerticesText = existingLinkData.PropertyJSON;\n            var newVertices = JSON.parse(newVerticesText);\n            if (newVertices) link.vertices(newVertices);\n            //console.log(`'${bottomLink.tag}' are updated with vertices ${newVerticesText} from DB.`);\n        }\n        return link;\n    }\n\n    function updateItemPosition(cell, sldComponents) {\n        // check if exising server data has customised position for this cell\n        var serverData = sldComponents.find(item => cell && cell.hasOwnProperty('tag') && item.Tag === cell.tag);\n        if (serverData) {\n            var newPositionText = serverData.PropertyJSON;\n            var newPosition = JSON.parse(newPositionText)\n            if (newPosition) cell.prop('position', newPosition);\n        }\n        return cell;\n    }\n\n    function updatePositionLength(busModel, sldComponents) {\n        // check if exising server data has customised node?, position and length for this bus\n        var serverData = sldComponents.find(item => busModel && busModel.hasOwnProperty('tag') && item.Tag === busModel.tag);\n        if (serverData) {\n            if (busModel.hasOwnProperty('type') && busModel.type === \"swing\") {\n                busModel.prop('position', JSON.parse(serverData.PropertyJSON));\n            } else {\n                var newPositionLengthText = serverData.PropertyJSON;\n                var newPositionLength = JSON.parse(newPositionLengthText);\n                if (newPositionLength.position) {\n\n                    busModel.prop('position', newPositionLength.position);\n                }\n                if (newPositionLength.length && busModel.type == \"bus\") {\n                    busModel.prop('size/width', newPositionLength.length);\n                    busModel.prop('attrs/body/x2', newPositionLength.length);\n                }\n\n                // check if its node or not\n                if (newPositionLength.node && busModel.type == \"bus\") {\n                    if (newPositionLength.node) {\n                        //busModel.prop('node', true);\n                        busModel.node = true;\n                    } else {\n                        //busModel.prop('node', false);\n                        busModel.node = false;\n                    }\n                    busModel = updateNodeOrBus(busModel);\n                }\n            }\n        }\n        return busModel;\n    }\n\n    function updateNodeOrBus(busModel) {\n        // update node status by either doubleclick or by server data\n        if (busModel.node) {\n            busModel.attr('label/textAnchor', 'end');\n            busModel.attr('label/refX', '50%');\n            busModel.attr('label/dx', -10);\n            busModel.attr('label/refY', 0);\n            busModel.attr('body/visibility', 'hidden');\n            busModel.attr('ratedSC/visibility', 'hidden');\n            busModel.attr('ratedVoltage/visibility', 'hidden');\n            busModel.attr('busFault/visibility', 'hidden');\n            busModel.attr('operatingVoltage/visibility', 'hidden');\n        } else {\n\n            //label: { ref: 'body', fill: 'blue', fontWeight: 'bold', textAnchor: 'start', fontSize: 8, refX: '0%', refY: -12 },\n            busModel.attr('label/textAnchor', 'start');\n            busModel.attr('label/refY', -12);\n            busModel.attr('body/visibility', 'visible');\n            busModel.attr('ratedSC/visibility', 'visible');\n            busModel.attr('ratedVoltage/visibility', 'visible');\n            busModel.attr('busFault/visibility', 'visible');\n            busModel.attr('operatingVoltage/visibility', 'visible');\n        }\n        return busModel;\n    }\n\n\n    paper.on('element:mouseenter', function (elementView) {\n        var tools = new dia.ToolsView({tools: [propertyButton]});\n        if (elementView.model.tag && !elementView.model.tag.includes('template')) elementView.addTools(tools);\n    });\n    paper.on('element:mouseleave', function (elementView) {\n        if (elementView.hasTools) elementView.removeTools();\n\n    });\n\n\n    //https://www.jointjs.com/demos/smart-routing\n    //https://github.com/clientIO/joint/blob/master/packages/joint-core/demo/routing/src/routing.js\n    paper.on('link:mouseenter', function (linkView) {\n        var tools = new dia.ToolsView({\n            tools: [\n                new linkTools.Vertices(),\n                new linkTools.Segments(),\n                //new linkTools.Boundary(),\n                // custom buttons complement the pre-made Remove button tool;\n                //new linkTools.Remove(),\n                infoButton, removeButton, validateButton\n            ]\n        });\n\n        var toolsR = new dia.ToolsView({\n            tools: [\n                new linkTools.Vertices(),\n                new linkTools.Segments(),\n                //new linkTools.Boundary(),\n                // custom buttons complement the pre-made Remove button tool;\n                //new linkTools.Remove(),\n                infoButton, removeButton\n            ]\n        });\n\n        if (linkView.model.prop('validated')) {\n\n            linkView.addTools(toolsR);\n        } else {\n            linkView.addTools(tools);\n        }\n    });\n\n    paper.on('link:mouseleave', function (linkView) {\n        linkView.removeTools();\n\n        const link = linkView.model;\n        const vertices = link.vertices();\n        //console.log(`${link.tag} has ${vertices.length} vertices and they are ${JSON.stringify(vertices)}.`);\n\n        // remove existing sldComponentStrings with this link tag, if exists\n        sldComponentsJS = sldComponentsJS.filter(sldComponent => sldComponent.Tag != link.tag || sldComponent.Type != \"link\" || sldComponent.SLD != \"key\");\n\n        // Creating an object using the sldComponentData constructor function\n        // add this new json string to the list\n        //if (vertices.length > 0) sldComponentsJS.push(new sldComponentData(link.tag, \"link\", \"key\", JSON.stringify(vertices)));\n        if (vertices.length > 0) sldComponentsJS.push({\n            'Type': \"link\",\n            'Tag': link.tag,\n            'SLD': \"key\",\n            'PropertyJSON': JSON.stringify(vertices)\n        });\n        //console.log(`Total ${sldComponentsJS.length} sldComponents, tag '${link.tag}' ${(vertices.length > 0 ? \"\" : \"not\")} added.`);\n    });\n\n\n    toWrite = true;\n    graph.on('change:position', function (cell) {\n\n        if (cell.tag == \"selectbox\") return;\n        if (cell.type == \"link\") return;\n        //if (cell.isLink) return;\n        // remove existing sldComponentStrings with this cell tag, if exists\n        sldComponentsJS = sldComponentsJS.filter(sldComponent => sldComponent.Tag != cell.tag || sldComponent.Type != cell.type || sldComponent.SLD != \"key\");\n\n        // Creating an object using the sldComponentData constructor function\n        // add this new json string to the list\n        //sldComponentsJS.push(new sldComponentData(cell.tag, cell.type, \"key\", JSON.stringify(cell.attributes.position)));\n        if (cell.type == \"bus\") {\n            // save position and length\n            var props = {'position': cell.attributes.position, 'length': cell.attributes.size.width};\n            sldComponentsJS.push({\n                'Type': cell.type,\n                'Tag': cell.tag,\n                'SLD': \"key\",\n                'PropertyJSON': JSON.stringify(props)\n            });\n        } else {\n            sldComponentsJS.push({\n                'Type': cell.type,\n                'Tag': cell.tag,\n                'SLD': \"key\",\n                'PropertyJSON': JSON.stringify(cell.attributes.position)\n            });\n        }\n        //console.log(`Total ${sldComponentsJS.length} sldComponents, tag '${link.tag}' ${(vertices.length > 0 ? \"\" : \"not\")} added.`);\n\n\n        if (toWrite) {\n            toWrite = false;\n            setTimeout(function () {\n                try {\n                    console.log(`Change position function @ 500ms : Tag '${cell.tag}' of type '${cell.type}' moved to (${cell.attributes.position.x},${cell.attributes.position.y})`);\n                    dotNetObjDraw.invokeMethodAsync('TagMoveUpdate', cell.type, cell.tag, cell.attributes.position.x, cell.attributes.position.y);\n                    toWrite = true;\n                } catch (err) {\n                    console.log(err.message);\n                }\n            }, 500);\n        }\n\n        // if any bus changes its position, update the switchboard accordingly\n\n        // update switchboard, if any, for this bus\n        if (cell.type == \"bus\") {\n            var swbd = switchboards.find(item => JSON.parse(item[1]).includes(cell.tag));\n            if (swbd) {\n                var swbdModel = swbdElement.find(item => item.tag == swbd[0]);\n                swbdModel = updateSwbdPositionSizeByBus(cell.tag, busesElement, switchboards, swbdElement, 30, 20, 30, 20);\n            }\n        }\n\n    });\n\n\n    // Create a text element for coordinates display\n    var textBlock = new shapes.standard.TextBlock();\n    textBlock.resize(1000, 20);\n    textBlock.position(100, 10);\n    textBlock.attr('body/fill', 'none');\n    textBlock.attr('body/stroke', 'none');\n    textBlock.attr('label/text', '');\n    textBlock.attr('label/fontSize', 8);\n    // Styling of the label via `style` presentation attribute (i.e. CSS).\n    textBlock.attr('label/style/color', 'red');\n    textBlock.addTo(graph);\n\n    // Update coordinates display on mouse move\n    paper.on('blank:pointerclick', function (evt, x, y) {\n        textBlock.attr('label/text', `X: ${x}, Y: ${y} `);\n    });\n    paper.on('cell:pointerclick', function (cell, evt, x, y) {\n        textBlock.attr('label/text', `X: ${x}, Y: ${y} x:  ${cell.getBBox().x} y: ${cell.getBBox().y} height:  ${cell.getBBox().height} width: ${cell.getBBox().width} shift: ${cell.getBBox().height / 3.5}`);\n        if (cell.model.tag && cell.model.tag.includes(\"template\")) {\n            console.log(cell.model.tag);\n        }\n\n    });\n\n\n    //loads.forEach(load => {\n    //    var i = loads.indexOf(load);\n    //    var connectedBus = buses.filter(bus => bus.T == load.BT)[0];\n    //    var connectedBranchList = branches.filter(br => br.BtT == connectedBus.T || br.BfT == connectedBus.T);\n    //    var connectedBranch = connectedBranchList[0];\n    //    var operatingPowerText = \"\";\n    //    if (connectedBranchList.length > 0) { operatingPowerText = Math.round(10 * connectedBranch.KW) / 10 + \"KW \" + Math.round(10 * connectedBranch.KVAR) / 10 + \"kVAR\"; }\n    //    var connectedBusNodeList = busesNodeElement.filter(item => item.tag == connectedBus.T + \"_\" + load.T);\n    //    if (connectedBusNodeList.length > 0) {\n    //        // do not draw load and link for loads not having connected bus\n    //        loadElement[i] = new LoadElement;\n    //        loadElement[i].position(connectedBus.CordX, connectedBus.CordY + yGridSpacing / 2);\n    //        loadElement[i].type = \"load\";\n    //        loadElement[i].tag = load.T;\n    //        loadElement[i].clicked = false;\n    //        loadElement[i].resize(20, 30);\n    //        var rating = (load.T.includes(\"-Lump\")) ? \"(combined)\" : \"(\" + Math.round(10000000 * load.P) / 10 + \"kW \" + Math.round(10000 * load.PF) / 100 + \"% PF)\";\n    //        operatingPowerText = (load.T.includes(\"-Lump\")) ? Math.round(10 * load.P) / 10 + \"KW \" + Math.round(10 * load.Q) / 10 + \"kVAR\" : operatingPowerText;\n    //        loadElement[i].attr({\n    //            label: { text: load.T },\n    //            operatingPower: { text: operatingPowerText },\n    //            rating: { text: rating },\n    //        });\n    //        link[linkCount] = new branchLink();  // load link\n    //        link[linkCount].addTo(graph);\n    //        linkCount++;\n    //        link[link.length - 1].source(connectedBusNodeList[0], {\n    //            anchor: { name: 'modelCenter', args: { rotate: true, dx: 0, } },\n    //            connectionPoint: {\n    //                name: 'bbox', args: { offset: 0, selector: 'body', }\n    //            }\n    //        });\n    //        link[link.length - 1].target(loadElement[i], {\n    //            anchor: { name: 'modelCenter', args: { rotate: true, dx: 0, } }\n    //        });\n    //        link[link.length - 1].router('orthogonal');\n    //        link[link.length - 1].connector('jumpover', { size: 5 });\n    //        link[link.length - 1].attr({\n    //            line: {\n    //                sourceMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', },\n    //                targetMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', }\n    //            }\n    //        });\n    //        loadElement[i].addTo(graph);\n    //    }\n    //});\n\n\n    //// assigning preset postion to all elements\n    ////busesElement.forEach(element => {\n    ////    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);\n    ////    if (xypos.length > 0) {\n    ////        element.position(xypos[0].CordX, xypos[0].CordY);\n    ////    }\n    ////});\n    //branchElement.forEach(element => {\n    //    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);\n    //    if (xypos.length > 0) {\n    //        element.position(xypos[0].CordX, xypos[0].CordY);\n    //    }\n    //});\n    //loadElement.forEach(element => {\n    //    var xypos = xy.filter(item => item.Type == element.type && item.Tag == element.tag);\n    //    if (xypos.length > 0) {\n    //        element.position(xypos[0].CordX, xypos[0].CordY);\n    //    }\n    //});\n    ////\n    //function busBFS(prntBusT, thisBusT, parentContainer) {\n    //    var parentBus = buses.filter(b => b.T == prntBusT)[0];\n    //    var bus = buses.filter(b => b.T == thisBusT)[0];\n    //    var busStr = bus.T + \" (\" + (bus.SCkAa).toString() + \"kA)\";\n    //    // create a container\n    //    container[buses.indexOf(bus)] = new Container({\n    //        z: 1,\n    //        attrs: { headerText: { text: busStr } }\n    //    });\n    //    graph.addCells([container[buses.indexOf(bus)]]);\n    //    container[buses.indexOf(bus)].toggle(false);\n\n    //    createChildLink(container[buses.indexOf(bus)], bus.T);\n\n    //    buses.filter(b => b.T == thisBusT)[0].SLDL = buses.filter(b => b.T == thisBusT)[0].SLDL + 1; // bus bar length\n    //    buses.filter(b => b.T == prntBusT)[0].SLDL = buses.filter(b => b.T == prntBusT)[0].SLDL + 1; // bus bar length\n\n    //    // for all connected loads on to this bus\n    //    if (loads.filter(l => l.BT == bus.T).length > 0) {\n    //        loads.filter(l => l.BT == bus.T).forEach(load => {\n    //            createChildLink(container[buses.indexOf(bus)], load.T);\n    //        })\n    //        busesDone.push(bus.T);\n    //        buses.filter(b => b.T == thisBusT)[0].SLDL = buses.filter(b => b.T == thisBusT)[0].SLDL + 1; // bus bar length\n    //        buses.filter(b => b.T == prntBusT)[0].SLDL = buses.filter(b => b.T == prntBusT)[0].SLDL + 1; // bus bar length\n\n    //    }\n    //    if (bus.Cn.length > 1) {\n    //        // this bus has further connected bus\n    //        // create a container for all downstream bus except the parentBus\n    //        (bus.Cn).filter(bT => busesDone.includes(bT) != true && bT != prntBusT).forEach(bT => {\n    //            var newChildBus = buses.filter(b => b.T == bT)[0];\n    //            //prntBusT = bus.T\n    //            //thisBusT = bT\n    //            busBFS(bus.T, bT, container[buses.indexOf(bus)]);\n    //        });\n    //        // as this bus is completely done\n    //        busesDone.push(bus.T);\n    //    }\n\n\n    //    paper.fitToContent();\n\n    //    function createChildLink(mycontainer, childtText) {\n    //        var ck = child.length;\n    //        var lk = link.length;\n    //        var posx = buses.filter(b => b.T == prntBusT)[0].CordX + 50 * buses.filter(b => b.T == prntBusT)[0].SLDL;\n    //        var posy = 150 + buses.filter(b => b.T == prntBusT)[0].CordY;\n    //        child[ck] = new Child({\n    //            z: 2,\n    //            position: { x: posx, y: posy },\n    //            attrs: { label: { text: childtText } }\n    //        });\n    //        //\n    //        link[lk] = new Link({\n    //            z: 4,\n    //            source: { id: mycontainer.id },\n    //            target: { id: child[ck].id }\n    //        });\n    //        graph.addCells([child[ck], link[lk]]);\n\n    //        mycontainer.embed(child[ck]);\n    //        link[lk].reparent();\n    //    }\n\n    //}\n\n\n    //----example------\n\n    //var portsIn = {\n    //    position: { name: 'top' },\n    //    attrs: { portBody: { magnet: true, r: 3, fill: '#023047', stroke: '#023047' } },\n    //    label: { position: { name: 'top', args: { y: 2 } }, markup: [{ tagName: 'text', selector: 'label', className: 'label-text' }] },\n    //    markup: [{ tagName: 'circle', selector: 'portBody' }]\n    //};\n\n    //var portsOut = {\n    //    position: { name: 'bottom' },\n    //    attrs: { portBody: { magnet: true, r: 3, fill: '#E6A502', stroke: '#023047' } },\n    //    label: { position: { name: 'bottom', args: { y: 2 } }, markup: [{ tagName: 'text', selector: 'label', className: 'label-text' }] },\n    //    markup: [{ tagName: 'circle', selector: 'portBody' }]\n    //};\n\n\n    //const rect1 = new shapes.standard.Rectangle({\n    //    size: { width: 40, height: 40 }, position: { x: 50, y: 1100 }, attrs: { body: { fill: '#8ECAE6' } },\n    //    ports: {\n    //        groups: { 'in': portsIn, 'out': portsOut }\n    //    }\n    //});\n\n\n    //rect1.addPorts([\n    //    { group: 'in', id: '1', attrs: { label: { text: '1' } } },\n    //    { group: 'in', id: '2', attrs: { label: { text: '2' } } },\n    //    { group: 'out', id: '3', attrs: { label: { text: '3' } } }\n    //]);\n    //const rect2 = rect1.clone().position(50, 1300);\n\n    //var link35 = new dia.Link({\n    //    source: { id: rect1.id, port: '3' },\n    //    target: { id: rect2.id, port: '2' }\n    //});\n\n    //link35.router('orthogonal');\n    //link35.connector('jumpover', { size: 10 });\n    //link35.attr({\n    //    line: {\n    //        sourceMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', },\n    //        targetMarker: { 'type': 'circle', 'r': 2, 'cx': 2, 'fill': '#000000', }\n    //    }\n    //});\n\n    //graph.addCells([rect1, rect2, link35]);\n\n\n    //var port = {\n    //    label: {\n    //        position: {\n    //            name: 'left'\n    //        },\n    //        markup: [{\n    //            tagName: 'text',\n    //            selector: 'label'\n    //        }]\n    //    },\n    //    attrs: {\n    //        portBody: { magnet: true, r: 5, x: 5, y: 5, fill: '#E6A502', stroke: '#023047' },\n    //        label: {\n    //            text: 'port'\n    //        }\n    //    },\n    //    markup: [{\n    //        tagName: 'rect',\n    //        selector: 'portBody'\n    //    }]\n    //};\n\n    //var model = new shapes.standard.Rectangle({ size: { width: 200, height: 10 }, attrs: { body: { fill: '#8ECAE6' } }, ports: { groups: { 'in': portsOut } } });\n\n    //model.addPorts([{ group: 'in', attrs: { label: { text: 'in1' } } }, { group: 'in', attrs: { label: { text: 'in2' } } }, { group: 'in', attrs: { label: { text: 'out' } } }]);\n\n    //model.addPort(port); // add a port using Port API\n\n\n    //const portId = model.getPorts()[0].id;\n\n    //model.portProp(portId, 'attrs/portBody', { r: 3, fill: 'darkslateblue' });\n    //model.portProp(portId, 'custom', { testAttribute: true });\n    //console.log(model.portProp(portId, 'custom'));\n\n\n    //const rect11 = new shapes.standard.Rectangle({ size: { width: 20, height: 20 }, attrs: { body: { fill: '#8ECAE6' } } });\n    //const rect12 = new shapes.standard.Rectangle({ size: { width: 20, height: 20 }, attrs: { body: { fill: '#8ECAE6' } } });\n\n    //var link11 = new branchLink();\n    //link11.source(rect11, { anchor: { name: 'bottom', args: { rotate: true, dx: 50, dy: 10 } } });\n    //link11.target(rect12, { anchor: { name: 'modelCenter', args: { rotate: true } } });\n\n\n    //link11.router('orthogonal');\n    //link11.connector('jumpover', { size: 5 });\n    //link11.vertex(0, {\n    //    x: 160,\n    //    y: 1450\n    //});\n\n    //graph.addCells([rect11, rect12, link11]);\n\n\n    //paper.on('element:button:pointerdown', function (elementView) {\n    //    var element = elementView.model;\n    //    element.toggle();\n    //    fitAncestors(element);\n    //});\n\n    //paper.on('element:pointermove', function (elementView) {\n    //    var element = elementView.model;\n    //    fitAncestors(element);\n    //});\n\n    //function fitAncestors(element) {\n    //    element.getAncestors().forEach(function (container) {\n    //        container.fitChildren();\n    //    });\n    //}\n\n\n    function dragStart(evt, x, y) {\n        //const data = (evt.data = {\n        //    tool,\n        //    ox: x,\n        //    oy: y\n        //});\n        ox = x;\n        oy = y;\n        // remove previously created selectboxes\n        var existingSelectBox = graph.getElements().find(el => el.tag && el.tag == \"selectbox\");\n        if (existingSelectBox) {\n            // unembed elements before removing this selectbox\n            var allChildren = graph.getElements();\n            //console.log(existingSelectBox.id);\n            //allChildren.forEach(child => console.log(child.id, \" - \", child.parent(), \" .\"));\n            var children = allChildren.filter(el => el.get('parent') && graph.getCell(el.get('parent')).tag == \"selectbox\");\n            if (children && children.length > 0) {\n                children.forEach(child => {\n                    // remove from the selection boundary\n                    //console.log(`DragStart: ${child.tag} was earlier embedded in parent '${child.get('parent')}', to be un-embedded.`);\n                    existingSelectBox.unembed(child);\n                    //console.log(`DragStart: ${child.tag} is un-embedded now and hence has parent '${child.get('parent')}' post un-embedding.`);\n                    // unhighlight the child element\n                    //var childView = paper.findView(child);\n                    //highlighters.mask.remove(childView);\n                });\n            }\n            //console.log(`DragStart: Earlier Select box '${existingSelectBox.id}' removed`);\n            existingSelectBox.remove()\n        }\n        //console.log(`Select box '${existingSelectBox.id}' removed`);\n        var selectBox = new shapes.standard.Rectangle({\n            position: {x: x, y: y},\n            size: {width: 1, height: 1},\n            attrs: {\n                body: {\n                    fill: 'rgba(100, 100, 0, 0.25)',\n                    stroke: 'red',\n                    strokeWidth: 1,\n                    strokeDasharray: '5,5'\n                }\n            }\n        });\n        selectBox.tag = \"selectbox\";\n        selectBox.type = \"selectbox\";\n        selectBox.addTo(graph);\n\n    }\n\n\n    function drag(evt, x, y) {\n        var selectBoxElement = graph.getElements().find(el => el.tag == \"selectbox\");\n        var selectBox = paper.findViewByModel(selectBoxElement);\n        if (selectBox) {\n            selectBox.model.prop('size/width', Math.abs(ox - x));\n            selectBox.model.prop('size/height', Math.abs(oy - y));\n            selectBox.model.prop('position/x', Math.min(ox, x));\n            selectBox.model.prop('position/y', Math.min(oy, y));\n        }\n    }\n\n    function dragEnd(evt) {\n\n        var selectBoxElement = graph.getElements().find(el => el.tag == \"selectbox\");\n        if (selectBoxElement) {\n            // if it is just a click without substantial drag, then the created selectBox to be removed\n            var selectBox = paper.findViewByModel(selectBoxElement);\n            var dx = selectBox.model.prop('size/width');\n            var dy = selectBox.model.prop('size/height');\n            if (dx < 5 && dy < 5) {\n                // unembed elements, if any, before removing this selectbox\n                var allChildren = graph.getElements();\n                var children = allChildren.filter(el => el.get('parent') && graph.getCell(el.get('parent')).tag == \"selectbox\");\n                if (children && children.length > 0) {\n                    children.forEach(child => {\n                        // remove from the selection boundary\n                        //console.log(`DragEnd: Insufficient drag : ${child.tag} was embedded in parent '${child.get('parent')}' , to be un-embedded.`);\n                        selectBoxElement.unembed(child);\n                        //console.log(`DragEnd: Insufficient drag : ${child.tag} is un-embedded now and hence has parent '${child.get('parent')}' post un-embedding.`);\n                    });\n                }\n                selectBoxElement.remove();\n                //console.log(`DragEnd: Insufficient drag : ${selectBoxElement.tag} is  removed as its not substatially dragged.`)\n            } else {\n                // retain the select box and embed all the elements inside\n                var selectedElements = graph.getElements().filter(el => el.tag && el.tag != selectBoxElement.tag && el.getBBox().intersect(selectBoxElement.getBBox()));\n                if (selectedElements.length > 0) {\n                    //console.log(`DragEnd: Total ${selectedElements.length} intersected items.`);\n                    selectedElements.forEach(el => {\n                        if (!el.get('parent')) {\n                            selectBoxElement.embed(el);\n                            //console.log(`DragEnd: Tag '${el.tag}' is embedded to '${el.get('parent')}'.`);\n                        } else {\n                            //console.log(`DragEnd: Tag '${el.tag}' has parent '${el.get('parent')}', hence embedding skipped.`);\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n\n    paper.on(\"blank:pointerdown\", (evt, x, y) => dragStart(evt, x, y));\n    //paper.on(\"element:pointerdown\", (_, evt, x, y) => dragStart(evt, x, y));\n\n    paper.on(\"blank:pointermove\", (evt, x, y) => drag(evt, x, y));\n    //paper.on(\"element:pointermove\", (_, evt, x, y) => drag(evt, x, y));\n\n    paper.on(\"blank:pointerup\", (evt) => dragEnd(evt));\n    //paper.on(\"element:pointerup\", (_, evt) => dragEnd(evt));\n\n\n    graph.on('change:source change:target', async function (link) {\n        console.log(`Checking link ....`);\n        if (!link instanceof shapes.standard.Link) return;\n        if (link.get('source').id && link.get('target').id) {\n            // both ends of the link are connected.\n            var source = graph.getCell(link.get('source'));\n            var target = graph.getCell(link.get('target'));\n            link.attr(`line\\stroke`, '#999999');\n            console.log(`Checking link between '${source.tag}' and ${target.tag}....`);\n            // validate the link at server side based on the business cases\n            var validatedLink = await validateLinkFromServer(link);\n\n            if (validatedLink.prop('valid')) {\n                // if the validation is successsfull, update the source/target (bus/port) data\n                // assign tag to this link\n                var sourcePortId = link.prop('source/port');\n                var targetPortId = link.prop('target/port');\n                link.tag = getLinkTag(link);\n                // if the source/targer are not bus, then make the magnet passive\n                // so that no further connection from the same port is possible\n                if (source.type !== \"bus\") {\n                    //source.getPort(sourcePortId).getAttribute('magnet') = 'passive';\n                    source.attr(`ports/${sourcePortId}/magnet`, 'passive');\n                }\n                if (target.type !== \"bus\") {\n                    //target.getPort(targetPortId).getAttribute('magnet') = 'passive';\n                    target.attr(`ports/${targetPortId}/magnet`, 'passive');\n                }\n\n                // if source/targets are bus, distribute the ports\n                // along the bus length as per no of links connected to this bus\n                if (source.type == \"bus\") busPortDistribution(source.id);\n                if (target.type == \"bus\") busPortDistribution(target.id);\n\n            } else {\n                // else remove the created link\n                removeLink(link);\n                if (source.type == \"bus\") busPortDistribution(source.id);\n                if (target.type == \"bus\") busPortDistribution(target.id);\n                console.log(`Created link between '${source.tag}' and ${target.tag} not valid, hence removed`);\n            }\n        }\n    })\n\n\n    // additional code for testing purpose\n\n\n    // Define the port configuration\n    var port = {\n        position: {name: 'right', args: {y: '0%'}},\n        label: {position: {name: 'top', args: {x: 6}}, markup: [{tagName: 'text', selector: 'label'}]},\n        attrs: {\n            portBody: {magnet: true, r: 3, fill: 'orange', stroke: 'blue', strokeWidth: 1,},\n            label: {text: 'port'}\n        },\n        markup: [{tagName: 'circle', selector: 'portBody'},]\n    };\n\n    var portsIn = {\n        position: {\n            name: 'left',\n            args: {y: -10} // Adjust as needed\n        },\n        label: {\n            position: {name: 'top', args: {y: -6}},\n            markup: [{tagName: 'text', selector: 'label', className: 'label-text'}]\n        },\n        attrs: {portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'}, label: {text: 'in'}},\n        markup: [{tagName: 'circle', selector: 'portBody'}],\n    };\n\n    var portsOut = {\n        position: {name: 'left', args: {y: '100%'}},\n        label: {\n            position: {name: 'right', args: {y: 6}},\n            markup: [{tagName: 'text', selector: 'label', className: 'label-text'}]\n        },\n        attrs: {portBody: {magnet: true, r: 3, fill: '#E6A502', stroke: '#023047'}, label: {text: 'out'}},\n        markup: [{tagName: 'circle', selector: 'portBody'}],\n    };\n\n\n    const rect = new shapes.standard.Rectangle({\n        position: {x: 50, y: 1250},\n        size: {width: 100, height: 120},\n        attrs: {\n            root: {title: 'Port Example'},\n            body: {fill: 'lightblue',},\n            label: {text: 'Port \\nRectangle', fontSize: 12},\n        },\n        ports: {\n            groups: {'in': portsIn, 'out': portsOut, 'any': port}\n        },\n    });\n\n    rect.addPorts([\n        //{ group: 'in', attrs: { label: { text: 'in0' } } },\n        {id: 'in1', group: 'in', attrs: {label: {text: 'in'}}},\n        {id: 'out1', group: 'out', attrs: {label: {text: 'out'}}},\n        {id: 'anyPort1', group: 'any', attrs: {label: {text: 'anyPort'}}}\n    ]);\n    rect.tag = \"Port-Rectangle\";\n    // ....\n    // add another port to group 'a'.\n    //rect.addPort(port);\n    rect.addTo(graph);\n\n    // get position of the port\n    var portId = 'anyPort1';\n    var portIndex = rect.getPortIndex(portId);\n    // set args on newly added\n    rect.addPort({group: 'anyPort', args: {y: '60%'}});\n    // update existing\n    rect.portProp(portId, 'args/y', '30%');\n\n\n    rect.portProp(portId, 'attrs/label/text', 'just chill'); // { name: 'right', args: { y: '60%' } });\n    //rect.prop('ports/items/' + portIndex + '/position', { name: 'right', args: { y: '60%' } });\n\n\n}\n\n\n//function linkTag(source, target, sourcePortIndex, targetPortIndex) {\n//    return (source.tag > target.tag) ?\n//        `${source.tag}:${sourcePortIndex} - ${target.tag}:${targetPortIndex}` :\n//        `${target.tag}:${targetPortIndex} - ${source.tag}:${sourcePortIndex}`;\n//}\n\n\nfunction getLinkTag(link) {\n    var source = graph.getCell(link.get('source'));\n    var target = graph.getCell(link.get('target'));\n    var sourcePortId = link.prop('source/port');\n    var targetPortId = link.prop('target/port');\n    var sourcePortIndex = source.getPortIndex(sourcePortId);\n    var targetPortIndex = target.getPortIndex(targetPortId);\n\n    return (source.tag > target.tag) ?\n        `${source.tag}:${sourcePortIndex} - ${target.tag}:${targetPortIndex}` :\n        `${target.tag}:${targetPortIndex} - ${source.tag}:${sourcePortIndex}`;\n}\n\n\nfunction getLinkData(link) {\n    var sPort = link.prop('source/port');\n    var tPort = link.prop('target/port');\n    //var sM = graph.getCell(link.prop('source').id);\n    var sM = graph.getElements().find(el => el.id === link.prop('source').id);\n    var tM = graph.getElements().find(el => el.id === link.prop('target').id);\n\n    return {\n        'sourceTag': sM.tag,\n        'targetTag': tM.tag,\n        'sourcePort': sPort ? sPort : \"\",\n        'targetPort': tPort ? tPort : \"\"\n    };\n}\n\n\nfunction busPortDistribution(busId) {\n    // function to distribute the ports along the bus length\n    // as per no of links connected to this bus\n\n    // pick the bus from graph and update there, does not return any\n    var bus = graph.getCell(busId);\n    // all busses have only one port group 'in' and default one port\n    // ports are numbered with 1, 2, 3...\n    // default port 1 cannot be deleted\n\n    // check all the links connected to this bus\n    const allLinks = graph.getConnectedLinks(bus);\n\n    // check existing ports \n    var ports = bus.getGroupPorts('in');\n    var busWidth = bus.prop('size/width'); // busWidth not required as the positions are refX in percentage\n\n    // check up-side and down-side connection requirement\n    var upLinks = [];\n    var downLinks = [];\n\n    // assign other end position (x,y) fpr filter purpose\n    allLinks.forEach(link => {\n        var source = graph.getCell(link.prop('source').id);\n        var target = graph.getCell(link.prop('target').id);\n        var otherEnd = source.id === bus.id ? target : source;\n        link.otherEndX = otherEnd.prop('position/x');\n        link.otherEndY = otherEnd.prop('position/y');\n    });\n\n    // arrange links as per the X value of the other end of the links\n    allLinks.sort((a, b) => a.otherEndX - b.otherEndX);\n\n    allLinks.forEach(link => {\n        if (link.otherEndY < bus.prop('position/y')) {\n            upLinks.push(link);\n        } else {\n            downLinks.push(link);\n        }\n\n        // below code is to compare based on the absolute position of the ports, not just element position\n        //var otherEndPortTag = source.id === bus.id ? link.prop('target/port') : link.prop('source/port');\n        //var otherEndPortPosition = otherEnd.getPortsPositions(otherEndPortTag);\n        //var otherEndPortPositionAbsoluteY = otherend.prop('position/y') + otherEndPortPosition.y;\n    });\n\n\n    // total no of ports is equal to total no of connections\n    var reqPorts = upLinks.length + downLinks.length;\n    console.log(`Bus port postion distribution for bus tag '${bus.tag}' having total ${allLinks.length} connections : ` +\n        `Upside links : ${upLinks.length} and Downside links ${downLinks.length}, total available ports ${ports.length} and required ports ${reqPorts}.`);\n\n    // Remove ports if the required no. of ports are less than the existing ports (however retain minimum 1)\n    if (reqPorts < ports.length && ports.length > 1) {\n        for (let i = ports.length; i > upLinks.length; i--) {\n            bus.removePort(`{i}`);\n        }\n    }\n\n    // Add ports if the required no. of ports are more than the existing ports\n    if (reqPorts > ports.length) {\n\n        // Define new ports\n        var newPorts = [];\n        for (let i = ports.length; i < reqPorts; i++) {\n            newPorts.push({id: `${i + 1}`, group: 'in', position: {name: 'absolute', args: {x: `0%`, y: 0}}});\n        }\n\n        // Add new ports to the element\n        newPorts.forEach(port => {\n            bus.addPort({\n                ...port,\n                attrs: {\n                    portBody: {magnet: true, r: 3, fill: 'orange', stroke: '#023047'},\n                    label: {text: port.id, fontSize: 8}\n                },\n                markup: [{tagName: 'circle', selector: 'portBody'}]\n            });\n        });\n    }\n\n    // Define new positions to the arranged ports as per final port nos\n    // and Update the ports' positions\n    for (let i = 0; i < upLinks.length; i++) {\n        // position for up-side ports\n        var pos = `${Math.round((i + 0.5) * 100 / upLinks.length)}%`;\n        console.log(`Bus tag '${bus.tag}' postion for Port #'${i + 1}' (up-link # ${i + 1}) '${pos}`);\n        bus.portProp(`${i + 1}`, 'args/x', pos);\n        bus.portProp(`${i + 1}`, 'attrs/label/refX', 3);\n        bus.portProp(`${i + 1}`, 'attrs/label/refY', -10);\n        // reassign the corresponding port for up-side links\n        var end = upLinks[i].prop('source').id == bus.id ? 'source' : 'target';\n        var portId = bus.getPorts()[i].id;\n\n        if (end == 'source') upLinks[i].set({source: {id: busId, port: portId}});\n        if (end == 'target') upLinks[i].set({target: {id: busId, port: portId}});\n\n\n        var end = upLinks[i].prop('source') == bus.id ? 'source' : 'target';\n        upLinks[i].prop(`${end}'/port`, `${i + 1}`);\n    }\n    for (let i = 0; i < downLinks.length; i++) {\n        // position for down-side ports\n        var pos = `${Math.round((i + 0.5) * 100 / downLinks.length)}%`;\n        console.log(`Bus tag '${bus.tag}' postion for Port #'${upLinks.length + i + 1}' (down-link # ${i + 1}) '${pos}`);\n        bus.portProp(`${upLinks.length + i + 1}`, 'args/x', pos);\n        bus.portProp(`${upLinks.length + i + 1}`, 'attrs/label/refX', 3);\n        bus.portProp(`${upLinks.length + i + 1}`, 'attrs/label/refY', 10);\n        // reassign the corresponding port for down-side links\n        var end = downLinks[i].prop('source').id == bus.id ? 'source' : 'target';\n        var portId = bus.getPorts()[upLinks.length + i].id;\n\n        if (end == 'source') downLinks[i].set({source: {id: busId, port: portId}});\n        if (end == 'target') downLinks[i].set({target: {id: busId, port: portId}});\n\n    }\n    // later : if up and down are same or both are odd or in LCM, there are common ports\n\n}\n\n\nasync function validateLinkFromServer(link) {\n\n    let linkData = getLinkData(link);\n    let success = false;\n    try {\n        if (dotNetObjSLD) {\n            success = await dotNetObjSLD.invokeMethodAsync('SLDValidateLink', JSON.stringify(linkData));\n            console.log(`Validation success of the Link between '${linkData.sourceTag} and ${linkData.targetTag}' from server side: ${success}.`);\n            if (success) {\n                link.set('valid', true);\n            } else {\n                link.set('valid', false);\n            }\n        }\n    } catch (e) {\n        console.log(`Validation process for link between'${linkData.sourceTag} and ${linkData.targetTag}' from server side failed due to error: ${e.message}.`);\n    }\n    return link;\n}\n\n\nasync function removeLink(link) {\n    var linkData = getLinkData(link);\n\n    var success;\n    if (dotNetObjSLD) {\n        success = await dotNetObjSLD.invokeMethodAsync('SLDRemoveLink', JSON.stringify(linkData));\n        if (success) {\n            link.remove(); // Remove the link from the graph\n        }\n        console.log(`Removal success of the Link between '${linkData.sourceTag} and ${linkData.targetTag}' : ${success}.`);\n    }\n}\n\n\nfunction isOverlapping(element, graph) {\n    // Function to check if an element overlaps with any other elements\n    const bbox = element.getBBox();\n    return graph.getCells().some(cell => {\n        if (cell === element) return false;\n        const cellBBox = cell.getBBox();\n        return bbox.intersect(cellBBox);\n    });\n}\n\n\nfunction findNearestEmptyPosition(element, graph, spacing = 20) {\n    // Function to find the nearest empty position\n    // Adjust spacing as needed\n    let position = element.get('position');\n    let newPosition = {...position};\n\n    while (isOverlapping(element, graph)) {\n        // Move the element to a new position\n        newPosition.x += spacing;\n        if (newPosition.x > paper.options.width) {\n            newPosition.x = 0;\n            newPosition.y += spacing;\n        }\n\n        // Ensure newPosition is within paper bounds\n        // and away from template (x>100) and top margin 50\n        newPosition.x = Math.max(100, Math.min(newPosition.x, paper.options.width - element.getBBox().width));\n        newPosition.y = Math.max(50, Math.min(newPosition.y, paper.options.height - element.getBBox().height));\n\n        element.set('position', newPosition);\n    }\n\n    return newPosition;\n}\n\n\nfunction updateBus(busModel, busInfo) {\n\n    if (busInfo.Category === \"Swing\") {\n        // grid            \n        busModel.attr({\n            label: {text: \"Grid\" + busInfo.Tag},\n            ratedSC: {text: Math.round(10 * busInfo.ISC) / 10 + \"kA\"},\n            ratedVoltage: {text: busInfo.VR / 1000 + \"kV\"},\n            busFaultkA: {text: Math.round(10 * busInfo.SCkAaMax) / 10 + \"kA\"},\n            operatingVoltage: {text: Math.round(10000 * busInfo.Vo.Magnitude) / 100 + \"% \" + Math.round(busInfo.Vo.Phase * 1800 / Math.PI) / 10 + \"\"}\n        });\n    } else {\n        // the other bus\n        busModel.attr({\n            label: {text: busInfo.Tag},\n            ratedSC: {text: Math.round(10 * busInfo.ISC) / 10 + \"kA\"},\n            ratedVoltage: {text: busInfo.VR / 1000 + \"kV\"},\n            busFault: {text: Math.round(10 * busInfo.SCkAaMax) / 10 + \"kA\"},\n            operatingVoltage: {text: Math.round(10000 * busInfo.Vo.Magnitude) / 100 + \"% \" + Math.round(busInfo.Vo.Phase * 1800 / Math.PI) / 10 + \"\"}\n        });\n    }\n    return busModel;\n}\n\n\nfunction updateTransformer(trafoModel, trafoInfo, branches) {\n\n    let branch = branches.find(br => br.Tag === trafoInfo.Tag);\n\n    trafoModel.attr({\n        tag: {text: trafoInfo.Tag},\n        voltage: {text: `${trafoInfo.V1 / 1000}/${trafoInfo.V2 / 1000}kV`},\n        kVArating: {text: `${trafoInfo.KVA}kVA`},\n        impedance: {text: `Z:${trafoInfo.Z}%`},\n        loading: {text: `${Math.round(10 * branch?.KW) / 10}KW ${Math.round(10 * branch?.KVAR) / 10}kVAR`}\n    });\n    return trafoModel;\n}\n\nfunction updateCable(cableModel, cabledata, branches) {\n\n    var branch = branches.find(br => br.Tag === cabledata.Tag);\n\n    cableModel.attr({\n        label: {text: cabledata.Tag},\n        size: {text: cabledata.CblDesc},\n        length: {text: `${cabledata.L}m, ${cabledata.Rl}-j${cabledata.Xl}/km`},\n        impedance: {text: `R:${cabledata.R}, X:${cabledata.X}`},\n        operatingCurrent: {text: `${Math.round(10 * branch?.Io.Magnitude) / 10}A ${Math.round(branch?.Io.Phase * 1800 / Math.PI) / 10}`}\n    });\n\n    return cableModel;\n}\n\nfunction updateBusDuct(busDuctModel, busDuctdata, branches) {\n\n    var branch = branches.find(br => br.Tag == busDuctdata.Tag);\n    busDuctModel.attr({\n        label: {text: busDuctdata.Tag},\n        size: {text: `${busDuctdata.IR}A`},\n        length: {text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}/km`},\n        impedance: {text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}`},\n        operatingCurrent: {text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}`}\n    });\n    return busDuctModel;\n}\n\n\nfunction updateMotor(motorModel, motordata, branches) {\n\n    var branch = branches.find(br => br.Tag == motordata.Tag);\n    motorModel.attr({\n        // label: { text: busDuctdata.Tag },\n        // size: { text: `${busDuctdata.IR}A` },\n        // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}/km` },\n        // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },\n        // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}` }\n    });\n    return motorModel;\n}\n\nfunction updateHeater(heaterModel, heaterdata, branches) {\n\n    var branch = branches.find(br => br.Tag == heaterdata.Tag);\n    heaterModel.attr({\n        // label: { text: busDuctdata.Tag },\n        // size: { text: `${busDuctdata.IR}A` },\n        // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}/km` },\n        // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },\n        // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}` }\n    });\n    return heaterModel;\n}\n\nfunction updateCapacitor(capacitorModel, capacitordata, branches) {\n\n    var branch = branches.find(br => br.Tag == capacitordata.Tag);\n    capacitorModel.attr({\n        // label: { text: busDuctdata.Tag },\n        // size: { text: `${busDuctdata.IR}A` },\n        // length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}/km` },\n        // impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },\n        // operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}` }\n    });\n    return capacitorModel;\n}\n\nfunction updateLumpLoad(lumpLoadModel, lumpLoaddata, branches) {\n\n    var branch = branches.find(br => br.Tag == lumpLoaddata.Tag);\n    lumploadModel.attr({\n        //label: { text: busDuctdata.Tag },\n        //size: { text: `${busDuctdata.IR}A` },\n        //length: { text: `${busDuctdata.L}m, ${Math.round(1000 * busDuctdata.Rl) / 1000}-j${Math.round(1000 * busDuctdata.Xl) / 1000}/km` },\n        //impedance: { text: `R:${Math.round(10000 * busDuctdata.R) / 10000}, X:${Math.round(10000 * busDuctdata.X) / 10000}` },\n        //operatingCurrent: { text: `${Math.round(10 * branch.Io.Magnitude) / 10}A ${Math.round(branch.Io.Phase * 1800 / Math.PI) / 10}` }\n    });\n    return lumploadModel;\n}\n","import * as THREE from 'three';\nimport {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';\nimport {FontLoader} from 'three/examples/jsm/loaders/FontLoader';\nimport {TextGeometry} from 'three/examples/jsm/geometries/TextGeometry';\nimport {GLTFExporter} from 'three/examples/jsm/exporters/GLTFExporter';\nimport {GUI} from 'three/examples/jsm/libs/lil-gui.module.min'; //dat-gui\n//import {Stats} from 'three/examples/jsm/libs/stats.module';\nimport {drawPlaneMesh} from '../src/threejs/objects/plane.js'\nimport {drawLadderMesh} from '../src/threejs/objects/ladder'\nimport {drawBendMesh} from '../src/threejs/objects/bend.js'\nimport {drawTeeMesh} from '../src/threejs/objects/tee.js'\nimport {drawCrossMesh} from '../src/threejs/objects/cross.js'\nimport {drawNodeMesh} from './threejs/objects/node'\nimport {drawSleeveMesh} from '../src/threejs/objects/sleeve.js'\nimport {drawEquipmentMesh} from '../src/threejs/objects/equipment'\nimport {drawSleepMesh} from '../src/threejs/objects/sleeve'\nimport {drawRefPointMesh} from '../src/threejs/objects/refPoint'\n\n\nvar dotNetObj;\nlet scene, camera, renderer;\nlet canvas, controls, currentPlane;\nlet rendererWidth = window.innerWidth;\nlet rendererHeight = window.innerHeight;\nvar raycaster;\nvar [posx, posy, posz, eventclientX, eventclientY,\n    eventpageX, eventpageY, eventoffsetX, eventoffsetY, eventlayerX, eventlayerY, eventx, eventy, mousex, mousey,\n    linePositionx, linePositiony, linePositionz] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n//const stats = new Stats();\n\n// materials\nvar defaultOpacity = 0.9, defaultColor = 0xc8c8c8, defaultColorLadder = 0xc80000, defaultColorEq = 0x7f868a,\n    defaultColorTrench = 0x77ff88;\nvar defaultColorSSFloor = 0x424242, defaultColorSleeve = 0x7f868a, defaultColorMCT = 0xc8c8c8,\n    defaultColorConcrete = 0xc8c8c8;\nvar substationFloorMaterial = new THREE.MeshStandardMaterial({\n    color: defaultColorSSFloor,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar ladderMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorLadder,\n    shininess: 100,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar equipmentMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorEq,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar sleeveMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorSleeve,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar trenchMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorTrench,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar concreteMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorConcrete,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar mctMaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorMCT,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar pointsMaterial = new THREE.PointsMaterial({color: 0x0080ff, size: 0.02, alphaTest: 0.5});\nvar redRingMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});\nvar yellowRingMaterial = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide});\nvar selectedObjectMaterial = new THREE.MeshPhongMaterial({\n    color: 0xffff00,\n    transparent: true,\n    opacity: 0.8,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\nvar savedObject, savedObjectMaterial; // storing previously selecyed object and its meterials properties\nvar selectItemColor = new THREE.MeshPhongMaterial({\n    color: 'yellow',\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true\n});\n\nvar ctrlKeyPressed = false;\nvar shiftKeyPressed = false;\n\nvar shadowRingMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc, side: THREE.DoubleSide});\n\nvar intervalId = window.setInterval(function () {\n    if (camera != undefined) {\n        const sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);\n        dotNetObj.invokeMethodAsync(\"SaveSceneInfo\", sceneInfo);\n    }\n}, 10000);\n\nlet eventListenersAdded = false;\n\n//clearInterval(intervalId)\nfunction drawScene3Js(divId, sceneInfoJson = \"\", dotNetObjRef) {\n    if (eventListenersAdded) return; // Prevent adding listeners multiple times\n    dotNetObj = dotNetObjRef;\n    canvas = document.getElementById(divId);\n    canvas.setAttribute('tabindex', '0'); // Make canvas focusable\n    //canvas.focus(); // Optionally set focus programmatically\n    scene = new THREE.Scene();\n    scene.Name = \"name\";\n    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 400);\n    //light\n    scene.add(new THREE.AmbientLight(0xffffff, 0.9));\n    scene.add(new THREE.HemisphereLight(0x9f9f9b, 0x080820, 1));\n    const pointLight = new THREE.PointLight(0xffffff, 1, 100);\n    pointLight.position.set(rendererWidth / 2, rendererHeight / 2, 100);\n    scene.add(pointLight);\n\n    const axesHelper = new THREE.AxesHelper(500);\n    scene.add(axesHelper);\n    //shadowRing(0, 0, plotElevtn + 0.01); // to shadow mouse movement when ctrl key is pressed    \n    const shadowRing = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.21, 20), shadowRingMaterial);\n    shadowRing.name = 'shadowRing';\n    shadowRing.position.set(0, 0, 0.01);\n    scene.add(shadowRing);\n\n    raycaster = new THREE.Raycaster();\n\n    renderer = new THREE.WebGLRenderer();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    canvas.appendChild(renderer.domElement);\n\n\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.autoRotate = true;\n    controls.autoRotateSpeed = 6;\n    controls.screenSpacePanning = true;\n    controls.minDistance = 5;\n    controls.maxDistance = 10000;\n    if (sceneInfoJson != \"\") {\n        var sceneInfo = JSON.parse(sceneInfoJson);\n        rendererWidth = sceneInfo[0];\n        rendererHeight = sceneInfo[1];\n        camera.position.x = sceneInfo[2];\n        camera.position.y = sceneInfo[3];\n        camera.position.z = sceneInfo[4];\n        camera.rotation.x = sceneInfo[5];\n        camera.rotation.y = sceneInfo[6];\n        camera.rotation.z = sceneInfo[7];\n    }\n    controls.addEventListener('change', () => {\n        const distance = camera.position.distanceTo(shadowRing.position);\n        const scale = distance *.1;\n        shadowRing.scale.set(scale, scale, scale);\n\n        // Updated scaling logic\n        const refObjects = getObjectsByName(scene, 'refPoint');\n\n        if (refObjects && refObjects.length > 0) {\n            refObjects.forEach((obj) => {\n                const d = camera.position.distanceTo(obj.position); // Use obj's position (group or individual)\n                const sc = d * 0.1;\n\n                if (obj instanceof THREE.Group) {\n                    // Scale the group itself: this scales all children and their relative positions\n                    obj.scale.set(sc, sc, sc);\n                } else {\n                    // For non-groups, scale the object directly (as before)\n                    obj.scale.set(sc, sc, sc);\n                }\n            });\n        }\n        \n    });\n    \n    const sceneInfo1 = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);\n    dotNetObj.invokeMethodAsync(\"SaveSceneInfo\", sceneInfo1);\n    controls.update();\n\n    camera.position.z = 5;\n\n// Add event listeners\n    window.addEventListener('resize', onWindowResize, false);\n    window.addEventListener('keydown', onKeyDown, false);\n    window.addEventListener('keyup', onKeyUp, false);\n    renderer.domElement.addEventListener('mousemove', onMouseMove, false);\n    renderer.domElement.addEventListener('wheel', mouseWheel, false);\n    renderer.domElement.addEventListener('mousedown', mouseDownListener, false);\n    renderer.domElement.addEventListener('mousemove', mouseMoveListener, false);\n    renderer.domElement.addEventListener('mouseup', mouseUpListener, false);\n\n    // Add double-click event listener\n    renderer.domElement.addEventListener('dblclick', autoZoomToFit);\n    \n    \n// Prevent context menu on Ctrl+click or right-click\n    renderer.domElement.addEventListener('contextmenu', (event) => {\n        event.preventDefault();\n    });\n\n    eventListenersAdded = true;\n\n// onWindowResize (unchanged)\n    function onWindowResize() {\n        console.log('Window resize event triggered');\n        rendererWidth = window.innerWidth;\n        rendererHeight = window.innerHeight;\n        camera.aspect = rendererWidth / rendererHeight;\n        const sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);\n        dotNetObj.invokeMethodAsync(\"SaveSceneInfo\", sceneInfo);\n        camera.updateProjectionMatrix();\n        scene.updateMatrixWorld(true);\n        renderer.setSize(rendererWidth, rendererHeight);\n        render();\n    }\n\n// onKeyDown (unchanged, as it works correctly)\n    function onKeyDown(event) {\n        console.log(`Key down event triggered: ${event.key}, Key code: ${event.code}`);\n        if (event.key === 'Control') {\n            ctrlKeyPressed = true;\n        }\n        if (event.key === 'Shift') {\n            shiftKeyPressed = true;\n        }\n\n        if (event.key === 'Escape') {\n            // clear all the clicked reference points to start afres\n            clearRefPoints();\n        }\n        \n        showHideShadowRingNPosinLines();\n        console.log(`Key pressed event after: ${event.key}, Key code: ${event.code}, \n        Ctrl key pressed status: ${ctrlKeyPressed}, Shift key pressed status: ${shiftKeyPressed}`);\n    }\n\n// onKeyUp (unchanged, as it works correctly)\n    function onKeyUp(event) {\n        console.log(`Key released event triggered: ${event.key}, Key code: ${event.code}`);\n        if (event.key === 'Control') {\n            ctrlKeyPressed = false;\n        }\n        if (event.key === 'Shift') {\n            shiftKeyPressed = false;\n        }\n        showHideShadowRingNPosinLines();\n        console.log(`Key released event after: ${event.key}, Key code: ${event.code}, \n        Ctrl key pressed status: ${ctrlKeyPressed}, Shift key pressed status: ${shiftKeyPressed}`);\n    }\n\n// onMouseMove (unchanged, as it works with global ctrlKeyPressed)\n    function onMouseMove(event) {\n        if (ctrlKeyPressed) {\n            [mouse, pos] = findCoordinate(event);\n            console.log(\"Control Key pressed and mouse move \", pos);\n            scene.getObjectByName('shadowRing').position.set(pos.x, pos.y, plotElevtn + 0.01);\n            var linePosition = topPlotPlanIntersectPosition(event);\n            scene.remove(scene.getObjectByName('positionlinex'));\n            var pointsx = [];\n            pointsx.push(new THREE.Vector3(linePosition.x + 100, linePosition.y, linePosition.z));\n            pointsx.push(new THREE.Vector3(linePosition.x - 100, linePosition.y, linePosition.z));\n            const geometry1 = new THREE.BufferGeometry().setFromPoints(pointsx);\n            const material1 = new THREE.LineBasicMaterial({ color: 0xff0000 });\n            linex = new THREE.Line(geometry1, material1);\n            linex.name = 'positionlinex';\n            scene.add(linex);\n            scene.remove(scene.getObjectByName('positionliney'));\n            var pointsy = [];\n            pointsy.push(new THREE.Vector3(linePosition.x, linePosition.y + 100, linePosition.z));\n            pointsy.push(new THREE.Vector3(linePosition.x, linePosition.y - 100, linePosition.z));\n            const geometry2 = new THREE.BufferGeometry().setFromPoints(pointsy);\n            const material2 = new THREE.LineBasicMaterial({ color: 0x0000ff });\n            liney = new THREE.Line(geometry2, material2);\n            liney.name = 'positionliney';\n            scene.add(liney);\n            render();\n        }\n    }\n\n    let drag = false;\n\n    function mouseDownListener(event) {\n        drag = false;\n    }\n\n    function mouseMoveListener(event) {\n        drag = true;\n    }\n\n    function mouseUpListener(event) {\n        if (drag) {\n            console.log('Drag Detected');\n        } else {\n            console.log('Click Detected');\n            // Only handle left-clicks\n            if (event.button === 0) {\n                console.log('Left-click detected');\n                // Use event.ctrlKey and event.shiftKey for reliability\n                console.log(`Click event: Ctrl key pressed status: ${event.ctrlKey}, Shift key pressed status: ${event.shiftKey}`);\n\n                // Moved from raycast and onClick\n                [mouse, pos] = findCoordinate(event);\n                \n                var linePosition = topPlotPlanIntersectPosition(event);\n                var objectPosition = topObjectIntersectPosition(event);\n                console.log(`Mouse position: Mouse:[${mouse.x}, ${mouse.y}],  `\n                    + `Position:[${pos.x}, ${pos.y}],  Client:[${event.clientX}, ${event.clientY}],  `\n                    + `Screen:[${event.screenX}, ${event.screenY}],  Page:[${event.pageX}, ${event.pageY}],  `\n                    + `Offset:[${event.offsetX}, ${event.offsetY}],  Layer:[${event.layerX}, ${event.layerY}],  `\n                    + `EvenXY:[${event.x}, ${event.y}],  LinePosition :[${linePosition.x}, ${linePosition.y}, ${linePosition.z}],  `\n                    + `Render Width Height:[${rendererWidth}, ${rendererHeight}]`);\n\n                dotNetObj.invokeMethodAsync(\"MouseClick\", pos.x, pos.y, pos.z, event.clientX, event.clientY,\n                    event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY,\n                    event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n\n                if (!event.ctrlKey) {\n                    console.log(`Select Object`);\n                    // castObject(event); // Uncomment if needed\n                }\n                if (!event.ctrlKey && event.shiftKey) {\n                    console.log(`De-select Object`);\n                    // castObject(event); // Uncomment if needed\n                }\n\n                if (event.ctrlKey) {\n                    console.log(`Clicked while Ctrl key is pressed`);\n                    let point = intersectPoint(currentPlane.Tag);\n                    point.z +=0.01;\n                    refPoints.push([point.x, point.y, mouse.x, mouse.y]);\n                    let refPointText=\"\";\n                    if (scalePlaneDoneStatus === false){\n                        refPointText =  refPointTexts[refPoints.length-1];\n                    }else {\n                        // centre\n                        refPointText = refPointTexts[-1];\n                    }\n                    scene.add(drawRefPointMesh(refPointText, point, .5));\n                    render();\n                    if (refPoints.length ===4 || scalePlaneDoneStatus === true && refPoints.length ===1) {\n                        console.log(`Draw UpdateRefPoints ${refPoints.toString()}`);\n                        dotNetObj.invokeMethodAsync(\"UpdateRefPoints\", refPoints.toString());\n                        }\n                }\n            } else if (event.button === 1) {\n                console.log('Middle-click detected');\n                // Add middle-click behavior if needed\n            } else if (event.button === 2) {\n                console.log('Right-click detected');\n                // Add right-click behavior if needed\n            }\n        }\n    }\n\n    function findCoordinate(event) {\n        // calculate mouse position in normalized device coordinates (-1 to +1) for both components\n        var rect = event.target.getBoundingClientRect();\n        var mouse = new THREE.Vector2();\n\n        var x = event.clientX - rect.left; //x position within the element.\n        var y = event.clientY - rect.top;  //y position within the element.\n        mouse.x = (x / rendererWidth) * 2 - 1;\n        mouse.y = -(y / rendererHeight) * 2 + 1;\n        //\n        var vec = new THREE.Vector3(); // create once and reuse\n        var pos = new THREE.Vector3(); // create once and reuse\n        //\n        vec.set(\n            ((event.clientX - rect.left) / rendererWidth) * 2 - 1,\n            -((event.clientY - rect.top) / rendererHeight) * 2 + 1,\n            0);\n        vec.unproject(camera);\n        vec.sub(camera.position).normalize();\n        var distance = -camera.position.z / vec.z;\n        pos.copy(camera.position).add(vec.multiplyScalar(distance));\n        // rounding to two decimal\n        pos.x = Math.round(pos.x * 100) / 100;\n        pos.y = Math.round(pos.y * 100) / 100;\n        return [mouse, pos];\n    }\n\n    function animate() {\n        requestAnimationFrame(animate);\n\n        //cube.rotation.x += 0.01;\n        //cube.rotation.y += 0.01;\n\n        renderer.render(scene, camera);\n    }\n\n    function GetSceneInfo(scene, camera) {\n        var sceneInfo = {\n            \"sceneName\": scene.Name,\n            \"cameraPosition\": {\n                \"x\": camera.position.x,\n                \"y\": camera.position.y,\n                \"z\": camera.position.z\n            },\n            \"cameraRotation\": {\n                \"x\": camera.rotation.x,\n                \"y\": camera.rotation.y,\n                \"z\": camera.rotation.z\n            },\n            \"rendererWidth\": rendererWidth,\n            \"rendererHeight\": rendererHeight,\n\n            //\"getWorlDirection\": JSON.stringify(cameraTargetVector),\n\n        };\n        return JSON.stringify(sceneInfo);\n    }\n\n    animate();\n}\n\nfunction drawCube3Js() {\n    let side = Math.random() * 1;\n    let geometry = new THREE.BoxGeometry(side, side, side);\n    let color = new THREE.Color();\n    color.setHex(`0x${parseInt(Math.random() * 255)}${parseInt(Math.random() * 255)}${parseInt(Math.random() * 255)}`);\n    let material = new THREE.MeshBasicMaterial({color: color});\n    let cube = new THREE.Mesh(geometry, material);\n    cube.position.x = Math.random() * 50;\n    cube.position.y = Math.random() * 50;\n    cube.position.z = Math.random() * 10;\n    scene.add(cube);\n    animate();\n}\n\n// Utility function (as above)\nfunction getObjectsByName(scene, name) {\n    const objects = [];\n    scene.traverse((obj) => {\n        if (obj.name === name) {\n            objects.push(obj);\n        }\n    });\n    return objects;\n}\n\n\n\n\n\nfunction clearScene3Js() {\n    scene.children.forEach(obj => {\n        if (obj.isMesh) {\n            scene.remove(obj);\n        }\n    });\n    renderer.render(scene, camera);\n}\n\nfunction hide3D3Js(hidePP) {\n    scene.children.forEach(child => {\n        if (child !== undefined) {\n            if (child.Tag !== undefined) {\n                if (child.Tag.includes(\"plotplan\")) {\n                    child.visible = hidePP;\n                }\n            }\n        }\n    });\n    renderer.render(scene, camera);\n}\n\nfunction drawPlane3Js(planeName, planeTag, imageString, scaleX, scaleY, centreX, centreY, elevation, opacity) {\n    //console.log(\"Step 3: Drawing Plane from three.js drawPlane : \", planeTag);\n    scene.add(drawPlaneMesh(rendererWidth, rendererHeight, planeName, planeTag, imageString, scaleX, scaleY, centreX, centreY, elevation, opacity));\n    currentPlane = scene.children[scene.children.length - 1];\n    scalePlaneDoneStatus = false;\n}\n\n\nfunction rotatePlaneJs(angle) {\n    if(currentPlane){\n        if (angle !== undefined ) {\n            currentPlane.rotateZ(angle);\n            renderer.render(scene, camera);\n        }\n    }\n}\n\nlet scalePlaneDoneStatus = false;\nfunction scalePlane3Js(scaleX, scaleY) {\n    if(currentPlane){\n        if (scaleX !== undefined && scaleY !== undefined) {\n            if (scaleX !== 0 && scaleY !== 0) {\n                currentPlane.scale.set(scaleX, scaleY, 1);\n                currentPlane.updateMatrixWorld();\n                clearRefPoints();\n                orthoCamera = new THREE.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);\n                renderer.render(scene, orthoCamera);\n                scalePlaneDoneStatus = true;\n            }\n        }\n    }\n}\n\nfunction centrePlan3Js(centreX, centreY, elevation) {\n    console.log(\"centrePlan3Js\", centreX, centreY, elevation);\n    // align to centre\n    if(currentPlane) {\n        if (centreX !== undefined && centreY !== undefined) {\n            currentPlane.position.set(-centreX, -centreY, elevation);\n            currentPlane.updateMatrixWorld();\n            clearRefPoints();\n            // orthoCamera = new THREE.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);\n            renderer.render(scene, orthoCamera);\n        }\n    }\n}\n\n\n\nfunction drawLadder3Js(tag, jsonPoints, color, opacity) {\n    scene.add(drawLadderMesh(tag, jsonPoints, ladderMaterial, color, opacity));\n}\n\nfunction drawLadderChunk3Js(jsonDataList, opacity) {\n    var dataList = JSON.parse(jsonDataList);\n    dataList.forEach((item, index) => {\n        scene.add(drawLadderMesh(item.Tag, item.JsonPoints, ladderMaterial, item.Color, opacity))\n    });\n}\n\nfunction drawBend3Js(tag, jsonFacePoints, color, opacity) {\n    scene.add(drawBendMesh(tag, jsonFacePoints, ladderMaterial, color, opacity));\n}\n\nfunction drawTee3Js(tag, jsonFacePoints, color, opacity) {\n    scene.add(drawTeeMesh(tag, jsonFacePoints, ladderMaterial, color, opacity));\n}\n\nfunction drawCross3Js(tag, jsonFacePoints, color, opacity) {\n    scene.add(drawCrossMesh(tag, jsonFacePoints, ladderMaterial, color, opacity));\n}\n\nfunction drawNode3Js(tag, jsonPoint, color, opacity) {\n    scene.add(drawNodeMesh(tag, jsonPoint, pointsMaterial, color, opacity));\n}\n\nfunction drawSleeve3Js(tag, jsonPoints, radious, segment, radialSegments, color, opacity) {\n    scene.add(drawSleeveMesh(tag, jsonPoints, radious, segment, radialSegments, sleeveMaterial, color, opacity));\n    renderer.render(scene, camera);\n}\n\nfunction drawEquipment3Js(tag, x, y, z, w, d, h, a, color, opacity, colortext) {\n    scene.add(drawEquipmentMesh(tag, x, y, z, w, d, h, a, equipmentMaterial, color, opacity, colortext));\n}\n\n\nfunction getRandomColor() {\n    new THREE.Color();\n    color.setHex(`0x${parseInt(Math.random() * 255)}${parseInt(Math.random() * 255)}${parseInt(Math.random() * 255)}`);\n    return color;\n}\n\n\nexport {\n    clearScene3Js,\n    hide3D3Js,\n    drawScene3Js,\n    drawCube3Js,\n    drawPlane3Js,\n    rotatePlaneJs,\n    scalePlane3Js,\n    centrePlan3Js,\n    drawLadder3Js,\n    drawLadderChunk3Js,\n    drawNode3Js,\n    drawBend3Js,\n    drawTee3Js,\n    drawCross3Js,\n    drawSleeve3Js,\n    drawEquipment3Js\n}\n\n\nwindow.Layout3d = {\n    load: (state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference) => {\n        loadScene3d(state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference);\n    },\n    scalePlotPlan: (scaleX, scaleY) => {\n        scalePlotPlan(scaleX, scaleY);\n    },\n    centrePlotPlan: (centreX, centreY, elevation) => {\n        centrePlotPlan(centreX, centreY, elevation);\n    },\n    //drawLadder: (tag, type, jsonPoints, opacity, color, animationText, progress) => { drawLadder(tag, type, jsonPoints, opacity, color, animationText, progress); },\n    //drawBend: (tag, jsonPoints, opacity, color) => { drawBend(tag, jsonPoints, opacity, color); },\n    //drawTee: (tag, jsonPoints, opacity, color) => { drawTee(tag, jsonPoints, opacity, color); },\n    //drawCross: (tag, jsonPoints, opacity, color) => { drawCross(tag, jsonPoints, opacity, color); },\n    drawCable: (tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option) => {\n        drawCable(tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option);\n    },\n\n    //drawNode: (tag, jsonPoint, color) => { drawNode(tag, jsonPoint, color); },\n    //drawSleeve: (tag, radious, jsonPoints, opacity, color) => { drawSleeve(tag, radious, jsonPoints, opacity, color); },\n    drawBoard: (tagName, jsonPoint, v, w, d, h, angle, color, opacity) => {\n        drawBoard(tagName, jsonPoint, v, w, d, h, angle, color, opacity);\n    },\n    equipment: (tag, x1, y1, z1, x2, y2, z2, w, d, h, a, color, opacity, colortext) => {\n        equipment(tag, x1, y1, z1, x2, y2, z2, w, d, h, a, color, opacity, colortext);\n    },\n    saveSceneGLTF: () => {\n        saveSceneGLTF();\n    },\n    removeItem: (tag) => {\n        removeItem(tag);\n    },\n    searchItem: (tag) => {\n        searchItem(tag);\n    },\n    toggleFunction: () => {\n        toggleFunction();\n    },\n    hidePlotPlan: (hidePP) => {\n        hidePlotPlan(hidePP);\n    },\n    orthoView: (ortho, xp, yp, zp) => {\n        orthoView(ortho, xp, yp, zp);\n    },\n\n    clearClickedPoints: () => {\n        clearClickedPoints();\n    },\n    selectObjectHighlight: (tag) => {\n        selectObjectHighlight(tag);\n    },\n    copyText: function (text) {\n        navigator.clipboard.writeText(text).then(function () {\n            alert(text, \" copied to clipboard!\");\n        })\n            .catch(function (error) {\n                alert(error);\n            });\n    }\n\n};\n\n\nvar projectName = \"BlazorNPM\";\n\nvar caller;\nvar clock = new THREE.Clock();\nvar mixer, cameraPerspective, orthoCamera;\nvar xscalefactor = 1.00, yscalefactor = 1.00, lxcentreworld = -110.62, lycentreworld = -72.08; // without scalling to match ladder coordinates\nvar planeMesh, lxmin, lxmax, lymin, lymax, xxmin, xxmax, yymin, yymax; // global variable for plot plan scale\nvar plotElevtn = 0;\n//var rendererWidth = window.innerWidth - 60;\n//var rendererHeight = Math.min(window.innerHeight - 100, rendererWidth * 0.6);\n\nvar selectedObject = [], selectedInputTab, clickCoordinate = [], clickedPointSeq = [];\nvar refPoints = [], refPointTexts = ['X-Left', 'X-Right', 'Y-Bottom', 'Y-Top', 'Centre (0,0)'];\n\nvar mouse = new THREE.Vector2();\nvar pos = new THREE.Vector3();\n\nvar raycaster;\n\n// ***** Clipping planes: *****\n//const localPlane = new THREE.Plane(new THREE.Vector3(0, - 1, 0), 0.8);\n//const xPlane = new THREE.Plane(new THREE.Vector3(- 1, 0, 0), 0.1);\n//const yPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.1);\n//const zPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0.1);\nvar startTime;\n\n// ***** Clipping planes: *****\n\nconst localPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 400);\nconst globalPlane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20);\nconst globalPlane1 = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.1);\nconst localPlane1 = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0.1);\n\n// ***** Clipping setup (renderer): *****\nconst globalPlanes = [globalPlane], Empty = Object.freeze([]);\nconst globalPlanesz = [globalPlane1];\n\n//const xPlanes = [xPlane], Empty = Object.freeze([]);\n//const yPlanes = [yPlane], Empty = Object.freeze([]);\n//const zPlane = [zPlanes], Empty = Object.freeze([]);\n\n\n// ***** Clipping setup (renderer): *****\n//const Empty = Object.freeze([]), xPlanes = [xPlane], yPlanes = [yPlane], zPlanes = [zPlane];\n\n//materials\nvar material = new THREE.MeshPhongMaterial({\n    color: 0x80ee10,\n    shininess: 100,\n    side: THREE.DoubleSide,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar defaultOpacity = 0.9;\nvar defaultColor = 0xc8c8c8;\nvar defaultColorLadder = 0xc80000;\nvar defaultColorEq = 0x7f868a, defaultColorSSFloor = 0x424242;\nvar defaultColorSleeve = 0xc8c8b8;\nvar defaultColorConcrete = 0xc8c898;\nvar defaultColorTrench = 0xc8c878;\nvar defaultColorMCT = 0xc8c838;\nvar substationFloorMaterial = new THREE.MeshStandardMaterial({\n    color: defaultColorSSFloor,\n    transparent: true,\n    opacity: 0.5,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar laddermaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorLadder,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar equipmentmaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorEq,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar sleevematerial = new THREE.MeshPhongMaterial({\n    color: defaultColorSleeve,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar sleeveRadialSegments = 30; // no of radial segments for tubes as sleeves\nvar sleeveTubularSegments = 30; // no of tubular segments for tubes as sleeves\nvar trenchmaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorTrench,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar concretematerial = new THREE.MeshPhongMaterial({\n    color: defaultColorConcrete,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar mctmaterial = new THREE.MeshPhongMaterial({\n    color: defaultColorMCT,\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar pointsMaterial = new THREE.PointsMaterial({color: 0x0080ff, size: 0.02, alphaTest: 0.5});\nvar redRingMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});\nvar yellowRingMaterial = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide});\nvar selectedObjectMaterial = new THREE.MeshPhongMaterial({\n    color: 0xffff00,\n    transparent: true,\n    opacity: 0.8,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar savedObject, savedObjectMaterial; // storing previously selecyed object and its meterials properties\nvar selectItemColor = new THREE.MeshPhongMaterial({\n    color: 'yellow',\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\nvar loader = new FontLoader();\n/*var textMesh, textGeometry;*/\nvar textMaterial = new THREE.MeshStandardMaterial({\n    color: 'brown',\n    transparent: true,\n    opacity: defaultOpacity,\n    side: THREE.DoubleSide,\n    flatShading: true,\n    clippingPlanes: [localPlane],\n    clipShadows: true\n});\n\n\n\nvar linex, liney;\n\n\n\n\n\n\nfunction animate1() {\n    //requestID = requestAnimationFrame(animate);\n    // need to update the orbitcontrols for autorotate camera to take effect\n    //controls.update();\n    requestAnimationFrame(animate);\n    controls.update();\n\n\n    arrowCamera.position.copy(camera.position);\n    arrowCamera.position.sub(controls.target);\n    arrowCamera.position.setLength(300);\n\n    arrowCamera.lookAt(arrowScene.position);\n\n    render();\n}\n\n\n// Function to auto-zoom to fit the scene\nfunction autoZoomToFit() {\n    console.log(\"double click to auto fit\");\n    // Create a Box3 to calculate the bounding box of the scene\n    const box = new THREE.Box3();\n    scene.traverse((object) => {\n        if (object.isMesh) {\n            box.expandByObject(object);\n        }\n    });\n\n    // Get the size and center of the bounding box\n    const size = box.getSize(new THREE.Vector3());\n    const center = box.getCenter(new THREE.Vector3());\n\n    // Set the camera to look at the center\n    controls.target.copy(center);\n    camera.lookAt(center);\n\n    // Calculate the distance the camera needs to be from the scene\n    const maxDim = Math.max(size.x, size.y, size.z);\n    const fov = camera.fov * (Math.PI / 180); // Convert FOV to radians\n    const cameraZ = maxDim / (2 * Math.tan(fov / 2));\n\n    // Adjust camera position\n    camera.position.copy(center);\n    camera.position.z += cameraZ * 1.5; // Add some padding (adjust multiplier as needed)\n\n    // Update the controls\n    controls.update();\n}\n\n\n\n\nfunction render() {\n    var a = clock.getDelta();\n    var delta = clock.getDelta();\n    if (mixer !== undefined) {\n        mixer.update(delta);\n    }\n    //fitCameraToObject(camera, planeMesh, 50);\n\n    if (resizeRendererToDisplaySize(renderer)) {\n        const canvas = renderer.domElement;\n        camera.aspect = canvas.clientWidth / canvas.clientHeight;\n        camera.updateProjectionMatrix();\n    }\n    //console.log('Render:', renderer.info.render.calls);\n    renderer.render(scene, camera);\n}\n\n\n// var docDiv1 = document.getElementById(div1)\n// docDiv1.body.appendChild(stats.dom)\n// function animate() {\n//     stats.begin();\n//     renderer.render(scene, camera);\n//     stats.end();\n//     requestAnimationFrame(animate);\n// }\n\n\n// glf exporter\nfunction saveSceneGLTF() {\n    //https://github.com/mrdoob/three.js/blob/master/examples/misc_exporter_gltf.html#L46\n    const gltfExporter = new GLTFExporter();\n    //\n    var hideObjectTypesForExport = [\"rawladder\", \"ladder\", \"bend\", \"tee\", \"cross\", \"node\", \"sleeve\", \"equipment\"];\n    scene.traverse(child => {\n        if (child instanceof THREE.Mesh) {\n            if (hideObjectTypesForExport.includes(child.type)) {\n                child.visible = false;\n            }\n        }\n    });\n    //\n    const options = {\n        trs: false,\n        onlyVisible: true,\n        binary: false,\n        maxTextureSize: 4096,\n    };\n    gltfExporter.parse(\n        scene,\n        function (result) {\n            if (result instanceof ArrayBuffer) {\n                saveArrayBuffer(result, 'scene.glb');\n            } else {\n                const output = JSON.stringify(result, null, 2);\n                saveString(output, 'scene.gltf');\n            }\n        },\n        function (error) {\n            console.log('An error happened during parsing', error);\n        },\n        options\n    );\n    //\n    scene.traverse(child => {\n        if (child instanceof THREE.Mesh) {\n            child.visible = false;\n        }\n    });\n}\n\nfunction save(blob, filename) {\n    const link = document.createElement('a');\n    link.style.display = 'none';\n    document.body.appendChild(link); // Firefox workaround, see #6594\n    link.href = URL.createObjectURL(blob);\n    link.download = filename;\n    link.click();\n    // URL.revokeObjectURL( url ); breaks Firefox...\n}\n\nfunction saveString(text, filename) {\n    save(new Blob([text], {type: 'text/plain'}), filename);\n}\n\nfunction saveArrayBuffer(buffer, filename) {\n    save(new Blob([buffer], {type: 'application/octet-stream'}), filename);\n}\n\n\nfunction loadScene3d(state, div1, guiDiv, file, scaleX, scaleY, centreX, centreY, elevation, opacity, reference) {\n    console.log(\"State : \", state);\n    //update widow size to server\n    const sceneInfo = JSON.stringify([rendererWidth, rendererHeight, camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]);\n    dotNetObj.invokeMethodAsync(\"SaveSceneInfo\", sceneInfo);\n    \n    //DotNet.invokeMethodAsync(projectName, \"UpdateOnWindowResize\", rendererWidth, rendererHeight);\n    \n\n    dotNetObj = reference;\n    caller = reference;\n    //function draw3d(file, scaleX, scaleY, centreX, centreY) {\n    //var div = 'layoutPage3d'\n    //var div = \"layoutPage3d1\"\n    canvas = document.getElementById(div1);\n\n\n    if (!canvas) {\n        return;\n    }\n\n    if (!arrowScene) {\n        //https://jsfiddle.net/b97zd1a3/16/\n        //var CANVAS_WIDTH = 200;\n        //var CANVAS_HEIGHT = 200;\n        //var arrowRenderer = new THREE.WebGLRenderer({ alpha: true }); // clear\n        //arrowRenderer.setClearColor(0x000000, 0);\n        //arrowRenderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        //var arrowCanvas = document.body.appendChild(arrowRenderer.domElement);\n        //arrowCanvas.setAttribute('id', 'arrowCanvas');\n        //arrowCanvas.style.width = CANVAS_WIDTH;\n        //arrowCanvas.style.height = CANVAS_HEIGHT;\n\n        //var arrowScene = new THREE.Scene();\n\n        //var arrowCamera = new THREE.PerspectiveCamera(50, CANVAS_WIDTH / CANVAS_HEIGHT, 1, 1000);\n        //arrowCamera.up = camera.up; // important!\n\n        //var arrowPos = new THREE.Vector3(0, 0, 0);\n        //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), arrowPos, 60, 0x7F2020, 20, 10));\n        //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), arrowPos, 60, 0x207F20, 20, 10));\n        //arrowScene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), arrowPos, 60, 0x20207F, 20, 10));\n    }\n\n\n    if (!scene) {\n        //create the scene and other initialiasations\n        console.log(\"No scene found XXXXXXXXXXXXXXXXXXXXXX\");\n        scene = new THREE.Scene();\n        scene.background = new THREE.Color(0x000000);\n\n        //renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true, premultipliedAlpha: false});\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(rendererWidth, rendererHeight);\n        renderer.shadowMap.enabled = true; // Enable shadow mapping\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        canvas.appendChild(renderer.domElement);\n\n        renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes\n        renderer.localClippingEnabled = false;\n\n\n        //\n        //https://threejs.org/examples/webgl_clipping.html\n        //// GUI\n        const gui = new GUI({autoPlace: false}),\n            folderLocal = gui.addFolder('Local Clipping'),\n            propsLocal = {\n                get 'Enabled'() {\n                    return renderer.localClippingEnabled;\n                },\n                set 'Enabled'(v) {\n                    renderer.localClippingEnabled = v;\n                },\n                get 'Plane'() {\n                    return localPlane.constant;\n                },\n                set 'Plane'(v) {\n                    localPlane.constant = v;\n                }\n            },\n            folderLocal1 = gui.addFolder('Z-axis Clipping'),\n            propsLocal1 = {\n                get 'Enabled'() {\n                    return renderer.localClippingEnabled;\n                },\n                set 'Enabled'(v) {\n                    renderer.localClippingEnabled = v;\n                },\n                get 'Plane'() {\n                    return localPlane1.constant;\n                },\n                set 'Plane'(v) {\n                    localPlane1.constant = v;\n                }\n            },\n            folderY = gui.addFolder('Y-axis Clipping'),\n            propsY = {\n                get 'Enabled'() {\n                    return renderer.clippingPlanes !== Empty;\n                },\n                set 'Enabled'(v) {\n                    renderer.clippingPlanes = v ? globalPlanes1 : Empty;\n                },\n                get 'Plane'() {\n                    return globalPlane1.constant;\n                },\n                set 'Plane'(v) {\n                    globalPlane1.constant = v;\n                }\n            },\n            folderX = gui.addFolder('X-axis Clipping'),\n            propsX = {\n                get 'Enabled'() {\n                    return renderer.clippingPlanes !== Empty;\n                },\n                set 'Enabled'(v) {\n                    renderer.clippingPlanes = v ? globalPlanes : Empty;\n                },\n                get 'Plane'() {\n                    return globalPlane.constant;\n                },\n                set 'Plane'(v) {\n                    globalPlane.constant = v;\n                }\n            };\n        var customContainer = document.getElementById(div1);\n        //customContainer.appendChild(gui.domElement);\n        gui.domElement.id = 'gui';\n        var guiContainer = document.getElementById(guiDiv);\n        //gui_container.appendChild(gui.domElement);\n        guiContainer.appendChild(gui.domElement);\n\n        // Start\n\n        //startTime = Date.now();\n        folderLocal.open()\n        folderLocal.add(propsLocal, 'Enabled');\n        folderLocal.add(propsLocal, 'Plane', -50, 500);\n        folderLocal1.open()\n        folderLocal1.add(propsLocal1, 'Enabled');\n        folderLocal1.add(propsLocal1, 'Plane', -5, 50);\n        folderX.open()\n        folderX.add(propsX, 'Enabled');\n        folderX.add(propsX, 'Plane', -50, 500);\n        folderY.open()\n        folderY.add(propsY, 'Enabled');\n        folderY.add(propsY, 'Plane', -50, 300);\n\n\n        var frameWidth = canvas.clientWidth;\n        var frameHeight = canvas.clientHeight;\n\n        //camera\n        const fov = 20;\n        var aspectRatio = rendererWidth / rendererHeight;\n        const frustumSize = 1000;\n        const near = 0.001;\n        const far = 4000;\n        cameraPerspective = new THREE.PerspectiveCamera(fov, aspectRatio, near, far);\n        //camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );\n        cameraPerspective.position.set(0, 0, 400);\n        //camera.up = new THREE.Vector3(0,0,1);\n        cameraPerspective.lookAt(scene.position);\n        cameraPerspective.add(new THREE.PointLight(0xffffff, 1));\n\n        camera = cameraPerspective;\n        scene.add(camera);\n\n        orthoCamera = new THREE.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);\n        orthoCamera.add(new THREE.PointLight(0xffffff, 1));\n        // helper\n        //var arrowHelper = new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 400, 0xff0000 );\n        var axis = new THREE.AxesHelper(300);\n        scene.add(axis);\n\n\n\n\n\n        createWheelStopListener(renderer.domElement, function () {\n            doAfterEndScrol();\n        });\n\n\n        raycaster = new THREE.Raycaster();\n\n\n        //-----------------------\n\n        var segments = [];\n        var maxCount = 1000;\n        var count = 0;\n        var thisgroup, segType = \"LV\", opacity = 0.8;\n        var w = .1, t = 0.02, deg = 0;\n        var Option = 'JS';\n        Option = 'CS';\n        var t0 = performance.now();\n\n\n        //window.getElementById(\"randomNumberSpan\").innerText = count;\t\n\n        //var geometry = new THREE.PlaneBufferGeometry(30, 30);\n        //var plane = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide }));\n        //scene.add(plane);\n\n        //light\n        scene.add(new THREE.AmbientLight(0xffffff, 0.9));\n        scene.add(new THREE.HemisphereLight(0xffffff, 0x080820, 1));\n        const pointLight = new THREE.PointLight(0xffffff, 1, 100);\n        pointLight.position.set(rendererWidth / 2, rendererHeight / 2, 100);\n        scene.add(pointLight);\n\n\n        //   renderer = new THREE.WebGLRenderer({ antialias: true });\n        //   renderer.setPixelRatio(window.devicePixelRatio);\n        //renderer.setSize(frameWidth, frameHeight);\n\n        while (canvas.lastElementChild) {\n            canvas.removeChild(canvas.lastElementChild);\n        }\n\n        canvas.appendChild(renderer.domElement);\n\n        controls = new OrbitControls(camera, renderer.domElement);\n        controls.screenSpacePanning = true;\n        controls.minDistance = 5;\n        controls.maxDistance = 10000;\n        //controls.target.set(1, 0, 0);\n        //controls.maxPolarAngle = Math.PI;\n        //controls.enableDamping = true;\n        //controls.dampingFactor = 0.05;\n        //controls.autoRotate = true;\n        //controls.listenToKeyEvents(window); // optional\n        //controls.addEventListener('change', render);\n        controls.update();\n\n\n        // draw mouse position lines (visible while ctrl key is pressed)\n        var linePosition = new THREE.Vector3(10, 10, .1);\n        if (linex == undefined) {\n            // create new position line parallel to x-axis\n            var pointsx = [];\n            pointsx.push(new THREE.Vector3(linePosition.x + 100, linePosition.y, linePosition.z));\n            pointsx.push(new THREE.Vector3(linePosition.x - 100, linePosition.y, linePosition.z));\n            const geometry2 = new THREE.BufferGeometry().setFromPoints(pointsx);\n            const material2 = new THREE.LineBasicMaterial({color: 0xff0000});\n            linex = new THREE.Line(geometry2, material2);\n            linex.name = 'positionlinex';\n            scene.add(linex);\n            linex.visible = false;\n        }\n        if (liney == undefined) {\n            // create new position line parallel to y-axis\n            var pointsy = [];\n            pointsy.push(new THREE.Vector3(linePosition.x, linePosition.y + 100, linePosition.z));\n            pointsy.push(new THREE.Vector3(linePosition.x, linePosition.y - 100, linePosition.z));\n            const geometry1 = new THREE.BufferGeometry().setFromPoints(pointsy);\n            const material1 = new THREE.LineBasicMaterial({color: 0x0000ff});\n            const liney = new THREE.Line(geometry1, material1);\n            liney.name = 'positionliney';\n            scene.add(liney);\n            liney.visible = false;\n        }\n\n    }\n\n    if (file !== null) {\n        loadPlotPlan(file, scaleX, scaleY, centreX, centreY, elevation, opacity);\n    }\n\n    animate();\n\n\n}\n\n\n\n\nfunction fitCameraToObject(camera, object, offset) {\n\n    offset = offset || 1.5;\n\n    const boundingBox = new THREE.Box3();\n\n    boundingBox.setFromObject(object);\n\n    const center = boundingBox.getCenter(new THREE.Vector3());\n    const size = boundingBox.getSize(new THREE.Vector3());\n\n    const startDistance = center.distanceTo(camera.position);\n    // here we must check if the screen is horizontal or vertical, because camera.fov is\n    // based on the vertical direction.\n    const endDistance = camera.aspect > 1 ?\n        ((size.y / 2) + offset) / Math.abs(Math.tan(camera.fov / 2)) :\n        ((size.y / 2) + offset) / Math.abs(Math.tan(camera.fov / 2)) / camera.aspect;\n\n\n    camera.position.set(\n        camera.position.x * endDistance / startDistance,\n        camera.position.y * endDistance / startDistance,\n        camera.position.z * endDistance / startDistance,\n    );\n    camera.lookAt(center);\n\n}\n\n\n\n\nfunction resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n        renderer.setSize(width, height, false);\n    }\n    return needResize;\n}\n\n\nfunction intersectPoint(planeTag) {\n    try {\n        raycaster.setFromCamera(mouse, camera);\n        var intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length !== 0){\n            intersects = intersects.filter(item => item.object.Tag !== undefined && item.object.Tag===planeTag);\n        }\n        if (intersects.length !== 0){            \n            return new THREE.Vector3(\n                Math.round(intersects[0].point.x * 1000) / 1000, \n                Math.round(intersects[0].point.y * 1000) / 1000, \n                Math.round(intersects[0].point.z * 1000) / 1000);\n        }else{\n            return new THREE.Vector3(mouse.x, mouse.y,0);\n        }\n    } catch (e) {\n        console.log(e);\n    }\n    return new THREE.Vector3();\n}\n\nfunction topPlotPlanIntersectPosition(event) {\n    try {\n        raycaster.setFromCamera(mouse, camera);\n        var intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length != 0) {\n            // filter intersect of plotplans\n            intersects = intersects.filter(item => item.object.Tag != undefined && item.object.Tag.includes(\"plotplan\"));\n            // if intersect is plot plan choose the next non plotplan item\n            if (intersects.length > 0) {\n                //console.log(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);\n                return new THREE.Vector3(Math.round(intersects[0].point.x * 1000) / 1000, Math.round(intersects[0].point.y * 1000) / 1000, Math.round(intersects[0].point.z * 1000) / 1000);\n            }\n        }\n    } catch (e) {\n        console.log(e);\n    }\n    return new THREE.Vector3();\n}\n\n\nfunction topObjectIntersectPosition(event) {\n    try {\n        raycaster.setFromCamera(mouse, camera);\n        var intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length != 0) {\n            if (intersects.length > 0) {\n                return new THREE.Vector3(Math.round(intersects[0].point.x * 1000) / 1000, Math.round(intersects[0].point.y * 1000) / 1000, Math.round(intersects[0].point.z * 1000) / 1000);\n            }\n        }\n    } catch (e) {\n        console.log(e);\n    }\n\n}\n\n\nfunction loadPlotPlanNotUsed(userImageFile, scaleX, scaleY, centreX, centreY, elevation, opacity) {\n    //online pdf to png converter: https://pdf2png.com\n    //online image editor: https://www.online-image-editor.com\n    // remove if there is any existing plot\n    //\n\n    if (userImageFile === undefined) {\n        alert(\"Select the plot plan background image.\");\n        light\n        return;\n    }\n    // Create an image\n    const image = new Image(); // or document.createElement('img' );\n    // Set image source\n    image.src = userImageFile;\n    image.onload = function () {\n        texture.needsUpdate = true;\n    };\n\n    var texture = new THREE.Texture(image);\n    var plotPlanOpacity = opacity;\n    var planeMaterial = new THREE.MeshPhongMaterial({\n        map: texture,\n        color: 0xa0a0a0,\n        transparent: true,\n        opacity: plotPlanOpacity,\n        side: THREE.DoubleSide,\n        flatShading: true,\n    });\n\n    // plane geometry\n    var planeGeometry = new THREE.PlaneGeometry(rendererWidth, rendererHeight);\n    planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n    planeMesh.translateOnAxis(new THREE.Vector3(0, 0, 1), elevation);\n    scene.add(planeMesh);\n\n    planeMesh.name = \"plotplan\"; // main background any additional plane to be added to this main background\n    var planeMeshCount = getObjectByNameArray(scene, 'plotplan').length;\n    planeMesh.Tag = \"plotplan\" + planeMeshCount; //toString();\n\n    scalePlotPlan(scaleX, scaleY);\n    centrePlotPlan(centreX, centreY, elevation);\n    shadowRing(0, 0, plotElevtn + 0.01); // to shadow mouse movement when ctrl key is pressed\n\n    renderer.render(scene, camera);\n    return false;\n}\n\nfunction getObjectByNameArray(parentObject, childObjectName) {\n    var match = [];\n    parentObject.traverse(function (child) {\n        if (child.name === childObjectName) {\n            match.push(child);\n        }\n    });\n    return match;\n}\n\nfunction scalePlotPlanNotUsed(scaleX, scaleY) {\n    // scale the plane\n    if (scaleX !== undefined && scaleY !== undefined) {\n        if (scaleX !== 0 && scaleY !== 0) {\n            planeMesh.scale.set(scaleX, scaleY, 1);\n            planeMesh.updateMatrixWorld();\n            scene.getObjectByName('shadowRing');\n            while (scene.getObjectByName('clickedPoints')) {\n                scene.remove(scene.getObjectByName('clickedPoints'));\n            }\n            orthoCamera = new THREE.OrthographicCamera(rendererWidth / -2, rendererWidth / 2, rendererHeight / 2, rendererHeight / -2, 1, 1000);\n            renderer.render(scene, orthoCamera);\n        }\n    }\n\n}\n\nfunction clearRefPoints() {\n    while (scene.getObjectByName('refPoint')) {\n        scene.remove(scene.getObjectByName('refPoint'));\n    }\n    renderer.render(scene, camera);\n    refPoints = [];    \n}\n\n\n\n\n\n\n\nfunction showHideShadowRingNPosinLines() {\n    if (scene.getObjectByName('shadowRing') && scene.getObjectByName('positionlinex') && scene.getObjectByName('positionliney')) {\n        if (ctrlKeyPressed) {\n            scene.getObjectByName('shadowRing').visible = true;\n            scene.getObjectByName('positionlinex').visible = true;\n            scene.getObjectByName('positionliney').visible = true;\n        } else {\n            scene.getObjectByName('shadowRing').visible = false;\n            scene.getObjectByName('positionlinex').visible = false;\n            scene.getObjectByName('positionliney').visible = false;\n        }\n        render();\n    }\n}\n\nfunction shadowRing(x, y, z) {\n\n    var shadowRingMaterial = new THREE.MeshPhongMaterial({color: 0xc3c383, side: THREE.DoubleSide});\n    var shadowRing = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 20), shadowRingMaterial);\n\n    //shadowRing.name = str == \"\" ? 'shadowRing' : str;\n    shadowRing.name = 'shadowRing';\n    shadowRing.position.set(y, x, z + 0.01);\n    //scene.getObjectByName('plotplan').add(shadowRing)\n    scene.add(shadowRing);\n    render();\n}\n\nfunction hideObject() {\n    selectedObject.forEach(el => {\n        el.visible = false;\n    });\n    render();\n}\n\nfunction resetObject() {\n    selectedObject.forEach(el => {\n        el.visible = true;\n        el.material.color = el.OriginalColor;\n    });\n    //clear selectedObject array\n    selectedObject.length = 0;\n    render();\n}\n\n\nfunction commonAction(event) {\n    if (window.event.shiftKey && (window.event.key == 'h' || window.event.key == 'H')) {\n        hideObject();\n    }\n    if (window.event.key === \"Escape\") {\n        resetObject();\n    }\n}\n\nvar mouseWheelStatus = false;\nvar hideObjectTypesOnScrolling = [\"rawladder\", \"ladder\", \"bend\", \"tee\", \"cross\", \"node\", \"sleeve\", \"equipment\"];\nvar raycastObjectTypes = [\"rawladder\", \"ladder\", \"bend\", \"tee\", \"cross\", \"node\", \"sleeve\", \"board\", \"cable\"];\n\nfunction mouseWheel() {\n    if (!mouseWheelStatus) {\n        scene.traverse(child => {\n            if (child instanceof THREE.Mesh) {\n                if (hideObjectTypesOnScrolling.includes(child.type)) {\n                    child.visible = false;\n                }\n            }\n        });\n        //console.log(\"mouseWheel\");\n        mouseWheelStatus = true;\n    }\n}\n\nfunction createWheelStopListener(element, callback, timeout) {\n    var handle = null;\n    var onScroll = function () {\n        if (handle) {\n            clearTimeout(handle);\n        }\n        handle = setTimeout(callback, timeout || 200); // default 200 ms\n    };\n    element.addEventListener('wheel', onScroll);\n    return function () {\n        element.removeEventListener('wheel', onScroll);\n    };\n}\n\nfunction doAfterEndScrol() {\n    if (mouseWheelStatus) {\n        scene.traverse(child => {\n            if (child instanceof THREE.Mesh) {\n                if (hideObjectTypesOnScrolling.includes(child.type)) {\n                    child.visible = true;\n                }\n            }\n        });\n        //console.log(\"scroll end\");\n        mouseWheelStatus = false;\n    }\n}\n\n\n\n//let isClicked = false;\n//function mouseClick() {\n//    console.log('click');\n//    isClicked = true;\n//}\n//function mouseMove(e) {\n//    if (isClicked) {\n//        console.log('clicked and draged')\n//    } else {\n//        console.log('drag');\n//        isClicked = false;\n//    }\n//}\n\n\nfunction raycastNotUsed(event) {\n    // clicked event\n    [mouse, pos] = findCoordinate(event);\n    var linePosition = topPlotPlanIntersectPosition(event);\n    var objectPosition = topObjectIntersectPosition(event);\n    if (linePosition == undefined) {\n        linePosition = new THREE.Vector3();\n    }\n    console.log(\"MouseClick2\", pos.x, pos.y, pos.z, event.clientX, event.clientY,\n        event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY,\n        event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n    //DotNet.invokeMethodAsync(projectName, \"UpdateLayout3DMousePosition\", pos.x, pos.y, pos.z, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n    dotNetObj.invokeMethodAsync(\"MouseClick2\", pos.x, pos.y, pos.z, event.clientX, event.clientY,\n        event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY,\n        event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n\n    if (!event.ctrlKey && !event.shiftKey) {\n        castObject(event)\n    }\n    //\n    try {\n        if (event.ctrlKey && !event.shiftKey) { // if ctrl key is not pressed, the raycast selects a point\n\n            drawRefPoint(planeName);\n            console.log();\n\n            console.log(\"Mouse posion : \"\n                + \"Mouse: [\" + mouse.x + \", \" + mouse.y + \"] \"\n                + \"Position:[\" + pos.x + \",\" + pos.y + \"] \"\n                + \"Client: [\" + event.clientX + \",\" + event.clientY + \"] \"\n                + \"Screen:[\" + event.screenX + \",\" + event.screenY + \"] \"\n                + \"Page:[\" + event.pageX + \",\" + event.pageY + \"] \"\n                + \"Offset:[\" + event.offsetX + \",\" + event.offsetY + \"] \"\n                + \"Layer:[\" + event.layerX + \",\" + event.layerY + \"] \"\n                + \"EvenXY:[\" + event.x + \",\" + event.y + \"] \"\n                + \"LinePosition :[\" + linePosition.x, linePosition.y, linePosition.z + \"] \");\n\n            pos.z = plotElevtn + 0.01; // plotplan elevation as default clicked coordinate elevation, .01 to make visible\n            //\n            var groupredRing = new THREE.Group();\n            var redRingMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});\n            var yellowRingMaterial = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide});\n            var redCircleGeometry = new THREE.CircleGeometry(0.1, 10);\n            var redCircle = new THREE.Mesh(redCircleGeometry, redRingMaterial);\n            groupredRing.add(redCircle);\n            var redRingGeometryIn = new THREE.RingGeometry(0.1, 0.3, 20);\n            var redRingMeshIn = new THREE.Mesh(redRingGeometryIn, yellowRingMaterial);\n            groupredRing.add(redRingMeshIn);\n            var redRingGeometryOut = new THREE.RingGeometry(0.3, 0.35, 20);\n            var redRingMeshOut = new THREE.Mesh(redRingGeometryOut, redRingMaterial);\n            groupredRing.add(redRingMeshOut);\n            //groupredRing.scale(0.5, 0.5, 0.5);\n            clickedPointSeq.push(\"clickedPoint\" + clickedPointSeq.length);\n            groupredRing.name = clickedPointSeq[clickedPointSeq.length - 1];\n            groupredRing.name = 'clickedPoints';\n            groupredRing.position.set(linePosition.x, linePosition.y, linePosition.z);\n            //clickedPointsGroup.add(groupredRing);\n            scene.add(groupredRing);\n            // storing clicked coordinates for adding segment\n            clickCoordinate.push([linePosition.x, linePosition.y, linePosition.z]);\n            //DotNet.invokeMethodAsync(projectName, \"UpdateLayout3DScale\", pos.x, pos.y, event.clientX, event.clientY, event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY, event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n            dotNetObj.invokeMethodAsync(\"MouseClick\", pos.x, pos.y, pos.z, event.clientX, event.clientY,\n                event.pageX, event.pageY, event.offsetX, event.offsetY, event.layerX, event.layerY,\n                event.x, event.y, mouse.x, mouse.y, linePosition.x, linePosition.y, linePosition.z);\n            render();\n        }\n    } catch (e) {\n        console.log(e)\n    }\n    //\n\n}\n\n//\n\nfunction findCoordinate(event) {\n    // calculate mouse position in normalized device coordinates (-1 to +1) for both components\n    var rect = event.target.getBoundingClientRect();\n    var mouse = new THREE.Vector2();\n\n    var x = event.clientX - rect.left; //x position within the element.\n    var y = event.clientY - rect.top;  //y position within the element.\n    mouse.x = (x / rendererWidth) * 2 - 1;\n    mouse.y = -(y / rendererHeight) * 2 + 1;\n    //\n    var vec = new THREE.Vector3(); // create once and reuse\n    var pos = new THREE.Vector3(); // create once and reuse\n    //\n    vec.set(\n        ((event.clientX - rect.left) / rendererWidth) * 2 - 1,\n        -((event.clientY - rect.top) / rendererHeight) * 2 + 1,\n        0);\n    vec.unproject(camera);\n    vec.sub(camera.position).normalize();\n    var distance = -camera.position.z / vec.z;\n    pos.copy(camera.position).add(vec.multiplyScalar(distance));\n    // rounding to two decimal\n    pos.x = Math.round(pos.x * 100) / 100;\n    pos.y = Math.round(pos.y * 100) / 100;\n    return [mouse, pos];\n}\n\n\nwindow.invokeDotnetStaticFunction = window.invokeDotnetStaticFunction || function () {\n    DotNet.invokeMethodAsync('BlazorJSDemoUI', 'CalculateLadderPoints')\n        .then(data => {\n            return data;\n        });\n}\n\n\nwindow.giveMerandomInt = window.giveMerandomInt || function (n) {\n    DotNet.invokeMethodAsync(projectName, 'GenerateRandomInt', n)\n        .then(result => {\n            document.getElementById('randomNumberSpan').innerText = result;\n        });\n}\n\n\n//\n\n\n// window.drawLadder = function (tag, type, jsonPoints, opacity, color) {\n//     let start = Date.now();\n//     if (!canvas) {\n//         return;\n//     }\n//     try {\n//         var clr = JSON.parse(color);\n//         var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n//         var points = JSON.parse(jsonPoints);\n//         var vertices1 = [];\n//         var pushorder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];\n//         pushorder.forEach(i => {\n//             vertices1.push(new THREE.Vector3(points[i].X, points[i].Y, points[i].Z));\n//         });\n//         var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n//\n//         //for wireframe\n//         const wireframe = new THREE.WireframeGeometry(pointsGeometry);\n//         const line = new THREE.LineSegments(wireframe);\n//         line.material.depthTest = false;\n//         line.material.opacity = 0.5;\n//         line.material.transparent = true;\n//         var wireFrameColor = new THREE.Color(0, 0, 1);\n//         line.material.color = setColor;\n//         //scene.add(line);\n//\n//         //for solid display\n//         var material = new THREE.MeshPhongMaterial({\n//             color: setColor,\n//             transparent: true,\n//             opacity: opacity,\n//             side: THREE.DoubleSide,\n//             flatShading: true,\n//             clippingPlanes: [localPlane],\n//             clipShadows: true\n//         });\n//         laddermaterial.color = setColor;\n//         var ladderMesh = new THREE.Mesh(pointsGeometry, material);\n//         ladderMesh.type = type; // \"ladder\" or \"rawladder\"\n//         //mesh.material.color.set(setColor);\n//         //mesh.material.opacity = opacity;\n//         //var cx = (points[1].X + points[6].X) / 2;\n//         //var cy = (points[1].Y + points[6].Y) / 2;\n//         //var cz = (points[1].Z + points[6].Z) / 2;\n//         ladderMesh.Tag = tag;\n//         ladderMesh.Clicked = false;\n//         ladderMesh.OriginalColor = ladderMesh.material.color;\n//         //let box = new THREE.Box3().setFromObject(ladderMesh);\n//         //let sphere = box.getBoundingSphere();\n//         //let centerPoint = box.getCenter();\n//         //let centerPoint = sphere.center;\n//         //ladderMesh.updateMatrixWorld();\n//         //ladderMesh.position.set(cx, cy, cz);\n//         var mesh = ladderMesh;\n//         var center = new THREE.Vector3();\n//         mesh.geometry.computeBoundingBox();\n//         mesh.geometry.boundingBox.getCenter(center);\n//         mesh.geometry.center();\n//         mesh.position.copy(center);\n//         //doAddScene(ladderMesh, animationText, progress, start, drawLadderCallback);\n//         scene.add(ladderMesh);\n//         //render();\n//         pointsGeometry.dispose();\n//     } catch (e) {\n//         console.log(tag + e);\n//     }\n//     //\n//     //if (animationText != \"\") {\n//     //    var progress = parseInt(animationText);\n//     //    DotNet.invokeMethodAsync('WslEncompass', \"SegmentPageUpdateLadderProgress\", progress);\n//     //}\n//     //DotNet.invokeMethodAsync(projectName, \"ItemDrawn\", tag);\n//     return tag;\n// }\nlet requestID;\n\nfunction doAddScene(meshObject, animationText, progress, start, callback) {\n    scene.add(meshObject);\n    let timeTaken = Date.now() - start;\n    console.log(\"Total time taken for \" + meshObject.Tag + \" : \" + timeTaken + \" milliseconds\");\n    callback(animationText, progress);\n}\n\n//function drawLadderCallback(animationText, progress) {\n\n//    if (animationText == \"first\") {\n//        cancelAnimationFrame(requestID);\n//        console.log(\"cancelleing animation\");\n//    } else if (animationText == \"last\") {\n//        animate();\n//        console.log(\"reverting animation\");\n//    } else if (animationText == \"progress\") {\n//        DotNet.invokeMethodAsync('WslEncompass', 'UpdateProgressLayoutComponent', progress);\n//        console.log(\"show progress animation : \" + progress);\n//    };\n//}\n\nwindow.drawBendNotUsed = function (tag, jsonFacePoints, opacity, color) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var faces = JSON.parse(jsonFacePoints);\n    var vertices1 = [];\n    faces.forEach(face => {\n        face.forEach(pt => {\n            vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n        });\n    });\n    try {\n        var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        pointsGeometry.computeBoundingSphere();\n        if (isNaN(pointsGeometry.boundingSphere.radius)) {\n            geometry.boundingSphere.radius = 1; // Set a default value or any suitable value\n        }\n        var material = new THREE.MeshPhongMaterial({\n            color: setColor,\n            transparent: true,\n            opacity: opacity,\n            side: THREE.DoubleSide,\n            flatShading: true,\n            clippingPlanes: [localPlane],\n            clipShadows: true\n        });\n\n        var bendMesh = new THREE.Mesh(pointsGeometry, material);\n\n        bendMesh.Tag = tag;\n        bendMesh.Clicked = false;\n        bendMesh.OriginalColor = bendMesh.material.color;\n        bendMesh.Type = \"bend\";\n\n        var mesh = bendMesh;\n        var center = new THREE.Vector3();\n        mesh.geometry.computeBoundingBox();\n        mesh.geometry.boundingBox.getCenter(center);\n        mesh.geometry.center();\n        mesh.position.copy(center);\n        scene.add(bendMesh);\n        pointsGeometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    //\n    return tag;\n}\n\nwindow.drawTeeNotUsed = function (tag, jsonFacePoints, opacity, color) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var faces = JSON.parse(jsonFacePoints);\n    var vertices1 = [];\n    faces.forEach(face => {\n        face.forEach(pt => {\n            vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n        });\n    });\n    try {\n        var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        var material = new THREE.MeshPhongMaterial({\n            color: setColor,\n            transparent: true,\n            opacity: opacity,\n            side: THREE.DoubleSide,\n            flatShading: true,\n            clippingPlanes: [localPlane],\n            clipShadows: true\n        });\n\n        var teeMesh = new THREE.Mesh(pointsGeometry, material);\n\n        teeMesh.Tag = tag;\n        teeMesh.Clicked = false;\n        teeMesh.OriginalColor = teeMesh.material.color;\n        teeMesh.Type = \"tee\";\n\n        var mesh = teeMesh;\n        var center = new THREE.Vector3();\n        mesh.geometry.computeBoundingBox();\n        mesh.geometry.boundingBox.getCenter(center);\n        mesh.geometry.center();\n        mesh.position.copy(center);\n\n\n        scene.add(teeMesh);\n        pointsGeometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    //\n    //DotNet.invokeMethodAsync(projectName, \"ItemDrawn\", tag);\n    return tag;\n}\n\nwindow.drawCrossNotUsed = function (tag, jsonFacePoints, opacity, color) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var faces = JSON.parse(jsonFacePoints);\n    var vertices1 = [];\n    faces.forEach(face => {\n        face.forEach(pt => {\n            vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n        });\n    });\n    try {\n        var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        var material = new THREE.MeshPhongMaterial({\n            color: setColor,\n            transparent: true,\n            opacity: opacity,\n            side: THREE.DoubleSide,\n            flatShading: true,\n            clippingPlanes: [localPlane],\n            clipShadows: true\n        });\n        var crossMesh = new THREE.Mesh(pointsGeometry, material);\n\n        crossMesh.Tag = tag;\n        crossMesh.Clicked = false;\n        crossMesh.OriginalColor = crossMesh.material.color;\n        crossMesh.Type = \"cross\";\n\n        var mesh = crossMesh;\n        var center = new THREE.Vector3();\n        mesh.geometry.computeBoundingBox();\n        mesh.geometry.boundingBox.getCenter(center);\n        mesh.geometry.center();\n        mesh.position.copy(center);\n\n        scene.add(crossMesh);\n        pointsGeometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    //\n    return tag;\n}\n\n\nwindow.drawSleeveNotUsed = function (tag, radious, jsonPoints, opacity, color) {\n    opacity = 1;\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var rawPoints = JSON.parse(jsonPoints);\n    //const segment = 20;\n    //const radialSegments = 8;\n    const material = new THREE.MeshBasicMaterial({color: 0x00ff00});\n    var points = [];\n    rawPoints.forEach(p => {\n        points.push(new THREE.Vector3(p.X, p.Y, p.Z));\n    });\n    try {\n        var curve = new THREE.CatmullRomCurve3(points);\n        var tubeGeometry = new THREE.TubeGeometry(curve, 20, radious, 8, false);\n        var tube = new THREE.Mesh(tubeGeometry, material);\n        tube.Type = \"sleeve\";\n        tube.Tag = tag;\n        tube.Clicked = false;\n        tube.OriginalColor = tube.material.color;\n        //tube.name = \"CB\" + icable;\n        //cableData[icable][11] = cableData[icable][11] + curve.getLength();//cable total length\n        //cableLaid.add( tube );\n        scene.add(tube);\n    } catch (e) {\n        console.log(tag + e);\n    }\n    var pp = curve.getPoints(20);\n    var pps = [];\n    pp.forEach(p => {\n        pps.push([p.x, p.y, p.z]);\n    });\n    return [tag, pps.toString()];\n}\n\n\nfunction drawCable(tag, jsonPointSetSegments, tubeTubularSegments, dia, tubeRadialSegments, opacity, color, option, percent) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var pointSetSegments = JSON.parse(jsonPointSetSegments);\n    var material = new THREE.MeshPhongMaterial({\n        color: setColor,\n        transparent: true,\n        opacity: opacity,\n        side: THREE.DoubleSide,\n        flatShading: true,\n        clippingPlanes: [localPlane],\n        clipShadows: true\n    });\n    for (let i = 0; i < pointSetSegments.length; i = i + 4) {\n        var ptFrom = new THREE.Vector3(pointSetSegments[i].X, pointSetSegments[i].Y, pointSetSegments[i].Z);\n        var v1 = new THREE.Vector3(pointSetSegments[i + 1].X, pointSetSegments[i + 1].Y, pointSetSegments[i + 1].Z);\n        var v2 = new THREE.Vector3(pointSetSegments[i + 2].X, pointSetSegments[i + 2].Y, pointSetSegments[i + 2].Z);\n        var ptTo = new THREE.Vector3(pointSetSegments[i + 3].X, pointSetSegments[i + 3].Y, pointSetSegments[i + 3].Z);\n        if (v1.x == 0 & v1.y == 0 && v1.z == 0 && v2.x == 0 & v2.y == 0 && v2.z == 0 || option != \"curve\") {\n            // case straight section\n            var curve = new THREE.LineCurve(ptFrom, ptTo);\n        } else {\n            //case bend\n            var curve = new THREE.CubicBezierCurve3(ptFrom, v1, v2, ptTo);\n        }\n        var tubeGeometry = new THREE.TubeGeometry(curve, tubeTubularSegments, dia / 2, tubeRadialSegments, false);\n        var tube = new THREE.Mesh(tubeGeometry, material);\n        //const wireframe = new THREE.WireframeGeometry(tubeGeometry);\n        //const tube = new THREE.LineSegments(wireframe)\n        tube.Tag = tag;\n        tube.Type = \"cable\";\n        scene.add(tube);\n        tubeGeometry.dispose();\n        if (percent == 1) {\n            tube.onAfterRender = function () {\n                console.log(\"last cable drawn\");\n            }\n        }\n    }\n\n\n    // return curve.getLength();//cable total length\n    //\n}\n\nwindow.drawCableFromRoute = function (tag, jsonPoints, tubeTubularSegments, dia, tubeRadialSegments, opacity, color) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var pts = JSON.parse(jsonPoints);\n    if (pts.length == 0) {\n        return;\n    }\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var material = new THREE.MeshPhongMaterial({\n        color: setColor,\n        transparent: true,\n        opacity: opacity,\n        side: THREE.DoubleSide,\n        flatShading: true,\n        clippingPlanes: [localPlane],\n        clipShadows: true\n    });\n\n\n\n    try {\n\n\n        // Create an array of points\n        var points = [];\n        pts.forEach(pt => points.push(new THREE.Vector3(pt.X, pt.Y, pt.Z)));\n\n        // Create a Catmull-Rom curve\n        //var spline = new THREE.Curve3(points);\n\n        // Define the radius of the tube\n        var radius = dia / 2;\n\n        // Define the number of radial segments\n        var radialSegments = tubeTubularSegments;\n\n        //// Define the number of tubular segments\n        //var tubularSegments = tubeTubularSegments;\n\n        //// Set closed to true if you want the tube to be closed\n        //var closed = false;\n\n        //// Create the tube geometry\n        //var geometry = new THREE.TubeGeometry(spline, points.length, radius, radialSegments, closed);\n\n        //// Create a material\n        ////var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n\n        //// Create the tube mesh\n        //var tubeMesh = new THREE.Mesh(geometry, material);\n\n        //// Add the tube to the scene\n        //tubeMesh.Tag = tag;\n        //tubeMesh.type = \"cable\";\n        //scene.add(tubeMesh);\n        //geometry.dispose();\n\n\n        // Create an array to hold vertices and faces\n        var vertices = [];\n        var indices = [];\n\n        // Iterate over each pair of consecutive points\n        for (var i = 0; i < points.length - 1; i++) {\n            var start = points[i];\n            var end = points[i + 1];\n\n            // Compute the direction vector between the points\n            var direction = new THREE.Vector3().subVectors(end, start).normalize();\n\n            // Compute the tangent vector (perpendicular to the direction)\n            var tangent = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 0, 1)).normalize();\n\n            // Compute the binormal vector (perpendicular to both direction and tangent)\n            var binormal = new THREE.Vector3().crossVectors(direction, tangent).normalize();\n\n            // Compute vertices for the pipe section\n            var theta = Math.PI * 2 / radialSegments;\n            for (var j = 0; j <= radialSegments; j++) {\n                var segment = tangent.clone().multiplyScalar(Math.cos(theta * j) * radius)\n                    .add(binormal.clone().multiplyScalar(Math.sin(theta * j) * radius));\n                vertices.push(start.clone().add(segment));\n            }\n        }\n\n        // Generate indices for faces\n        for (var i = 0; i < points.length - 1; i++) {\n            for (var j = 0; j < radialSegments; j++) {\n                var v0 = i * (radialSegments + 1) + j;\n                var v1 = v0 + 1;\n                var v2 = (i + 1) * (radialSegments + 1) + j;\n                var v3 = v2 + 1;\n                indices.push(v0, v1, v2);\n                indices.push(v1, v3, v2);\n            }\n        }\n\n        // Create a geometry\n        var geometry = new THREE.BufferGeometry();\n        geometry.setFromPoints(vertices);\n        geometry.setIndex(indices);\n\n        // Create a material\n        var material = new THREE.MeshBasicMaterial({color: 0xff0000});\n\n        // Create the pipe mesh\n        var pipeMesh = new THREE.Mesh(geometry, material);\n        pipeMesh.Tag = tag;\n        pipeMesh.Type = \"cable\";\n        // Add the pipe to the scene\n        scene.add(pipeMesh);\n\n\n    } catch (e) {\n        console.log(tag + e);\n    }\n\n\n    //\n    return tag;\n}\n\nwindow.drawNodeNotUsed = function (tag, jsonPoint, color) {\n    if (!canvas) {\n        return;\n    }\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var nodePoint = JSON.parse(jsonPoint);\n    const geometry = new THREE.SphereGeometry(0.03, 5, 5); // radious, widthsegment, heightsegments\n    var material = new THREE.MeshPhongMaterial({\n        color: setColor,\n        transparent: true,\n        opacity: 0.5,\n        side: THREE.DoubleSide,\n        flatShading: true,\n        clippingPlanes: [localPlane],\n        clipShadows: true\n    });\n    const sphere = new THREE.Mesh(geometry, material);\n    sphere.position.set(nodePoint.X, nodePoint.Y, nodePoint.Z);\n    //sphere.translate(new THREE.Vector3(nodePoint.X, nodePoint.Y, nodePoint.Z));\n    sphere.Type = \"node\";\n    scene.add(sphere);\n    sphere.Tag = tag;\n    sphere.Clicked = false;\n    sphere.OriginalColor = sphere.material.color;\n    geometry.dispose();\n    //\n    return tag;\n}\n\n\nfunction equipmentNotUsed(tag, x, y, z, w, d, h, a, color, opacity, colortext) {\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    var clrT = JSON.parse(colortext);\n    var textColor = new THREE.Color(clrT[0] / 255, clrT[1] / 255, clrT[2] / 255);\n    var geometry = new THREE.BoxGeometry(w, d, h);  // l along x-axis, w along y axis, d along z axis\n    var material = new THREE.MeshPhongMaterial({\n        color: setColor,\n        transparent: true,\n        opacity: opacity,\n        side: THREE.DoubleSide,\n        flatShading: true,\n        clippingPlanes: [localPlane],\n        clipShadows: true\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    //\n    // Point P -> x1, y1, z1\n    // Point Q -> x2, y2, z2\n    // Vector  PQ' is the projection of vector PQ on x-y plane\n    // vector along the width PW = cross of Z axis vector and PQ'\n    // vector along depth PD = PW cross PQ'\n    //\n    //var tempv1 = new THREE.Vector3(0, 0, 0);\n    //var tempv2 = new THREE.Vector3(0, 0, 0);\n    //var tempv3 = new THREE.Vector3(0, 0, 0);\n    //var tempv4 = new THREE.Vector3(0, 0, 0);\n    //tempv1.set(x2 - x1, y2 - y1, z2 - z1); // pQ\n    //tempv2.set(x2 - x1, y2 - y1, 0); //PQ'\n    //tempv3.set(0, 0, 1); // Z axis\n    //tempv4 = tempv2.clone().cross(tempv3); // PW\n    //cube.rotateOnAxis(tempv3, Math.atan((y2 - y1) / (x2 - x1)));  // rotate cube at x-y plane , own axis and world axis is same\n    //cube.rotateOnWorldAxis(tempv4.normalize(), tempv1.angleTo(tempv2));  // rotate along width world axis\n    //cube.position.x = (x1 + x2) / 2; cube.position.y = (y1 + y2) / 2; cube.position.z = (z1 + z2) / 2; // position\n    //const fontSize = 0.8 * Math.min(1, Math.max(w, d) / tag.length);\n\n    var fontSize = 0.3 * Math.min(w, d, 1);\n    if (tag.length * fontSize > Math.max(w, d)) {\n        fontSize = Math.max(w, d) / tag.length;\n    }\n    const fontHeight = fontSize / 5; // Thickness to extrude text\n    //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }\n    //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }\n    loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {\n\n        // Create the text geometry\n        const textGeometry = new TextGeometry(tag, {\n            font: font,\n            height: fontHeight,\n            size: fontSize,\n            color: '#5C4033'\n            //, curveSegments: 32,\n            //bevelEnabled: true,\n            //bevelThickness: 0.5,\n            //bevelSize: 0.5,\n            //bevelSegments: 8,\n        });\n        // Geometries are attached to meshes so that they get rendered\n        const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n        textMesh.geometry.center();\n        // Update positioning of the text\n        textMesh.position.set(0, 0, h / 2);\n        textMesh.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI * (-1 + w < d ? 1 / 2 : 0));\n        cube.add(textMesh);\n    });\n    cube.rotateOnAxis(new THREE.Vector3(0, 0, 1), a);\n\n    cube.position.set(x, y, z);\n    cube.updateMatrixWorld();\n    cube.OriginalColor = cube.material.color;\n    cube.Tag = tag;\n    cube.Type = \"equipment\";\n    cube.Clicked = false;\n    scene.add(cube);\n    geometry.dispose();\n    //\n}\n\nfunction drawBoard(tagName, jsonPoint, v, w, d, h, angle, color, opacity) {\n    if (!canvas) {\n        return;\n    }\n    //tagName, jsonPoints, v, w, d, h, angle, JsonConvert.SerializeObject(color), opacity\n    var Point = JSON.parse(jsonPoint);\n    var clr = JSON.parse(color);\n    var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n    // text label orientation\n    // label on 'front' means, the text on 'xz' plane along x axis. \n    // label on 'top' means xy plane along y axis\n    var writePlane = 'xz'; // default 'front'\n    var textcolor = 0x1000000 - defaultColorEq // tag label of the equipment with invert colour\n    //draw each vertical\n    for (let i = 0; i < v; i++) {\n        //ith vertical\n        var x = -w / 2 + (i + 1 / 2) * w / v;\n        var y = d / 2;\n        var z = h / 2;\n        var drawEdge = true;\n        var drawMesh = true;\n        // draw each verticals\n        functionVertical(x, y, z, w / v, d, h, defaultColorEq, opacity, drawEdge, drawMesh);\n        // add label for each verticals on front\n        if (v != 1 && writeLabelText) {\n            // writing the label\n            var labelText = 'PNL#' + (i + 1).toString();\n            var textSize = 0.1;\n            // coordinate of the text\n            // text width is assumed as 40% of text height\n            var labelCoordinate = [x - textSize * labelText.length * 0.4, y - d / 2 - 0.001, z];\n            //\n            //writeLabel(labelText, textSize, labelCoordinate, textcolor, groupEq);\n            //\n        }\n    }\n    var writeLabelText = true;\n    //adding tag label of the equipment\n    if (writeLabelText) {\n        var textSize = 0.2;\n        // if switchgears (multiple verticals) write in front, else for pumps, compressors, etc., write on top\n        if (v != 1) { // switchgear\n            var textCoordinate = [-w / 2 + textSize, -0.001, z + h / 2 - 2 * textSize];\n        } else {  // other equipment like pump, etc.\n            writePlane = 'xy';\n            var textCoordinate = [textSize / 2, d / 2 - textSize * tagName.length * 0.4, h + 0.005]\n        }\n        //writeLabel(tagName, textSize, textCoordinate, textcolor);\n    }\n    //\n    // rotating the equipment as per the face direction\n    // and positioning the panel at the required coordinates\n    //tempv1.set(Point.X, Point.Y, Point.Z);\n    //tempv1.sub((tempv2.normalize()).multiplyScalar(d / 2));\n    //groupEq.rotateZ(angle * Math.PI / 180);\n    //groupEq.position.set(tempv1.x, tempv1.y, tempv1.z);\n    //groupEq.lookAt(tempv2); // not used\n    //\n    //cube.Clicked = false;\n    //cube.OriginalColor = cube.material.color;\n    //crossMesh.type = \"board\";\n}\n\n//\n\n// function for Single Vertical Panel\nfunction functionVertical(x, y, z, w, d, h, colr, opec, drawEdge, drawMesh) {\n    // equipment is drawn facing -y axis, i.e., from South\n    var geometry = new THREE.BoxGeometry(w, d, h);\n    // drawing mesh\n    if (drawMesh) {\n        var material = new THREE.MeshPhongMaterial();\n        material.clone(equipmentmaterial);\n        var cube = new THREE.Mesh(geometry, material);\n        cube.position.x = x;\n        cube.position.y = y;\n        cube.position.z = z;\n        cube.material.color.setHex(colr);\n        cube.material.opacity = opec;\n        //scene.add(cube);\n    }\n    //\n    //drawing outerline/edge\n    if (drawEdge) {\n        var edges = new THREE.EdgesGeometry(geometry)\n        var line = new THREE.LineSegments(edges);\n        line.material.depthTest = false;\n        line.material.opacity = 0.1;\n        line.material.transparent = true;\n        line.position.set(x, y, z);\n        var color = new THREE.Color(0x000ff)\n        line.material.color = color;\n        scene.add(line);\n    }\n    geometry.dispose();\n}\n\nfunction searchItem(tag) {\n    var selectedObject = scene.children.filter(child => child.Tag && child.Tag.includes(tag));\n    if (selectedObject[0] != undefined) {\n        for (let i = 0; i < selectedObject.length; i++) {\n            selectedObject[i].material.color = selectItemColor.color;\n        }\n        camera.lookAt(selectedObject[0].position);\n        controls.target = new THREE.Vector3(selectedObject[0].position.x, selectedObject[0].position.y, selectedObject[0].position.z);\n        //controls.minDistance = 5;\n        //controls.maxDistance = 20;\n        //controls.update();\n        //camera.zoom = 100;\n        animate();\n    }\n}\n\n\nfunction hidePlotPlan(hidePP) {\n    //var selectedObject = scene.children.filter(child => child.Tag.includes(\"plotplan\"));\n    scene.children.forEach(child => {\n        if (child != undefined) {\n            if (child.Tag != undefined) {\n                if (child.Tag.includes(\"plotplan\")) {\n                    child.visible = hidePP;\n                }\n            }\n        }\n    });\n    animate();\n}\n\nfunction orthoView(ortho, xp, yp, zp) {\n    //orthographic camera view;\n    //https://stackoverflow.com/questions/48758959/what-is-required-to-convert-threejs-perspective-camera-to-orthographic\n    //https://www.google.ae/search?q=threejs+camera&sca_esv=562123659&tbm=vid&sxsrf=AB5stBih_AvvkPKwAIYnui6TpwA4RL21aA:1693635801552&source=lnms&sa=X&ved=2ahUKEwjtgdKCpYuBAxVhRKQEHQ7fAMwQ_AUoA3oECAEQBQ&biw=1727&bih=1076&dpr=1.5#fpstate=ive&vld=cid:af7537a2,vid:FwcXultcBl4\n    //https://sbcode.net/view_source/section.html\n    //\n    if (ortho == true) {\n        var v3_object = scene.children.filter(child => child.hasOwnProperty('Tag') && child.Tag.includes(\"plotplan\"))[0];\n        if (v3_object == undefined) return;\n        var v3_camera = cameraPerspective.position;\n\n        var line_of_sight = new THREE.Vector3();\n        cameraPerspective.getWorldDirection(line_of_sight);\n        //var v3_object_position = v3_object.position;\n        var v3_object_position = new THREE.Vector3(v3_object.position.x, v3_object.position.y, v3_object.position.z);\n        var v3_distance = v3_object_position.sub(v3_camera);\n        //var v3_distance = (v3_object.clone()).sub(v3_camera);\n        var depth = v3_distance.dot(line_of_sight);\n\n\n        var fov_y = cameraPerspective.fov;\n        var height_ortho = depth * 2 * Math.atan(fov_y * (Math.PI / 180) / 2)\n        //var aspect = width / height;\n        var width_ortho = height_ortho * cameraPerspective.aspect;\n        //var width_ortho = height_ortho * aspect;\n\n        var neworthoCamera = new THREE.OrthographicCamera(\n            width_ortho / -2, width_ortho / 2,\n            height_ortho / 2, height_ortho / -2,\n            cameraPerspective.near, cameraPerspective.far);\n        neworthoCamera.name = 'orthoCamera';\n        neworthoCamera.lookAt(v3_object_position);\n        neworthoCamera.position.set(xp, yp, zp);\n        neworthoCamera.updateProjectionMatrix();\n        //neworthoCamera.quaternion.copy(cameraPerspective.quaternion);\n        camera = neworthoCamera;\n    } else {\n        camera = cameraPerspective;\n        scene.remove(scene.getObjectByName('orthoCamera'));\n        renderer.render(scene, camera);\n    }\n    //animate(); // animate includes render\n    renderer.render(scene, camera);\n}\n\nfunction removeItem(tag) {\n    var selectedObject = scene.children.filter(child => child.Tag == tag);\n    if (selectedObject != undefined) {\n        scene.remove(selectedObject);\n        animate();\n    }\n}\n\nfunction writeLabel(labelText, textSize, labelCoordinate, textcolor) {\n    // write label facing -y axis at the given coordinate\n    const loader = new FontLoader();\n    //loader.load('..fonts/helvetiker_regular.typeface.json', function (font) {\n    //    //helvetiker_regular\n    //    //gentilis_regular.typeface\n    //    //const color = 0xffff00;\n    //    const textMaterial = new THREE.MeshBasicMaterial({\n    //        color: textcolor,\n    //        transparent: true,\n    //        opacity: 0.9,\n    //        side: THREE.DoubleSide\n    //    });\n    //    const shapes = font.generateShapes(labelText, textSize);\n    //    const textGeometry = new THREE.ShapeBufferGeometry(shapes);\n    //    const text = new THREE.Mesh(textGeometry, textMaterial);\n    //    text.position.set(labelCoordinate[0], labelCoordinate[1], labelCoordinate[2]);\n    //    scene.add(text);\n    //    textGeometry.dispose();\n    //    render();\n    //});\n}\n\n\nfunction castObject(event) {\n    // select an object by clicking it \n    // if ctrl key is not pressed, the raycast selects or deselects the object (cable, ladeder, etc.)\n    // find intersections\n    //2. set the picking ray from the camera position and mouse coordinates\n\n    try {\n        raycaster.setFromCamera(mouse, camera);\n        //\n        //3. compute intersections (no 2nd parameter true anymore)\n        var intersects = raycaster.intersectObjects(scene.children);\n        // remove hidden items from intersects if raycasted: not required as its covered in below while loop\n        //var intersects = intersectstemp.filter(function (val) {\n        //        return selectedObject.indexOf(val) == -1;\n        //    });\n        if (intersects.length == 0) return;\n        if (!(intersects[0].object.Tag == undefined)) {\n            var intersectItemIndex = 0;\n            // if intersect is plot plan choose the next non plotplan item\n            intersects = intersects.filter(item => !(item.object.Tag.includes(\"plotplan\")));\n            if (intersects.length == 0) return; // no object other than plotplan\n            while (intersects[intersectItemIndex].object.visible == false\n            && intersectItemIndex < intersects.length) {\n                intersectItemIndex++;\n            }\n            var castObjectTags = [];\n            var castObjectUIDs = [];\n            if (intersects.length > 0) {\n                controls.target = new THREE.Vector3(intersects[0].object.position.x, intersects[0].object.position.y, intersects[0].object.position.z);\n                if (selectedObject.includes(intersects[intersectItemIndex].object)) {\n                    var indx = selectedObject.indexOf(intersects[intersectItemIndex].object);\n                    selectedObject.splice(indx, 1);\n                } else {\n                    selectedObject.push(intersects[intersectItemIndex].object);\n                }\n                intersects.forEach(el => {\n                    if (el.object.Tag != undefined) {\n                        castObjectTags.push(el.object.Tag);\n                        castObjectUIDs.push(el.object.UID == undefined ? newGuid() : el.object.UID);\n                    }\n                });\n                if (intersects[intersectItemIndex].object.Clicked) {\n                    intersects[intersectItemIndex].object.material.color = intersects[intersectItemIndex].object.OriginalColor;\n\n                } else {\n                    intersects[intersectItemIndex].object.material.color = selectItemColor.color;\n                }\n                intersects[intersectItemIndex].object.Clicked = !intersects[intersectItemIndex].object.Clicked;\n                //\n                var castObjects = intersects.filter(item => item.object.visible == true);\n                var castObjectHidden = intersects[0];\n                var casObjectTag = \"\";\n                //\n                var x = 0, y = 0, z = 0, xh = castObjectHidden.object.position.x,\n                    yh = castObjectHidden.object.position.y, zh = castObjectHidden.object.position.z;\n                if (castObjects.length > 0) {\n                    casObjectTag = castObjects[0].object.Tag;\n                    x = castObjects[0].object.position.x;\n                    y = castObjects[0].object.position.y;\n                    z = castObjects[0].object.position.z;\n                }\n                DotNet.invokeMethodAsync(projectName, \"UpdateCastObject\", JSON.stringify(castObjectUIDs), JSON.stringify(castObjectTags), casObjectTag, x, y, z, castObjectHidden.object.Tag, xh, yh, zh);\n            }\n        }\n    } catch (e) {\n        console.log(e)\n    }\n}\n\n\nwindow.selectObjectHighlight = (tag) => {\n    var selectObject = scene.children.filter(child => child.Tag == tag);\n    var returnColour = selectObject.mesh.color;\n    return returnColour;\n}\n\nfunction toggleFunction() {\n    var toggle = document.getElementById(\"layoutPage3dSegment\");\n    if (toggle.style.display === \"none\") {\n        toggle.style.display = \"block\";\n    } else {\n        toggle.style.display = \"none\";\n    }\n}\n\nfunction newGuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,\n        function (c) {\n            var uuid = Math.random() * 16 | 0, v = c == 'x' ? uuid : (uuid & 0x3 | 0x8);\n            return uuid.toString(16);\n        });\n}","import * as THREE from 'three';\n\nfunction drawBendMesh(tag, jsonFacePoints, material, color, opacity) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        var faces = JSON.parse(jsonFacePoints);\n        var vertices1 = [];\n        faces.forEach(face => {\n            face.forEach(pt => {\n                vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n            });\n        });\n        if (jsonFacePoints.includes(\"NaN\")) {\n            console.log(\"NanN :\", tag, jsonFacePoints);\n        }\n        var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        pointsGeometry.computeBoundingSphere();\n        if (isNaN(pointsGeometry.boundingSphere.radius)) {\n            geometry.boundingSphere.radius = 1; // Set a default value or any suitable value\n        }\n        var bendMesh = new THREE.Mesh(pointsGeometry, material);\n\n        bendMesh.Tag = tag;\n        bendMesh.Type = \"bend\";\n        bendMesh.Clicked = false;\n        bendMesh.OriginalColor = bendMesh.material.color;\n        bendMesh.material.opacity = opacity;\n\n        var center = new THREE.Vector3();\n        bendMesh.geometry.computeBoundingBox();\n        bendMesh.geometry.boundingBox.getCenter(center);\n        bendMesh.geometry.center();\n        bendMesh.position.copy(center);\n\n        pointsGeometry.dispose();\n\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return bendMesh;\n}\n\nexport {drawBendMesh}","import * as THREE from 'three';\n\nfunction drawCrossMesh(tag, jsonFacePoints, material, color, opacity) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        var faces = JSON.parse(jsonFacePoints);\n        var vertices1 = [];\n        faces.forEach(face => {\n            face.forEach(pt => {\n                vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n            });\n        });\n        var geometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        var crossMesh = new THREE.Mesh(geometry, material);\n\n        crossMesh.Tag = tag;\n        crossMesh.Type = \"cross\";\n        crossMesh.Clicked = false;\n        crossMesh.OriginalColor = crossMesh.material.color;\n        crossMesh.material.opacity = opacity;\n\n        var center = new THREE.Vector3();\n        crossMesh.geometry.computeBoundingBox();\n        crossMesh.geometry.boundingBox.getCenter(center);\n        crossMesh.geometry.center();\n        crossMesh.position.copy(center);\n\n        geometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return crossMesh;\n}\n\nexport {drawCrossMesh}","import * as THREE from 'three';\n\nexport default function drawEquipmentMesh(tag, x, y, z, w, d, h, a, material, color, opacity, colortext) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        var clrT = JSON.parse(colortext);\n        var textColor = new THREE.Color(clrT[0] / 255, clrT[1] / 255, clrT[2] / 255);\n\n        var geometry = new THREE.BoxGeometry(w, d, h);  // l along x-axis, w along y axis, d along z axis\n        var equipmentMesh = new THREE.Mesh(geometry, material);\n        //\n        var fontSize = 0.3 * Math.min(w, d, 1);\n        if (tag.length * fontSize > Math.max(w, d)) {\n            fontSize = Math.max(w, d) / tag.length;\n        }\n        const fontHeight = fontSize / 5; // Thickness to extrude text\n        //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }\n        //if (fontHeight > 0.3 * Math.min(w, d, 1)) { fontHeight = 0.3 * Math.min(w, d, 1); fontSize = 4 * fontHeight; }\n        loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {\n\n            // Create the text geometry\n            const textGeometry = new TextGeometry(tag, {\n                font: font,\n                height: fontHeight,\n                size: fontSize,\n                color: '#5C4033'\n                //, curveSegments: 32,\n                //bevelEnabled: true,\n                //bevelThickness: 0.5,\n                //bevelSize: 0.5,\n                //bevelSegments: 8,\n            });\n            // Geometries are attached to meshes so that they get rendered\n            const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n            textMesh.geometry.center();\n            // Update positioning of the text\n            textMesh.position.set(0, 0, h / 2);\n            textMesh.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI * (-1 + w < d ? 1 / 2 : 0));\n            equipmentMesh.add(textMesh);\n        });\n        equipmentMesh.rotateOnAxis(new THREE.Vector3(0, 0, 1), a);\n\n        equipmentMesh.position.set(x, y, z);\n        equipmentMesh.updateMatrixWorld();\n\n        equipmentMesh.Tag = tag;\n        equipmentMesh.Type = \"equipment\";\n        equipmentMesh.Clicked = false;\n        equipmentMesh.OriginalColor = equipmentMesh.material.color;\n        equipmentMesh.material.opacity = opacity;\n\n        geometry.dispose();\n        //\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return equipmentMesh;\n}\n\nexport {drawEquipmentMesh}","import * as THREE from 'three';\n\n\nfunction drawLadderMesh(tag, jsonPoints, material, color, opacity) {\n    try {\n        // Parse color only once and handle potential errors\n        let clr;\n        try {\n            clr = JSON.parse(color);\n        } catch (colorParseError) {\n            console.error(`Error parsing color for tag ${tag}: ${colorParseError}`);\n            return null; // Exit if color parsing fails\n        }\n\n        const setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        // Parse points only once and handle errors\n        let points;\n        try {\n            points = JSON.parse(jsonPoints);\n        } catch (pointsParseError) {\n            console.error(`Error parsing points for tag ${tag}: ${pointsParseError}`);\n            return null; // Exit if points parsing fails\n        }\n\n        const vertices1 = [];\n        const pushOrder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];\n\n        // Pre-allocate array for better performance\n        vertices1.length = pushOrder.length;\n\n        // Use a for loop for better performance than forEach\n        for (let i = 0; i < pushOrder.length; i++) {\n            const pointIndex = pushOrder[i];\n            vertices1[i] = new THREE.Vector3(points[pointIndex].X, points[pointIndex].Y, points[pointIndex].Z);\n        }\n\n        const pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1);\n\n        const ladderMesh = new THREE.Mesh(pointsGeometry, material);\n\n        ladderMesh.Tag = tag;\n        ladderMesh.Type = \"ladder\";\n        ladderMesh.Clicked = false;\n        ladderMesh.OriginalColor = ladderMesh.material.color.clone(); // Clone the color\n\n        const center = new THREE.Vector3();\n        pointsGeometry.computeBoundingBox();\n        pointsGeometry.boundingBox.getCenter(center);\n        ladderMesh.geometry.center();\n        ladderMesh.position.copy(center);\n        ladderMesh.material.opacity = opacity;\n\n        // Dispose of geometry after use\n        //pointsGeometry.dispose(); // Moved to be handled outside of this function.\n\n        return ladderMesh;\n    } catch (e) {\n        console.error(`${tag} - Unexpected error: ${e}`);\n        return null;\n    }\n}\n\n\nfunction drawLadderMeshBatch(tags, jsonPointsArray, material, colors, opacities) {\n    console.log(\"Step 4: Drawing from ladder.js : drawLadderMeshBatch for \" + tags.length +\n        \" trays with \" + jsonPointsArray.length)\n    // Validate inputs\n    if (!Array.isArray(jsonPointsArray) || !Array.isArray(tags) || !Array.isArray(colors) || !Array.isArray(opacities)) {\n        console.error('Invalid input arrays:', {tags, jsonPointsArray, colors, opacities});\n        return null;\n    }\n    if (jsonPointsArray.length !== tags.length || jsonPointsArray.length !== colors.length || jsonPointsArray.length !== opacities.length) {\n        console.error('Array lengths mismatch:', {\n            tags: tags.length,\n            points: jsonPointsArray.length,\n            colors: colors.length,\n            opacities: opacities.length\n        });\n        return null;\n    }\n\n    const geometry = new THREE.BufferGeometry();\n    const vertices = [];\n    const pushOrder = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6];\n\n    // Parse and validate points\n    const points = [];\n    for (let i = 0; i < jsonPointsArray.length; i++) {\n        try {\n            const parsed = JSON.parse(jsonPointsArray[i]);\n            if (!Array.isArray(parsed) || parsed.length < 8) {\n                console.error(`Tray ${i} : Invalid points array for tag ${tags[i]}: Expected at least 8 vertices, got`, parsed);\n                continue;\n            }\n            if (!parsed.every(p => p && typeof p.X === 'number' && typeof p.Y === 'number' && typeof p.Z === 'number')) {\n                console.error(`Tray ${i} : Invalid point structure for tag ${tags[i]}: Missing or invalid X, Y, Z`, parsed);\n                continue;\n            }\n            points.push(parsed);\n        } catch (e) {\n            console.error(`Tray ${i} : Error parsing JSON for tag ${tags[i]}:`, e);\n        }\n    }\n\n    if (points.length === 0) {\n        console.error('No valid points to render');\n        return null;\n    }\n\n    // Create vertices for valid ladders\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < pushOrder.length; j++) {\n            const idx = pushOrder[j];\n            vertices.push(points[i][idx].X, points[i][idx].Y, points[i][idx].Z);\n        }\n    }\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    // Material cache\n    const materialCache = {};\n\n    function getMaterial(color, opacity) {\n        const key = `${color}_${opacity}`;\n        if (!materialCache[key]) {\n            let colorArray;\n            try {\n                // Handle case where color is a JSON string\n                if (typeof color === 'string') {\n                    colorArray = JSON.parse(color);\n                } else if (Array.isArray(color)) {\n                    // Handle case where color is already an array\n                    colorArray = color;\n                } else {\n                    throw new Error('Tray ' + i + ' : Invalid color format');\n                }\n                // Validate color array\n                if (!Array.isArray(colorArray) || colorArray.length !== 3 || !colorArray.every(c => typeof c === 'number' && c >= 0 && c <= 255)) {\n                    throw new Error('Tray ' + i + ' : Invalid color array');\n                }\n                materialCache[key] = new THREE.MeshBasicMaterial({\n                    color: new THREE.Color(...colorArray.map(c => c / 255)),\n                    opacity,\n                    transparent: true\n                });\n            } catch (e) {\n                console.error(`Error processing color for key ${key}:`, e, 'Color value:', color);\n                // Fallback to default color (white)\n                materialCache[key] = new THREE.MeshBasicMaterial({\n                    color: 0xffffff,\n                    opacity,\n                    transparent: true\n                });\n            }\n        }\n        return materialCache[key];\n    }\n\n    const count = points.length;\n    const instancedMesh = new THREE.InstancedMesh(geometry, getMaterial(colors[0], opacities[0]), count);\n\n    // Store tags for valid ladders only\n    instancedMesh.instanceTags = points.map((_, i) => tags[i]);\n    instancedMesh.Type = \"ladder\";\n    instancedMesh.castShadow = true; // Cast shadows\n    instancedMesh.receiveShadow = true; // Receive shadows (optional, for ladders shadowing each other)\n\n    // Set instance matrices and colors\n    for (let i = 0; i < count; i++) {\n        const matrix = new THREE.Matrix4();\n        const center = new THREE.Vector3();\n        const tempGeometry = new THREE.BufferGeometry().setFromPoints(\n            pushOrder.map(idx => new THREE.Vector3(points[i][idx].X, points[i][idx].Y, points[i][idx].Z))\n        );\n        tempGeometry.computeBoundingBox();\n        tempGeometry.boundingBox.getCenter(center);\n        matrix.setPosition(center);\n        instancedMesh.setMatrixAt(i, matrix);\n        try {\n            let colorArray;\n            if (typeof colors[i] === 'string') {\n                colorArray = JSON.parse(colors[i]);\n            } else if (Array.isArray(colors[i])) {\n                colorArray = colors[i];\n            } else {\n                throw new Error('Tray ' + i + ' : Invalid color format');\n            }\n            if (!Array.isArray(colorArray) || colorArray.length !== 3 || !colorArray.every(c => typeof c === 'number' && c >= 0 && c <= 255)) {\n                throw new Error('Tray ' + i + ' : Invalid color array');\n            }\n            instancedMesh.setColorAt(i, new THREE.Color(...colorArray.map(c => c / 255)));\n        } catch (e) {\n            console.error(`Tray ${i} : Error setting color for tag ${tags[i]}:`, e, 'Color value:', colors[i]);\n            instancedMesh.setColorAt(i, new THREE.Color(1, 11));\n        }\n        tempGeometry.dispose();\n    }\n\n    instancedMesh.instanceMatrix.needsUpdate = true;\n    instancedMesh.instanceColor.needsUpdate = true;\n\n    return instancedMesh;\n}\n\nexport {drawLadderMesh, drawLadderMeshBatch}","import * as THREE from 'three';\n\nfunction drawNodeMesh(tag, jsonPoint, material, color, opacity) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        var nodePoint = JSON.parse(jsonPoint);\n        const geometry = new THREE.SphereGeometry(0.03, 5, 5); // radious, widthsegment, heightsegments\n        const sphereMesh = new THREE.Mesh(geometry, material);\n        sphereMesh.position.set(nodePoint.X, nodePoint.Y, nodePoint.Z);\n\n        sphereMesh.Tag = tag;\n        sphereMesh.Type = \"node\";\n        sphereMesh.Clicked = false;\n        sphereMesh.OriginalColor = sphereMesh.material.color;\n        sphereMesh.material.opacity = opacity;\n\n        geometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return sphereMesh;\n}\n\nexport {drawNodeMesh}","import * as THREE from 'three';\n\nfunction drawPlaneMesh(rendererWidth, rendererHeight, planeName, planeTag,\n                       imageString, scaleX, scaleY, centreX, centreY, elevation, opacity) {\n    try {\n        // Create an image\n        const image = new Image(); // or document.createElement('img' );\n        // Set image source\n        image.src = imageString;\n        //console.log(\"Step 4: Drawing planeMesh plane.js\", planeName, planeTag)\n        var texture = new THREE.Texture(image);\n        var planeMaterial = new THREE.MeshPhongMaterial({\n            map: texture,\n            color: 0xffffff,\n            transparent: true,\n            opacity: opacity,\n            side: THREE.DoubleSide,\n            flatShading: true\n        });\n        image.onload = function () {\n            texture.needsUpdate = true;\n        };\n        //\n        // plane geometry\n        var planeGeometry = new THREE.PlaneGeometry(rendererWidth, rendererHeight);\n        var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n        planeMesh.translateOnAxis(new THREE.Vector3(0, 0, 1), elevation);\n        planeMesh.Name = planeName;// \"plotplan\"; // main background any additional plane to be added to this main background\n        //var planeMeshCount = getObjectByNameArray(scene, 'plotplan').length;\n        planeMesh.Tag = planeTag;// \"plotplan\" + planeMeshCount; //toString();\n        planeMesh.Type = 'plotplan';\n        planeMesh.material.opacity = opacity;\n        // scale the plane\n        if (scaleX !== undefined && scaleY !== undefined) {\n            if (scaleX !== 0 && scaleY !== 0) {\n                planeMesh.scale.set(scaleX, scaleY, 1);\n                planeMesh.updateMatrixWorld();\n            }\n        }\n        //\n        // align to centre\n        if (centreX !== undefined && centreY !== undefined) {\n            planeMesh.position.set(-centreX, -centreY, elevation);\n            planeMesh.updateMatrixWorld();\n        }\n        //\n    } catch (e) {\n        console.log(planeTag + e);\n    }\n    return planeMesh;\n}\n\nexport {drawPlaneMesh}","\nimport * as THREE from 'three';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\nimport fontData from '../fonts/helvetiker_regular.typeface.json';\nimport {FontLoader} from \"three/examples/jsm/loaders/FontLoader\";\n\nfunction drawRefPointMesh(tag, point, opacity) {\n    let refPoint;\n    try {\n        refPoint = new THREE.Group();\n\n        // Create materials with transparency and opacity\n        const redRingMaterial = new THREE.MeshBasicMaterial({\n            color: 0xff0000,\n            side: THREE.DoubleSide,\n            transparent: false,\n            opacity: opacity\n        });\n        const yellowRingMaterial = new THREE.MeshBasicMaterial({\n            color: 0xffff00,\n            side: THREE.DoubleSide,\n            transparent: false,\n            opacity: opacity\n        });\n\n        const textMaterial = new THREE.MeshStandardMaterial({\n            color: 0xffff00,\n            transparent: false,\n            opacity: 1,\n            side: THREE.DoubleSide,\n\n        });\n\n        // Create geometries and meshes for circle and rings\n        const redCircleGeometry = new THREE.CircleGeometry(0.1, 10);\n        const redCircle = new THREE.Mesh(redCircleGeometry, redRingMaterial);\n        refPoint.add(redCircle);\n\n        const redRingGeometryIn = new THREE.RingGeometry(0.1, 0.3, 20);\n        const redRingMeshIn = new THREE.Mesh(redRingGeometryIn, yellowRingMaterial);\n        refPoint.add(redRingMeshIn);\n\n        const redRingGeometryOut = new THREE.RingGeometry(0.3, 0.35, 20);\n        const redRingMeshOut = new THREE.Mesh(redRingGeometryOut, redRingMaterial);\n        refPoint.add(redRingMeshOut);\n\n        // Load font and create text mesh\n        const fontSize = .3;\n        const fontHeight = fontSize / 5; // Thickness to extrude text\n        const loader = new FontLoader();\n         loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {\n\n             // Create the text geometry\n             const textGeometry = new TextGeometry(tag, {\n                 font: font,\n                 depth: fontHeight,\n                 size: fontSize,\n                 color: '#0000ff',\n                 //, curveSegments: 32,\n                 bevelEnabled: false,\n                 //bevelThickness: 0.5,\n                 //bevelSize: 0.5,\n                 //bevelSegments: 8,\n             });\n             // Geometries are attached to meshes so that they get rendered\n             const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n             textMesh.geometry.center();\n             // Update positioning of the text\n             textMesh.position.set( .5,  .5, 0);\n             refPoint.add(textMesh);\n         });\n   \n        // Set group position\n        refPoint.position.set(point.x, point.y, point.z);\n\n        // Set custom properties\n        refPoint.Tag = tag;\n        refPoint.Type = \"refPoint\";\n        refPoint.Clicked = false;\n        refPoint.name = 'refPoint';\n\n        // Dispose geometries\n        redCircleGeometry.dispose();\n        redRingGeometryIn.dispose();\n        redRingGeometryOut.dispose();\n\n    } catch (e) {\n        console.log(tag + ' Error: ' + e);\n    }\n    return refPoint;\n}\n\nexport { drawRefPointMesh };","import * as THREE from 'three';\n\nfunction drawSleeveMesh(tag, jsonPoints, radious, segment, radialSegments, material, color, opacity) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        // var rawPoints = JSON.parse(jsonPoints);\n        // var points = [];\n        // rawPoints.forEach(p => {\n        //     points.push(new THREE.Vector3(p.X, p.Y, p.Z));\n        // });\n        //\n        // //var pp = curve.getPoints(segment);\n        // var pps = [];\n        // points.forEach(p => { pps.push([p.x, p.y, p.z]); });\n        //\n        // var geometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        // var curve = new THREE.CatmullRomCurve3(points);\n        // var tubeGeometry = new THREE.TubeBufferGeometry(curve, segment, radious, radialSegments, false);\n        // var tubeMesh = new THREE.Mesh(tubeGeometry, material);\n\n\n        // Parse and create points\n        var rawPoints = JSON.parse(jsonPoints);\n        var points = rawPoints.map(p => new THREE.Vector3(p.X, p.Y, p.Z));\n\n        // Create curve from points\n        var curve = new THREE.CatmullRomCurve3(points);\n\n        // Create tube geometry\n        var tubeGeometry = new THREE.TubeGeometry(curve, segment, radious, radialSegments, false);\n\n        // Create mesh\n        var tubeMesh = new THREE.Mesh(tubeGeometry, material);\n\n        tubeMesh.Tag = tag;\n        tubeMesh.Type = \"sleeve\";\n        tubeMesh.Clicked = false;\n        tubeMesh.OriginalColor = color;\n        tubeMesh.material.opacity = opacity;\n        //console.log(\"drawing sleeve sleeve.js tubeJeometry done for \", tag);\n        tubeGeometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return tubeMesh;\n}\n\nexport {drawSleeveMesh}","import * as THREE from 'three';\n\nfunction drawTeeMesh(tag, jsonFacePoints, material, color, opacity) {\n    try {\n        var clr = JSON.parse(color);\n        var setColor = new THREE.Color(clr[0] / 255, clr[1] / 255, clr[2] / 255);\n        material.color = setColor;\n\n        var faces = JSON.parse(jsonFacePoints);\n        var vertices1 = [];\n        faces.forEach(face => {\n            face.forEach(pt => {\n                vertices1.push(new THREE.Vector3(pt.X, pt.Y, pt.Z));\n            });\n        });\n\n        var pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices1, 3);\n        var teeMesh = new THREE.Mesh(pointsGeometry, material);\n\n        teeMesh.Tag = tag;\n        teeMesh.Type = \"tee\";\n        teeMesh.Clicked = false;\n        teeMesh.OriginalColor = teeMesh.material.color;\n        teeMesh.material.opacity = opacity;\n\n        var center = new THREE.Vector3();\n        teeMesh.geometry.computeBoundingBox();\n        teeMesh.geometry.boundingBox.getCenter(center);\n        teeMesh.geometry.center();\n        teeMesh.position.copy(center);\n\n        pointsGeometry.dispose();\n    } catch (e) {\n        console.log(tag + e);\n    }\n    return teeMesh;\n}\n\nexport {drawTeeMesh}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//// Module Manager for registering the modules of the chart\n//import { ModuleManager } from 'igniteui-webcomponents-core';\n//// Radial Gauge Module\n//import { IgcRadialGaugeModule } from 'igniteui-webcomponents-gauges';\n\n\n//// register the modules\n//ModuleManager.register(\n//    IgcRadialGaugeModule\n//);\n\nimport 'bootstrap';\nimport {\n    drawScene3Js,\n    drawPlane3Js,\n    rotatePlaneJs,\n    scalePlane3Js,\n    centrePlan3Js,\n    drawBend3Js,\n    drawCross3Js,\n    drawCube3Js,\n    drawEquipment3Js,\n    drawLadder3Js,\n    drawLadderChunk3Js,\n    drawNode3Js,\n    drawSleeve3Js,\n    drawTee3Js,\n    hide3D3Js,\n} from './myThree'\nimport {drawSLD, updateSLD, updateSLDItem, updateSLDWithStudyResults} from './mySLD'\nimport {\n    focusElement,\n    //getModalDialogElement,\n    getModalDialogRect,\n    setModalPosition,\n    //setupDraggableModal,\n    startModalDrag,\n    stopModalDrag\n} from '../src/modal/modal-interop';\n\n\nwindow.consoleLog = function (logString) {\n    console.log(logString);\n}\n\n\n//drawBend, drawTee, drawCross, drawCable\nwindow.drawScene = function (divId, sceneJSON = \"\", dotNetObjRef) {\n    drawScene3Js(divId, sceneJSON, dotNetObjRef);\n}\nwindow.drawCube = drawCube3Js\nwindow.hide3D = hide3D3Js\nwindow.clearScene = function () {\n    clearScene();\n}\n\nwindow.drawPlane = drawPlane3Js;\nwindow.rotatePlane = rotatePlaneJs;\nwindow.scalePlane = scalePlane3Js;\nwindow.centrePlane = centrePlan3Js;\n\n\n\n\nwindow.updateValue = function (value) {\n    var rg = document.getElementById(\"rg\");\n    rg.value = value;\n}\n\nwindow.drawLadder = drawLadder3Js\nwindow.drawLadderChunk = drawLadderChunk3Js\n\nwindow.drawBend = drawBend3Js\nwindow.drawTee = drawTee3Js\nwindow.drawCross = drawCross3Js\nwindow.drawNode = drawNode3Js\nwindow.drawSleeveZ = drawSleeve3Js\nwindow.drawEquipment = drawEquipment3Js\n\nvar dotNetObj;\nwindow.initialiseObjectRef = function (dotNetObjRef) {\n    dotNetObj = dotNetObjRef;\n}\n// eventlisteners\nwindow.addEventListener('resize', onWindowResize, false);\n\nfunction onWindowResize() {\n    var windowWidth = parseInt(window.innerWidth);\n    var windowHeight = parseInt(window.innerHeight);\n    //dotNetObj.invokeMethodAsync(\"WindowSize\", windowWidth, windowHeight);\n}\n\n\nwindow.saveAsFile = function (fileName, bytesBase64) {\n    var link = document.createElement('a');\n    link.download = fileName;\n    link.href = \"data:application/octet-stream;base64,\" + bytesBase64;\n    document.body.appendChild(link); // Needed for Firefox\n    link.click();\n    document.body.removeChild(link);\n}\n\n\nwindow.drawSLD = drawSLD\nwindow.updateSLD = updateSLD\nwindow.updateSLDItem = updateSLDItem\nwindow.updateSLDWithStudyResults = updateSLDWithStudyResults\n\n\n//window.setupDraggableModal = setupDraggableModal;\nwindow.startModalDrag = startModalDrag;\nwindow.stopModalDrag = stopModalDrag;\nwindow.getModalDialogRect = getModalDialogRect;\n//window.getModalDialogElement = getModalDialogElement;\nwindow.setModalPosition = setModalPosition;\n//window.focusElement = focusElement;\n\n"],"names":["currentDotNetHelper","currentModalDialogElement","getModalDialogRect","element","getBoundingClientRect","startModalDrag","dotNetHelper","style","position","margin","document","onmousemove","e","invokeMethodAsync","clientX","clientY","onmouseup","stopModalDrag","setModalPosition","x","y","left","concat","top","focusElement","focus","t","r","Symbol","n","iterator","o","toStringTag","i","c","prototype","Generator","u","Object","create","_regeneratorDefine2","f","p","G","v","a","d","bind","length","l","TypeError","call","done","value","GeneratorFunction","GeneratorFunctionPrototype","getPrototypeOf","setPrototypeOf","__proto__","displayName","_regenerator","w","m","defineProperty","_regeneratorDefine","_invoke","enumerable","configurable","writable","asyncGeneratorStep","Promise","resolve","then","_asyncToGenerator","arguments","apply","_next","_throw","dia","elementTools","linkTools","shapes","drawSLD","updateSLD","updateSLDItem","updateSLDWithStudyResults","dotNetObjDraw","dotNetObjSLD","graph","paper","sldComponentsJS","sldComponentsString1","propertyButton","Button","focusOpacity","offset","action","evt","model","tag","type","markup","tagName","selector","attributes","infoButton","distance","console","log","id","removeButton","link","getCell","isLink","removeLink","validateButton","validateLinkFromServer","allChildren","getElements","sldComponentsString","JSON","stringify","slice","Math","min","itemJSON","modalType","originalTag","branchesString","item","parse","branches","itemModel","find","el","updateBus","updateTransformer","updateCable","updateBusDuct","updateSwitch","updateCapacitor","updateMotor","updateHeater","updateLumpLoad","itemModels","getLinks","filter","source","hasOwnProperty","target","itemModels1","Tag","links","filteredLinks","attr","forEach","getLinkTag","busesString","switchboardString","switchString","loadsString","transformersString","cableBranchesString","busDuctsString","buses","switchboards","switches","loads","transformers","cableBranches","busDucts","br","Category","divString","xGridSize","yGridSize","leftSpacing","topSpacing","xGridSpacing","yGridSpacing","cablesString","xyString","dotNetObjRef","dotNetObjSLDRef","GridElement","Element","define","attrs","body","refWidth","refHeight","refX","refY","label","fill","fontWeight","textAnchor","fontSize","ratedSC","dx","ratedVoltage","busFaultkA","operatingVoltage","ports","groups","ref","name","args","portBody","magnet","stroke","text","items","group","strokeWidth","SwitchboardElement","root","refCx","refCy","strokeDasharray","alphaValue","NodeElement","busFault","BusElement","BusNodeElement","cx","cy","LoadElement","operatingPower","rating","LumpLoadElement","body1","refRCircumscribed","body2","CapacitorElement","TransformerElement","primary","secondary","voltage","kVArating","impedance","loading","BusDuctElement","size","operatingCurrent","CableElement","MotorElement","HeaterElement","branchLink","standard","Link","router","connector","radius","jumpover","line","sourceMarker","targetMarker","cables","sldComponents","namespace","defaultGrid","defaultBus","defaultCable","defaultTransformer","defaultBusduct","Graph","cellNamespace","Paper","getElementById","width","height","gridSize","drawGrid","background","color","cellViewNamespace","interactive","cellView","isElement","elementMove","interaction","defaultLink","linkPinning","validateConnection","cellViewS","magnetS","cellViewT","magnetT","end","linkView","sourcePortId","prop","targetPortId","allLinksSource","getConnectedLinks","sourcePortLinks","allLinksTarget","targetPortLinks","on","sM","tM","sPort","tPort","linkM","validateMagnet","_evt","getAttribute","snapLinks","border","hasLink","portName","some","get","port","getPortId","getPorts","getPort","saveDataButton","Rectangle","resize","addTo","templateGridElement","clicked","newGridElement","clone","templateBusElement","x1","y1","x2","y2","newBusElement","templateCableElement","newCableElement","templateTransformerElement","newTransformerElement","templateBusDuctElement","newBusDuctElement","templateCapacitorElement","newCapacitorElement","templateMotorElement","newMotorElement","templateHeaterElement","newHeaterElement","templateLumpLoadElement","newLumpLoadElement","container","child","linkCount","branchElement","busesDone","busesElement","swbdElement","busesNodeElement","loadElement","elementView","event","includes","isOverlapping","newPosition","findNearestEmptyPosition","set","push","at","toString","padStart","capacitorElement","bus","index","CordX","CordY","round","ISC","VR","SCkAaMax","Vo","Magnitude","Phase","PI","Length","updatePositionLength","getGroupPorts","b","getPortsPositions","swbd","busTags","node","updateNodeOrBus","Type","SLD","props","cwidth","ox","oy","clickedBusTag","oposx","owidth","cposx","pos","toWrite","setTimeout","max","swbdModel","updateSwbdPositionSizeByBus","anyBusTagOfThisBoard","busTag","dx1","dx2","dy1","dy2","Number","MAX_SAFE_INTEGER","bustag","bbox","getBBox","branch","sourceBus","BfT","targetBus","BtT","sourceBusNode","targetBusNode","cable","cbl","transformer","tr","busDuct","updateItemPosition","fromLink","toLink","sourceBusElement","targetBusElement","thisbranchElement","updateLinkVertices","addCell","busElement","busPortDistribution","existingLinkData","newVerticesText","PropertyJSON","newVertices","vertices","cell","serverData","newPositionText","busModel","newPositionLengthText","newPositionLength","tools","ToolsView","addTools","hasTools","removeTools","Vertices","Segments","toolsR","sldComponent","err","message","textBlock","TextBlock","dragStart","existingSelectBox","children","unembed","remove","selectBox","drag","selectBoxElement","findViewByModel","abs","dragEnd","dy","selectedElements","intersect","embed","_ref","_callee","validatedLink","_context","_x","portsIn","className","portsOut","rect","title","addPorts","portId","portIndex","getPortIndex","addPort","portProp","sourcePortIndex","targetPortIndex","getLinkData","busId","allLinks","busWidth","upLinks","downLinks","otherEnd","otherEndX","otherEndY","sort","reqPorts","removePort","newPorts","_objectSpread","_x2","_validateLinkFromServer","_callee2","linkData","success","_t","_context2","sourceTag","targetTag","_x3","_removeLink","_callee3","_context3","getCells","cellBBox","spacing","undefined","options","busInfo","trafoModel","trafoInfo","V1","V2","KVA","Z","KW","KVAR","cableModel","cabledata","CblDesc","L","Rl","Xl","R","X","Io","busDuctModel","busDuctdata","IR","motorModel","motordata","heaterModel","heaterdata","capacitorModel","capacitordata","lumpLoadModel","lumpLoaddata","lumploadModel","THREE","OrbitControls","FontLoader","TextGeometry","GLTFExporter","GUI","drawPlaneMesh","drawLadderMesh","drawBendMesh","drawTeeMesh","drawCrossMesh","drawNodeMesh","drawSleeveMesh","drawEquipmentMesh","drawSleepMesh","drawRefPointMesh","dotNetObj","scene","camera","renderer","canvas","controls","currentPlane","rendererWidth","window","innerWidth","rendererHeight","innerHeight","raycaster","posx","posy","posz","eventclientX","eventclientY","eventpageX","eventpageY","eventoffsetX","eventoffsetY","eventlayerX","eventlayerY","eventx","eventy","mousex","mousey","linePositionx","linePositiony","linePositionz","defaultOpacity","defaultColor","defaultColorLadder","defaultColorEq","defaultColorTrench","defaultColorSSFloor","defaultColorSleeve","defaultColorMCT","defaultColorConcrete","substationFloorMaterial","MeshStandardMaterial","transparent","opacity","side","DoubleSide","flatShading","ladderMaterial","MeshPhongMaterial","shininess","equipmentMaterial","sleeveMaterial","trenchMaterial","concreteMaterial","mctMaterial","pointsMaterial","PointsMaterial","alphaTest","redRingMaterial","MeshBasicMaterial","yellowRingMaterial","selectedObjectMaterial","savedObject","savedObjectMaterial","selectItemColor","ctrlKeyPressed","shiftKeyPressed","shadowRingMaterial","intervalId","setInterval","sceneInfo","z","rotation","eventListenersAdded","drawScene3Js","divId","sceneInfoJson","setAttribute","Scene","Name","PerspectiveCamera","add","AmbientLight","HemisphereLight","pointLight","PointLight","axesHelper","AxesHelper","shadowRing","Mesh","RingGeometry","Raycaster","WebGLRenderer","setSize","appendChild","domElement","autoRotate","autoRotateSpeed","screenSpacePanning","minDistance","maxDistance","addEventListener","distanceTo","scale","refObjects","getObjectsByName","obj","sc","Group","sceneInfo1","update","onWindowResize","onKeyDown","onKeyUp","onMouseMove","mouseWheel","mouseDownListener","mouseMoveListener","mouseUpListener","autoZoomToFit","preventDefault","aspect","updateProjectionMatrix","updateMatrixWorld","render","key","code","clearRefPoints","showHideShadowRingNPosinLines","_findCoordinate","findCoordinate","_findCoordinate2","_slicedToArray","mouse","getObjectByName","plotElevtn","linePosition","topPlotPlanIntersectPosition","pointsx","Vector3","geometry1","BufferGeometry","setFromPoints","material1","LineBasicMaterial","linex","Line","pointsy","geometry2","material2","liney","button","ctrlKey","shiftKey","_findCoordinate3","_findCoordinate4","objectPosition","topObjectIntersectPosition","screenX","screenY","pageX","pageY","offsetX","offsetY","layerX","layerY","point","intersectPoint","refPoints","refPointText","scalePlaneDoneStatus","refPointTexts","Vector2","vec","unproject","sub","normalize","copy","multiplyScalar","animate","requestAnimationFrame","GetSceneInfo","drawCube3Js","random","geometry","BoxGeometry","Color","setHex","parseInt","material","cube","objects","traverse","clearScene3Js","isMesh","hide3D3Js","hidePP","visible","drawPlane3Js","planeName","planeTag","imageString","scaleX","scaleY","centreX","centreY","elevation","rotatePlaneJs","angle","rotateZ","scalePlane3Js","orthoCamera","OrthographicCamera","centrePlan3Js","drawLadder3Js","jsonPoints","drawLadderChunk3Js","jsonDataList","dataList","JsonPoints","drawBend3Js","jsonFacePoints","drawTee3Js","drawCross3Js","drawNode3Js","jsonPoint","drawSleeve3Js","radious","segment","radialSegments","drawEquipment3Js","h","colortext","getRandomColor","Layout3d","load","state","div1","guiDiv","file","reference","loadScene3d","scalePlotPlan","_scalePlotPlan","centrePlotPlan","_centrePlotPlan","_x4","_x5","drawCable","jsonPointSetSegments","tubeTubularSegments","tubeRadialSegments","option","drawBoard","equipment","_equipment","_x6","_x7","_x8","_x9","_x0","_x1","_x10","_x11","_x12","_x13","_x14","_x15","_x16","_x17","z1","z2","saveSceneGLTF","removeItem","searchItem","toggleFunction","hidePlotPlan","orthoView","ortho","xp","yp","zp","clearClickedPoints","_clearClickedPoints","selectObjectHighlight","_selectObjectHighlight","_x18","copyText","navigator","clipboard","writeText","alert","error","projectName","caller","clock","Clock","mixer","cameraPerspective","xscalefactor","yscalefactor","lxcentreworld","lycentreworld","planeMesh","lxmin","lxmax","lymin","lymax","xxmin","xxmax","yymin","yymax","selectedObject","selectedInputTab","clickCoordinate","clickedPointSeq","startTime","localPlane","Plane","globalPlane","globalPlane1","localPlane1","globalPlanes","Empty","freeze","globalPlanesz","clippingPlanes","clipShadows","laddermaterial","equipmentmaterial","sleevematerial","sleeveRadialSegments","sleeveTubularSegments","trenchmaterial","concretematerial","mctmaterial","loader","textMaterial","animate1","arrowCamera","setLength","lookAt","arrowScene","box","Box3","object","expandByObject","getSize","center","getCenter","maxDim","fov","cameraZ","tan","getDelta","delta","resizeRendererToDisplaySize","clientWidth","clientHeight","gltfExporter","hideObjectTypesForExport","trs","onlyVisible","binary","maxTextureSize","result","ArrayBuffer","saveArrayBuffer","output","saveString","save","blob","filename","createElement","display","href","URL","createObjectURL","download","click","Blob","buffer","antialias","preserveDrawingBuffer","premultipliedAlpha","setPixelRatio","devicePixelRatio","shadowMap","enabled","PCFSoftShadowMap","localClippingEnabled","gui","autoPlace","folderLocal","addFolder","propsLocal","Enabled","constant","folderLocal1","propsLocal1","folderY","propsY","globalPlanes1","folderX","propsX","customContainer","guiContainer","open","frameWidth","frameHeight","aspectRatio","frustumSize","near","far","axis","createWheelStopListener","doAfterEndScrol","segments","maxCount","count","thisgroup","segType","deg","Option","t0","performance","now","lastElementChild","removeChild","loadPlotPlan","fitCameraToObject","boundingBox","setFromObject","startDistance","endDistance","needResize","setFromCamera","intersects","intersectObjects","loadPlotPlanNotUsed","userImageFile","light","image","Image","src","onload","texture","needsUpdate","Texture","plotPlanOpacity","planeMaterial","map","planeGeometry","PlaneGeometry","translateOnAxis","planeMeshCount","getObjectByNameArray","parentObject","childObjectName","match","scalePlotPlanNotUsed","hideObject","resetObject","OriginalColor","commonAction","mouseWheelStatus","hideObjectTypesOnScrolling","raycastObjectTypes","callback","timeout","handle","onScroll","clearTimeout","removeEventListener","raycastNotUsed","_findCoordinate5","_findCoordinate6","castObject","drawRefPoint","groupredRing","redCircleGeometry","CircleGeometry","redCircle","redRingGeometryIn","redRingMeshIn","redRingGeometryOut","redRingMeshOut","invokeDotnetStaticFunction","DotNet","data","giveMerandomInt","innerText","requestID","doAddScene","meshObject","animationText","progress","start","timeTaken","Date","drawBendNotUsed","clr","setColor","faces","vertices1","face","pt","Y","pointsGeometry","computeBoundingSphere","isNaN","boundingSphere","bendMesh","Clicked","mesh","computeBoundingBox","dispose","drawTeeNotUsed","teeMesh","drawCrossNotUsed","crossMesh","drawSleeveNotUsed","rawPoints","points","curve","CatmullRomCurve3","tubeGeometry","TubeGeometry","tube","pp","getPoints","pps","percent","pointSetSegments","ptFrom","v1","v2","ptTo","LineCurve","CubicBezierCurve3","onAfterRender","drawCableFromRoute","pts","indices","direction","subVectors","tangent","crossVectors","binormal","theta","j","cos","sin","v0","v3","setIndex","pipeMesh","drawNodeNotUsed","nodePoint","SphereGeometry","sphere","equipmentNotUsed","clrT","textColor","fontHeight","font","textGeometry","textMesh","rotateOnAxis","Point","writePlane","textcolor","drawEdge","drawMesh","functionVertical","writeLabelText","labelText","textSize","labelCoordinate","textCoordinate","colr","opec","edges","EdgesGeometry","LineSegments","depthTest","v3_object","v3_camera","line_of_sight","getWorldDirection","v3_object_position","v3_distance","depth","dot","fov_y","height_ortho","atan","width_ortho","neworthoCamera","writeLabel","intersectItemIndex","castObjectTags","castObjectUIDs","indx","indexOf","splice","UID","newGuid","castObjects","castObjectHidden","casObjectTag","xh","yh","zh","selectObject","returnColour","toggle","replace","uuid","equipmentMesh","colorParseError","pointsParseError","pushOrder","pointIndex","ladderMesh","drawLadderMeshBatch","tags","jsonPointsArray","colors","opacities","Array","isArray","parsed","every","idx","Float32BufferAttribute","materialCache","getMaterial","colorArray","Error","_construct","_toConsumableArray","instancedMesh","InstancedMesh","instanceTags","_","castShadow","receiveShadow","_loop","_i4","matrix","Matrix4","tempGeometry","setPosition","setMatrixAt","setColorAt","instanceMatrix","instanceColor","sphereMesh","fontData","refPoint","bevelEnabled","tubeMesh","consoleLog","logString","drawScene","sceneJSON","drawCube","hide3D","clearScene","drawPlane","rotatePlane","scalePlane","centrePlane","updateValue","rg","drawLadder","drawLadderChunk","drawBend","drawTee","drawCross","drawNode","drawSleeveZ","drawEquipment","initialiseObjectRef","windowWidth","windowHeight","saveAsFile","fileName","bytesBase64"],"ignoreList":[],"sourceRoot":""}