@page "/sld"
@attribute [Authorize(Policy = "RequireUser")]

@rendermode InteractiveServer


@inject NavigationManager MyNavigationManager
@inject IJSRuntime JsRuntime


@inject IDataRetrievalService DataService
@inject ITableService Table
@inject ICacheService CacheService
@inject IGlobalDataService GlobalData
@inject ILayoutFunctionService LayoutFunction
@inject ISystemStudyFunctionService StudyFunction
@inject IMyFunctionService MyFunction
@inject IMiscService MiscService

@using Switch = ElDesignApp.Models.Switch
@using ElDesignApp.Services
@using Microsoft.AspNetCore.Authorization
@using ElDesignApp.Components.Pages.MyComponents.Table
@using ElDesignApp.Services.SLD
@using Microsoft.EntityFrameworkCore.Storage.ValueConversion


<style>
    /*https://www.jointjs.com/demos/shapes-drawing*/

</style>

@if (!loadChild)
{
    <div class="loading-card">
        <div class="loading-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
            </svg>
        </div>
        
        <h4 class="loading-title">Loading SLD Data</h4>
        <p class="loading-message">@_loadingMessage</p>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" style="width: @(LoadingPercentage)%"></div>
            </div>
            <div class="progress-text">@LoadingPercentage%</div>
        </div>

        <div class="loading-steps">
            @for (int i = 0; i < _loadingTables.Length ; i++)
            {
                <div class="step @(_loadingStep >= i+1 ? "completed" : _loadingStep == i ? "active" : "")">
                    <span class="step-dot"></span>
                    <span class="step-label">@_loadingTables[i] </span>
                </div>
            }
        </div>
    </div>
}
else
{
    <div class="d-flex justify-content-between align-items-center" style="background-color:beige">
        <button type="submit" @onclick="@(() => { tablesHide = !tablesHide; })" class="btn btn-info"
                style="float:right;">↴
        </button>
    </div>
    
    @if (_isProcessing)
    {
        <div class="processing-overlay">
            <img src="./images/working.gif" asp-append-version="true" width="40" alt="Processing..."/>
            <h5 class="mb-0">@_processingMessage</h5>
        </div>
    }
    
    <div hidden="@(!tablesHide)" class="container-fluid">
        <div class="row">
            @* Tab Buttons - unchanged *@
            <div class="tab-container">
                @for (int i = 0; i < _tabName.Length; i++)
                {
                    var index = i; // Capture for closure
                    <button @onclick="() => TabUpdate(index)"
                            class="tab-button @(GlobalData.SLDPageTab == index ? "active" : "")">
                        @_tabName[index]
                    </button>
                }
            </div>
            @if (tab[0])
            {
                <div class="container-fluid tab-content" style="display: @(tab[0] ? "block" : "none")">
                    <h4>@_tabName[0]</h4>
                    @if (_loads != null)
                    {
                        <Table @key="@("table-load")"
                               List="_loads"
                               ListOriginal="GlobalData.Loads"
                               T="Load"
                               Fields="@_loadFieldList"
                               TableWidthPx="1200px"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[1])
            {
                <div class="container-fluid tab-content" style="display: @(tab[1] ? "block" : "none")">
                    <h4>@_tabName[1]</h4>
                    @if (_buses != null)
                    {
                        <Table @key="@("table-bus")"
                               List="_buses"
                               ListOriginal="GlobalData.Buses"
                               T="Bus"
                               Fields="@_busFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[2])
            {
                <div class="container-fluid tab-content" style="display: @(tab[2] ? "block" : "none")">
                    <h4>@_tabName[2]</h4>
                    @if (_transformers != null)
                    {
                        <Table @key="@("table-transformer")"
                               List="_transformers"
                               ListOriginal="GlobalData.Transformers"
                               T="Transformer"
                               Fields="@_transformerFieldList"
                               AutoCheckParentCallback="AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[3])
            {
                <div class="container-fluid tab-content" style="display: @(tab[3] ? "block" : "none")">
                    <h4>@_tabName[3]</h4>
                    @if (_cableBranches != null)
                    {
                        <Table @key="@("table-cablebranch")"
                               List="_cableBranches"
                               ListOriginal="GlobalData.CableBranches"
                               T="CableBranch"
                               Fields="@_cableBranchFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[4])
            {
                <div class="container-fluid tab-content" style="display: @(tab[4] ? "block" : "none")">
                    <h4>@_tabName[4]</h4>
                    @if (_busDucts != null)
                    {
                        <Table @key="@("table-busduct")"
                               List="_busDucts"
                               ListOriginal="GlobalData.BusDucts"
                               T="BusDuct"
                               Fields="@_busDuctFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[5])
            {
                <div class="container-fluid tab-content" style="display: @(tab[5] ? "block" : "none")">
                    <h4>@_tabName[5]</h4>
                    @if (_switches != null)
                    {
                        <Table @key="@("table-switch")"
                               List="_switches"
                               ListOriginal="GlobalData.Switches"
                               T="Switch"
                               Fields="@_switchFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[6])
            {
                <div class="container-fluid tab-content" style="display: @(tab[6] ? "block" : "none")">
                    <h4>@_tabName[6]</h4>
                    @if (_switches != null)
                    {
                        <Table @key="@("table-switch")"
                               List="_boards"
                               ListOriginal="GlobalData.Boards"
                               T="Board"
                               Fields="@_boardFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[7])
            {
                <div class="container-fluid tab-content" style="display: @(tab[7] ? "block" : "none")">
                    <h4>@_tabName[7]</h4>
                    @if (_switches != null)
                    {
                        <Table @key="@("table-fuse")"
                               List="_fuses"
                               ListOriginal="GlobalData.Fuses"
                               T="Fuse"
                               Fields="@_fuseFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
            @if (tab[8])
            {
                <div class="container-fluid tab-content" style="display: @(tab[8] ? "block" : "none")">
                    <h4>@_tabName[8]</h4>
                    @if (_switches != null)
                    {
                        <Table @key="@("table-busbarlink")"
                               List="_busBarLinks"
                               ListOriginal="GlobalData.BusBarLinks"
                               T="BusBarLink"
                               Fields="@_busBarLinkFieldList"
                               AutoCheckParentCallback="@AutoCheckOnTableChange"
                               AutoCheckParentFunc="AutoCheckOnTableChangeFunc"
                               UpdateParentCallback="@UpdateOnTableChange"
                               DiscardParentCallback="@DiscardTableChange"
                               ActionMessage="@_tableActionMessage"
                               SuccessMessage="@_tableSuccessMessage"
                               InfoMessage="@_tableInfoMessage"
                               WarningMessage="@_tableWarningMessage"
                               ErrorMessage="@_tableErrorMessage">
                            <ResultMessage>
                            </ResultMessage>
                        </Table>
                    }
                </div>
            }
        </div>
    </div>
    
    <SLD_Validation_Panel Messages="_validationMessages"
                     Title="Connection Validation"
                     MaxHeight="240"
                     OnDismiss="ClearValidationMessages" />

    <div class="container-fluid">
        <div>
            <button type="submit"
                    @onclick="@DoMainLoadFlow"
                    class="btn btn-success" style="float:right;">
                Run Load Flow and Short Circuit from SQL Data
            </button>
        </div>
    </div>
    <div class="container-fluid">
        <div>
            Select SLD to be drawn
            @{
                sLDs = GlobalData.Buses.Where(bus => bus.Cn.Count > 2).ToList().Select(e => e.BoardTag).Distinct().ToList();
                if (!sLDs.Contains("Key")) sLDs.Insert(0, "Key");
            }
            <select for="sLD" class="form-control" @onchange="OnSelectionChanged">
                @foreach (var sld in sLDs)
                {
                    if (sld == sLD)
                    {
                        <option value="@sld" selected>@sld</option>
                    }
                    else
                    {
                        <option value="@sld">@sld</option>
                    }
                }
            </select>
        </div>
        @*        <div>
    <InputFile hidden="@HideFileInput" OnChange="@MyFunction.LoadExcel" class="btn btn-info  btn-sm" style="float:left;" />
    </div>*@
        @*        <div>
    <button type="submit"
    @onclick="@MainLoadFlow"
    class="btn btn-success" style="float:inline-end;">
    Run Load Flow and Short Cuircuit
    </button>
    </div>*@
        <div class="btn-toolbar">
            <div>
                <button type="submit" @onclick="@DrawKeySLD" class="btn btn-info " style="float:left;">Draw SLD
                    - @sLD</button>
                <button type="submit" @onclick="@UpdateSLD" class="btn btn-success " style="float:right;">Save Updated SLD
                </button>
                <button type="submit" @onclick="@UpdateStudyResultsToClientPage" class="btn btn-info "
                        style="float:right;">Refresh Study Results
                </button>
                <button type="submit" @onclick="@SaveResult" class="btn btn-success " style="float:right;">Save Study
                    Results
                </button>
            </div>
        </div>


        <div hidden="@true">

            @if (_branches.Count == 0)
            {
                <div class="p-md-1">
                    <p class="p-sm-2"><em>Branch info not loaded yet...</em></p>
                </div>
            }
            else
            {
                <table class="table table-striped">
                    <thead>
                    <tr>
                        @foreach (var property in BranchProperties)
                        {
                            <th>@property.Name</th>
                        }
                    </tr>
                    </thead>
                    <tbody id="myBlockTable">
                    @foreach (var item in _branches)
                    {
                        <tr>
                            @foreach (var property in BranchProperties)
                            {
                                <td>@property.GetValue(item)</td>
                            }
                        </tr>
                    }
                    </tbody>
                </table>
            }
        </div>
    </div>
}

<div class="p-md-1">
    <p class="p-sm-2"><em>@_resultMessage</em></p>
</div>

<div class="sld-container">
    @* Expand / Collapse toggle button — top-left corner *@
    <button class="sld-toggle-btn"
            title="@(_sldExpanded ? "Shrink to window width" : "Expand to full diagram width")"
            @onclick="@(() => _sldExpanded = !_sldExpanded)">
        @(_sldExpanded ? "⇤ Shrink" : "⇥ Expand")
    </button>

    <div hidden="@HideLabel" id="paper"></div>

    @* Scrollable wrapper — toggles between viewport-fit and full-width *@
    <div class="sld-diagram-wrapper @(_sldExpanded ? "expanded" : "")">
        <div id="@_divString" class="sld-canvas"></div>
    </div>
</div>


@if (showEquipmentPropertyModal)
{
    switch (modalType)
    {
        case "grid":
        case "bus":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalBus"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        case "transformer":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalTransformer"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        case "cable":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalCableBranch"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        case "busduct":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalBusDuct"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        case "motor":
        case "heater":
        case "capacitor":
        case "lumpload":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalLoad"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        case "switch":
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modalSwitch"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
        default:
            <ElementPropertyModal1 Title="Properties"
                             Text="Provide details for new item"
                             Item="modelEquipment"
                             Fields="modalFieldList"
                             OnClose="@UpdateItemPropertyClientPage"></ElementPropertyModal1>
            break;
    }
}



@code {
    
    private List<ValMessage> _validationMessages = new();

    private void ClearValidationMessages()
    {
        _validationMessages.Clear();
        StateHasChanged();
    }

    DotNetObjectReference<SLD> dotNetObjRefSLD;
    
    private ConnectionValidationService _connectionValidationService;
    private ConnectionEvaluationService _connectionEvaluationService;
    
    // Progress tracking
    private int _loadingStep = 0;
    private static string[] _loadingTables = ["Cable Catalogue", "Motor Catalogue", "Load", "Bus", "Transformer", "CableBranch", "BusDuct", "Switch", "Board","Study results","SLD Coordinates","SLD Components"];
    private string _loadingMessage = "Initializing...";
    
    // Calculate percentage
    private int LoadingPercentage => (int)((double)_loadingStep / _loadingTables.Length * 100);

    private readonly CoordinateSystemManager _coordinateSystemManager;
    private bool loadChild = false;
    private bool _isProcessing = false;
    private string _processingMessage = "processing";
    
    private readonly bool[] tab = new bool[10];
    private int clickTab = 1;
    private readonly string[] _tabName = ["Load", "Bus", "Transformer", "CableBranch", "BusDuct", "Switch", "Board", "Fuse", "BusBarLink"];
    
    // Field lists
    private readonly string[] _loadFieldList = ["RecordId", "Tag", "TagDesc", "WBS", "Category", "Ph", "R", "Unit", "PA", "Duty", "VR", "IR", "Pf", "Eff", "Supply", "ConnectedBus", "FeederType", "L", "CblDesc", "CblAuto", "CblDescA", "VdRA", "VdSA", "CblDescM", "VdRM", "VdSM", "UpdatedBy", "UpdatedOn"];
    private readonly string[] _busFieldList = ["Tag", "TagDesc", "VR", "IR", "SC", "ISC", "XR", "BoardTag", "Sec", "IsNode", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _transformerFieldList = ["Tag", "TagDesc", "Category", "kVA", "Z", "XR", "V1", "V2", "FromElement", "ToElement", "FromBus", "ToBus", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _cableBranchFieldList = ["Tag", "TagDesc", "CblDesc", "FromElement", "ToElement", "FromBus", "ToBus", "L", "Rl", "Xl", "R", "X", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _busDuctFieldList = ["Tag", "TagDesc", "CblDesc", "FromElement", "ToElement","FromBus", "ToBus", "L", "Rl", "Xl", "R", "X", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _switchFieldList = ["Tag", "TagDesc", "VR", "IR", "SC", "FromElement", "ToElement", "IsOpen", "SwitchType", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _fuseFieldList = ["Tag", "TagDesc", "VR", "IR", "SC", "FromElement", "ToElement", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _busBarLinkFieldList = ["Tag", "TagDesc", "VR", "IR", "SC", "FromElement", "ToElement", "UpdatedBy", "UpdatedOn", "Remark"];
    private readonly string[] _capacitorFieldList = ["RecordId", "Tag", "TagDesc", "WBS", "Category", "Ph", "R", "Duty", "VR", "IR", "Pf", "Supply", "FromBus", "FeederType", "L", "CblDesc", "CblAuto", "CblDescA", "VdRA", "VdSA", "CblDescM", "VdRM", "VdSM", "UpdatedBy", "UpdatedOn"];
    private readonly string[] _heaterFieldList = ["RecordId", "Tag", "TagDesc", "WBS", "Category", "Ph", "R", "Duty", "VR", "IR", "Supply", "FromBus", "FeederType", "L", "CblDesc", "CblAuto", "CblDescA", "VdRA", "VdSA", "CblDescM", "VdRM", "VdSM", "UpdatedBy", "UpdatedOn"];
    private readonly string[] _motorFieldList = ["RecordId", "Tag", "TagDesc", "WBS", "Category", "Ph", "R", "Unit", "PA", "Duty", "VR", "IR", "Pf", "Eff", "Supply", "FromBus", "FeederType", "L", "CblDesc", "CblAuto", "CblDescA", "VdRA", "VdSA", "CblDescM", "VdRM", "VdSM", "UpdatedBy", "UpdatedOn"];
    private readonly string[] _boardFieldList = ["RecordId", "Tag", "TagDesc", "Width", "Depth", "Height", "CentrePointS", "CoordSystem", "Panels", "PanelTags", "PanelWidths", "FaceS", "Remark", "UpdatedBy", "UpdatedOn"];


    // Messages
    private string _tableActionMessage = "";
    private string _tableSuccessMessage = "";
    private string _tableInfoMessage = "";
    private string _tableWarningMessage = "";
    private string _tableErrorMessage = "";

    private List<Load> _loads = [];
    private List<Bus> _buses = [];
    private List<Bus> _busesToUpdate = [];
    private List<Board> _boards = [];
    private List<Branch> _branches = [];
    private List<CableBranch> _cableBranches = [];
    private List<BusDuct> _busDucts = [];
    private List<Transformer> _transformers = [];
    private List<Switch> _switches = [];
    private List<Fuse> _fuses = [];
    private List<BusBarLink> _busBarLinks = [];

    private List<BusStudyResult> _busStudyResults = [];
    private List<SLDXY> _sldXYs = [];
    private List<SLDComponent>? _sldComponents = [];
    
   private  Dictionary<string, int> resultLoadConnectionCounts = new();


    private bool tablesHide { get; set; }
    private bool HideLabel { get; } = true;
    private bool _sldExpanded = false;

    private static string _errorString = "";
    private static string _resultMessage = "";
    private static bool _hideFileInput = false;
    private static bool _importResultShow;
    private static bool _errorStringShow;
    
    private static DateTime _timeTaken = DateTime.Now;

    public class BusVisit
    {
        public Bus B { get; set; } // Bus
        public bool V { get; set; } // Bus Visited

        public BusVisit(Bus b, bool v)
        {
            B = b;
            V = v;
        }
    }

    public class LFResult
    {
        public List<Bus> BusResult { get; set; }
        public double MS { get; set; }
        public int IT { get; set; }

        public LFResult(List<Bus> busResult, double ms, int it)
        {
            BusResult = busResult;
            MS = ms;
            IT = it;
        }
    }

    public static double PC2Decimal(double v)
    {
        return v < -100 || v > 100 ? 1 : v > 1 || v < -1 ? v / 100 : v;
    }

    public static double Sb = 1000; // in MVA
    public static double Vbg = 1; // in kV GlobalData if there is no transformer


    public static string sLD { get; set; } = "Key"; // "Key" or switchboard "Key as default
    public static List<string> sLDs { get; set; } // list of all SLDS "Key" and all switchboards

    private static List<Bus> busesResult { get; set; }
    private static List<Branch> branchesResult { get; set; }

    public static List<Bus> StudyResultLFBus = new();
    public static List<Branch> StudyResultLFBranch = new();
    public static List<Bus> StudyResultSCBus = new();
    public static List<Branch> StudyResultSCBranch = new();

    public static List<BusVisit> BusVisited = new();

    public static PropertyInfo[] BusProperties = typeof(Bus).GetProperties();
    public static PropertyInfo[] BranchProperties = typeof(Branch).GetProperties();
    public static PropertyInfo[] LoadProperties = typeof(Load).GetProperties();

    //class for DrawSLDBoard and DrawKeySLD
    public static List<BusParent> BusParentList = new();

    public class BusParent
    {
        public string B { get; set; } // This Bus
        public string P { get; set; } // Parent Bus towards Source
        public string S { get; set; } // corresponding source bus

        public BusParent()
        {
        }

        public BusParent(string b, string p, string s)
        {
            B = b;
            P = p;
            S = s;
        }
    }


    public static int iterationLF = 500; // 500
    public static int iterationSC = 1000; // 1000
    public static double precisionLF = 0.00001; // 0.00001;
    public static double precisionSC = 0.001; // 0.001
    public static int counterLF = 10; //10
    public static bool loadContribution = false; // load contributioin for SC study


    private static bool showEquipmentPropertyModal;
    private static Load? modalLoad = new();
    private static Bus? modalBus = new();
    private static Branch modalBranch = new();
    private static CableBranch? modalCableBranch = new();
    private static BusDuct? modalBusDuct = new();
    private static Transformer? modalTransformer = new();
    private static Switch? modalSwitch = new();
    private object modelEquipment;
    private string[] modalFieldList;
    private string modalType;
    private string modalitemJSON;
    private string itemJSON;
    
    private SLDLayoutService _sldLayoutService;

    private static string _divString;

    [Inject]
    private ILogger<SegmentPage> _logger { get; set; } = default!;

    private string loginUser;

    private Dictionary<(string, string), Guid> _allTags = new();

    protected override void OnInitialized()
    {
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");

        // Initialize all tabs to false first
        for (int i = 0; i < tab.Length; i++)
        {
            tab[i] = false;
        }
        
        // Set the active tab
        tab[GlobalData.SLDPageTab] = true;
        
        GlobalData.selectedPage = "SLD: Loads, Buses, Transformers, CableBranches, Switches";
        GlobalData.Show3D = false;
        
        // Notify the MainLayout that the page title has changed
        GlobalData.NotifyHeaderChanged();
        
        GlobalData.sceneCurrent = "SLD";
        StateHasChanged();
        base.OnInitialized();
    }

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri} -  {MethodBase.GetCurrentMethod()?.Name} - First Render:{firstRender} Load Child? {loadChild}");

        if (firstRender)
        {
            var (userId, userName) = await MiscService.GetCurrentUserInfoAsync();
            loginUser = userName ?? "Guest";
            
            _connectionValidationService = new ConnectionValidationService();
            _connectionEvaluationService = new ConnectionEvaluationService();
            _sldLayoutService = new SLDLayoutService();
            
            //_loadingTables = ["Cable Catalogue", "Motor Catalogue", "Load", "Bus", "Transformer", "CableBranch", "BusDuct", "Switch", "Board","Study results","SLD Coordinates","SLD Components"];
            string logInfo = "", logWarning = "", logError = "";
            
            // Load common data
            // read cable data and motor data at outset, if not read yet
            
            // Step 1: CableData
            _loadingStep = 0;
            _loadingMessage = "Loading CableData...";
            StateHasChanged();
            await Task.Delay(10); // Allow UI to update
            if (GlobalData.CableData is { Count: 0 })
            {
                (GlobalData.CableData, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Models.CableData>() ;
                Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
                
            }
            
            // Step 2: MotorData
            _loadingStep++;
            _loadingMessage = "Loading MotorData...";
            StateHasChanged();
            await Task.Delay(10); // Allow UI to update
            if (GlobalData.MotorData is { Count: 0 })
            {
                (GlobalData.MotorData, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<MotorData>() ;
                Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            }
            
            
            // Step 3: Loads
            _loadingStep++;
            _loadingMessage = "Loading Loads...";
            StateHasChanged();
            await Task.Delay(10); // Allow UI to update
            (_loads, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Load>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            
            // Update Load so that Power values and cable sizes are calculated
            _loads.ForEach(item =>
            {
                LayoutFunction.LoadUpdate(item);
                item.Save2DB = true;
            });
            
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_loads);
            
            // Step 4: Buses
            _loadingStep++;
            _loadingMessage = "Loading Buses...";
            StateHasChanged();
            await Task.Delay(10); // Allow UI to update
            
            // read Buses at the outset
            //Buses = await ReadFromCacheOrDB(new Bus());
            (_buses, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Bus>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            _buses.ForEach(item => { item.Update(); item.Save2DB = true; });
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_buses);
            // programatically generated new buses through 'BranchBusUpdate' are not to saved to DB
            
            
            // Step 5: Transformers
            _loadingMessage = "Loading Transformers...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_transformers, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Transformer>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_transformers);
            
            // _transformers.ForEach(item => { item.Category = "Transformer"; item.Save2DB = true;
            //     // Branch PU Impedance Update is possible after assigning the Base Voltages as per the source to bus connection map
            //     _buses = LayoutFunction.BranchBusUpdate(item.Tag, item.Category, item.FromBus, item.ToBus, _buses);
            // });

            // Step 6: Cable Branches
            _loadingMessage = "Loading Cable Branches...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_cableBranches, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<CableBranch>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_cableBranches);
            
            // _cableBranches.ForEach(item =>
            // {
            //     item.Category = "Cable";
            //     item.Save2DB = true;
            //     LayoutFunction.CableRXUpdate(item);
            //     _buses = LayoutFunction.BranchBusUpdate(item.Tag, item.Category, item.FromBus, item.ToBus, _buses);
            // });

            // Step 7: Bus Ducts
            _loadingMessage = "Loading Bus Ducts...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_busDucts, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<BusDuct>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_busDucts);
            
            // _busDucts.ForEach(item =>
            // {
            //     item.Category = "BusDuct";
            //     item.Save2DB = true;
            //     LayoutFunction.BusDuctRXUpdate(item);
            //     _buses = LayoutFunction.BranchBusUpdate(item.Tag, item.Category, item.FromBus, item.ToBus, _buses);
            // });
            
            
            // Step 8: Switches/Fuse/BusBarLinks
            _loadingMessage = "Loading Switches, Fuses, Bus Bar Links...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_switches, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Switch>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            (_fuses, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Fuse>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            (_busBarLinks, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<BusBarLink>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));

            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_switches);
            AddItemsInAllTagsList(_fuses);
            AddItemsInAllTagsList(_busBarLinks);
        
            // Step 9: Boards
            _loadingMessage = "Loading Boards ...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_boards, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<Board>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            // Add to GlobalData.AllTags
            AddItemsInAllTagsList(_boards);
            
            // Add the bus tags in boards
            _buses.ForEach(bus =>
            {
                if (string.IsNullOrEmpty(bus.BoardTag)) return;
                if (_boards.All(board => board.Tag != bus.BoardTag)) return;
                {
                    var board = _boards.FirstOrDefault(board => board.Tag == bus.BoardTag);
                    board?.Bus ??= [];
                    if (bus.Tag != null) board?.Bus.Add(bus.Tag);
                }
            });

            
            // Step 10: Study Results
            _loadingMessage = "Loading Study Results...";
            _loadingStep = 8;
            StateHasChanged();
            await Task.Delay(10);
            (_busStudyResults, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<BusStudyResult>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            
            
            // Step 11: SLD Coordinates
            _loadingMessage = "Loading SLD Layout Info...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            (_sldXYs, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<SLDXY>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            
            
            // Step 12: SLD Components 
            _loadingMessage = "Loading SLD Components...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            // read SLD components afresh from the database to avoid missing change due to old cache data
            (_sldComponents, logInfo, logWarning, logError) = await DataService.ReadFromCacheOrDb<SLDComponent>() ;
            Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
            
            
            // Step 13: Finalizing
            _loadingMessage = "Finalizing...";
            _loadingStep++;
            StateHasChanged();
            await Task.Delay(10);
            // as all the Tables are now updated, assign the same to Global Tables
            
            var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
            
            GlobalData.Buses = JsonSerializer.Deserialize<List<Bus>>(JsonSerializer.Serialize(_buses, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.Boards = JsonSerializer.Deserialize<List<Board>>(JsonSerializer.Serialize(_boards, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.Transformers = JsonSerializer.Deserialize<List<Transformer>>(JsonSerializer.Serialize(_transformers, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.CableBranches = JsonSerializer.Deserialize<List<CableBranch>>(JsonSerializer.Serialize(_cableBranches, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.BusDucts = JsonSerializer.Deserialize<List<BusDuct>>(JsonSerializer.Serialize(_busDucts, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.Loads = JsonSerializer.Deserialize<List<Load>>(JsonSerializer.Serialize(_loads, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.Switches = JsonSerializer.Deserialize<List<Switch>>(JsonSerializer.Serialize(_switches, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.Fuses = JsonSerializer.Deserialize<List<Fuse>>(JsonSerializer.Serialize(_fuses, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.BusBarLinks = JsonSerializer.Deserialize<List<BusBarLink>>(JsonSerializer.Serialize(_busBarLinks, jsonSerializerOptions), jsonSerializerOptions);

            GlobalData.BusStudyResults = JsonSerializer.Deserialize<List<BusStudyResult>>(JsonSerializer.Serialize(_busStudyResults, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.SLDXYs = JsonSerializer.Deserialize<List<SLDXY>>(JsonSerializer.Serialize(_sldXYs, jsonSerializerOptions), jsonSerializerOptions);
            GlobalData.SLDComponents = JsonSerializer.Deserialize<List<SLDComponent>>(JsonSerializer.Serialize(_sldComponents, jsonSerializerOptions), jsonSerializerOptions);
            
            
            GlobalData.AllTags = new Dictionary<(string, string), Guid>(_allTags);
            // create branches considering all branch elements (cablebranch, transformer, busduct, etc..)

            _branches = StudyFunction.GetBranches(_cableBranches, _transformers, _busDucts);
                    
            var processor = new ConnectionProcessingService();

            var result = processor.ProcessAllConnections(
                _buses, _loads, _cableBranches, _transformers, _busDucts, _switches, _fuses, _busBarLinks);

            PopulateValidationMessages(result);
            
            _loadingStep = _loadingTables.Length;
            _loadingMessage = "Complete!";
            StateHasChanged();
            await Task.Delay(200); // Brief pause to show 100%
            // Done!
            
            loadChild = true;
            _timeTaken = DateTime.Now;
            _divString = "sldPaper";

            StateHasChanged();
            
            if (!result.Success)
            {
                // Show errors - DO NOT PROCEED
                foreach (var error in result.ValidationErrors)
                    Console.WriteLine(error.Message);


            }
            else
            {
                // Success - use evaluated data
                _buses = result.Buses; // With new buses if created
                var updatedBranches = result.Branches; // With FromBus/ToBus assigned
                resultLoadConnectionCounts = result.LoadConnectionCounts;

                // Update the branch list with evaluated FromBus/ToBus ===
                // Map back to original lists
                foreach (var branch in updatedBranches)
                {
                    var original = _cableBranches?.FirstOrDefault(c => c.Tag == branch.Tag);
                    if (original != null)
                    {
                        original.FromBus = branch.FromBus;
                        original.ToBus = branch.ToBus;
                    }

                    var origTrf = _transformers?.FirstOrDefault(t => t.Tag == branch.Tag);
                    if (origTrf != null)
                    {
                        origTrf.FromBus = branch.FromBus;
                        origTrf.ToBus = branch.ToBus;
                    }

                    var origBd = _busDucts?.FirstOrDefault(b => b.Tag == branch.Tag);
                    if (origBd != null)
                    {
                        origBd.FromBus = branch.FromBus;
                        origBd.ToBus = branch.ToBus;
                    }
                }
                
                // draw SLD only if the validation is successful
                
                await DrawKeySLD();
            }

            
        }
    }


    public void Dispose()
    {
        
    }
    
    public async ValueTask DisposeAsync()
    {
        // Clean up JavaScript resources first
        try
        {
            await JsRuntime.InvokeVoidAsync("disposeSLD");
        }
        catch (Exception ex)
        {
            // Log but don't throw during disposal
            Console.WriteLine($"Error disposing SLD: {ex.Message}");
        }
    
        // Dispose .NET references
        dotNetObjRefSLD?.Dispose();
    }

    private void AddItemsInAllTagsList<T>(List<T> list)
    {
        // Add to GlobalData.AllTags
        
        var type = typeof(T).Name;
        var tagProperty = typeof(T).GetProperty("Tag");
        var uidProperty = typeof(T).GetProperty("UID");
        if (tagProperty == null || uidProperty == null) return;
       
        list.ForEach(item =>
        {
            var tag = tagProperty.GetValue(item)??"";
            var key = (type,  (string)tag);

            // TryAdd returns true if the key was added, false if it already existed
            var wasAdded = _allTags.TryAdd(key, (Guid)(uidProperty.GetValue(item) ?? Guid.Empty));

            if (!wasAdded)
            {
                Console.WriteLine($"This {key.ToString()} combination already exists!");
            }
        });
    }


    private (List<T>? items, List<T>? itemsOriginal) GetItemsNOriginalItems<T>()
    {
        var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
        List<T>? items = new();
        List<T>? itemsOriginal = new();
        switch (typeof(T).Name)
        {
            case "Load":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_loads, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.Loads, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Bus":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_buses, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.Buses, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Transformer":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_transformers, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.Transformers, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "CableBranch":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_cableBranches, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.CableBranches, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Switch":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_switches, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.Switches, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "BusDuct":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_busDucts, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.BusDucts, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "BusBarLink":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_busBarLinks, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.BusBarLinks, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Fuse":
                items = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(_fuses, jsonSerializerOptions), jsonSerializerOptions);
                itemsOriginal = JsonSerializer.Deserialize<List<T>>(JsonSerializer.Serialize(GlobalData.Fuses, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Item1":
                // items = JsonConvert.DeserializeObject<List<T>>(JsonConvert.SerializeObject(Item1, jsonSerializerOptions), jsonSerializerOptions);
                // itemsOriginal = JsonConvert.DeserializeObject<List<T>>(JsonConvert.SerializeObject(GlobalData.Item1, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Item2":
                // items = JsonConvert.DeserializeObject<List<T>>(JsonConvert.SerializeObject(Item2, jsonSerializerOptions), jsonSerializerOptions);
                // itemsOriginal = JsonConvert.DeserializeObject<List<T>>(JsonConvert.SerializeObject(GlobalData.Item2, jsonSerializerOptions), jsonSerializerOptions);
                break;
            default:
                Console.WriteLine($"Error: Type '{typeof(T).Name}' case is not defined.");
                break;
        }

        return ( items, itemsOriginal);
    }


    private void SetItems<T>(List<T>? inputList)
    {
        var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
        
        switch (typeof(T).Name)
        {
            case "CableBranch":
                _cableBranches = JsonSerializer.Deserialize<List<CableBranch>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Load":
                _loads = JsonSerializer.Deserialize<List<Load>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Bus":
                _buses = JsonSerializer.Deserialize<List<Bus>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Transformer":
                _transformers = JsonSerializer.Deserialize<List<Transformer>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Switch":
                _switches = JsonSerializer.Deserialize<List<Switch>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "BusDuct":
                _busDucts = JsonSerializer.Deserialize<List<BusDuct>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Fuse":
                _fuses = JsonSerializer.Deserialize<List<Fuse>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "BusBarLink":
                _busBarLinks = JsonSerializer.Deserialize<List<BusBarLink>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions)?? [];
                break;
            case "Item1":
                //Item1 = JsonConvert.DeserializeObject<List<Item1>>(JsonConvert.SerializeObject(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Item2":
                //Item2 = JsonConvert.DeserializeObject<List<Item2>>(JsonConvert.SerializeObject(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
                default:
                Console.WriteLine($"Error: Type '{typeof(T).Name}' case is not defined.");
                break;
        }
    }
    
    private void SetGlobalData<T>(List<T>? inputList)
    {
        var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
        
        switch (typeof(T).Name)
        {
            case "CableBranch":
                GlobalData.CableBranches = JsonSerializer.Deserialize<List<CableBranch>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Load":
                GlobalData.Loads = JsonSerializer.Deserialize<List<Load>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Bus":
                GlobalData.Buses = JsonSerializer.Deserialize<List<Bus>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Transformer":
                GlobalData.Transformers = JsonSerializer.Deserialize<List<Transformer>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Switch":
                GlobalData.Switches = JsonSerializer.Deserialize<List<Switch>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Fuse":
                GlobalData.Fuses = JsonSerializer.Deserialize<List<Fuse>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "BusBarLink":
                GlobalData.BusBarLinks = JsonSerializer.Deserialize<List<BusBarLink>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "BusDuct":
                GlobalData.BusDucts = JsonSerializer.Deserialize<List<BusDuct>>(JsonSerializer.Serialize(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Item1":
                //Item1 = JsonConvert.DeserializeObject<List<Item1>>(JsonConvert.SerializeObject(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            case "Item2":
                //Item2 = JsonConvert.DeserializeObject<List<Item2>>(JsonConvert.SerializeObject(inputList, jsonSerializerOptions), jsonSerializerOptions);
                break;
            default:
                Console.WriteLine($"Error: Type '{typeof(T).Name}' case is not defined.");
                break;
        }
    }

    protected async void AutoCheckOnTableChange<T>(
        (T iteratedItem, Guid, PropertyInfo, T, List<T>, List<T>, string, string, string, string) args) where T : class
    {
        await AutoCheckOnTableChangeFunc<T>(args);
    }


    protected async Task<(T iteratedItem, string _tableSuccessMessage, string _tableInfoMessage, string _tableWarningMessage, string _tableErrorMessage)> 
        AutoCheckOnTableChangeFunc<T>((T iteratedItem, Guid, PropertyInfo, T, List<T>, List<T>, string, string, string, string) args)
    {
        // Access the parameters from args
        var iteratedItem = args.iteratedItem;
        var uid = args.Item2;
        var propertyInfo = args.Item3;
        var originalItem = args.Item4;
        List<T> itemsCurrent = args.Item5;
        List<T> itemsOriginal = args.Item6;
        _tableSuccessMessage = args.Item7;
        _tableInfoMessage = args.Item8;
        _tableWarningMessage = args.Item9;
        _tableErrorMessage = args.Item10;
        //
        // any further validation
        var anyFurtherValidation = true;
        if (anyFurtherValidation)
        {
            // additional validation
            Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name} : {propertyInfo.Name} further validation checks at parent side...");
            _tableErrorMessage += "";
            // additional validation
            _tableSuccessMessage += "";
            // var getItemsNOriginalItems = GetItemsNOriginalItems(item);
            // List<T> items = getItemsNOriginalItems[0];
            // List<T> itemsOriginal = getItemsNOriginalItems[1];
            // clear cache as the data is updated
            //await cache.RemoveAsync("NavMenu_" + typeof(T).Name + "_" + DateTime.Now.ToString("yyyyMMdd_hh"));
            //
            // Action for "Load"
            if (typeof(T).Name == "Load")
            {
                // Get the MethodInfo for the method "MyMethod"
                var methodInfo = typeof(T).GetMethod("Update");
                if (methodInfo != null)
                {
                    // Invoke the method on the instance obj
                    // null because MyMethod does not take any parameters
                    methodInfo.Invoke(iteratedItem, null);
                }
            }
            
            
            if (iteratedItem is Load loadItem)
            {
                // Now loadItem is strictly typed as 'Load'
                LayoutFunction.LoadUpdate(loadItem);
            }

            //
            // Action for CableBranch
            if (typeof(T).Name == "CableBranch")
            {
                var methodCableRXUpdate = typeof(T).GetMethod("CableRXUpdate");
                if (methodCableRXUpdate != null)
                {
                    // Invoke the method on the instance obj
                    // null because MyMethod does not take any parameters
                    methodCableRXUpdate.Invoke(iteratedItem, null);
                }
            }

            _tableActionMessage = _tableInfoMessage;
        }

        return (iteratedItem, _tableSuccessMessage, _tableInfoMessage, _tableWarningMessage, _tableErrorMessage);

        //var itemsNOriginalItems = GetItemsNOriginalItems(item);
        //SetItems(itemsCurrent);
    }


    protected async void UpdateOnTableChange<T>(
        (T item, List<T> list, List<T> originalList, string success, string info, string warning, string error ) args) where T : class
    {
        try
        {
            ResetTableMessages();
            Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
            //
            var itemslist = args.list;
            var origialItemslist = args.originalList;

            // write to the DB
            var result = await Table.SyncListAsync(itemslist, origialItemslist, loginUser);
            _logger.LogError(result.Errors?.ToString());
            _logger.LogInformation($"Records Added: {result.Added}, Modified: {result.Modified} and Deleted: {result.Deleted}.");
            
            // clear cache invoking the parent page
            _tableSuccessMessage = "Data updated to the Database";
            _tableActionMessage = _tableSuccessMessage;
            
            // reassign the Table List and original list
            
            // Set the list _cableBranches/_lods/_transformers/_busDucts/etc. as per the changed table
            var items = GetItemsNOriginalItems<T>().items;
            SetItems(itemslist);
            
            // Set the Global Data of Transformers/Buses/CableBranches/etc. as per the changed Table
            // Updated Global Data is now becoming the original list
            SetGlobalData(itemslist);
            
            StateHasChanged();
        
        
            // as the data is updated, to clear the cache entry for the current hour
            var recordKey = "NavMenu_"  + "_" + GlobalData.SelectedProject.Tag + "_" +typeof(T).Name + "_" + DateTime.Now.ToString("yyyyMMdd_hh");
            //await CacheService.RemoveAsync(recordKey);
       
            // Construct the pattern to match all hourly keys for this type.
            // The pattern needs a wildcard for the varying parts.
            // Original key format: "NavMenu_" + dbName + "_" + DateTime.Now.ToString("yyyyMMdd_hh")
            // So, the pattern will be: "NavMenu_CableData_*"
            var pattern = $"NavMenu_{typeof(T).Name}_*";
            await CacheService.RemoveByPatternAsync(pattern);
            Console.WriteLine($"Attempted to clear all cache for pattern: {pattern}");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error: {e.Message}");
        }
    }

    private void ResetTableMessages()
    {
        _tableSuccessMessage = "";
        _tableInfoMessage = "";
        _tableWarningMessage = "";
        _tableErrorMessage = "";
    }

    public void DiscardTableChange<T>((T item, List<T> list, List<T> originalList) args)
    {
        ResetTableMessages();
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
        var item = args.Item1;
        List<T> origialItemslist = args.Item3;
        //
        var originalItems = GetItemsNOriginalItems<T>().itemsOriginal;
        
        // Set the list _cableBranches/_lods/_transformers/_busDucts/etc. as per the originalList
        SetItems(originalItems);
        _tableSuccessMessage = "All changes discarded";
        _tableActionMessage = _tableSuccessMessage;
        StateHasChanged();
    }

    private void OnSelectionChanged(ChangeEventArgs e)
    {
        sLD = e.Value.ToString();
        Console.WriteLine($"'{sLD}' SLD selected.");
        if (sLD == "Key")
        {
            DrawKeySLD();
        }
        else
        {
            DrawSLD();
        }
    }


    private async Task DrawSLD()
    {
    }


    private async Task DrawKeySLD()
    {
        _processingMessage = "running system study afresh before drawing SLD";
        _isProcessing = true;
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : _isProcessing: {_isProcessing}");
        StateHasChanged();
        // Give Blazor a chance to process the pending render cycle.
        await Task.Yield(); 
        
        var buses ="";
        string branches ="";
        string loads ="";
        string transformers ="";
        string cableBranches ="" ;
        string busDucts ="";
        string allTags = "";
        int xgridSize =0;
        int ygridSize=0;
        string xyString = "";
        string sldComponents ="";
        string switchboards ="";
        
        
        List<Bus> finalBusesResult = new List<Bus>();
        List<Branch> finalBranchesResult = new List<Branch>();
        List<SLDComponent> finalSLDComponents = new List<SLDComponent>();
        
        await Task.Run((Func<Task>)(async () =>
        {
        var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
        
        
        var sld = "key"; // name of the SLD: Key, DB-001, etc.
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
        //

        // var xyCoordinateFromSystemStudy = false;
        //
        // if (!xyCoordinateFromSystemStudy)
        // {
            // calculate XY coordinates without the SystemStudy 

            busesResult = StudyFunction.AssignVbSwingSourcesAndAutoXY(
                _buses, _loads, _cableBranches, _busDucts, _transformers, _switches, _fuses, _busBarLinks, resultLoadConnectionCounts);
            
            // only the bus X,Y location is determined , accordingly the branches are placed in the JS based on from to bus.
            branchesResult = StudyFunction.GetBranches(_cableBranches, _transformers, _busDucts);
            // ──────────────────────────────────────────────────────────────────────────────
            // NEW: Use SLDLayoutService for coordinate assignment
            // ──────────────────────────────────────────────────────────────────────────────
            
            // Run the layout engine (discovers chains, computes tier gaps, assigns coordinates)
            var layoutResult = _sldLayoutService.BuildLayout(
                busesResult,
                _cableBranches,
                _transformers,
                _busDucts,
                _switches,
                _fuses,
                _busBarLinks,
                GlobalData.topSpacing,
                GlobalData.leftSpacing,
                GlobalData.xGridSpacing,
                resultLoadConnectionCounts);
            
            if (!layoutResult.Success)
            {
                Console.WriteLine($"Layout computation failed: {layoutResult.Message}");
                // Fallback to old logic if needed
            }
            else
            {
                Console.WriteLine($"Layout computed successfully: {layoutResult.Message}");
            
                // Buses already have CordX/CordY updated by BuildLayout
                busesResult = layoutResult.Buses;
            
                // Restore swing flag from original data
                busesResult.ForEach(bus =>
                {
                    if (_buses.Find(b => b.Tag == bus.Tag)?.IsSwing == true) bus.IsSwing = true;
                });
            
                // Override auto-layout with user-saved coordinates from SLDComponent table
                // (SLDComponent stores position data as JSON in PropertyJSON field;
                //  the deprecated SLDXY table is no longer used)
                _sldLayoutService.ApplySavedCoordinates(
                    _sldComponents,
                    sld,                                    // "key" or switchboard name
                    busesResult,
                    layoutResult.ElementCoordinates);
            }
            
            // Prepare chain element coordinates for JS
            // This dictionary maps element Tag → {CordX, CordY} for branches and non-branches
            var chainElementCoordinates = layoutResult.ElementCoordinates
                .Select(kvp => new { Tag = kvp.Key, X = kvp.Value.X, Y = kvp.Value.Y })
                .ToList();
            
            var chainElementCoordsJson = JsonSerializer.Serialize(chainElementCoordinates, jsonSerializerOptions);
            
            // Prepare chain data for JS (so JS knows the link sequence)
            var chainDataForJs = layoutResult.Chains.Select(c => new
            {
                FromBus = c.FromBusTag,
                ToBus = c.ToBusTag,
                Elements = c.ElementTags,
                ContainsBranch = c.ContainsBranch,
                BranchTag = c.BranchTag,
                Orientation = c.Orientation.ToString(),
                ParallelIndex = c.ParallelIndex,
                ParallelCount = c.ParallelCount
            }).ToList();
            
            var chainsJson = JsonSerializer.Serialize(chainDataForJs, jsonSerializerOptions);
            
            // Serialize non-branch items for JS
            var switchesJson = JsonSerializer.Serialize(_switches, jsonSerializerOptions);
            var fusesJson = JsonSerializer.Serialize(_fuses, jsonSerializerOptions);
            var busBarLinksJson = JsonSerializer.Serialize(_busBarLinks, jsonSerializerOptions);
            
            // ──────────────────────────────────────────────────────────────────────────────
            // END OF NEW LAYOUT CODE
            // ──────────────────────────────────────────────────────────────────────────────
            
                                            
                                
                                
                                
                    

        // }
        // if(xyCoordinateFromSystemStudy)
        // {
        //     // run LF SC study to obtain all the latest data for the 1st time drawing SLD
        //     var tupleResult = await MainLoadFlow(_buses, _loads, _cableBranches, _transformers, _busDucts, _switches, _fuses, _busBarLinks);
        //     busesResult = tupleResult.Item1;
        //     branchesResult = tupleResult.Item2;
        // }
        //
        // busesResult = busesResult.OrderBy(bus => bus.CordY).ThenBy(bus => bus.CordX).ToList();
        // // set the coordinates for the elements in the KeySLD
        // // check if there are coordinates stored in the DB
        // busesResult.ForEach(bus =>
        // {
        //     // in SC study Swing buses are temporarily converted as ordinary "" bus
        //     // revert them with "Swing" category
        //     if (_buses.Find(b => b.Tag == bus.Tag).IsSwing) bus.IsSwing = true;
        //     //
        //     var sldbuses = _sldXYs.Where(b => b.SLD == sld && b.Tag == bus.Tag).ToList();
        //     if (sldbuses.Count > 0)
        //     {
        //         // coordinate is stored by user
        //         bus.CordX = sldbuses[0].CordX;
        //         bus.CordY = sldbuses[0].CordY;
        //         bus.Length = sldbuses[0].Length;
        //     }
        //     else
        //     {
        //         // assign as per the Auto X-Y logic from Function AssignVbSwingSourcesAndAutoXY
        //         bus.CordY = GlobalData.topSpacing + GlobalData.yGridSpacing * bus.SLDY;
        //         var xs = busesResult.Where(b => b.SLDY == bus.SLDY && b.SLDX <= bus.SLDX).ToList();
        //         var cordX = 0;
        //         xs.ForEach(item => cordX += item.SLDL);
        //         bus.CordX = GlobalData.leftSpacing + cordX * GlobalData.xGridSpacing;
        //         bus.Length = (int)(0.5 * GlobalData.xGridSpacing * (bus.SLDL - 0.5));
        //     }
        // });
        //

        

        // draw scene

        buses = JsonSerializer.Serialize(busesResult, jsonSerializerOptions);
        branches = JsonSerializer.Serialize(branchesResult, jsonSerializerOptions);
        loads = JsonSerializer.Serialize(_loads);
        transformers = JsonSerializer.Serialize(_transformers, jsonSerializerOptions);
        cableBranches = JsonSerializer.Serialize(_cableBranches, jsonSerializerOptions);
        busDucts = JsonSerializer.Serialize(_busDucts, jsonSerializerOptions);

        xgridSize = busesResult.Max(bus => bus.CordX) + 200;
        ygridSize = busesResult.Max(bus => bus.CordY) + 150;
        xyString = "";
        
        
        var tagArray = _allTags
            .Select(kvp => new { category = kvp.Key.Item1, tag = kvp.Key.Item2 })
            .ToList();
        var tagArrayJson = JsonSerializer.Serialize(tagArray, jsonSerializerOptions);
        
        // read SLD data afresh directly from the DB and not from cache
        
        (_sldComponents, var logInfo, var logWarning, var logError) = await DataService.RefreshCacheAndReadFromDb<SLDComponent>() ;
        Console.WriteLine(MyFunction.LogMessage(logInfo, logWarning, logError));
        sldComponents = JsonSerializer.Serialize(_sldComponents, jsonSerializerOptions);

        // create switchboard strings
        switchboards = JsonSerializer.Serialize(FindSwitchboards(busesResult), jsonSerializerOptions);
        
        


        //var dotNetObjRef = DotNetObjectReference.Create(new Draw(LayoutFunction, GlobalData, _coordinateSystemManager));
        
        dotNetObjRefSLD = DotNetObjectReference.Create(this);
        
        Console.WriteLine($"DEBUG: chainElementCoords count = {chainElementCoordinates?.Count}");
        Console.WriteLine($"DEBUG: chains count = {chainDataForJs?.Count}");
        Console.WriteLine($"DEBUG: switches count = {_switches?.Count}");
        Console.WriteLine($"DEBUG: chainElementCoordsJson length = {chainElementCoordsJson?.Length}");

        await JsRuntime.InvokeVoidAsync("drawSLD", _divString,
            xgridSize, ygridSize, GlobalData.leftSpacing, GlobalData.topSpacing, 
            GlobalData.xGridSpacing, GlobalData.yGridSpacing,
            buses, switchboards, branches, loads, transformers, cableBranches, 
            busDucts, xyString, sldComponents, dotNetObjRefSLD, dotNetObjRefSLD,
            chainElementCoordsJson,     // coordinates for all chain elements
            chainsJson,                 // chain structure (element ordering, bus ends)
            switchesJson,               // switch data
            fusesJson,                  // fuse data
            busBarLinksJson,             // bus bar link data
            tagArrayJson                     // all Tags with Categories    
            );
        
        _timeTaken = DateTime.Now;
        }));
        _processingMessage = "processing";
        _isProcessing = false;
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : _isProcessing: {_isProcessing}");

        StateHasChanged();
        
    }


    private void SaveResult()
    {
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
    }

    void TabUpdate(int i)
    {
        tab[GlobalData.SLDPageTab] = false;
        GlobalData.SLDPageTab = i;
        tab[i] = true;
    }

    private async Task DoMainLoadFlow()
    {
        await MainLoadFlow( _buses, _loads, _cableBranches, _transformers, _busDucts, _switches, _fuses, _busBarLinks);
    }

    private async Task<Tuple<List<Bus>, List<Branch>>> MainLoadFlow(List<Bus> buses, List<Load> loads, 
        List<CableBranch> cableBranches, List<Transformer> transformers, List<BusDuct> busDucts, 
        List<Switch> switches,List<Fuse> fuses, List<BusBarLink> busBarLinks)
    {
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");

        //
        // update the Buses as per last SystemStudy (LF and SC) Result
        buses.ForEach(bus =>
        {
            List<BusStudyResult> busStudyResults = _busStudyResults.Where(item => item.Tag == bus.Tag).ToList();
            if (busStudyResults.Count > 0)
            {
                //bus.Vo = busStudyResults[0].Vo;
                bus.VoJSON = busStudyResults[0].VoJSON;
                bus.Vo = JsonSerializer.Deserialize<Complex>(busStudyResults[0].VoJSON);

                //bus.SCResult = busStudyResults[0].SCResult;
                bus.SCResultJSON = busStudyResults[0].SCResultJSON;
                bus.SCResult = JsonSerializer.Deserialize<List<SCBusVal>>(busStudyResults[0].SCResultJSON);
            }
        });

        var tupleLFSCResult = StudyFunction.MainLoadFlow(cableBranches, transformers, busDucts, buses, switches, loads, fuses, busBarLinks);
        List<Bus> busesLFSC = tupleLFSCResult.Item1;
        List<Branch> branchesLFSC = tupleLFSCResult.Item2;

        // Save LF and SC Bus SystemStudy Result to DB
        // store the result to save to the database


        Console.WriteLine("\nSaving Load Flow and Short Circuit results to DB....\n");
        //
        busesLFSC.ForEach(bus =>
        {
            BusStudyResult busStudyResult;

            List<BusStudyResult> busStudyResults = _busStudyResults.Where(item => item.Tag == bus.Tag).ToList();
            if (busStudyResults.Count > 0)
            {
                busStudyResult = busStudyResults[0];
            }
            else
            {
                busStudyResult = new BusStudyResult();
                busStudyResult.Tag = bus.Tag;
                busStudyResult.UID = Guid.NewGuid();
                busStudyResult.ProjectId = GlobalData.SelectedProject.Tag;
                busStudyResult.OptionId = "base";
                _busStudyResults.Add(busStudyResult);
            }

            busStudyResult.VoJSON = bus.VoJSON;
            busStudyResult.SCResultJSON = bus.SCResultJSON;
            busStudyResult.UpdatedBy = "KP";
            busStudyResult.UpdatedOn = DateTime.Now;
            busStudyResult.Save2DB = true;
        });
        await Table.SyncListAsync(_busStudyResults, GlobalData.BusStudyResults);


        // clear cache invoking the parent page
        _tableSuccessMessage = "LF and SC Result Data updated to the Database";
        _tableActionMessage = _tableSuccessMessage;
       // StateHasChanged();
 
        
        // as the data is updated, to clear the cache entry for the current hour
        var recordKey = "NavMenu_"  + "_" + GlobalData.SelectedProject.Tag + "_" + typeof(BusStudyResult).Name + "_" + DateTime.Now.ToString("yyyyMMdd_hh");
        //await CacheService.RemoveAsync(recordKey);
       
        // Construct the pattern to match all hourly keys for this type.
        // The pattern needs a wildcard for the varying parts.
        // Original key format: "NavMenu_" + dbName + "_" + DateTime.Now.ToString("yyyyMMdd_hh")
        // So, the pattern will be: "NavMenu_CableData_*"
        var pattern = $"NavMenu_{typeof(BusStudyResult).Name}_*";
        await CacheService.RemoveByPatternAsync(pattern);
        Console.WriteLine($"Attempted to clear all cache for pattern: {pattern}");
        
        

        return new Tuple<List<Bus>, List<Branch>>(busesLFSC, branchesLFSC);
    }


    private async Task UpdateSLD()
    {
        // for SLD
        // invoke JavaScript function to send the modified SLD component data back to server so that
        // server saves the received data to the database through 'SLDComponentUpdate' function
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  - {MethodBase.GetCurrentMethod()?.Name}");
        // the dotnet reference shall the 'this' razor page and not "Draw.cs" as the "await myTable" to be invoked to write data to database
        Console.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : Calling Client side updateSLD from server side.");
        await JsRuntime.InvokeVoidAsync("updateSLD");
    }



    [JSInvokable("OnElementSelected")]
    public async Task OnElementSelected(Payload payload)
    {
        var id          = payload.Id??"";
        var tag         = payload.Tag??"";
        var elementType = payload.ElementType??"";
        var sourceId    = payload.SourceId;
        Console.WriteLine($"Server Side:OnElementSelected.....id:{id}  tag:{tag} elementType:{elementType} id:{sourceId}");
    }
    
    [JSInvokable("OnElementDeselected")]
    public async Task OnElementDeselected(Payload payload)
    {
        var id          = payload.Id??"";
        var tag         = payload.Tag??"";
        var elementType = payload.ElementType??"";
        var sourceId    = payload.SourceId;
        Console.WriteLine($"Server Side:OnElementDeselected.....id:{id}  tag:{tag} elementType:{elementType} id:{sourceId}");
    }
    
    [JSInvokable("OnElementPlaced")]
    public Task OnElementPlaced(Payload payload)
    {
        var id          = payload.Id??"";
        var tag         = payload.Tag??"";
        var elementType = payload.ElementType??"";
        var sourceTag = payload.SourceTag ?? "";
        var sourceId = payload.SourceId;
        Console.WriteLine($"Server Side:OnElementPlaced.....id:{id}  tag:{tag} elementType:{elementType} id:{sourceId}");
        
        switch (payload.ElementType?.ToLower())
        {
            case "transformer":  PlaceElementCopy(sourceId, sourceTag, tag, _transformers);  break;
            case "bus":          PlaceElementCopy(sourceId, sourceTag, tag, _buses);         break;
            case "load":         PlaceElementCopy(sourceId, sourceTag, tag, _loads);         break;
            case "cablebranch":  PlaceElementCopy(sourceId, sourceTag, tag, _cableBranches); break;
            case "busduct":      PlaceElementCopy(sourceId, sourceTag, tag, _busDucts);      break;
            case "switch":       PlaceElementCopy(sourceId, sourceTag, tag, _switches);      break;
            case "fuse":         PlaceElementCopy(sourceId, sourceTag, tag, _fuses);         break;
            case "busbarlink":   PlaceElementCopy(sourceId, sourceTag, tag, _busBarLinks);   break;
            // add other element types here
            default:
                Console.WriteLine($"[OnElementPlaced] Unknown elementType: {payload.ElementType}");
                return Task.CompletedTask;
        }
        StateHasChanged();
        return Task.CompletedTask;
    }
    
    // Generic helper — handles any item type that implements ITaggedItem
    private void PlaceElementCopy<T>(Guid uid, string sourceTag, string tag, List<T> targetList) where T : class, new()
    {
        var uidProperty = typeof(T).GetProperty("UID")
                          ?? throw new InvalidOperationException($"Property 'UID' not found in type {typeof(T).Name}.");
        var tagProperty = typeof(T).GetProperty("Tag")
                          ?? throw new InvalidOperationException($"Property 'Tag' not found in type {typeof(T).Name}.");
        var seqProperty = typeof(T).GetProperty("Seq")
                          ?? throw new InvalidOperationException($"Property 'Seq' not found in type {typeof(T).Name}.");
        
        var jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };
    
        // Ensure inputs are valid
        if (uidProperty == null || tagProperty == null || seqProperty == null || tag == null || targetList == null) return;
        
        var sourceItem = targetList.FirstOrDefault(x => 
            (string)tagProperty.GetValue(x) == sourceTag);
        var newItem = JsonSerializer.Deserialize<T>(JsonSerializer.Serialize(sourceItem, jsonSerializerOptions), jsonSerializerOptions);
        var newUid = Guid.NewGuid();
        tagProperty.SetValue(newItem, tag);
        uidProperty.SetValue(newItem, newUid);
        

        var sourceTag1 = tagProperty.GetValue(sourceItem)?.ToString();
        var serverSideDerivedTag = MiscService.BuildCopyTag(sourceTag, typeof(T).Name, _allTags);

        targetList.Insert(targetList.IndexOf(sourceItem), newItem); 
        
        // update sequence
        foreach (var (value, index) in targetList.Select((v, i) => (v, i)))
        {
            seqProperty.SetValue(value, index);
        }
        
        // Register in _allTags so further copies see it
        var key = (typeof(T).Name,  tag);
        _allTags.TryAdd(key, newUid);
    }


    [JSInvokable("SLDComponentAdd")]
    public async Task SLDComponentAdd(string elementType, string copyTag = "")
    {
        var str = copyTag == "" ? "" : " from tag '" + copyTag + "'";
        Console.WriteLine($"Server Side:SLDComponentAdd..... for Element type '{elementType}' {str}...");
        
        switch (elementType)
        {
            case "grid":
            case "bus":
                _buses.Add(new Bus());
                break;
            case "transformer":
                _transformers.Add(new Transformer());
                break;
            case "cable":
                _cableBranches.Add(new CableBranch());
                break;
            case "busDuct":
                _busDucts.Add(new BusDuct());
                break;
            case "motor":
            case "heater":
            case "capacitor":
            case "lumpLoad":
                _loads.Add(new Load());
                break;
            case "switch":
                _switches.Add(new Switch());
                break;
            default:
                // code block
                //modalSwitch
                //modalLoad
                //modalCableBranch
                //modalBusDuct
                break;
        }
        StateHasChanged();
    }

    [JSInvokable("PropertyUpdate")]
    public Task PropertyUpdate(string tag, string type)
    {
        Console.WriteLine($"Server Side:PropertyUpdate..... for Element type '{type}' tag '{tag}...");
        showEquipmentPropertyModal = true;
        modalType = type;

        switch (type)
        {
            case "grid":
            case "bus":
                modalBus = _buses.Find(item => item.Tag == tag);
                if (modalBus is null)
                {
                    modalBus = new Bus { Tag = tag };
                    _buses.Add(modalBus);
                }

                modalFieldList = _busFieldList;
                break;
            case "transformer":
                modalTransformer = _transformers.Find(item => item.Tag == tag);
                // if (modalTransformer is null)
                // {
                //     modalTransformer = new Transformer { Tag = tag };
                //     _transformers.Add(modalTransformer);
                // }

                modalFieldList = _transformerFieldList;
                break;
            case "cable":
                modalCableBranch = _cableBranches.Find(item => item.Tag == tag);
                if (modalCableBranch is null)
                {
                    modalCableBranch = new CableBranch { Tag = tag };
                    _cableBranches.Add(modalCableBranch);
                }

                modalFieldList = _cableBranchFieldList;
                break;
            case "busduct":
                modalBusDuct = _busDucts.Find(item => item.Tag == tag);
                if (modalBusDuct is null)
                {
                    modalBusDuct = new BusDuct { Tag = tag };
                    _busDucts.Add(modalBusDuct);
                }

                modalFieldList = _busDuctFieldList;
                break;
            case "motor":
            case "heater":
            case "capacitor":
            case "lumpload":
                modalLoad = _loads.Find(item => item.Tag == tag);
                if (modalLoad is null)
                {
                    modalLoad = new Load { Tag = tag };
                    _loads.Add(modalLoad);
                    modalLoad.LoadType = type == "motor" ? "Motor" : type == "heater" ? "Heater" : type == "capacitor" ? "Capacitor" : "LumpLoad";
                }

                modalFieldList = type == "motor" ? _motorFieldList : type == "heater" ? _heaterFieldList : type == "capacitor" ? _capacitorFieldList : _loadFieldList;
                break;
            case "switch":
                modalSwitch = _switches.Find(item => item.Tag == tag);
                if (modalSwitch is null)
                {
                    modalSwitch = new Switch { Tag = tag };
                    _switches.Add(modalSwitch);
                }

                modalFieldList = _switchFieldList;
                break;
            default:
                // code block
                //modalSwitch
                //modalLoad
                //modalCableBranch
                //modalBusDuct
                modalFieldList = _switchFieldList;
                break;
        }

        StateHasChanged();
        return Task.CompletedTask;
    }


    private async Task UpdateItemPropertyClientPage((string itemJSON, string Type, string originalTag, string changedTag, string button) args)
    {
        showEquipmentPropertyModal = false;
        Console.WriteLine($"Server Side: UpdatePropertyClientPage......{args.button} pressed");
        
        // before updating the SLD with the changed parameters, updating the SLD components list at the server side 
        
        
        //TODO update this function in view of introduced fields of FromElement and ToElement 

        


        var branches = JsonSerializer.Serialize(branchesResult);
        
        // Step 1: Handle Tag change

        if (args.originalTag != args.changedTag)
        {
            // besides other parameters, the tag is changed
            // if the type of the item is cable or transformer or bus duct, there is no concern
            // as only the link tag and source tag will get affected and are managed in client side (JS)
            // however, if bus tag is changed, then it affects all the tables
            if (args.Type == "Bus")
            {
                //CableBranches, Transformers, BusDucts, Buses, Switches, Loads
                _cableBranches?.ForEach(item =>
                {
                    if (item.FromBus == args.originalTag) item.FromBus = args.changedTag;
                    if (item.ToBus == args.originalTag) item.ToBus = args.changedTag;
                });
                _transformers?.ForEach(item =>
                {
                    if (item.FromBus == args.originalTag) item.FromBus = args.changedTag;
                    if (item.ToBus == args.originalTag) item.ToBus = args.changedTag;
                });
                _busDucts?.ForEach(item =>
                {
                    if (item.FromBus == args.originalTag) item.FromBus = args.changedTag;
                    if (item.ToBus == args.originalTag) item.ToBus = args.changedTag;
                });
                _loads?.ForEach(item =>
                {
                    if (item.ConnectedBus == args.originalTag) item.ConnectedBus = args.changedTag;
                });

                _switches?.ForEach(item =>
                {
                    if (item.FromElement == args.originalTag) item.FromElement = args.changedTag;
                    if (item.ToElement == args.originalTag) item.ToElement = args.changedTag;
                    // if (item.T3 == args.originalTag) item.T3 = args.changedTag;
                });
            }
        }

        // Step 2: Handle From Equipment / To Equipment / Connected Bus
        //TODO: Corresponding previous links, if any, to be removed
        //TODO: and new links to be created as per the changed connection
        
        // Step 3: Other parameters (SQL Table fields)
        // _buses, _transformers, ... are updated with the newly added item or the changed parameters.
        
        // load flow is not done unless asked by the user as it takes some time to run
        // minor changes like the tag, and ratings are only required to be reflected on the SLD only
        await JsRuntime.InvokeVoidAsync("updateSLDItem", args.itemJSON, args.Type, args.originalTag, branches);
        //
    }


    private List<List<string>> FindSwitchboards(List<Bus> buses)
    {
        // create switchboard strings from buses info
        List<List<string>> switchboards = new();

        buses
            .Where(i => !string.IsNullOrWhiteSpace(i.BoardTag))
            .GroupBy(i => i.BoardTag)
            .Select(g => g.First())
            .ToList().ForEach(bus =>
            {
                var switchboard = bus.BoardTag;
                var busesOfThisBoard = buses.FindAll(item => item.BoardTag == switchboard).ToList();
                var busTags = busesOfThisBoard.Select(item => item.Tag).ToList();
                var busSections = busesOfThisBoard.Select(item => item.Sec).ToList();
                if (busTags.Count > 1)
                {
                    switchboards.Add(new List<string> { switchboard, JsonSerializer.Serialize(busTags), JsonSerializer.Serialize(busSections) });
                }
            });

        return switchboards;
    }


    public async Task UpdateStudyResultsToClientPage()
    {
        Console.WriteLine("Server Side: Refreshng study results to the client page......");
        // run LF SC study to generate all the latest data
        var tupleResult = await MainLoadFlow(_buses, _loads, _cableBranches, _transformers, _busDucts, _switches, _fuses, _busBarLinks);
        var BusesResult = tupleResult.Item1;
        var BranchesResult = tupleResult.Item2;

        if (BusesResult.Count == 0 || BranchesResult.Count == 0) return;

        var buses = JsonSerializer.Serialize(BusesResult);
        var switchboards = JsonSerializer.Serialize(FindSwitchboards(BusesResult));
        var switches = JsonSerializer.Serialize(_switches);
        var branches = JsonSerializer.Serialize(BranchesResult);
        var loads = JsonSerializer.Serialize(_loads);
        var transformers = JsonSerializer.Serialize(_transformers);
        var cableBranches = JsonSerializer.Serialize(_cableBranches);
        var busDucts = JsonSerializer.Serialize(_busDucts);

        // as SLD is already created, only parameters are passed on

        await JsRuntime.InvokeVoidAsync("updateSLDWithStudyResults", buses, switchboards, switches, branches, loads, transformers, cableBranches, busDucts);
    }

    

    [JSInvokable("TagMoveUpdate")]
    public void TagMoveUpdate(string type, string tag, int x, int y)
    {
        Console.WriteLine($"Server Side: {type} : Tag: {tag} moved to: ({x}, {y})");
    }

    [JSInvokable("SLDComponentUpdate")]
    public async Task SLDComponentUpdate(string sldComponentsString)
    {
        // assumption: only changed data is received since only the changed data is logged into sldState.sldComponentsJS
        // besides the position or link break point changes, there may be changes in the SLD items parameters

         UpdateOnTableChange<Bus>((new Bus(), _buses, GlobalData.Buses, "", "", "",""));
         UpdateOnTableChange<Load>((new Load(), _loads, GlobalData.Loads, "", "", "",""));
         UpdateOnTableChange<Board>((new Board(), _boards, GlobalData.Boards, "", "", "",""));
         UpdateOnTableChange<CableBranch>((new CableBranch(), _cableBranches, GlobalData.CableBranches, "", "", "",""));
         UpdateOnTableChange<BusDuct>((new BusDuct(), _busDucts, GlobalData.BusDucts, "", "", "",""));
         UpdateOnTableChange<Switch>((new Switch(), _switches, GlobalData.Switches, "", "", "",""));
         UpdateOnTableChange<Fuse>((new Fuse(), _fuses, GlobalData.Fuses, "", "", "",""));
         UpdateOnTableChange<BusBarLink>((new BusBarLink(), _busBarLinks, GlobalData.BusBarLinks, "", "", "",""));

         
        // read data from the database afresh, not from cache
        GlobalData.SLDComponents = await Table.GetListAsync<SLDComponent>(GlobalData.SelectedProject.Tag);
        _sldComponents = await Table.GetListAsync<SLDComponent>(GlobalData.SelectedProject.Tag);

        try
        {
            var sldComponents = JsonSerializer.Deserialize<List<SLDComponent>>(sldComponentsString);
            Console.WriteLine($"Server Side:SLDComponentUpdate.....{sldComponents.Count} data changed.");

            foreach (var sldJS in sldComponents)
            {
                // find existing entry is available
                var sld = _sldComponents.Find(item =>
                    item.Tag == sldJS.Tag &&
                    item.Type == sldJS.Type &&
                    item.SLD == sldJS.SLD
                );
                // if not found new SLDComponent will be created
                if (sld is not null)
                {
                    Console.WriteLine($"Tag '{sld.Tag}', Type '{sld.Type}' SLD '{sld.SLD}' : data changed from '{sld.PropertyJSON}' to '{sldJS.PropertyJSON}'.");
                    sld.UpdatedOn = DateTime.Now;
                    sld.UpdatedBy = loginUser;
                    // update the JSON Property
                    sld.PropertyJSON = sldJS.PropertyJSON;
                    // update existing record
                    await Table.UpdateAsync(sld);
                }
                else
                {
                    Console.WriteLine($"Tag '{sldJS.Tag}', Type '{sldJS.Type}' SLD '{sldJS.SLD}': new data '{sldJS.PropertyJSON}' to be added.");
                    // create a new SLDComponent afresh
                    sld = new SLDComponent();
                    sld.ProjectId = GlobalData.SelectedProject.Tag;;
                    sld.Tag = sldJS.Tag;
                    sld.Type = sldJS.Type;
                    sld.SLD = sldJS.SLD;
                    sld.PropertyJSON = sldJS.PropertyJSON;
                    sld.UID = Guid.NewGuid();
                    sld.UpdatedOn = DateTime.Now;
                    sld.UpdatedBy = loginUser;
                    sld.Save2DB = true;
                    // add the new item
                    await Table.InsertAsync(sld);
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Server Side:SLDComponentUpdate.....Error {e.Message}.");
        }
    }

    
    
    /// <summary>
/// JS-callable: Traces a chain from an element's From or To end to the terminating bus.
/// </summary>
[JSInvokable("TraceConnectionChain")]
public Task<string> TraceConnectionChain(string elementTag, string direction)
{
    if (_sldLayoutService == null)
        return Task.FromResult(JsonSerializer.Serialize(new { Success = false, Error = "Layout service not initialized" }));

    var result = _sldLayoutService.TraceChain(elementTag, direction);

    var response = new
    {
        result.Success,
        result.ErrorMessage,
        result.StartElementTag,
        result.Direction,
        result.TerminatingBusTag,
        Steps = result.Steps.Select(s => new
        {
            s.Tag,
            s.Type,
            Category = s.Category.ToString()
        }).ToList()
    };

    return Task.FromResult(JsonSerializer.Serialize(response));
}

/// <summary>
/// JS-callable: Returns valid connection candidates for an element's specified side.
/// </summary>
[JSInvokable("GetValidConnectionCandidates")]
public Task<string> GetValidConnectionCandidates(string elementTag, string side)
{
    if (_sldLayoutService == null)
        return Task.FromResult(JsonSerializer.Serialize(new List<object>()));

    var candidates = _sldLayoutService.GetValidCandidates(elementTag, side);

    var response = candidates.Select(c => new
    {
        c.Tag,
        c.Type,
        Category = c.Category.ToString(),
        c.AvailableSide,
        c.Reason
    }).ToList();

    return Task.FromResult(JsonSerializer.Serialize(response));
}

/// <summary>
/// JS-callable: Traces the full path from an element upstream to the source (swing) bus.
/// </summary>
[JSInvokable("TraceToSource")]
public Task<string> TraceToSourceFromElement(string elementTag)
{
    if (_sldLayoutService == null)
        return Task.FromResult(JsonSerializer.Serialize(new { Success = false, Error = "Layout service not initialized" }));

    var results = _sldLayoutService.TraceToSource(elementTag);

    var response = results.Select(r => new
    {
        r.Success,
        r.ErrorMessage,
        r.StartElementTag,
        r.Direction,
        r.TerminatingBusTag,
        Steps = r.Steps.Select(s => new
        {
            s.Tag,
            s.Type,
            Category = s.Category.ToString()
        }).ToList()
    }).ToList();

    return Task.FromResult(JsonSerializer.Serialize(response));
}


// ============================================================================
// STEP 6: Updated SLDValidateLink to use the new connectivity service
// Replace the existing SLDValidateLink method with this:
// ============================================================================

[JSInvokable("SLDValidateLink")]
public async Task<string> SLDValidateLink(string linkDataString)
{
    try
    {
        using var doc = JsonDocument.Parse(linkDataString);
        var root = doc.RootElement;

        var sourceTag = root.TryGetProperty("sourceTag", out var st) ? st.GetString() : null;
        var targetTag = root.TryGetProperty("targetTag", out var tt) ? tt.GetString() : null;
        var sourcePort = root.TryGetProperty("sourcePort", out var sp) ? sp.GetString() : null;
        var targetPort = root.TryGetProperty("targetPort", out var tp) ? tp.GetString() : null;

        Console.WriteLine($"Validating link: {sourceTag}[{sourcePort}] → {targetTag}[{targetPort}]");
        Console.WriteLine($"Server Side: Source {sourceTag} Port {sourcePort} Target {targetTag} Port{targetPort} to be validated...");

        if (string.IsNullOrEmpty(sourceTag) || string.IsNullOrEmpty(targetTag))
        {
            return JsonSerializer.Serialize(new
            {
                Valid = false,
                Message = "Source or target tag is empty."
            });
        }

        // Determine which side of the source this connection is on
        // Port 0 = From (top), Port 1 = To (bottom) - adjust based on your port convention
        string sourceSide = sourcePort == "0" ? "From" : "To";

        // Get valid candidates for this element and side
        var candidates = _sldLayoutService.GetValidCandidates(sourceTag, sourceSide);

        bool isValid = candidates.Any(c => c.Tag == targetTag);

        if (isValid)
        {
            Console.WriteLine($"  ✅ Link valid: {sourceTag} → {targetTag}");
            return JsonSerializer.Serialize(new
            {
                Valid = true,
                Message = $"Connection from '{sourceTag}' to '{targetTag}' is valid."
            });
        }
        else
        {
            // Provide specific reason
            string reason = "Target is not a valid candidate for this connection.";

            // Check specific violations
            if (sourceTag == targetTag)
                reason = "Cannot connect an element to itself.";
            else
            {
                // Check if it would be branch-to-branch
                // ... add more specific checks as needed
            }

            Console.WriteLine($"  ❌ Link invalid: {sourceTag} → {targetTag}: {reason}");
            return JsonSerializer.Serialize(new
            {
                Valid = false,
                Message = reason,
                ValidCandidates = candidates.Select(c => c.Tag).Take(10).ToList()
            });
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error validating link: {ex.Message}");
        return JsonSerializer.Serialize(new
        {
            Valid = false,
            Message = $"Validation error: {ex.Message}"
        });
    }
}


    [JSInvokable("SLDRemoveLink")]
    public async Task<bool> SLDRemoveLink(string linkDataString)
    {
        // Parse the JSON string into a JsonDocument
        using (var doc = JsonDocument.Parse(linkDataString))
        {
            var root = doc.RootElement;

            // You can navigate the JsonElement and read values
            var sourceTag = root.GetProperty("sourceTag").GetString();
            var targetTag = root.GetProperty("targetTag").GetString();
            var sourcePort = root.GetProperty("sourcePort").GetString();
            var targetPort = root.GetProperty("targetPort").GetString();
            Console.WriteLine($"Server Side: Removing Link between Source {sourceTag} Port {sourcePort} Target {targetTag} Port{targetPort} ...");
        }

        return true;
    }

    

    private async Task ClearCache<T>(T item)
    {
        //var dbName = typeof(T).Name;
        //var recordKey = "NavMenu_" + dbName + "_" + DateTime.Now.ToString("yyyyMMdd_hh");
        //await cache.RemoveAsync(recordKey);
        
        // Construct the pattern to match all hourly keys for this type.
        // The pattern needs a wildcard for the varying parts.
        // Original key format: "NavMenu_" + dbName + "_" + DateTime.Now.ToString("yyyyMMdd_hh")
        // So, the pattern will be: "NavMenu_CableData_*"
        var pattern = $"NavMenu_{typeof(T).Name}_*";
        await CacheService.RemoveByPatternAsync(pattern);
        Console.WriteLine($"Attempted to clear all cache for pattern: {pattern}");
        
        
    }


    // public class DefaultClass
    // { }

    // public T ItemOfType<T>(string tag, string classType) where T : class
    // {
    //     switch (classType)
    //     {
    //         case "transformer": return Transformers.Find(item => item.Tag == tag) as T;
    //         case "bus": return Buses.Find(item => item.Tag == tag) as T;
    //         case "cable": return CableBranches.Find(item => item.Tag == tag) as T;
    //         case "busduct": return BusDucts.Find(item => item.Tag == tag) as T;
    //         case "loads": return Loads.Find(item => item.Tag == tag) as T;
    //         default: return new DefaultClass() as T;
    //     }
    // }
    
    
    
    
    /// <summary>
    /// Converts ProcessingResult into display messages for the ValidationPanel.
    /// Call this right after _connectionProcessingService.ProcessAllConnections().
    /// </summary>
private void PopulateValidationMessages(ProcessingResult result, SLDLayoutResult layoutResult = null)
{
    _validationMessages.Clear();

    if (result == null) return;

    // ── Errors ──
    if (result.ValidationErrors != null)
    {
        foreach (var e in result.ValidationErrors)
        {
            _validationMessages.Add(new ValMessage
            {
                Severity   = "error",
                Code       = e.Code ?? "ERROR",
                Message    = e.Message,
                ElementTag = e.SourceElement
            });
        }
    }

    // ── Warnings ──
    if (result.ValidationWarnings != null)
    {
        foreach (var w in result.ValidationWarnings)
        {
            _validationMessages.Add(new ValMessage
            {
                Severity   = "warning",
                Code       = w.Code ?? "WARNING",
                Message    = w.Message,
                ElementTag = w.SourceElement
            });
        }
    }

    // ── Info — auto-created buses for loads ──
    if (result.NewBusesCreatedForLoads != null)
    {
        foreach (var bus in result.NewBusesCreatedForLoads)
        {
            _validationMessages.Add(new ValMessage
            {
                Severity   = "info",
                Code       = "AUTO_BUS",
                Message    = $"Bus '{bus.Tag}' was auto-created to satisfy connection requirements.",
                ElementTag = bus.Tag
            });
        }
    }

    // ── Evaluation alerts ──
    if (result.EvaluationAlerts != null)
    {
        foreach (var a in result.EvaluationAlerts)
        {
            _validationMessages.Add(new ValMessage
            {
                Severity   = a.Severity == AlertSeverity.Error ? "error" :
                             a.Severity == AlertSeverity.Warning ? "warning" : "info",
                Code       = "EVAL",
                Message    = a.Message,
                ElementTag = a.ElementTag
            });
        }
    }

    // ── Layout warnings (if layout result provided) ──
    if (layoutResult?.Warnings != null)
    {
        foreach (var w in layoutResult.Warnings)
        {
            _validationMessages.Add(new ValMessage
            {
                Severity = "warning",
                Code     = "LAYOUT",
                Message  = w
            });
        }
    }

    StateHasChanged();
}
    
    
    public class Payload
    {
        public string Id          { get; set; } = "";
        public string Tag         { get; set; } = "";
        public string SourceTag   { get; set; } = "";
        public string ElementType { get; set; } = "";
        public Guid SourceId    { get; set; } = Guid.Empty;
    }



}
