@using System.Diagnostics
@using System.Numerics
@using System.Reflection
@using System.Runtime
@using System.Text.Json
@inject NavigationManager MyNavigationManager;
@inject IJSRuntime JSRuntime;
@using ElDesignApp.Models;
@using ElDesignApp.Data;

@inject IDataRetrievalService DataService
@inject ITableService Table
@inject IGlobalDataService GlobalData
@inject IMyFunctionService MyFunction
@inject ILayoutFunctionService LayoutFunction

@implements IAsyncDisposable

<button @onclick="@HidePlotPlan" data-toggle="button" class="btn btn-info" style="float:left;" 
        title="Hide/Show 3D">Plot Plan for @_title: @(_show3D ? "Hide" : "Show")</button>

@if (_show3D)
{
    <h5>@Header</h5>
    @if (isWorking)
    {
        <img src="/images/working.gif" asp-append-version="true" width="300" alt=""/>
    }

    <h6>
        <pre>    @timeStamp @_sceneInfo?.Display[0] @_sceneInfo?.Display[1] @_sceneInfo?.Display[2]</pre>
    </h6>
}

<div class="progress" style="display:@(_show3D ? "block" : "none")">
    <div class="progress-bar progress-bar-striped bg-success" role="progressbar" style="width:@progress%"
         aria-valuenow="@progress" aria-valuemin="0" aria-valuemax="100">@progressItem @progress%
    </div>
</div>

<div id="@_divString" onclick="@UpdatePage"
     style="height: 1200px; width: 800px; display:@(_show3D ? "block" : "none")"></div>

<h5>@Footer</h5>
<br/>

@code {
    [Parameter] public RenderFragment? Header { get; set; }
    [Parameter] public string? Title { get; set; }
    [Parameter] public string? DivString { get; set; }
    [Parameter] public SceneInfo SceneInfo { get; set; } = new();
    [Parameter] public List<ClickedPoint> ClickedPoints { get; set; } = new();
    [Parameter] public RenderFragment? Footer { get; set; }
    [Parameter] public List<string> DisplayItems { get; set; } = [];

    // FIXED: Removed 'static' from all fields
    private string? _title;
    private SceneInfo? _sceneInfo;
    private List<ClickedPoint>? _clickedPoints;
    private string? _divString;
    private float _rendererWidth;
    private float _rendererHeight;
    private DotNetObjectReference<Draw>? objPlot;
    private bool shouldRenderUIChanges = true;
    private string timeStamp = "";
    private int progress;
    private string progressItem = "";
    private bool isWorking;
    private bool _show3D;
    private bool _sceneInitialized;  // NEW: Track if scene has been initialized
    

    private readonly JsonSerializerOptions _jsonSerializerOptions = new JsonSerializerOptions { IncludeFields = true };

    public async Task HidePlotPlan()
    {
        _show3D = !_show3D;

        if (_show3D && !_sceneInitialized)
        {
            // First time showing - need to initialize scene after DOM updates
            await InvokeAsync(StateHasChanged);
            await Task.Delay(50);  // Small delay for DOM to update
            await InitializeAndDrawSceneAsync();
        }
        else
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnInitialized()
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  Plot - {MethodBase.GetCurrentMethod()?.Name}");
        
        _title = Title;
        _divString = DivString;
        _sceneInfo = SceneInfo;
        _clickedPoints = ClickedPoints;
        
        base.OnInitialized();
    }

    protected override async Task OnInitializedAsync()
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  Plot - {MethodBase.GetCurrentMethod()?.Name}");
        await base.OnInitializedAsync();
    }

    protected override void OnParametersSet()
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  Plot - {MethodBase.GetCurrentMethod()?.Name}");
        
        // UpdateParentCallback local copies when parameters change
        _title = Title;
        _divString = DivString;
        _sceneInfo = SceneInfo;
        _clickedPoints = ClickedPoints;
        
        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri} - {MethodBase.GetCurrentMethod()?.Name} - First Render:{firstRender}, show3D:{_show3D}");

        if (firstRender)
        {
            // Load segment data if needed
            if (GlobalData.Trays != null && GlobalData.Trays.Count == 0 && _show3D)
            {
                isWorking = true;
                StateHasChanged();
                if (GlobalData.SegmentResults != null)
                {
                    var tuple = LayoutFunction.ReadSegNodeEtc(GlobalData.SegmentResults);
                    GlobalData.Trays = tuple.Item1;
                    GlobalData.Bends = tuple.Item2;
                    GlobalData.Tees = tuple.Item3;
                    GlobalData.Crosses = tuple.Item4;
                    GlobalData.Sleeves = tuple.Item5;
                    GlobalData.Nodes = tuple.Item6;
                }
                isWorking = false;
                StateHasChanged();
            }

            // FIXED: Only initialize scene if show3D is true
            if (_show3D && !_sceneInitialized)
            {
                await InitializeAndDrawSceneAsync();
            }
        }

        await base.OnAfterRenderAsync(firstRender);  // FIXED: Added await
    }

    /// <summary>
    /// Initialize the Three.js scene and draw all elements
    /// </summary>
    private async Task InitializeAndDrawSceneAsync()
    {
        if (_sceneInitialized || string.IsNullOrEmpty(_divString))
        {
            return;
        }

        try
        {
            // Check if element exists in DOM
            var elementExists = await JSRuntime.InvokeAsync<bool>("checkElementExists", _divString);
            if (!elementExists)
            {
                Debug.WriteLine($"Element '{_divString}' not found, waiting...");
                await Task.Delay(100);
                elementExists = await JSRuntime.InvokeAsync<bool>("checkElementExists", _divString);
                if (!elementExists)
                {
                    Debug.WriteLine($"Element '{_divString}' still not found after retry");
                    return;
                }
            }

            // Initialize scene
            objPlot = DotNetObjectReference.Create(new Draw(LayoutFunction, GlobalData));
            await JSRuntime.InvokeVoidAsync("drawScene", _divString, _sceneInfo?.SceneJSON ?? "", objPlot);
            
            _sceneInitialized = true;
            
            GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
            GC.Collect();

            // Draw all scene elements (your existing code)
            await DrawAllSceneElementsAsync();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error initializing scene: {ex.Message}");
            _sceneInitialized = false;
        }
    }

    /// <summary>
    /// Draw all scene elements - contains your existing drawing logic
    /// </summary>
    private async Task DrawAllSceneElementsAsync()
    {
        // ============ DRAW PLOT PLANS ============
        if (GlobalData.PlotPlans != null)
        {
            var plotPlans = GlobalData.PlotPlans.ToList();
            _rendererWidth = _sceneInfo?.RendererWidth ?? 800;
            _rendererHeight = _sceneInfo?.RendererHeight ?? 600;

            if (plotPlans.Count != 0 && DisplayItems.Contains("Plot"))
            {
                try
                {
                    for (var i = 0; i < plotPlans.Count; i++)
                    {
                        var im = plotPlans[i];
                        var planeName = $"{_title} - {im.Tag}";
                        var planeTag = $"plotplan{(i + 1).ToString("D" + 2)}";
                        var scaleX = im.ScaleX * im.RendererWidth / _rendererWidth;
                        var scaleY = im.ScaleY * im.RendererHeight / _rendererHeight;
                        Debug.WriteLine($"Drawing Plot Plan -> planeName {planeName}, planeTag {planeTag}, " +
                                        $"im.ScaleX: {im.ScaleX}, im.ScaleY: {im.ScaleY}, " +
                                        $"im.RendererWidth: {im.RendererWidth}, im.RendererHeight: {im.RendererHeight}, " +
                                        $"_rendererWidth: {_rendererWidth}, _rendererHeight: {_rendererHeight}, " +
                                        $"scaleX: {scaleX}, scaleY: {scaleY}, im.CentreX: {im.CentreX}, im.CentreY: {im.CentreY}, " +
                                        $"im.Z, {im.Z}, im.Opacity {im.Opacity}");
                        await JSRuntime.InvokeVoidAsync("drawPlane", planeName, planeTag, im.ImgString,
                            scaleX, scaleY, im.CentreX, im.CentreY, im.Z, im.Opacity);
                    }
                }
                catch (Exception e)
                {
                    Debug.WriteLine($"Error drawing plot plans: {e.Message}");
                }
            }
        }

        // ============ DRAW TRAYS (RAW SEGMENTS) ============
        var trays = GlobalData.Segments?.ToList() ?? new List<Segment>();
        if (trays.Count != 0 && DisplayItems.Contains("RawSegment"))
        {
            var validTrays = trays.Where(tray => tray.End1 != tray.End2 && 
                Math.Abs(Vector3.Dot(Vector3.Normalize(tray.End2 - tray.End1), Vector3.Normalize(tray.Face))) < 0.95f).ToList();

            try
            {
                progress = 0;
                for (var i = 0; i < validTrays.Count; i++)
                {
                    var tray = validTrays[i];
                    var jSONstring = LayoutFunction.DrawLadderJSONPoints(tray.Width, tray.Height, tray.End1, tray.End2, tray.Face);
                    var color = tray.AllowableTypes != null && tray.AllowableTypes.Contains("LV") 
                        ? GlobalData.segmentColorLV 
                        : tray.AllowableTypes != null && tray.AllowableTypes.Contains("HV") 
                            ? GlobalData.segmentColorHV 
                            : GlobalData.segmentColorNeutral;
                    var opacity = 1;
                    await JSRuntime.InvokeVoidAsync("drawLadder", tray.Tag, jSONstring, 
                        JsonSerializer.Serialize(color, _jsonSerializerOptions), opacity);
                    
                    if (validTrays.Count > 0 && 100 * i / validTrays.Count != progress)
                    {
                        progress = 100 * i / validTrays.Count;
                        progressItem = $"Drawing Straight Sections {i + 1}/{validTrays.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing trays: {e.Message}");
            }
        }

        // ============ DRAW BENDS ============
        var bends = GlobalData.Bends?.ToList() ?? new List<Bend>();
        if (bends.Count != 0 && DisplayItems.Contains("Bend"))
        {
            try
            {
                progress = 0;
                for (var i = 0; i < bends.Count; i++)
                {
                    var bend = bends[i];
                    // YOUR EXISTING BEND DRAWING CODE HERE
                    // Uncomment and use your actual DrawBendJSONPoints call:
                    // var jSONstring = LayoutFunction.DrawBendJSONPoints(...your parameters...);
                    // var color = GlobalData.segmentColorNeutral;
                    // var opacity = 1;
                    // await JSRuntime.InvokeVoidAsync("drawBend", bend.Tag, jSONstring, JsonSerializer.Serialize(color), opacity);
                    
                    if (bends.Count > 0 && 100 * i / bends.Count != progress)
                    {
                        progress = 100 * i / bends.Count;
                        progressItem = $"Drawing Bends {i + 1}/{bends.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing bends: {e.Message}");
            }
        }

        // ============ DRAW TEES ============
        var tees = GlobalData.Tees?.ToList() ?? new List<Tee>();
        if (tees.Count != 0 && DisplayItems.Contains("Tee"))
        {
            try
            {
                progress = 0;
                for (var i = 0; i < tees.Count; i++)
                {
                    var tee = tees[i];
                    // YOUR EXISTING TEE DRAWING CODE HERE
                    // Uncomment and use your actual DrawTeeJSONPoints call
                    
                    if (tees.Count > 0 && 100 * i / tees.Count != progress)
                    {
                        progress = 100 * i / tees.Count;
                        progressItem = $"Drawing Tee Junctions {i + 1}/{tees.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing tees: {e.Message}");
            }
        }

        // ============ DRAW CROSSES ============
        var crosses = GlobalData.Crosses?.ToList() ?? new List<Cross>();
        if (crosses.Count != 0 && DisplayItems.Contains("Cross"))
        {
            try
            {
                progress = 0;
                for (var i = 0; i < crosses.Count; i++)
                {
                    var cross = crosses[i];
                    var jSONstring = LayoutFunction.DrawCrossJSONPoints(cross.X, cross.P1, cross.P2, cross.P3, cross.P4, 
                        cross.W1, cross.W2, cross.W3, cross.W4, cross.F1, cross.F2, cross.F3, cross.F4, 
                        cross.H1, cross.H2, cross.H3, cross.H4, cross.Step);
                    var color = GlobalData.segmentColorNeutral;
                    var opacity = 1;
                    // await JSRuntime.InvokeVoidAsync("drawCross", cross.Tag, jSONstring, JsonSerializer.Serialize(color), opacity);
                    
                    if (crosses.Count > 0 && 100 * i / crosses.Count != progress)
                    {
                        progress = 100 * i / crosses.Count;
                        progressItem = $"Drawing Crosses {i + 1}/{crosses.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing crosses: {e.Message}");
            }
        }

        // ============ DRAW NODES ============
        var nodes = GlobalData.Nodes?.ToList() ?? new List<Node>();
        if (nodes.Count != 0 && DisplayItems.Contains("Node"))
        {
            try
            {
                progress = 0;
                for (var i = 0; i < nodes.Count; i++)
                {
                    var node = nodes[i];
                    var jSONstring = JsonSerializer.Serialize(node.Point);
                    var color = GlobalData.nodeColor;
                    var opacity = 1;
                    // await JSRuntime.InvokeVoidAsync("drawNode", node.Tag, jSONstring, JsonSerializer.Serialize(color), opacity);
                    
                    if (nodes.Count > 0 && 100 * i / nodes.Count != progress)
                    {
                        progress = 100 * i / nodes.Count;
                        progressItem = $"Drawing Nodes {i + 1}/{nodes.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing nodes: {e.Message}");
            }
        }

        // ============ DRAW SLEEVES ============
        var sleeves = GlobalData.Sleeves?.ToList() ?? new List<Sleeve>();
        if (sleeves.Count != 0 && DisplayItems.Contains("Sleeve"))
        {
            try
            {
                progress = 0;
                for (var i = 0; i < sleeves.Count; i++)
                {
                    var sleeve = sleeves[i];
                    var jsonPoints = LayoutFunction.DrawSleeveJSONPoints(sleeve.Points, sleeve.BendRadius);
                    var color = GlobalData.nodeColor;
                    var opacity = .5;
                    var tag = sleeve.Tag;
                    var radious = sleeve.Dia / 2;
                    var segment = 5;
                    var radialSegments = 10;
                    await JSRuntime.InvokeVoidAsync("drawSleeveZ", tag, jsonPoints, radious, segment, radialSegments, 
                        JsonSerializer.Serialize(color), opacity);
                    
                    if (sleeves.Count > 0 && 100 * i / sleeves.Count != progress)
                    {
                        progress = 100 * i / sleeves.Count;
                        progressItem = $"Drawing Sleeves {i + 1}/{sleeves.Count}";
                        StateHasChanged();
                    }
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine($"Error drawing sleeves: {e.Message}");
            }
        }
    }

    protected override bool ShouldRender()
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  Plot - {MethodBase.GetCurrentMethod()?.Name}");
        return base.ShouldRender();
    }

    private void UpdatePage(MouseEventArgs e)
    {
        timeStamp = $"[{DateTime.Now:HH:mm:ss.f}]";
    }

    public async ValueTask DisposeAsync()
    {
        Debug.WriteLine($"{DateTime.Now:hh.mm.ss.ffffff} : {MyNavigationManager.Uri}  Plot - DisposeAsync");
        
        if (_sceneInitialized && !string.IsNullOrEmpty(_divString))
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("clearScene");
            }
            catch (JSDisconnectedException)
            {
                // Circuit already disconnected, ignore
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error clearing scene: {ex.Message}");
            }
        }
        
        objPlot?.Dispose();
        _sceneInitialized = false;
    }
}